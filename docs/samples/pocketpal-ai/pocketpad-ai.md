================================================
FILE: README.md
================================================
# PocketPal AI üì±üöÄ

PocketPal AI is a pocket-sized AI assistant powered by small language models (SLMs) that run directly on your phone. Designed for both iOS and Android, PocketPal AI lets you interact with various SLMs without the need for an internet connection. Your privacy is fully protected as all processing happens entirely on-device ‚Äî your conversations, prompts, and data never leave your phone or get stored on external servers.

> **Note on Privacy**: The only data that may leave your device is what you explicitly choose to share: benchmark results (if you opt to contribute to the leaderboard) and any feedback you voluntarily submit through the app.

## Table of Contents

- [PocketPal AI üì±üöÄ](#pocketpal-ai-)
  - [Table of Contents](#table-of-contents)
  - [üì∞ News & Announcements](#-news--announcements)
  - [Features](#features)
  - [Installation](#installation)
    - [iOS](#ios)
    - [Android](#android)
  - [Usage](#usage)
    - [Downloading a Model](#downloading-a-model)
    - [Loading a Model](#loading-a-model)
    - [Chatting with the model](#chatting-with-the-model)
    - [Copying Text](#copying-text)
    - [Message Editing](#message-editing)
    - [Using Pals](#using-pals)
    - [Benchmarking](#benchmarking)
    - [Setup Hugging Face Access Token](#setup-hugging-face-access-token)
    - [Send Feedback](#send-feedback)
  - [Development Setup](#development-setup)
    - [Prerequisites](#prerequisites)
    - [Getting Started](#getting-started)
    - [Scripts](#scripts)
  - [Contributing](#contributing)
    - [Quick Start for Contributors](#quick-start-for-contributors)
  - [Roadmap](#roadmap)
  - [License](#license)
  - [Contact](#contact)
  - [Acknowledgements](#acknowledgements)

## üì∞ News & Announcements
- **üîí HF Token Authentication (v1.9.0, Apr, 2025)**: Access gated models from Hugging Face with your authentication token.
- **üåê Localization Support (v1.8.16, Apr, 2025)**: PocketPal AI now supports multiple languages (At the moment Japanese and Chinese).
- **üì± iPad Support (v1.8.12, Mar, 2025)**: Full support for iPad devices including landscape orientation.
- **üë§ Pals Feature (v1.8.0, Feb, 2025)**: Create and chat with personalized AI assistants with different personalities.
- **üîç Benchmarking Tool (v1.6.1, 2024)**: Test and compare model performance with the built-in benchmarking feature.
- **üé® New Icon Alert (Nov 2024)**: PocketPal AI has a fresh new look! Huge thanks to **[Chun Te Lee](https://github.com/Reeray)** for the design! [Read more](https://github.com/a-ghorbani/pocketpal-ai/discussions/102).
- **üöÄ Hugging Face Public Hub Integration (v1.5, Nov 2024)**: PocketPal AI now integrates with the Hugging Face model Hub! Browse, download, and run models directly from the Hugging Face Hub within the app. [Read more](https://github.com/a-ghorbani/pocketpal-ai/discussions/104)

## Features

- **Offline AI Assistance**: Run language models directly on your device without internet connectivity.
- **Model Flexibility**: Download and swap between multiple SLMs, including Danube 2 and 3, Phi, Gemma 2, and Qwen.
- **Auto Offload/Load**: Automatically manage memory by offloading models when the app is in the background.
- **Inference Settings**: Customize model parameters like system prompt, temperature, BOS token, and chat templates.
- **Real-Time Performance Metrics**: View tokens per second and milliseconds per token during AI response generation.
- **Message Editing**: Edit your messages and retry AI generation.
- **Personalized Pals**: Create different AI personalities with customized settings.
- **Background Downloads**: Continue downloading models while using other apps (iOS).
- **Screen Awake During Inference**: Keep your screen on while the AI is generating responses.
- **Multi-device Support**: Optimized for both phones and tablets, including iPad.
- **Localization**: Use the app in your preferred language.
- **Hugging Face Integration**: Access both public and gated models with authentication.

## Installation

### iOS

Download PocketPal AI from the App Store:

[**Download on the App Store**](https://apps.apple.com/us/app/pocketpal-ai/id6502579498)

### Android

Get PocketPal AI on Google Play:

[**Get it on Google Play**](https://play.google.com/store/apps/details?id=com.pocketpalai)

## Usage

### Downloading a Model

1. Open the app and tap the **Menu** icon (‚ò∞).
2. Navigate to the **Models** page.
3. Choose a model from the list and tap **Download**.
4. Or tap the + button to add models from Hugging Face or locally downloaded ones.
5. If you select "Add from Hugging Face", you can search GGUF models directly on HF and select any quantization that fits your device (memory and storage).
6. You can then download it immediately or bookmark it for later.

<img src="assets/images and logos/Download_models.png" alt="Download Models Screenshot" width="100%">

### Loading a Model

- After downloading, tap **Load** next to the model to load it to memory.
- You can also load a model directly within the chat page using the chevron icon on the left side of the chat input.

### Chatting with the model 

1. Ensure a model is loaded.
2. Navigate to the **Chat** page from the menu.
3. Start conversing with your AI assistant!
4. The screen will stay awake during inference and deactivate when idle.
5. You can select and load models using the chevron icon on the left side of the chat input.

<img src="assets/images and logos/Chat.png" alt="Chat Screenshot" width="83%">

### Copying Text

- **Copy Entire Response**: Tap the copy icon at the bottom of the AI's response bubble.
- **Copy Specific Paragraph**: Long-press on a paragraph to copy its content.

*Note*: Preserving text formatting while copying is currently limited. We're working on improving this feature.

### Message Editing

1. Long-press on any of your messages to edit them.
2. After editing, the AI will regenerate its response based on your changes.
3. Use the retry option to get a new response without changing your message.
4. You can also retry generation using a different model for comparison or better results.

### Using Pals

1. Create personalized AI assistants with different personalities and settings.
2. PocketPal offers two different pal types:
   - **Assistant Pal**: Select a default model, set a system prompt (manually or generated by another AI), and customize chat text input color.
   - **Roleplay Pal**: Similar to Assistant Pal plus additional settings for location, AI's role, and other contextual parameters.
3. Select a Pal using the Pal picker in the chat page to quickly switch between different personas.

<div style="margin-top: 30px; margin-bottom: 30px;">
  <img src="assets/images and logos/Pals.png" alt="Assistant Pal Screenshot" width="100%">
  <p><em>An example of creating a cocktail recipe assistant</em></p>
</div>

<div style="margin-top: 30px; margin-bottom: 30px;">
  <img src="assets/images and logos/Roleplay.png" alt="Roleplay Pal Screenshot" width="33%">
  <p><em>Setting up a roleplay pal with custom parameters</em></p>
</div>

<div style="margin-top: 30px; margin-bottom: 30px;">
  <img src="assets/images and logos/Pals-AI_generates_system_prompt.png" alt="AI-Generated System Prompt" width="16%">
  <p><em>Using AI to generate system prompts for your pals</em></p>
</div>

### Benchmarking

1. Navigate to the Benchmarking page.
2. Run performance tests on your models to compare speed and efficiency.
3. View detailed metrics like tokens per second and memory usage.
4. Share your benchmark results and compare with other devices on the [PocketPal AI Phone Leaderboard](https://huggingface.co/spaces/a-ghorbani/ai-phone-leaderboard).

<img src="assets/images and logos/Benchmark.png" alt="Benchmark Screenshot" width="100%">

### Setup Hugging Face Access Token

Access gated models from Hugging Face by setting up your authentication token:

1. First, get an access token from your Hugging Face account:
   - Refer to the [HF Security Tokens documentation](https://huggingface.co/docs/hub/en/security-tokens)

   <img src="assets/images and logos/Get_token_from_HF.png" alt="Get Token from Hugging Face" width="1000%">

2. In PocketPal AI:
   - Navigate to the Settings page
   - Tap on "Set Token"
   - Paste your personal access token in the text input
   - Save

   <img src="assets/images and logos/Token_in_pocketpal.png" alt="Token Setup in PocketPal" width="66%">

### Send Feedback

Share your thoughts directly from the app:

1. Navigate to the App Info page
2. Tap on "Sharing your thoughts" 
3. Type in whatever you'd like to share, from feature requests to suggestions
4. Hit "Submit Feedback"

<img src="assets/images and logos/Send_Feedback.png" alt="Send Feedback Screenshot" width="50%">

## Development Setup

Interested in contributing or running the app locally? Follow the steps below.

### Prerequisites

- **Node.js** (version 18 or higher)
- **Yarn**
- **React Native CLI**
- **Xcode** (for iOS development)
- **Android Studio** (for Android development)

### Getting Started

1. **Fork and Clone the Repository**

   ```bash
   git clone https://github.com/a-ghorbani/pocketpal-ai
   cd pocketpal-ai
   ```

2. **Install Dependencies**

   ```bash
   yarn install
   ```

3. **Install Pod Dependencies (iOS Only)**

   ```bash
   cd ios
   pod install
   cd ..
   ```

4. **Run the App**

   - **iOS Simulator**

     ```bash
     yarn ios
     ```

   - **Android Emulator**

     ```bash
     yarn android
     ```

### Scripts

- **Start Metro Bundler**

  ```bash
  yarn start
  ```

- **Clean Build Artifacts**

  ```bash
  yarn clean
  ```

- **Lint and Type Check**

  ```bash
  yarn lint
  yarn typecheck
  ```

- **Run Tests**

  ```bash
  yarn test
  ```

## Contributing

We welcome all contributions! Please read our [Contributing Guidelines](CONTRIBUTING.md) and [Code of Conduct](./CODE_OF_CONDUCT.md) before you start.

### Quick Start for Contributors

1. **Fork the Repository**
2. **Create a New Branch**

   ```bash
   git checkout -b feature/your-feature-name
   ```

3. **Make Your Changes**
4. **Test Your Changes**

   - **Run on iOS**

     ```bash
     yarn ios
     ```

   - **Run on Android**

     ```bash
     yarn android
     ```

5. **Lint and Type Check**

   ```bash
   yarn lint
   yarn typecheck
   ```

6. **Commit Your Changes**

   - Follow the Conventional Commits format:

     ```bash
     git commit -m "feat: add new model support"
     ```

7. **Push and Open a Pull Request**

   ```bash
   git push origin feature/your-feature-name
   ```

## Roadmap

- **New Models**: Add support for more tiny LLMs.
- **UI/UX Enhancements**: Continue improving the overall user interface and user experience.
- **Improved Documentation**: Enhance the documentation of the project.
- **Performance Optimization**: Further optimize performance across different device types.
- **More Languages**: Add support for additional languages through localization.
- **Enhanced Error Handling**: Improve error handling and recovery mechanisms.

Feel free to open issues to suggest features or report bugs.

## License

This project is licensed under the [MIT License](LICENSE).

## Contact

For questions or feedback, please open an issue.

## Acknowledgements

PocketPal AI is built using the amazing work from:

- **[llama.cpp](https://github.com/ggerganov/llama.cpp)**: Enables efficient inference of LLMs on local devices.
- **[llama.rn](https://github.com/mybigday/llama.rn)**: Implements llama.cpp bindings into React Native.
- **[React Native](https://reactnative.dev/)**: The framework powering the cross-platform mobile experience.
- **[MobX](https://mobx.js.org/)**: State management library that keeps the app reactive and performant.
- **[React Native Paper](https://callstack.github.io/react-native-paper/)**: Material Design components for the UI.
- **[React Navigation](https://reactnavigation.org/)**: Routing and navigation for the app's screens.
- **[Gorhom Bottom Sheet](https://github.com/gorhom/react-native-bottom-sheet)**: Powers the smooth bottom sheet interactions throughout the app.
- **[@dr.pogodin/react-native-fs](https://github.com/birdofpreyru/react-native-fs)**: File system access that enables model download and management.

And many other open source libraries that make this project possible!

---

Happy exploring! üöÄüì±‚ú®



================================================
FILE: app.json
================================================
{
  "name": "PocketPal",
  "displayName": "PocketPal"
}



================================================
FILE: App.tsx
================================================
import * as React from 'react';
import {Dimensions, StyleSheet} from 'react-native';

import {observer} from 'mobx-react';
import {NavigationContainer} from '@react-navigation/native';
import {Provider as PaperProvider} from 'react-native-paper';
import {BottomSheetModalProvider} from '@gorhom/bottom-sheet';
import {createDrawerNavigator} from '@react-navigation/drawer';
import {SafeAreaProvider} from 'react-native-safe-area-context';
import {KeyboardProvider} from 'react-native-keyboard-controller';
import {
  gestureHandlerRootHOC,
  GestureHandlerRootView,
} from 'react-native-gesture-handler';

import {uiStore} from './src/store';
import {useTheme} from './src/hooks';
import {Theme} from './src/utils/types';
import {initializeLookiePal} from './src/store/PalStore';

import {l10n} from './src/utils/l10n';
import {initLocale} from './src/utils';
import {L10nContext} from './src/utils';
import {ROUTES} from './src/utils/navigationConstants';

import {
  SidebarContent,
  ModelsHeaderRight,
  PalHeaderRight,
  HeaderLeft,
  AppWithMigration,
} from './src/components';
import {
  ChatScreen,
  ModelsScreen,
  SettingsScreen,
  BenchmarkScreen,
  AboutScreen,
  PalsScreen,

  // Dev tools screen. Only available in debug mode.
  DevToolsScreen,
} from './src/screens';

// Check if app is in debug mode
const isDebugMode = __DEV__;

const Drawer = createDrawerNavigator();

const screenWidth = Dimensions.get('window').width;

const App = observer(() => {
  const theme = useTheme();
  const styles = createStyles(theme);
  const currentL10n = l10n[uiStore.language];

  // Initialize locale with the current language and create default pals
  React.useEffect(() => {
    initLocale(uiStore.language);
    initializeLookiePal();
  }, []);

  return (
    <GestureHandlerRootView style={styles.root}>
      <SafeAreaProvider>
        <KeyboardProvider statusBarTranslucent navigationBarTranslucent>
          <PaperProvider theme={theme}>
            <L10nContext.Provider value={currentL10n}>
              <NavigationContainer>
                <BottomSheetModalProvider>
                  <Drawer.Navigator
                    useLegacyImplementation={false}
                    screenOptions={{
                      headerLeft: () => <HeaderLeft />,
                      drawerStyle: {
                        width: screenWidth > 400 ? 320 : screenWidth * 0.8,
                      },
                      headerStyle: {
                        backgroundColor: theme.colors.background,
                      },
                      headerTintColor: theme.colors.onBackground,
                      headerTitleStyle: styles.headerTitle,
                    }}
                    drawerContent={props => <SidebarContent {...props} />}>
                    <Drawer.Screen
                      name={ROUTES.CHAT}
                      component={gestureHandlerRootHOC(ChatScreen)}
                      options={{
                        headerShown: false,
                      }}
                    />
                    <Drawer.Screen
                      name={ROUTES.MODELS}
                      component={gestureHandlerRootHOC(ModelsScreen)}
                      options={{
                        headerRight: () => <ModelsHeaderRight />,
                        headerStyle: styles.headerWithoutDivider,
                        title: currentL10n.screenTitles.models,
                      }}
                    />
                    <Drawer.Screen
                      name={ROUTES.PALS}
                      component={gestureHandlerRootHOC(PalsScreen)}
                      options={{
                        headerRight: () => <PalHeaderRight />,
                        headerStyle: styles.headerWithoutDivider,
                        title: currentL10n.screenTitles.pals,
                      }}
                    />
                    <Drawer.Screen
                      name={ROUTES.BENCHMARK}
                      component={gestureHandlerRootHOC(BenchmarkScreen)}
                      options={{
                        headerStyle: styles.headerWithoutDivider,
                        title: currentL10n.screenTitles.benchmark,
                      }}
                    />
                    <Drawer.Screen
                      name={ROUTES.SETTINGS}
                      component={gestureHandlerRootHOC(SettingsScreen)}
                      options={{
                        headerStyle: styles.headerWithoutDivider,
                        title: currentL10n.screenTitles.settings,
                      }}
                    />
                    <Drawer.Screen
                      name={ROUTES.APP_INFO}
                      component={gestureHandlerRootHOC(AboutScreen)}
                      options={{
                        headerStyle: styles.headerWithoutDivider,
                        title: currentL10n.screenTitles.appInfo,
                      }}
                    />

                    {/* Only show Dev Tools screen in debug mode */}
                    {isDebugMode && (
                      <Drawer.Screen
                        name={ROUTES.DEV_TOOLS}
                        component={gestureHandlerRootHOC(DevToolsScreen)}
                        options={{
                          headerStyle: styles.headerWithoutDivider,
                          title: 'Dev Tools',
                        }}
                      />
                    )}
                  </Drawer.Navigator>
                </BottomSheetModalProvider>
              </NavigationContainer>
            </L10nContext.Provider>
          </PaperProvider>
        </KeyboardProvider>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
});

const createStyles = (theme: Theme) =>
  StyleSheet.create({
    root: {
      flex: 1,
    },
    headerWithoutDivider: {
      elevation: 0,
      shadowOpacity: 0,
      borderBottomWidth: 0,
      backgroundColor: theme.colors.background,
    },
    headerWithDivider: {
      backgroundColor: theme.colors.background,
    },
    headerTitle: {
      ...theme.fonts.titleSmall,
    },
  });

// Wrap the App component with AppWithMigration to show migration UI when needed
const AppWithMigrationWrapper = () => {
  return (
    <AppWithMigration>
      <App />
    </AppWithMigration>
  );
};

export default AppWithMigrationWrapper;



================================================
FILE: babel.config.js
================================================
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    ['module:react-native-dotenv', {moduleName: '@env'}],
    ['@babel/plugin-proposal-decorators', {legacy: true}],
    'react-native-reanimated/plugin',
  ],
};



================================================
FILE: CODE_OF_CONDUCT.md
================================================
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
info@llm-ventures.com.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.



================================================
FILE: commitlint.config.js
================================================
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'type-enum': [
      2,
      'always',
      [
        'feat', // New feature
        'fix', // Bug fix
        'docs', // Documentation changes
        'chore', // Refactoring, tooling, miscellaneous, etc.
      ],
    ],
  },
};



================================================
FILE: CONTRIBUTING.md
================================================
# Contributing

Thank you for your interest in contributing! We welcome all contributions, from bug reports and feature requests to code changes. Please feel free to put up a PR for any issue or feature request.

## Code of Conduct

Please be respectful to others in all interactions related to this project. We expect contributors to adhere to the [code of conduct](./CODE_OF_CONDUCT.md).

## Creating issues

If you find any bugs, have suggestions for improvements, or encounter unexpected behavior, please open an issue.
Creating an issue before submitting a PR helps us discuss the problem or feature request in advance.

## Submitting Pull Requests

We are grateful for any pull requests! To ensure a smooth contribution process, please follow these steps:

### Workflow for Contributing

1. Fork this repository.
2. Clone your fork
3. Create a new branch
4. Make your changes: Implement your feature, fix the issue, or improve the code.
5. Test your changes: Please make sure your changes are tested locally (for all affected devices).

### Testing Your Changes

We highly encourage testing your changes before submitting a pull request.

- Run the Metro server:
  ```bash
  yarn start:reset
  ```
- Run the app on iOS:
  ```bash
  yarn ios
  ```
- Run the app on Android:
  ```bash
  yarn android
  ```

### Linting and Type Checking

Make sure your code passes the lint and type check processes:

- **Lint your code** with ESLint:
  ```bash
  yarn lint
  ```
- **Type check** your code with TypeScript:
  ```bash
  yarn typecheck
  ```


### Writing Tests

Please add tests for any new features or changes. We use **Jest** for unit testing:

- Run tests:
  ```bash
  yarn test
  ```

If your changes affect the app's behavior, ensure you include or update tests as appropriate.

### Commit Message Guidelines

We follow the **Conventional Commits** specification for our commit messages to ensure clarity and consistency. Use one of the following prefixes for your commits:

- `feat`: New features (e.g., `feat: add new model support functionality`).
- `fix`: Bug fixes (e.g., `fix: resolve crash on app startup`).
- `docs`: Documentation changes (e.g., `docs: update README.md`).
- `chore`: Refactoring, tooling, testing, or configuration changes (e.g., `chore: update CI pipeline`).

### Opening a Pull Request

1. Commit your changes following the commit message guidelines.
2. Push your branch to your fork.
3. Open a pull request from your branch in your fork to the `main` branch of this repository.
4. Follow the pull request template and fill in all relevant details.

Before opening a pull request, make sure:
- Your changes are focused and kept to a **single logical change**.
- Your code is linted and passes type checks.
- Tests are added or updated if applicable.



================================================
FILE: env.d.ts
================================================
declare module '@env' {
  export const FIREBASE_FUNCTIONS_URL: string;
  export const APPCHECK_DEBUG_TOKEN_ANDROID: string;
  export const APPCHECK_DEBUG_TOKEN_IOS: string;
}



================================================
FILE: Gemfile
================================================
source 'https://rubygems.org'

# You may use http://rbenv.org/ or https://rvm.io/ to install and use this version
ruby "3.2.3"

# Cocoapods 1.15 introduced a bug which break the build. We will remove the upper
# bound in the template on Cocoapods with next React Native release.
gem 'cocoapods', '>= 1.13', '!= 1.15.0', '!= 1.15.1'
gem 'activesupport', '>= 6.1.7.5', '!= 7.1.0'

# Fastlane
gem "fastlane"
gem "fastlane-plugin-versioning"
gem 'fastlane-plugin-versioning_android'


================================================
FILE: index.js
================================================
/**
 * @format
 */

import {AppRegistry} from 'react-native';
import App from './App';
import {name as appName} from './app.json';

AppRegistry.registerComponent(appName, () => App);



================================================
FILE: jest.config.js
================================================
module.exports = {
  preset: 'react-native',
  collectCoverage: true,
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!**/index.{ts,tsx}',
    '!**/styles.{ts,tsx}',
    '!**/types.{ts,tsx}',
    '!**/*.d.ts',
    '!**/ImageView.android.ts',
    '!**/ImageView.ios.ts',
    '!**/ImageView.tsx',
  ],
  coveragePathIgnorePatterns: ['/src/screens/DevToolsScreen/'],
  coverageThreshold: {
    global: {
      branches: 60,
      functions: 60,
      lines: 60,
      statements: 60,
    },
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
  setupFiles: ['./jest/setup.ts'],
  transformIgnorePatterns: [
    'node_modules/(?!(@flyerhq|@react-native|react-native|uuid|react-native-reanimated|react-native-gesture-handler|react-native-vector-icons|react-native-image-viewing|react-native-parsed-text|@react-navigation/.*|@react-native-masked-view/masked-view|react-native-linear-gradient|react-native-picker-select|react-native-paper|react-native-keyboard-controller)/)',
  ],
  testMatch: [
    '**/__tests__/**/*.test.[jt]s?(x)',
    '**/?(*.)+(spec|test).[jt]s?(x)',
  ],
  moduleNameMapper: {
    '@react-native-async-storage/async-storage':
      '<rootDir>/__mocks__/external/@react-native-async-storage/async-storage.js',
    '@pocketpalai/llama.rn': '<rootDir>/__mocks__/external/llama.rn.ts',
    'react-dom': '<rootDir>/__mocks__/external/react-dom.js',
    'react-native-device-info':
      '<rootDir>/__mocks__/external/react-native-device-info.js',
    'react-native-document-picker':
      '<rootDir>/__mocks__/external/react-native-document-picker.js',
    '@dr.pogodin/react-native-fs':
      '<rootDir>/__mocks__/external/@dr.pogodin/react-native-fs.js',
    'react-native-haptic-feedback':
      '<rootDir>/__mocks__/external/react-native-haptic-feedback.js',
    '@react-native-firebase/app':
      '<rootDir>/__mocks__/external/@react-native-firebase/app.js',
    '@react-native-firebase/app-check':
      '<rootDir>/__mocks__/external/@react-native-firebase/app-check.js',
    '\\.svg': '<rootDir>/__mocks__/external/react-native-svg.js',
    'react-native-keychain':
      '<rootDir>/__mocks__/external/react-native-keychain.js',
    '@nozbe/watermelondb':
      '<rootDir>/__mocks__/external/@nozbe/watermelondb.js',
    '@nozbe/watermelondb/adapters/sqlite':
      '<rootDir>/__mocks__/external/@nozbe/watermelondb/adapters/sqlite.js',
    '@nozbe/watermelondb/decorators':
      '<rootDir>/__mocks__/external/@nozbe/watermelondb/decorators.js',
    '@nozbe/watermelondb/Schema':
      '<rootDir>/__mocks__/external/@nozbe/watermelondb/Schema/index.js',
    '@nozbe/watermelondb/Schema/migrations':
      '<rootDir>/__mocks__/external/@nozbe/watermelondb/Schema/migrations.js',
    '@nozbe/watermelondb/QueryDescription':
      '<rootDir>/__mocks__/external/@nozbe/watermelondb/QueryDescription.js',
    '@nozbe/watermelondb/Model':
      '<rootDir>/__mocks__/external/@nozbe/watermelondb/Model.js',
    '@nozbe/simdjson': '<rootDir>/__mocks__/external/@nozbe/simdjson.js',
    '@nozbe/sqlite': '<rootDir>/__mocks__/external/@nozbe/sqlite.js',
    '../database': '<rootDir>/__mocks__/database.js',
    'mobx-persist-store': '<rootDir>/__mocks__/external/mobx-persist-store.js',
    'react-native-image-picker':
      '<rootDir>/__mocks__/external/react-native-image-picker.js',
    'react-native-vision-camera':
      '<rootDir>/__mocks__/external/react-native-vision-camera.ts',
  },
};



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2024 Asghar Ghorbani

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: metro.config.js
================================================
const {getDefaultConfig, mergeConfig} = require('@react-native/metro-config');

//const localPackagePaths = ['localpath/code/llama.rn'];

const defaultConfig = getDefaultConfig(__dirname);
const {assetExts, sourceExts} = defaultConfig.resolver;

const config = {
  resolver: {
    //nodeModulesPaths: [...localPackagePaths], // update to resolver
    assetExts: assetExts.filter(ext => ext !== 'svg'),
    sourceExts: [...sourceExts, 'svg'],
  },
  transformer: {
    babelTransformerPath: require.resolve(
      'react-native-svg-transformer/react-native',
    ),
    getTransformOptions: async () => ({
      transform: {
        experimentalImportSupport: false,
        inlineRequires: true,
      },
    }),
    // Make sure decorators are properly transformed
    enableBabelRuntime: true,
  },
  //watchFolders: [...localPackagePaths],
};

module.exports = mergeConfig(getDefaultConfig(__dirname), config);



================================================
FILE: package.json
================================================
{
  "name": "PocketPal",
  "version": "1.10.21",
  "private": true,
  "scripts": {
    "prepare": "husky",
    "postinstall": "patch-package",
    "android": "react-native run-android",
    "build:android": "cd android && ./gradlew assembleDebug && cd ..",
    "build:android:release": "cd android && ./gradlew bundleRelease && cd ..",
    "ios": "react-native run-ios --simulator=\"iPhone 16 Pro\"",
    "ios:build": "cd ios && xcodebuild CC=clang CPLUSPLUS=clang++ LD=clang LDPLUSPLUS=clang++ -workspace PocketPal.xcworkspace -scheme PocketPal -configuration Debug -sdk iphonesimulator -arch $(uname -m) ONLY_ACTIVE_ARCH=YES GCC_OPTIMIZATION_LEVEL=0 GCC_PRECOMPILE_PREFIX_HEADER=YES ASSETCATALOG_COMPILER_OPTIMIZATION=time DEBUG_INFORMATION_FORMAT=dwarf COMPILER_INDEX_STORE_ENABLE=NO | xcpretty",
    "ios:build:release": "cd ios && xcodebuild CC=clang CPLUSPLUS=clang++ LD=clang LDPLUSPLUS=clang++ -workspace PocketPal.xcworkspace -scheme PocketPal -configuration Release -sdk iphoneos -arch arm64 -arch x86_64 GCC_OPTIMIZATION_LEVEL=s GCC_PRECOMPILE_PREFIX_HEADER=YES ASSETCATALOG_COMPILER_OPTIMIZATION=space DEBUG_INFORMATION_FORMAT=dwarf-with-dsym COMPILER_INDEX_STORE_ENABLE=YES | xcpretty",
    "clean:ios": "cd ios && xcodebuild clean -workspace PocketPal.xcworkspace -scheme PocketPal -configuration Debug && cd ..",
    "clean:android": "cd android && ./gradlew clean && cd ..",
    "clean": "yarn clean:ios && yarn clean:android",
    "lint": "eslint .",
    "typecheck": "tsc --noEmit",
    "lint:fix": "eslint \"**/*.{js,ts,tsx}\" --fix",
    "format": "prettier --write \"**/*.{js,ts,tsx,json,md}\"",
    "start": "react-native start",
    "start:reset": "react-native start --reset-cache",
    "test": "jest"
  },
  "dependencies": {
    "@dr.pogodin/react-native-fs": "2.30.3",
    "@flyerhq/react-native-link-preview": "^1.6.0",
    "@gorhom/bottom-sheet": "^5.0.6",
    "@hookform/resolvers": "^3.10.0",
    "@nozbe/watermelondb": "^0.28.0",
    "@pocketpalai/llama.rn": "^0.6.7-2",
    "@react-native-async-storage/async-storage": "^2.1.0",
    "@react-native-clipboard/clipboard": "^1.15.0",
    "@react-native-community/blur": "^4.4.1",
    "@react-native-community/slider": "^4.5.5",
    "@react-native-firebase/app": "21.6.1",
    "@react-native-firebase/app-check": "21.6.1",
    "@react-native-masked-view/masked-view": "^0.3.1",
    "@react-native-picker/picker": "^2.10.2",
    "@react-navigation/bottom-tabs": "^6.6.1",
    "@react-navigation/drawer": "^6.6.15",
    "@react-navigation/native": "^6.1.17",
    "@react-navigation/stack": "^6.3.29",
    "axios": "^1.8.2",
    "chat-formatter": "^0.3.4",
    "date-fns": "^3.6.0",
    "dayjs": "^1.11.11",
    "mobx": "^6.12.3",
    "mobx-persist-store": "^1.1.5",
    "mobx-react": "^9.1.1",
    "react": "18.3.1",
    "react-hook-form": "^7.54.2",
    "react-native": "0.76.3",
    "react-native-config": "^1.5.1",
    "react-native-device-info": "^14.0.4",
    "react-native-document-picker": "^9.1.2",
    "react-native-gesture-handler": "^2.20.2",
    "react-native-get-random-values": "^1.11.0",
    "react-native-haptic-feedback": "^2.3.3",
    "react-native-image-picker": "^8.2.1",
    "react-native-image-viewing": "^0.2.2",
    "react-native-keyboard-controller": "^1.16.4",
    "react-native-keychain": "^10.0.0",
    "react-native-linear-gradient": "^2.8.3",
    "react-native-marked": "^6.0.4",
    "react-native-modal": "^13.0.1",
    "react-native-paper": "^5.12.5",
    "react-native-parsed-text": "^0.0.22",
    "react-native-picker-select": "^9.1.3",
    "react-native-reanimated": "^3.16.3",
    "react-native-render-html": "^6.3.4",
    "react-native-safe-area-context": "^4.14.0",
    "react-native-screens": "^4.8.0",
    "react-native-share": "^12.0.9",
    "react-native-svg": "^15.11.1",
    "react-native-vector-icons": "^10.1.0",
    "react-native-vision-camera": "^4.6.4",
    "uuid": "^10.0.0",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@babel/plugin-proposal-decorators": "^7.27.1",
    "@babel/preset-env": "^7.25.3",
    "@babel/runtime": "^7.27.4",
    "@commitlint/cli": "^19.6.0",
    "@commitlint/config-conventional": "^19.6.0",
    "@react-native-community/cli": "15.0.1",
    "@react-native-community/cli-platform-android": "15.0.1",
    "@react-native-community/cli-platform-ios": "15.0.1",
    "@react-native/babel-preset": "0.76.3",
    "@react-native/eslint-config": "0.73.2",
    "@react-native/metro-config": "0.76.3",
    "@react-native/typescript-config": "0.76.3",
    "@testing-library/react-hooks": "^8.0.1",
    "@testing-library/react-native": "^12.9.0",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.17.13",
    "@types/react": "^18.2.6",
    "@types/react-test-renderer": "^18.0.0",
    "@types/uuid": "^10.0.0",
    "babel-jest": "^29.6.3",
    "eslint": "^8.19.0",
    "husky": "^9.1.7",
    "jest": "^29.6.3",
    "patch-package": "^8.0.0",
    "postinstall-postinstall": "^2.1.0",
    "prettier": "2.8.8",
    "react-native-dotenv": "^3.4.11",
    "react-native-svg-transformer": "^1.5.0",
    "react-test-renderer": "18.3.1",
    "typescript": "5.0.4"
  },
  "engines": {
    "node": ">=18"
  },
  "packageManager": "yarn@1.22.22"
}



================================================
FILE: react-native.config.js
================================================
module.exports = {
  project: {
    ios: {},
    android: {},
  },
  assets: ['./src/assets/fonts'],
};



================================================
FILE: tsconfig.json
================================================
{
  "extends": "@react-native/typescript-config/tsconfig.json",
  "compilerOptions": {
    "noImplicitAny": false,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "useDefineForClassFields": true
  }
}



================================================
FILE: .env.example
================================================
APP_RELEASE_STORE_PASSWORD=
APP_RELEASE_KEY_PASSWORD=
FIREBASE_FUNCTIONS_URL=

# Debug tokens (only for local development)
APPCHECK_DEBUG_TOKEN_ANDROID=
APPCHECK_DEBUG_TOKEN_IOS= 


================================================
FILE: .eslintrc.js
================================================
module.exports = {
  root: true,
  extends: '@react-native',
  ignorePatterns: ['coverage/'],
};



================================================
FILE: .prettierrc.js
================================================
module.exports = {
  arrowParens: 'avoid',
  bracketSameLine: true,
  bracketSpacing: false,
  singleQuote: true,
  trailingComma: 'all',
};



================================================
FILE: .svgrrc
================================================
{
  "replaceAttrValues": {
    "#333333": "{props.fill}",
    "#858585": "{props.fill}",
    "#FF653F": "{props.fill}"
  }
}



================================================
FILE: .version
================================================
1.10.21



================================================
FILE: .watchmanconfig
================================================
{}



================================================
FILE: .yarnrc.yml
================================================
nodeLinker: node-modules



================================================
FILE: __mocks__/database.js
================================================
import {Database} from '@nozbe/watermelondb';
import {Q} from '@nozbe/watermelondb/QueryDescription';

// Mock models
class ChatSession {
  static table = 'chat_sessions';
  static associations = {
    messages: {type: 'has_many', foreignKey: 'session_id'},
    completion_settings: {type: 'has_many', foreignKey: 'session_id'},
  };
}

class Message {
  static table = 'messages';
  static associations = {
    chat_sessions: {type: 'belongs_to', key: 'session_id'},
  };
}

class CompletionSetting {
  static table = 'completion_settings';
  static associations = {
    chat_sessions: {type: 'belongs_to', key: 'session_id'},
  };
}

class GlobalSetting {
  static table = 'global_settings';
}

// Mock schema
const schema = {
  version: 1,
  tables: [
    {
      name: 'chat_sessions',
      columns: [
        {name: 'title', type: 'string'},
        {name: 'date', type: 'string'},
        {name: 'active_pal_id', type: 'string', isOptional: true},
        {name: 'created_at', type: 'number'},
        {name: 'updated_at', type: 'number'},
      ],
    },
    {
      name: 'messages',
      columns: [
        {name: 'session_id', type: 'string', isIndexed: true},
        {name: 'author', type: 'string'},
        {name: 'text', type: 'string', isOptional: true},
        {name: 'type', type: 'string'},
        {name: 'created_at', type: 'number'},
        {name: 'metadata', type: 'string'},
        {name: 'position', type: 'number'},
      ],
    },
    {
      name: 'completion_settings',
      columns: [
        {name: 'session_id', type: 'string', isIndexed: true},
        {name: 'settings', type: 'string'},
        {name: 'created_at', type: 'number'},
        {name: 'updated_at', type: 'number'},
      ],
    },
    {
      name: 'global_settings',
      columns: [
        {name: 'key', type: 'string', isIndexed: true},
        {name: 'value', type: 'string'},
        {name: 'created_at', type: 'number'},
        {name: 'updated_at', type: 'number'},
      ],
    },
  ],
};

// Mock migrations
const migrations = {
  migrations: [],
};

// Mock adapter
const adapter = {
  schema,
  migrations,
  dbName: 'pocketpalai_test',
  jsi: false,
};

// Mock database
export const database = new Database({
  adapter,
  modelClasses: [ChatSession, Message, CompletionSetting, GlobalSetting],
});

// Export models
export {ChatSession, Message, CompletionSetting, GlobalSetting, Q};



================================================
FILE: __mocks__/external/llama.rn.ts
================================================
class MockLlamaContext {
  id: number;
  gpu: boolean;
  reasonNoGPU: string;
  model: {isChatTemplateSupported?: boolean};

  constructor({
    contextId,
    gpu = false,
    reasonNoGPU = '',
    model = {},
  }: {
    contextId: number;
    gpu?: boolean;
    reasonNoGPU?: string;
    model?: {isChatTemplateSupported?: boolean};
  }) {
    this.id = contextId;
    this.gpu = gpu;
    this.reasonNoGPU = reasonNoGPU;
    this.model = model;
  }

  loadSession = jest.fn();
  saveSession = jest.fn();
  completion = jest.fn();
  stopCompletion = jest.fn();
  bench = jest.fn();
  // Add other methods if needed.
}

export const LlamaContext = jest
  .fn()
  .mockImplementation((params: any) => new MockLlamaContext(params));

export const loadLlamaModelInfo = jest.fn();

export default {
  LlamaContext,
  initLlama: jest.fn(),
  CompletionParams: jest.fn(),
  loadLlamaModelInfo,
};



================================================
FILE: __mocks__/external/mobx-persist-store.js
================================================
// Mock the named export
export const makePersistable = jest.fn().mockImplementation(() => {
  return Promise.resolve();
});



================================================
FILE: __mocks__/external/react-dom.js
================================================
export default {};



================================================
FILE: __mocks__/external/react-native-device-info.js
================================================
import {deviceInfo} from '../../jest/fixtures/device-info';

export default {
  getUniqueId: jest.fn(() => 'unique-id'),
  getManufacturer: jest.fn(() => 'Apple'),
  getModel: jest.fn(() => 'iPhone 12'),
  getSystemVersion: jest.fn(() => '14.5'),
  getFreeDiskStorage: jest.fn(() => deviceInfo.freeDiskStorage),
  getTotalMemory: jest.fn(() => deviceInfo.totalMemory),
  getUsedMemory: jest.fn(() => deviceInfo.usedMemory),
  getVersion: jest.fn(() => deviceInfo.version),
  getBuildNumber: jest.fn(() => deviceInfo.buildNumber),
  isEmulator: jest.fn(() => false),
  getBrand: jest.fn(() => 'Apple'),
  getDevice: jest.fn(() => 'iPhone 12'),
  getDeviceId: jest.fn(() => 'test-device-id'),
  supportedAbis: jest.fn(() => ['arm64', 'arm64-v8a']),

  // Not all methods are mocked, add any other methods from react-native-device-info that you use in your code
};



================================================
FILE: __mocks__/external/react-native-document-picker.js
================================================
export default {
  pick: jest.fn(() =>
    Promise.resolve({
      uri: 'dummy-uri',
      type: 'dummy-type',
      name: 'dummy-name',
      size: 1234,
    }),
  ),
  pickMultiple: jest.fn(() =>
    Promise.resolve([
      {
        uri: 'dummy-uri',
        type: 'dummy-type',
        name: 'dummy-name',
        size: 1234,
      },
    ]),
  ),
  types: {
    allFiles: 'public.all-files',
    images: 'public.images',
  },
};

//export default DocumentPicker;



================================================
FILE: __mocks__/external/react-native-haptic-feedback.js
================================================
const ReactNativeHapticFeedback = {
  trigger: jest.fn(),
};

export default ReactNativeHapticFeedback;



================================================
FILE: __mocks__/external/react-native-image-picker.js
================================================
export const launchCamera = jest.fn(options => {
  return Promise.resolve({
    didCancel: false,
    assets: [
      {
        uri: 'file://mock-image.jpg',
        fileName: 'mock-image.jpg',
        type: 'image/jpeg',
      },
    ],
  });
});

export const launchImageLibrary = jest.fn(options => {
  return Promise.resolve({
    didCancel: false,
    assets: [
      {
        uri: 'file://mock-image-library.jpg',
        fileName: 'mock-image-library.jpg',
        type: 'image/jpeg',
      },
    ],
  });
});



================================================
FILE: __mocks__/external/react-native-keychain.js
================================================
export const setGenericPassword = jest.fn(() => Promise.resolve('mockPass'));
export const getGenericPassword = jest.fn(() =>
  Promise.resolve({password: 'mockPass', username: 'mockUser'}),
);
export const resetGenericPassword = jest.fn(() => Promise.resolve(null));



================================================
FILE: __mocks__/external/react-native-svg.js
================================================
module.exports = 'SvgMock';



================================================
FILE: __mocks__/external/react-native-vision-camera.ts
================================================
export const Camera = 'Camera';
export const useCameraDevice = jest.fn(() => ({
  id: 'back',
  name: 'Back Camera',
  position: 'back',
  devices: [],
}));
export const useCameraPermission = jest.fn(() => ({
  hasPermission: true,
  requestPermission: jest.fn(),
}));



================================================
FILE: __mocks__/external/@dr.pogodin/react-native-fs.js
================================================
// Track deleted files for stateful behavior in tests
const deletedFiles = new Set();
export const stat = jest.fn();
export const mkdir = jest.fn();
export const unlink = jest.fn().mockImplementation(path => {
  deletedFiles.add(path);
  console.log('deleting: ', path);
  return Promise.resolve();
});
export const exists = jest.fn().mockImplementation(path => {
  const fileExists = !deletedFiles.has(path);
  if (fileExists) {
    console.log(
      'checkFileExists: marking as downloaded - this should not happen:',
      path.split('/').pop()?.replace('.gguf', ''),
    );
  }
  return Promise.resolve(fileExists);
});
export const stopDownload = jest.fn();
export const readFile = jest.fn(path => {
  if (path.includes('session-metadata.json')) {
    // Return valid session metadata JSON
    return Promise.resolve(
      JSON.stringify([
        {
          id: '1',
          title: 'Test Session',
          date: '2024-01-01T00:00:00Z',
          messages: [],
        },
      ]),
    );
  }

  // Handle other required file.
  return Promise.resolve('Some default content');
});
export const writeFile = jest.fn(() => {
  return Promise.resolve();
});
export const downloadFile = jest.fn();
export const DocumentDirectoryPath = '/path/to/documents';
export const copyFile = jest.fn().mockResolvedValue(true);

// Expose method to reset state for tests
export const __resetMockState = () => {
  deletedFiles.clear();
};

// Add namespace export for compatibility
const RNFS = {
  mkdir,
  stat,
  unlink,
  exists,
  stopDownload,
  readFile,
  writeFile,
  downloadFile,
  DocumentDirectoryPath,
  copyFile,
  __resetMockState,
};

export {RNFS};



================================================
FILE: __mocks__/external/@nozbe/simdjson.js
================================================
// Mock for simdjson
export default {};



================================================
FILE: __mocks__/external/@nozbe/sqlite.js
================================================
// Mock for @nozbe/sqlite
export default class SQLite {
  constructor() {
    // Mock constructor
  }

  // Add any methods you need
}



================================================
FILE: __mocks__/external/@nozbe/watermelondb.js
================================================
// Mock for WatermelonDB

// Mock Model class
class MockModel {
  constructor(collection, raw = {}) {
    this.collection = collection;
    this._raw = raw;
    this.id = raw.id || 'mock-id-' + Math.random().toString(36).substring(7);

    // Copy all properties from raw to this
    Object.keys(raw).forEach(key => {
      this[key] = raw[key];
    });
  }

  // Common Model methods
  update() {
    return Promise.resolve(this);
  }

  prepareUpdate() {
    return record => {
      // This function will be called with the record to update
      return Promise.resolve(this);
    };
  }

  markAsDeleted() {
    return Promise.resolve();
  }

  destroyPermanently() {
    return Promise.resolve();
  }

  // Add any other methods you need
}

// Mock Collection class
class MockCollection {
  constructor(database, modelClass) {
    this.database = database;
    this.modelClass = modelClass;
    this.table = modelClass.table;
    this._records = [];
  }

  // Mock query builder
  query() {
    return {
      fetch: () => Promise.resolve(this._records),
      observe: () => ({
        subscribe: callback => {
          callback(this._records);
          return {unsubscribe: () => {}};
        },
      }),
      where: () => this.query(),
      find: id =>
        Promise.resolve(this._records.find(record => record.id === id)),
    };
  }

  // Create a new record
  create(recordCreator) {
    const newRecord = new this.modelClass(this);
    if (typeof recordCreator === 'function') {
      recordCreator(newRecord);
    } else if (recordCreator) {
      Object.assign(newRecord, recordCreator);
    }
    this._records.push(newRecord);
    return Promise.resolve(newRecord);
  }

  // Find a record by ID
  find(id) {
    return Promise.resolve(this._records.find(record => record.id === id));
  }

  // Add any other methods you need
}

// Mock Database class
class MockDatabase {
  constructor(options = {}) {
    this.collections = new Map();
    this._adapter = options.adapter || {};

    // Initialize collections from modelClasses
    if (options.modelClasses) {
      options.modelClasses.forEach(modelClass => {
        this.collections.set(
          modelClass.table,
          new MockCollection(this, modelClass),
        );
      });
    }
  }

  // Get a collection by name
  get(collectionName) {
    return this.collections.get(collectionName);
  }

  // Batch operations
  batch(...operations) {
    return Promise.resolve();
  }

  // Write operations
  write(callback) {
    return Promise.resolve(callback());
  }

  // Action operations
  action(callback) {
    return callback();
  }

  // Add any other methods you need
}

// Mock SQLiteAdapter
class MockSQLiteAdapter {
  constructor(options = {}) {
    this.schema = options.schema;
    this.migrations = options.migrations;
    this.dbName = options.dbName;
  }

  // Add any methods you need
}

// Mock decorators
const text = () => (target, key) => {};
const field = () => (target, key) => {};
const date = () => (target, key) => {};
const children = () => (target, key) => {};
const relation = () => (target, key) => {};
const readonly = () => (target, key) => {};
const immutableRelation = () => (target, key) => {};
const json = () => (target, key) => {};
const nochange = () => (target, key) => {};

// Mock schema builders
const appSchema = schema => schema;
const tableSchema = schema => schema;

// Mock migrations
const schemaMigrations = migrations => migrations;
const createTable = table => ({type: 'create_table', table});
const addColumns = (table, columns) => ({type: 'add_columns', table, columns});
const createIndex = (table, columns) => ({
  type: 'create_index',
  table,
  columns,
});

// Export all the mocks
module.exports = {
  Database: MockDatabase,
  Model: MockModel,
  Collection: MockCollection,

  // Adapters
  SQLiteAdapter: MockSQLiteAdapter,

  // Decorators
  text,
  field,
  date,
  children,
  relation,
  readonly,
  immutableRelation,
  json,
  nochange,

  // Schema
  appSchema,
  tableSchema,

  // Migrations
  schemaMigrations,
  createTable,
  addColumns,
  createIndex,

  // Q for queries
  Q: {
    where: jest.fn(() => ({})),
    eq: jest.fn(() => ({})),
    gt: jest.fn(() => ({})),
    gte: jest.fn(() => ({})),
    lt: jest.fn(() => ({})),
    lte: jest.fn(() => ({})),
    between: jest.fn(() => ({})),
    oneOf: jest.fn(() => ({})),
    notIn: jest.fn(() => ({})),
    like: jest.fn(() => ({})),
    notLike: jest.fn(() => ({})),
    sanitizeLikeString: jest.fn(string => string),
    on: jest.fn(() => ({})),
    and: jest.fn(() => ({})),
    or: jest.fn(() => ({})),
    sortBy: jest.fn(() => ({})),
    desc: jest.fn(() => ({})),
    asc: jest.fn(() => ({})),
    take: jest.fn(() => ({})),
    skip: jest.fn(() => ({})),
    unsafe: jest.fn(() => ({})),
  },
};



================================================
FILE: __mocks__/external/@nozbe/watermelondb/decorators.js
================================================
// Mock decorators
export const text = () => (target, key) => {};
export const field = () => (target, key) => {};
export const date = () => (target, key) => {};
export const children = () => (target, key) => {};
export const relation = () => (target, key) => {};
export const readonly = () => (target, key) => {};
export const immutableRelation = () => (target, key) => {};
export const json = () => (target, key) => {};
export const nochange = () => (target, key) => {};



================================================
FILE: __mocks__/external/@nozbe/watermelondb/Model.js
================================================
// Mock Model class
export default class Model {
  constructor(collection, raw = {}) {
    this.collection = collection;
    this._raw = raw;
    this.id = raw.id || 'mock-id-' + Math.random().toString(36).substring(7);

    // Copy all properties from raw to this
    Object.keys(raw).forEach(key => {
      this[key] = raw[key];
    });
  }

  // Common Model methods
  update() {
    return Promise.resolve(this);
  }

  prepareUpdate() {
    return record => {
      // This function will be called with the record to update
      return Promise.resolve(this);
    };
  }

  markAsDeleted() {
    return Promise.resolve();
  }

  destroyPermanently() {
    return Promise.resolve();
  }
}

// Mock Associations type
export const Associations = {};



================================================
FILE: __mocks__/external/@nozbe/watermelondb/QueryDescription.js
================================================
// Mock Q for queries
export const Q = {
  where: jest.fn(() => ({})),
  eq: jest.fn(() => ({})),
  gt: jest.fn(() => ({})),
  gte: jest.fn(() => ({})),
  lt: jest.fn(() => ({})),
  lte: jest.fn(() => ({})),
  between: jest.fn(() => ({})),
  oneOf: jest.fn(() => ({})),
  notIn: jest.fn(() => ({})),
  like: jest.fn(() => ({})),
  notLike: jest.fn(() => ({})),
  sanitizeLikeString: jest.fn(string => string),
  on: jest.fn(() => ({})),
  and: jest.fn(() => ({})),
  or: jest.fn(() => ({})),
  sortBy: jest.fn(() => ({})),
  desc: jest.fn(() => ({})),
  asc: jest.fn(() => ({})),
  take: jest.fn(() => ({})),
  skip: jest.fn(() => ({})),
  unsafe: jest.fn(() => ({})),
};



================================================
FILE: __mocks__/external/@nozbe/watermelondb/adapters/sqlite.js
================================================
// Mock for SQLiteAdapter
class MockSQLiteAdapter {
  constructor(options = {}) {
    this.schema = options.schema;
    this.migrations = options.migrations;
    this.dbName = options.dbName;
  }
}

export default MockSQLiteAdapter;



================================================
FILE: __mocks__/external/@nozbe/watermelondb/Schema/index.js
================================================
// Mock schema builders
export const appSchema = schema => schema;
export const tableSchema = schema => schema;



================================================
FILE: __mocks__/external/@nozbe/watermelondb/Schema/migrations.js
================================================
// Mock migrations
export const schemaMigrations = migrations => migrations;
export const createTable = table => ({type: 'create_table', table});
export const addColumns = (table, columns) => ({
  type: 'add_columns',
  table,
  columns,
});
export const createIndex = (table, columns) => ({
  type: 'create_index',
  table,
  columns,
});



================================================
FILE: __mocks__/external/@react-native-async-storage/async-storage.js
================================================
import mockAsyncStorage from '@react-native-async-storage/async-storage/jest/async-storage-mock';

export default mockAsyncStorage;
export * from '@react-native-async-storage/async-storage/jest/async-storage-mock';
// https://react-native-async-storage.github.io/async-storage/docs/advanced/jest/



================================================
FILE: __mocks__/external/@react-native-firebase/app-check.js
================================================
const mockAppCheck = {
  newReactNativeFirebaseAppCheckProvider: jest.fn().mockReturnValue({
    configure: jest.fn(),
  }),
  initializeAppCheck: jest.fn(),
  getToken: jest.fn().mockResolvedValue({token: 'mock-token'}),
};

export default () => ({
  appCheck: () => mockAppCheck,
});



================================================
FILE: __mocks__/external/@react-native-firebase/app.js
================================================
const mockFirebase = {
  appCheck: jest.fn().mockReturnValue({
    newReactNativeFirebaseAppCheckProvider: jest.fn().mockReturnValue({
      configure: jest.fn(),
    }),
    initializeAppCheck: jest.fn(),
    getToken: jest.fn().mockResolvedValue({token: 'mock-token'}),
  }),
};

export default mockFirebase;



================================================
FILE: __mocks__/repositories/ChatSessionRepository.js
================================================
import {defaultCompletionParams} from '../utils/completionSettingsVersions';

// Default completion settings without prompt and stop
const defaultCompletionSettings = {...defaultCompletionParams};
delete defaultCompletionSettings.prompt;
delete defaultCompletionSettings.stop;

class ChatSessionRepository {
  // Check if we need to migrate from JSON files
  async checkAndMigrateFromJSON() {
    return false; // Mock: no migration needed
  }

  // Get all sessions grouped by date
  async getAllSessions() {
    return []; // Mock: return empty array
  }

  // Get a single session with its messages and settings
  async getSessionById(id) {
    return {
      session: {
        id,
        title: 'Mock Session',
        date: new Date().toISOString(),
      },
      messages: [],
      completionSettings: {
        id: 'mock-settings-id',
        sessionId: id,
        settings: JSON.stringify(defaultCompletionSettings),
        getSettings: () => defaultCompletionSettings,
      },
    };
  }

  // Create a new session
  async createSession(
    title,
    initialMessages = [],
    completionSettings = defaultCompletionSettings,
    activePalId,
  ) {
    return {
      id: 'mock-session-id',
      title,
      date: new Date().toISOString(),
      activePalId,
    };
  }

  // Delete a session
  async deleteSession(id) {
    return; // Mock: do nothing
  }

  // Add a message to a session
  async addMessageToSession(sessionId, message) {
    return {
      id: 'mock-message-id',
      sessionId,
      author: message.author.id,
      text: message.text,
      type: message.type,
      createdAt: Date.now(),
      metadata: JSON.stringify(message.metadata || {}),
      position: 1,
    };
  }

  // Update a message
  async updateMessage(id, update) {
    return; // Mock: do nothing
  }

  async deleteMessage(id) {
    return; // Mock: do nothing
  }

  async setSessionActivePal(sessionId, palId) {
    return; // Mock: do nothing
  }

  // Update session completion settings
  async updateSessionCompletionSettings(sessionId, settings) {
    return; // Mock: do nothing
  }

  // Get global completion settings
  async getGlobalCompletionSettings() {
    return defaultCompletionSettings;
  }

  // Save global completion settings
  async saveGlobalCompletionSettings(settings) {
    return; // Mock: do nothing
  }

  // Update session title
  async updateSessionTitle(sessionId, newTitle) {
    return; // Mock: do nothing
  }
}

export const chatSessionRepository = new ChatSessionRepository();



================================================
FILE: __mocks__/services/downloads.ts
================================================
import {downloadingModel} from '../../jest/fixtures/models';

export const downloadManager = {
  isDownloading: jest.fn().mockImplementation(modelId => {
    // Return true for specific model IDs that should be "downloading"
    return modelId === downloadingModel.id;
  }),
  getDownloadProgress: jest.fn().mockImplementation(modelId => {
    return modelId === downloadingModel.id ? 50 : 0;
  }),
  startDownload: jest.fn().mockResolvedValue(undefined),
  cancelDownload: jest.fn(),
  setCallbacks: jest.fn(),
  syncWithActiveDownloads: jest.fn(),
};



================================================
FILE: __mocks__/stores/benchmarkStore.ts
================================================
import {BenchmarkResult} from '../../src/utils/types';
import {mockResult} from '../../jest/fixtures/benchmark';

// Create mock functions
const mockRemoveResult = jest.fn((timestamp: string) => {
  benchmarkStore.results = benchmarkStore.results.filter(
    result => result.timestamp !== timestamp,
  );
});

const mockClearResults = jest.fn(() => {
  benchmarkStore.results = [];
});

const mockAddResult = jest.fn((result: BenchmarkResult) => {
  benchmarkStore.results.unshift(result);
});

const mockMarkAsSubmitted = jest.fn((uuid: string) => {
  const result = benchmarkStore.results.find(r => r.uuid === uuid);
  if (result) {
    result.submitted = true;
  }
});

const mockGetResultsByModel = jest.fn((modelId: string): BenchmarkResult[] => {
  return benchmarkStore.results.filter(result => result.modelId === modelId);
});

// Define the mockBenchmarkStore
export const benchmarkStore = {
  results: [mockResult],
  addResult: mockAddResult,
  removeResult: mockRemoveResult,
  clearResults: mockClearResults,
  markAsSubmitted: mockMarkAsSubmitted,
  getResultsByModel: mockGetResultsByModel,
  latestResult: mockResult,
};



================================================
FILE: __mocks__/stores/chatSessionStore.ts
================================================
import {sessionFixtures} from '../../jest/fixtures/chatSessions';
import {defaultCompletionSettings} from '../../src/store/ChatSessionStore';

export const mockChatSessionStore = {
  sessions: sessionFixtures,
  //currentSessionMessages: [],
  activeSessionId: 'session-1',
  newChatCompletionSettings: defaultCompletionSettings,
  isMigrating: false,
  migrationComplete: true,
  loadSessionList: jest.fn().mockResolvedValue(undefined),
  loadGlobalSettings: jest.fn().mockResolvedValue(undefined),
  deleteSession: jest.fn().mockResolvedValue(undefined),
  setActiveSession: jest.fn(),
  addMessageToCurrentSession: jest.fn().mockResolvedValue(undefined),
  resetActiveSession: jest.fn(),
  updateSessionTitle: jest.fn().mockResolvedValue(undefined),
  updateSessionTitleBySessionId: jest.fn().mockResolvedValue(undefined),
  groupedSessions: {
    Today: [sessionFixtures[0]],
    Yesterday: [sessionFixtures[1]],
  },
  createNewSession: jest.fn().mockResolvedValue(undefined),
  updateMessage: jest.fn().mockResolvedValue(undefined),
  updateMessageToken: jest.fn().mockResolvedValue(undefined),
  updateSessionCompletionSettings: jest.fn().mockResolvedValue(undefined),
  applySessionSettingsToGlobal: jest.fn().mockResolvedValue(undefined),
  resetSessionSettingsToGlobal: jest.fn().mockResolvedValue(undefined),
  exitEditMode: jest.fn(),
  enterEditMode: jest.fn(),
  removeMessagesFromId: jest.fn(),
  setIsGenerating: jest.fn(),
  duplicateSession: jest.fn().mockResolvedValue(undefined),
  setNewChatCompletionSettings: jest.fn().mockResolvedValue(undefined),
  resetNewChatCompletionSettings: jest.fn().mockResolvedValue(undefined),
  setActivePal: jest.fn().mockResolvedValue(undefined),
  dateGroupNames: {
    today: 'Today',
    yesterday: 'Yesterday',
    thisWeek: 'This week',
    lastWeek: 'Last week',
    twoWeeksAgo: '2 weeks ago',
    threeWeeksAgo: '3 weeks ago',
    fourWeeksAgo: '4 weeks ago',
    lastMonth: 'Last month',
    older: 'Older',
  },
  setDateGroupNames: jest.fn(),
  initialize: jest.fn().mockResolvedValue(undefined),
};

Object.defineProperty(mockChatSessionStore, 'currentSessionMessages', {
  get: jest.fn(() => []),
  configurable: true,
});

Object.defineProperty(mockChatSessionStore, 'activePalId', {
  get: jest.fn(() => null),
  configurable: true,
});

Object.defineProperty(mockChatSessionStore, 'shouldShowHeaderDivider', {
  get: jest.fn(() => true),
  configurable: true,
});



================================================
FILE: __mocks__/stores/hfStore.ts
================================================
import {mockHFModel1, mockHFModel2} from '../../jest/fixtures/models';

export const mockHFStore = {
  models: [mockHFModel1, mockHFModel2],
  isLoading: false,
  error: '',
  nextPageLink: null,
  searchQuery: '',
  queryFilter: 'gguf',
  queryFull: true,
  queryConfig: true,
  hfToken: '',
  useHfToken: true,

  get isTokenPresent(): boolean {
    return !!this.hfToken && this.hfToken.trim().length > 0;
  },
  get shouldUseToken(): boolean {
    return this.isTokenPresent && this.useHfToken;
  },

  setUseHfToken: jest.fn(),
  setToken: jest.fn().mockResolvedValue(Promise.resolve(true)),
  clearToken: jest.fn().mockResolvedValue(Promise.resolve(true)),

  // Methods
  setSearchQuery: jest.fn(),
  fetchAndSetGGUFSpecs: jest.fn().mockResolvedValue(undefined),
  fetchModelFileDetails: jest.fn().mockResolvedValue(undefined),
  getModelById: jest.fn(id =>
    mockHFStore.models.find(model => model.id === id),
  ),
  fetchModelData: jest.fn().mockResolvedValue(undefined),
  fetchModels: jest.fn().mockResolvedValue(undefined),
  fetchMoreModels: jest.fn().mockResolvedValue(undefined),
};

// Mock the store instance
export const hfStore = mockHFStore;



================================================
FILE: __mocks__/stores/modelStore.ts
================================================
import {computed, makeAutoObservable} from 'mobx';

import {modelsList} from '../../jest/fixtures/models';

import {downloadManager} from '../services/downloads';

import {Model} from '../../src/utils/types';
import {LlamaContext} from '@pocketpalai/llama.rn';

class MockModelStore {
  models = modelsList;
  n_context = 1024;
  n_batch = 512;
  n_ubatch = 512;
  n_threads = 4;
  max_threads = 4;
  MIN_CONTEXT_SIZE = 200;
  useAutoRelease = true;
  useMetal = false;
  n_gpu_layers = 50;
  activeModelId: string | undefined;
  inferencing = false;
  isStreaming = false;
  context: LlamaContext | undefined = undefined;

  refreshDownloadStatuses: jest.Mock;
  addLocalModel: jest.Mock;
  setNContext: jest.Mock;
  updateUseAutoRelease: jest.Mock;
  updateUseMetal: jest.Mock;
  setNGPULayers: jest.Mock;
  resetModels: jest.Mock;
  initContext: jest.Mock;
  lastUsedModelId: any;
  checkSpaceAndDownload: jest.Mock;
  getDownloadProgress: jest.Mock;
  manualReleaseContext: jest.Mock;
  addHFModel: jest.Mock;
  downloadHFModel: jest.Mock;
  cancelDownload: jest.Mock;
  disableAutoRelease: jest.Mock;
  enableAutoRelease: jest.Mock;
  deleteModel: jest.Mock;
  removeModelFromList: jest.Mock;
  canDeleteProjectionModel: jest.Mock;
  setDefaultProjectionModel: jest.Mock;
  isContextLoading: boolean = false;
  loadingModel: Model | undefined;

  constructor() {
    makeAutoObservable(this, {
      refreshDownloadStatuses: false,
      addLocalModel: false,
      setNContext: false,
      updateUseAutoRelease: false,
      updateUseMetal: false,
      setNGPULayers: false,
      resetModels: false,
      initContext: false,
      checkSpaceAndDownload: false,
      getDownloadProgress: false,
      manualReleaseContext: false,
      addHFModel: false,
      downloadHFModel: false,
      cancelDownload: false,
      disableAutoRelease: false,
      enableAutoRelease: false,
      deleteModel: false,
      removeModelFromList: false,
      canDeleteProjectionModel: false,
      setDefaultProjectionModel: false,
      lastUsedModel: computed,
      activeModel: computed,
      displayModels: computed,
      availableModels: computed,
      isDownloading: computed,
    });
    this.refreshDownloadStatuses = jest.fn();
    this.addLocalModel = jest.fn();
    this.setNContext = jest.fn();
    this.updateUseAutoRelease = jest.fn();
    this.updateUseMetal = jest.fn();
    this.setNGPULayers = jest.fn();
    this.resetModels = jest.fn();
    this.initContext = jest.fn().mockResolvedValue(Promise.resolve());
    this.checkSpaceAndDownload = jest.fn();
    this.getDownloadProgress = jest.fn();
    this.manualReleaseContext = jest.fn();
    this.addHFModel = jest.fn();
    this.downloadHFModel = jest.fn();
    this.cancelDownload = jest.fn();
    this.disableAutoRelease = jest.fn();
    this.enableAutoRelease = jest.fn();
    this.deleteModel = jest.fn().mockResolvedValue(Promise.resolve());
    this.removeModelFromList = jest.fn();
    this.canDeleteProjectionModel = jest.fn().mockReturnValue({
      canDelete: true,
      reason: null,
      dependentModels: [],
    });
    this.setDefaultProjectionModel = jest.fn();
  }

  setActiveModel = (modelId: string) => {
    this.activeModelId = modelId;
  };

  setInferencing = (value: boolean) => {
    this.inferencing = value;
  };

  setIsStreaming = (value: boolean) => {
    this.isStreaming = value;
  };

  get lastUsedModel(): Model | undefined {
    return this.lastUsedModelId
      ? this.models.find(m => m.id === this.lastUsedModelId)
      : undefined;
  }

  get isDownloading() {
    return (modelId: string) => {
      return downloadManager.isDownloading(modelId);
    };
  }

  get activeModel() {
    return this.models.find(model => model.id === this.activeModelId);
  }

  get displayModels(): Model[] {
    // Filter out projection models for display purposes
    return this.models.filter(model => model.modelType !== 'projection');
  }

  get availableModels() {
    return this.models.filter(model => model.isDownloaded);
  }

  isModelAvailable(modelId: string) {
    return this.availableModels.some(model => model.id === modelId);
  }

  async isMultimodalEnabled(): Promise<boolean> {
    // Mock implementation - return false by default for tests
    return false;
  }

  async getModelFullPath(model: Model): Promise<string> {
    // Mock implementation - return a simple path for tests
    return `/mock/path/${model.filename || model.name}`;
  }

  getCompatibleProjectionModels = jest.fn().mockReturnValue([]);
  hasRequiredProjectionModel = jest.fn().mockReturnValue(true);
  getProjectionModelStatus = jest.fn().mockReturnValue({
    isAvailable: true,
    state: 'not_needed',
  });
  getModelVisionPreference = jest.fn().mockReturnValue(true);
  setModelVisionEnabled = jest.fn().mockResolvedValue(undefined);
  getDownloadedLLMsUsingProjectionModel = jest.fn().mockReturnValue([]);
}

export const mockModelStore = new MockModelStore();



================================================
FILE: __mocks__/stores/palStore.ts
================================================
import {makeAutoObservable} from 'mobx';
import {
  AssistantFormData,
  RoleplayFormData,
  VideoPalFormData,
} from '../../src/components/PalsSheets/types';
import {Pal} from '../../src/store/PalStore';

class MockPalStore {
  pals: Pal[] = [];

  constructor() {
    makeAutoObservable(this);
  }

  addPal = jest.fn(
    (data: AssistantFormData | RoleplayFormData | VideoPalFormData) => {
      const newPal = {
        id: 'mock-uuid-12345' + Math.random(),
        ...data,
      } as Pal;
      this.pals.push(newPal);
    },
  );

  updatePal = jest.fn(
    (
      id: string,
      data: Partial<AssistantFormData | RoleplayFormData | VideoPalFormData>,
    ) => {
      const palIndex = this.pals.findIndex(p => p.id === id);
      if (palIndex !== -1) {
        const currentPal = this.pals[palIndex];
        this.pals[palIndex] = {
          ...currentPal,
          ...data,
          palType: currentPal.palType,
        } as Pal;
      }
    },
  );

  deletePal = jest.fn((id: string) => {
    const palIndex = this.pals.findIndex(p => p.id === id);
    if (palIndex !== -1) {
      this.pals.splice(palIndex, 1);
    }
  });

  getPals = jest.fn(() => {
    return this.pals;
  });
}

export const mockPalStore = new MockPalStore();



================================================
FILE: __mocks__/stores/uiStore.ts
================================================
import {l10n} from '../../src/utils/l10n';

export class UIStore {
  static readonly GROUP_KEYS = {
    READY_TO_USE: 'ready_to_use',
    AVAILABLE_TO_DOWNLOAD: 'available_to_download',
  } as const;
}

export const mockUiStore = {
  colorScheme: 'light',
  autoNavigatetoChat: false,
  benchmarkShareDialog: {
    shouldShow: true,
  },
  pageStates: {
    modelsScreen: {
      filters: [],
      expandedGroups: {
        [UIStore.GROUP_KEYS.READY_TO_USE]: true,
      },
    },
  },
  language: 'en',
  supportedLanguages: ['en', 'ja', 'zh'],
  l10n: l10n.en,
  setValue: jest.fn(),
  displayMemUsage: false,
  setAutoNavigateToChat: jest.fn(),
  setColorScheme: jest.fn(),
  setDisplayMemUsage: jest.fn(),
  setBenchmarkShareDialogPreference: jest.fn(),
  showError: jest.fn(),
};



================================================
FILE: __mocks__/utils/completionSettingsVersions.js
================================================
// Mock for completionSettingsVersions.ts

export const CURRENT_COMPLETION_SETTINGS_VERSION = 3;

export const defaultCompletionParams = {
  // App-specific properties
  version: CURRENT_COMPLETION_SETTINGS_VERSION,
  include_thinking_in_context: true,
  enable_thinking: true,

  // llama.rn API properties
  prompt: '',
  n_predict: 1024,
  temperature: 0.7,
  top_k: 40,
  top_p: 0.95,
  min_p: 0.05,
  xtc_threshold: 0.1,
  xtc_probability: 0.0,
  typical_p: 1.0,
  penalty_last_n: 64,
  penalty_repeat: 1.0,
  penalty_freq: 0.0,
  penalty_present: 0.0,
  mirostat: 0,
  mirostat_tau: 5,
  mirostat_eta: 0.1,
  seed: -1,
  n_probs: 0,
  stop: ['</s>'],
  jinja: true,
};

export function migrateCompletionSettings(settings) {
  // Clone the settings to avoid modifying the original
  const migratedSettings = {...settings};

  // If no version is specified, assume it's the initial version (0)
  if (migratedSettings.version === undefined) {
    migratedSettings.version = 0;
  }

  // Apply migrations sequentially
  if (migratedSettings.version < 1) {
    // Migration to version 1: Add include_thinking_in_context
    migratedSettings.include_thinking_in_context =
      defaultCompletionParams.include_thinking_in_context;
    migratedSettings.version = 1;
  }

  if (migratedSettings.version < 2) {
    // Migration to version 2: Add jinja parameter
    migratedSettings.jinja = defaultCompletionParams.jinja;
    migratedSettings.version = 2;
  }

  if (migratedSettings.version < 3) {
    // Migration to version 3: Add enable_thinking parameter
    migratedSettings.enable_thinking = defaultCompletionParams.enable_thinking;
    migratedSettings.version = 3;
  }

  return migratedSettings;
}



================================================
FILE: __tests__/App.test.tsx
================================================
/**
 * @format
 */

import 'react-native';
import React from 'react';
import App from '../App';
jest.useFakeTimers(); // Mock all timers

// Note: import explicitly to use the types shipped with jest.
import {it} from '@jest/globals';

// Note: test renderer must be required after react-native.
import renderer from 'react-test-renderer';

import {act} from 'react-test-renderer';

it('renders correctly', async () => {
  await act(async () => {
    renderer.create(<App />);
  });
});



================================================
FILE: __tests__/keepAwake.test.js
================================================
// Import the mocked module
jest.mock('../src/utils/keepAwake');
import {activateKeepAwake, deactivateKeepAwake} from '../src/utils/keepAwake';

describe('keepAwake', () => {
  beforeEach(() => {
    // Clear all mocks before each test
    jest.clearAllMocks();
  });

  it('should call activate on the native module', () => {
    activateKeepAwake();
    expect(activateKeepAwake).toHaveBeenCalled();
  });

  it('should call deactivate on the native module', () => {
    deactivateKeepAwake();
    expect(deactivateKeepAwake).toHaveBeenCalled();
  });
});



================================================
FILE: __tests__/watermelondb.test.js
================================================
import {database} from '../src/database';

describe('WatermelonDB', () => {
  it('should have a mocked database', () => {
    expect(database).toBeDefined();
    expect(database.collections).toBeDefined();
  });

  it('should have mocked collections', () => {
    const chatSessionsCollection = database.get('chat_sessions');
    expect(chatSessionsCollection).toBeDefined();
  });

  it('should be able to create records', async () => {
    const chatSessionsCollection = database.get('chat_sessions');
    const session = await chatSessionsCollection.create(record => {
      record.title = 'Test Session';
      record.date = new Date().toISOString();
    });

    expect(session).toBeDefined();
    expect(session.title).toBe('Test Session');
  });
});



================================================
FILE: android/gradle.properties
================================================
# Project-wide Gradle settings.

# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.

# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html

# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
# Default value: -Xmx512m -XX:MaxMetaspaceSize=256m
org.gradle.jvmargs=-Xmx2048m -XX:MaxMetaspaceSize=512m

# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true

# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Automatically convert third-party libraries to use AndroidX
# android.enableJetifier=true

# Use this property to specify which architecture you want to build.
# You can also override it from the CLI using
# ./gradlew <task> -PreactNativeArchitectures=x86_64
reactNativeArchitectures=arm64-v8a,x86_64

# Use this property to enable support to the new architecture.
# This will allow you to use TurboModules and the Fabric render in
# your application. You should enable this flag either if you want
# to write custom TurboModules/Fabric components OR use libraries that
# are providing them.
newArchEnabled=false

# Use this property to enable or disable the Hermes JS engine.
# If set to false, you will be using JSC instead.
hermesEnabled=true



================================================
FILE: android/gradlew
================================================
#!/bin/sh

#
# Copyright ¬© 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions ¬´$var¬ª, ¬´${var}¬ª, ¬´${var:-default}¬ª, ¬´${var+SET}¬ª,
#           ¬´${var#prefix}¬ª, ¬´${var%suffix}¬ª, and ¬´$( cmd )¬ª;
#         * compound commands having a testable exit status, especially ¬´case¬ª;
#         * various built-in commands including ¬´command¬ª, ¬´set¬ª, and ¬´ulimit¬ª.
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"



================================================
FILE: android/gradlew.bat
================================================
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega



================================================
FILE: android/link-assets-manifest.json
================================================
{
  "migIndex": 1,
  "data": [
    {
      "path": "src/assets/fonts/Inter-Bold.ttf",
      "sha1": "518a0361a245a66b49bc24ae0137f38328197bdc"
    },
    {
      "path": "src/assets/fonts/Inter-ExtraBold.ttf",
      "sha1": "d01b4a9a01dfdb6d9a5c6ec153d528d70706d885"
    },
    {
      "path": "src/assets/fonts/Inter-Light.ttf",
      "sha1": "6b041e6fc61656b930d8ef638a0b9d6a0ac8e084"
    },
    {
      "path": "src/assets/fonts/Inter-Medium.ttf",
      "sha1": "e2d21cdc9730ce4d4bdccb3476413a5b79fe7d52"
    },
    {
      "path": "src/assets/fonts/Inter-Regular.ttf",
      "sha1": "bd1976c1f019853ab6143ef1246e25aa66fd990e"
    },
    {
      "path": "src/assets/fonts/Inter-SemiBold.ttf",
      "sha1": "f3e44abd6661d5b861e66db22f4f79a6c466cd00"
    },
    {
      "path": "src/assets/fonts/Inter-Thin.ttf",
      "sha1": "4f2b3c3c97e618166627b4d3fff9322fa5198e81"
    }
  ]
}



================================================
FILE: android/app/debug.keystore
================================================
[Binary file]


================================================
FILE: android/app/proguard-rules.pro
================================================
# Add project specific ProGuard rules here.
# By default, the flags in this file are appended to flags specified
# in /usr/local/Cellar/android-sdk/24.3.3/tools/proguard/proguard-android.txt
# You can edit the include path and order by changing the proguardFiles
# directive in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# Add any project specific keep options here:



================================================
FILE: android/app/src/debug/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <application
        android:usesCleartextTraffic="true"
        tools:targetApi="28"
        tools:ignore="GoogleAppIndexingWarning"/>
</manifest>



================================================
FILE: android/app/src/main/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <!-- Allow app to check if any other app can handle URLs -->
    <queries>
        <intent>
            <action android:name="android.intent.action.VIEW" />
            <data android:scheme="https"/>
        </intent>
    </queries>

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.CAMERA" />

    <!-- Needed only for devices running Android¬†9 (API¬†28) or lower -->
    <!-- Currently it is used only for storing chat sessions (/Download)-->
    <uses-permission
        android:name="android.permission.READ_EXTERNAL_STORAGE"
        android:maxSdkVersion="28"/>
    <uses-permission
        android:name="android.permission.WRITE_EXTERNAL_STORAGE"
        android:maxSdkVersion="28"/>

    <uses-sdk android:minSdkVersion="23" android:targetSdkVersion="35" />

    <application
      android:name=".MainApplication"
      android:label="@string/app_name"
      android:icon="@mipmap/ic_launcher"
      android:roundIcon="@mipmap/ic_launcher_round"
      android:dataExtractionRules="@xml/backup_rules_12_plus"
      android:fullBackupContent="@xml/backup_rules_legacy"
      android:theme="@style/AppTheme"
      android:supportsRtl="true">
      <activity
        android:name=".MainActivity"
        android:label="@string/app_name"
        android:configChanges="keyboard|keyboardHidden|orientation|screenLayout|screenSize|smallestScreenSize|uiMode"
        android:launchMode="singleTask"
        android:windowSoftInputMode="adjustResize"
        android:exported="true">
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
      </activity>
    </application>
</manifest>



================================================
FILE: android/app/src/main/java/com/pocketpalai/DeviceInfoModule.kt
================================================
package com.pocketpal

import com.facebook.react.bridge.*
import android.os.Build
import java.io.File

class DeviceInfoModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {

    override fun getName(): String = "DeviceInfoModule"

    @ReactMethod
    fun getChipset(promise: Promise) {
        try {
            val chipset = Build.HARDWARE.takeUnless { it.isNullOrEmpty() } ?: Build.BOARD
            promise.resolve(chipset)
        } catch (e: Exception) {
            promise.reject("ERROR", e.message)
        }
    }

    @ReactMethod
    fun getCPUInfo(promise: Promise) {
        try {
            val cpuInfo = Arguments.createMap()
            cpuInfo.putInt("cores", Runtime.getRuntime().availableProcessors())
            
            val processors = Arguments.createArray()
            val features = mutableSetOf<String>()
            val cpuInfoFile = File("/proc/cpuinfo")
            
            if (cpuInfoFile.exists()) {
                val cpuInfoLines = cpuInfoFile.readLines()
                var currentProcessor = Arguments.createMap()
                var hasData = false
                
                for (line in cpuInfoLines) {
                    if (line.isEmpty() && hasData) {
                        processors.pushMap(currentProcessor)
                        currentProcessor = Arguments.createMap()
                        hasData = false
                        continue
                    }
                    
                    val parts = line.split(":")
                    if (parts.size >= 2) {
                        val key = parts[0].trim()
                        val value = parts[1].trim()
                        when (key) {
                            "processor", "model name", "cpu MHz", "vendor_id" -> {
                                currentProcessor.putString(key, value)
                                hasData = true
                            }
                            "flags", "Features" -> {  // "flags" for x86, "Features" for ARM
                                features.addAll(value.split(" ").filter { it.isNotEmpty() })
                            }
                        }
                    }
                }
                
                if (hasData) {
                    processors.pushMap(currentProcessor)
                }
                
                cpuInfo.putArray("processors", processors)
                
                // Convert features set to array
                val featuresArray = Arguments.createArray()
                features.forEach { featuresArray.pushString(it) }
                cpuInfo.putArray("features", featuresArray)

                // ML-related CPU features detection
                cpuInfo.putBoolean("hasFp16", features.any { it in setOf("fphp", "fp16") })
                cpuInfo.putBoolean("hasDotProd", features.any { it in setOf("dotprod", "asimddp") })
                cpuInfo.putBoolean("hasSve", features.any { it == "sve" })
                cpuInfo.putBoolean("hasI8mm", features.any { it == "i8mm" })
            }
            
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                cpuInfo.putString("socModel", Build.SOC_MODEL)
            }
            
            promise.resolve(cpuInfo)
        } catch (e: Exception) {
            promise.reject("ERROR", e.message)
        }
    }
} 


================================================
FILE: android/app/src/main/java/com/pocketpalai/DeviceInfoPackage.kt
================================================
package com.pocketpal

import android.view.View
import com.facebook.react.ReactPackage
import com.facebook.react.bridge.NativeModule
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.uimanager.ReactShadowNode
import com.facebook.react.uimanager.ViewManager

class DeviceInfoPackage : ReactPackage {
    override fun createNativeModules(reactContext: ReactApplicationContext): List<NativeModule> {
        return listOf(DeviceInfoModule(reactContext))
    }

    override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<View, ReactShadowNode<*>>> {
        return emptyList()
    }
} 


================================================
FILE: android/app/src/main/java/com/pocketpalai/KeepAwakeModule.kt
================================================
package com.pocketpal

import android.app.Activity
import android.view.WindowManager
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.bridge.ReactContextBaseJavaModule
import com.facebook.react.bridge.ReactMethod

class KeepAwakeModule(private val reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {

    override fun getName(): String = "KeepAwakeModule"

    @ReactMethod
    fun activate() {
        val activity = reactContext.currentActivity
        activity?.runOnUiThread {
            activity.window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
        }
    }

    @ReactMethod
    fun deactivate() {
        val activity = reactContext.currentActivity
        activity?.runOnUiThread {
            activity.window.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
        }
    }
} 


================================================
FILE: android/app/src/main/java/com/pocketpalai/KeepAwakePackage.kt
================================================
package com.pocketpal

import com.facebook.react.ReactPackage
import com.facebook.react.bridge.NativeModule
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.uimanager.ViewManager

class KeepAwakePackage : ReactPackage {
    override fun createNativeModules(reactContext: ReactApplicationContext): List<NativeModule> {
        return listOf(KeepAwakeModule(reactContext))
    }

    override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> {
        return emptyList()
    }
} 


================================================
FILE: android/app/src/main/java/com/pocketpalai/MainActivity.kt
================================================
package com.pocketpal

import com.facebook.react.ReactActivity
import com.facebook.react.ReactActivityDelegate
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.fabricEnabled
import com.facebook.react.defaults.DefaultReactActivityDelegate
import androidx.activity.enableEdgeToEdge
import android.os.Bundle  // Required for onCreate parameter


class MainActivity : ReactActivity() {

  /**
   * Returns the name of the main component registered from JavaScript. This is used to schedule
   * rendering of the component.
   */
  override fun getMainComponentName(): String = "PocketPal"

  /**
   * Returns the instance of the [ReactActivityDelegate]. We use [DefaultReactActivityDelegate]
   * which allows you to enable New Architecture with a single boolean flags [fabricEnabled]
   */
  override fun createReactActivityDelegate(): ReactActivityDelegate =
      DefaultReactActivityDelegate(this, mainComponentName, fabricEnabled)

  override fun onCreate(savedInstanceState: Bundle?) {
      enableEdgeToEdge()
      // Pass null to prevent react-native-screens fragments from being restored
      // This fixes the "Screen fragments should never be restored" crash
      // See: https://github.com/software-mansion/react-native-screens/issues/17
      // and https://github.com/software-mansion/react-native-screens?tab=readme-ov-file#android
      super.onCreate(null)
  }
}



================================================
FILE: android/app/src/main/java/com/pocketpalai/MainApplication.kt
================================================
package com.pocketpal

import android.app.Application
import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactHost
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.load
import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
import com.facebook.react.defaults.DefaultReactNativeHost
import com.facebook.react.soloader.OpenSourceMergedSoMapping
import com.facebook.soloader.SoLoader
import com.pocketpal.download.DownloadPackage

class MainApplication : Application(), ReactApplication {

  override val reactNativeHost: ReactNativeHost =
      object : DefaultReactNativeHost(this) {
        override fun getPackages(): List<ReactPackage> =
            PackageList(this).packages.apply {
              // Packages that cannot be autolinked yet can be added manually here, for example:
              // add(MyReactNativePackage())
              add(DeviceInfoPackage())
              add(KeepAwakePackage())
              add(DownloadPackage())
            }

        override fun getJSMainModuleName(): String = "index"

        override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG

        override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
        override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED
      }

  override val reactHost: ReactHost
    get() = getDefaultReactHost(applicationContext, reactNativeHost)

  override fun onCreate() {
    super.onCreate()
    SoLoader.init(this, OpenSourceMergedSoMapping)
    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      load()
    }
  }
}



================================================
FILE: android/app/src/main/java/com/pocketpalai/download/DownloadDao.kt
================================================
package com.pocketpal.download

import androidx.room.*
import kotlinx.coroutines.flow.Flow

@Dao
interface DownloadDao {
    @Query("SELECT * FROM downloads")
    fun getAllDownloads(): Flow<List<DownloadEntity>>

    @Query("SELECT * FROM downloads WHERE id = :downloadId")
    suspend fun getDownload(downloadId: String): DownloadEntity?

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertDownload(download: DownloadEntity)

    @Update
    suspend fun updateDownload(download: DownloadEntity)

    @Delete
    suspend fun deleteDownload(download: DownloadEntity)

    @Query("UPDATE downloads SET downloadedBytes = :bytes, totalBytes = :totalBytes, status = :status WHERE id = :downloadId")
    suspend fun updateProgress(downloadId: String, bytes: Long, totalBytes: Long, status: DownloadStatus)

    @Query("UPDATE downloads SET status = :status, error = :error WHERE id = :downloadId")
    suspend fun updateStatus(downloadId: String, status: DownloadStatus, error: String? = null)
} 


================================================
FILE: android/app/src/main/java/com/pocketpalai/download/DownloadDatabase.kt
================================================
package com.pocketpal.download

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase

@Database(
    entities = [DownloadEntity::class],
    version = 2,
    exportSchema = false
)
abstract class DownloadDatabase : RoomDatabase() {
    abstract fun downloadDao(): DownloadDao

    companion object {
        private const val DATABASE_NAME = "downloads.db"

        private val MIGRATION_1_2 = object : Migration(1, 2) {
            override fun migrate(database: SupportSQLiteDatabase) {
                database.execSQL("ALTER TABLE downloads ADD COLUMN authToken TEXT")
            }
        }

        @Volatile
        private var INSTANCE: DownloadDatabase? = null

        fun getInstance(context: Context): DownloadDatabase {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: Room.databaseBuilder(
                    context.applicationContext,
                    DownloadDatabase::class.java,
                    DATABASE_NAME
                )
                .addMigrations(MIGRATION_1_2)
                .build()
                .also { INSTANCE = it }
            }
        }
    }
} 


================================================
FILE: android/app/src/main/java/com/pocketpalai/download/DownloadEntity.kt
================================================
package com.pocketpal.download

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "downloads")
data class DownloadEntity(
    @PrimaryKey
    val id: String,
    val url: String,
    val destination: String,
    val totalBytes: Long,
    val downloadedBytes: Long,
    val status: DownloadStatus,
    val priority: Int,
    val networkType: NetworkType,
    val createdAt: Long,
    val error: String? = null,
    val authToken: String? = null
)

enum class DownloadStatus {
    QUEUED, RUNNING, PAUSED, COMPLETED, FAILED, CANCELLED
}

enum class NetworkType {
    ANY, WIFI
} 


================================================
FILE: android/app/src/main/java/com/pocketpalai/download/DownloadModule.kt
================================================
package com.pocketpal.download

import android.util.Log
import androidx.lifecycle.Observer
import androidx.work.*
import com.facebook.react.bridge.*
import com.facebook.react.modules.core.DeviceEventManagerModule
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.first
import java.io.File
import java.util.*
import androidx.work.await

class DownloadModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {
    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)
    private val downloadDao = DownloadDatabase.getInstance(reactContext).downloadDao()
    private val workManager = WorkManager.getInstance(reactContext)
    // Map to store work observers by download ID
    private val workObservers = mutableMapOf<String, Observer<List<WorkInfo>>>()

    init {
        Log.d(TAG, "Initializing DownloadModule")
        
        scope.launch {
            Log.d(TAG, "Logging initial download database state")
            logEntireDownloadDatabase()
        }
    }

    override fun getName() = "DownloadModule"

    @ReactMethod
    fun addListener(eventName: String) {
        Log.d(TAG, "Adding listener for event: $eventName")
    }

    @ReactMethod
    fun removeListeners(count: Int) {
        Log.d(TAG, "Removing $count listeners")
    }

    private fun sendEvent(eventName: String, params: WritableMap) {
        Log.d(TAG, "Sending event: $eventName with params: $params")
        reactApplicationContext
            .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter::class.java)
            .emit(eventName, params)
    }

    private fun removeWorkObserver(downloadId: String) {
        workObservers.remove(downloadId)?.let { observer ->
            Log.d(TAG, "Removing work observer for download: $downloadId")
            val workName = getWorkName(downloadId)
            workManager.getWorkInfosForUniqueWorkLiveData(workName)
                .removeObserver(observer)
        }
    }

    @ReactMethod
    fun startDownload(url: String, config: ReadableMap, promise: Promise) {
        Log.d(TAG, "Starting download with config: $config")
        scope.launch {
            try {
                val downloadId = UUID.randomUUID().toString()
                Log.d(TAG, "Generated download ID: $downloadId")

                val destination = config.getString("destination")
                    ?: throw IllegalArgumentException("Destination path is required")
                Log.d(TAG, "Destination path: $destination")

                // Extract authorization token if provided
                val authToken = if (config.hasKey("authToken")) config.getString("authToken") else null
                if (authToken != null) {
                    Log.d(TAG, "Authorization token provided for download")
                }

                val networkType = when (config.getString("networkType")) {
                    "WIFI" -> NetworkType.WIFI
                    else -> NetworkType.ANY
                }
                Log.d(TAG, "Network type: $networkType")

                val progressInterval = config.getDouble("progressInterval")?.toLong() 
                    ?: DownloadWorker.DEFAULT_PROGRESS_INTERVAL
                Log.d(TAG, "Progress interval: $progressInterval ms")

                val download = DownloadEntity(
                    id = downloadId,
                    url = url,
                    destination = destination,
                    totalBytes = 0,
                    downloadedBytes = 0,
                    status = DownloadStatus.QUEUED,
                    priority = config.getInt("priority") ?: 0,
                    networkType = networkType,
                    createdAt = System.currentTimeMillis(),
                    authToken = authToken
                )

                withContext(Dispatchers.IO) {
                    Log.d(TAG, "Inserting download into database: $download")
                    downloadDao.insertDownload(download)
                }

                val workRequest = DownloadWorker.createWorkRequest(downloadId, progressInterval)
                Log.d(TAG, "Created work request: ${workRequest.id}")
                
                createAndRegisterObserver(downloadId)

                // Enqueue the work
                workManager.enqueueUniqueWork(
                    getWorkName(downloadId),
                    androidx.work.ExistingWorkPolicy.REPLACE,
                    workRequest
                )

                val response = Arguments.createMap().apply {
                    putString("downloadId", downloadId)
                }
                Log.d(TAG, "Resolving promise with download ID: $downloadId")
                promise.resolve(response)
            } catch (e: Exception) {
                Log.e(TAG, "Failed to start download", e)
                promise.reject("DOWNLOAD_ERROR", e.message)
            }
        }
    }

    @ReactMethod
    fun reattachDownloadObserver(downloadId: String, promise: Promise) {
        Log.d(TAG, "Re-attaching observer for download: $downloadId")
        scope.launch {
            try {
                val download = withContext(Dispatchers.IO) {
                    downloadDao.getDownload(downloadId)
                }
                
                if (download == null) {
                    Log.w(TAG, "No download found to re-attach observer: $downloadId")
                    promise.reject("DOWNLOAD_NOT_FOUND", "Download not found")
                    return@launch
                }
                
                createAndRegisterObserver(downloadId)
                
                Log.d(TAG, "Successfully re-attached observer for download: $downloadId")
                promise.resolve(true)
            } catch (e: Exception) {
                Log.e(TAG, "Failed to re-attach observer for download: $downloadId", e)
                promise.reject("REATTACH_ERROR", e.message)
            }
        }
    }

    @ReactMethod
    fun getActiveDownloads(promise: Promise) {
        Log.d(TAG, "Getting active downloads")
        scope.launch {
            try {
                val downloads = withContext(Dispatchers.IO) {
                    Log.d(TAG, "Fetching downloads from database")
                    downloadDao.getAllDownloads().first()
                        .filter { 
                            it.status == DownloadStatus.QUEUED || 
                            it.status == DownloadStatus.RUNNING ||
                            it.status == DownloadStatus.PAUSED 
                        }
                }
                Log.d(TAG, "Found ${downloads.size} active downloads")

                val result = Arguments.createArray()
                downloads.forEach { download ->
                    Log.d(TAG, "Processing download: ${download.id}")
                    result.pushMap(Arguments.createMap().apply {
                        putString("id", download.id)
                        putString("url", download.url)
                        putString("destination", download.destination)
                        putDouble("progress", 
                            if (download.totalBytes > 0) 
                                (download.downloadedBytes.toDouble() / download.totalBytes.toDouble()) * 100 
                            else 0.0
                        )
                        putString("status", download.status.name)
                    })
                }
                Log.d(TAG, "Resolving promise with ${downloads.size} downloads")
                promise.resolve(result)
            } catch (e: Exception) {
                Log.e(TAG, "Failed to get active downloads", e)
                promise.reject("FETCH_ERROR", e.message)
            }
        }
    }

    @ReactMethod
    fun logDownloadDatabase(promise: Promise) {
        Log.d(TAG, "Logging download database state (requested from JS)")
        scope.launch {
            try {
                logEntireDownloadDatabase()
                promise.resolve(true)
            } catch (e: Exception) {
                Log.e(TAG, "Failed to log download database", e)
                promise.reject("LOG_ERROR", e.message)
            }
        }
    }

    @ReactMethod
    fun pauseDownload(downloadId: String, promise: Promise) {
        Log.d(TAG, "Pausing download: $downloadId")
        scope.launch {
            try {
                withContext(Dispatchers.IO) {
                    Log.d(TAG, "Updating status to PAUSED for: $downloadId")
                    downloadDao.updateStatus(downloadId, DownloadStatus.PAUSED)
                }
                promise.resolve(true)
            } catch (e: Exception) {
                Log.e(TAG, "Failed to pause download: $downloadId", e)
                promise.reject("PAUSE_ERROR", e.message)
            }
        }
    }

    @ReactMethod
    fun resumeDownload(downloadId: String, promise: Promise) {
        Log.d(TAG, "Resuming download: $downloadId")
        scope.launch {
            try {
                withContext(Dispatchers.IO) {
                    val download = downloadDao.getDownload(downloadId)
                    if (download != null) {
                        Log.d(TAG, "Updating status to QUEUED for: $downloadId")
                        downloadDao.updateStatus(downloadId, DownloadStatus.QUEUED)
                        
                        // Create new work request only if there isn't one running
                        val workName = getWorkName(downloadId)
                        val workInfo = workManager.getWorkInfosForUniqueWork(workName).await().firstOrNull()
                        if (workInfo == null || workInfo.state.isFinished) {
                            Log.d(TAG, "Creating new work request for: $downloadId")
                            val workRequest = DownloadWorker.createWorkRequest(downloadId)
                            workManager.enqueueUniqueWork(
                                workName,
                                androidx.work.ExistingWorkPolicy.REPLACE,
                                workRequest
                            )
                        } else {
                            Log.d(TAG, "Work is already running for: $downloadId")
                        }
                    } else {
                        Log.w(TAG, "No download found to resume: $downloadId")
                    }
                }
                promise.resolve(true)
            } catch (e: Exception) {
                Log.e(TAG, "Failed to resume download: $downloadId", e)
                promise.reject("RESUME_ERROR", e.message)
            }
        }
    }

    @ReactMethod
    fun retryDownload(downloadId: String, promise: Promise) {
        Log.d(TAG, "Retrying download: $downloadId")
        scope.launch {
            try {
                withContext(Dispatchers.IO) {
                    val download = downloadDao.getDownload(downloadId)
                    if (download != null) {
                        Log.d(TAG, "Updating status to QUEUED for: $downloadId")
                        downloadDao.updateStatus(downloadId, DownloadStatus.QUEUED)
                        Log.d(TAG, "Creating new work request for: $downloadId")
                        val workRequest = DownloadWorker.createWorkRequest(downloadId)
                        workManager.enqueue(workRequest)
                    } else {
                        Log.w(TAG, "No download found to retry: $downloadId")
                    }
                }
                promise.resolve(true)
            } catch (e: Exception) {
                Log.e(TAG, "Failed to retry download: $downloadId", e)
                promise.reject("RETRY_ERROR", e.message)
            }
        }
    }

    @ReactMethod
    fun cancelDownload(downloadId: String, promise: Promise) {
        Log.d(TAG, "Cancelling download: $downloadId")
        scope.launch {
            try {
                // First update the database to mark as cancelled
                withContext(Dispatchers.IO) {
                    val download = downloadDao.getDownload(downloadId)
                    if (download != null) {
                        Log.d(TAG, "Updating status to CANCELLED for download: $downloadId")
                        downloadDao.updateStatus(downloadId, DownloadStatus.CANCELLED, "Download cancelled by user")
                        
                        // Clean up the partial download file
                        val file = File(download.destination)
                        if (file.exists()) {
                            Log.d(TAG, "Deleting partial download file: ${file.absolutePath}")
                            file.delete()
                        }
                    }
                }

                // Cancel the work using the work name format
                val workName = getWorkName(downloadId)
                val operation = workManager.cancelUniqueWork(workName)
                
                // Wait for cancellation to complete
                withContext(Dispatchers.IO) {
                    try {
                        operation.result.await()
                    } catch (e: Exception) {
                        Log.e(TAG, "Error waiting for work cancellation", e)
                    }
                }

                // Force stop any ongoing work
                workManager.pruneWork()
                
                // Send cancellation event to notify the JS side
                sendCancellationEvent(downloadId)
                
                promise.resolve(true)
            } catch (e: Exception) {
                Log.e(TAG, "Failed to cancel download: $downloadId", e)
                promise.reject("CANCEL_ERROR", e.message)
            }
        }
    }

    private fun sendProgressEvent(downloadId: String, bytesWritten: Long, totalBytes: Long) {
        val params = Arguments.createMap().apply {
            putString("downloadId", downloadId)
            putDouble("bytesWritten", bytesWritten.toDouble())
            putDouble("totalBytes", totalBytes.toDouble())
            putDouble("progress", if (totalBytes > 0) (bytesWritten.toDouble() / totalBytes.toDouble()) * 100 else 0.0)
        }
        sendEvent("onDownloadProgress", params)
    }

    private fun sendCompletionEvent(downloadId: String, filePath: String) {
        val params = Arguments.createMap().apply {
            putString("downloadId", downloadId)
            putString("filePath", filePath)
        }
        sendEvent("onDownloadComplete", params)
    }

    private fun sendFailureEvent(downloadId: String, error: String) {
        val params = Arguments.createMap().apply {
            putString("downloadId", downloadId)
            putString("error", error)
        }
        sendEvent("onDownloadFailed", params)
    }

    private fun sendCancellationEvent(downloadId: String) {
        val params = Arguments.createMap().apply {
            putString("downloadId", downloadId)
            putString("message", "Download cancelled by user")
        }
        sendEvent("onDownloadCancelled", params)
    }

    override fun onCatalystInstanceDestroy() {
        Log.d(TAG, "Cleaning up DownloadModule")
        // Clean up all observers
        workObservers.entries.forEach { (downloadId, observer) ->
            removeWorkObserver(downloadId)
        }
        workObservers.clear()
        super.onCatalystInstanceDestroy()
        scope.cancel()
    }

    // Helper function to log the current state of a download in the database
    private suspend fun logDownloadDatabaseState(downloadId: String) {
        withContext(Dispatchers.IO) {
            try {
                val download = downloadDao.getDownload(downloadId)
                if (download != null) {
                    Log.d(TAG, "DB STATE for $downloadId: " +
                        "status=${download.status}, " +
                        "progress=${download.downloadedBytes}/${download.totalBytes} bytes " +
                        "(${if (download.totalBytes > 0) (download.downloadedBytes.toFloat() / download.totalBytes * 100).toInt() else 0}%), " +
                        "error=${download.error ?: "none"}")
                } else {
                    Log.d(TAG, "DB STATE for $downloadId: No record found in database")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Failed to log database state for $downloadId", e)
            }
        }
    }

    // Helper function to log the entire download database
    private suspend fun logEntireDownloadDatabase() {
        withContext(Dispatchers.IO) {
            try {
                val allDownloads = downloadDao.getAllDownloads().first()
                if (allDownloads.isEmpty()) {
                    Log.d(TAG, "DOWNLOAD DATABASE: Empty - No downloads found")
                    return@withContext
                }
                
                Log.d(TAG, "DOWNLOAD DATABASE: Found ${allDownloads.size} downloads")
                Log.d(TAG, "DOWNLOAD DATABASE: ----------------------------------------")
                
                allDownloads.forEachIndexed { index, download ->
                    val progressPercent = if (download.totalBytes > 0) 
                        (download.downloadedBytes.toFloat() / download.totalBytes * 100).toInt() 
                    else 0
                    
                    Log.d(TAG, "DOWNLOAD #${index + 1}:")
                    Log.d(TAG, "  ID: ${download.id}")
                    Log.d(TAG, "  URL: ${download.url}")
                    Log.d(TAG, "  Destination: ${download.destination}")
                    Log.d(TAG, "  Status: ${download.status}")
                    Log.d(TAG, "  Progress: ${download.downloadedBytes}/${download.totalBytes} bytes ($progressPercent%)")
                    Log.d(TAG, "  Priority: ${download.priority}")
                    Log.d(TAG, "  Network Type: ${download.networkType}")
                    Log.d(TAG, "  Created At: ${java.util.Date(download.createdAt)}")
                    Log.d(TAG, "  Error: ${download.error ?: "none"}")
                    Log.d(TAG, "  ----------------------------------------")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Failed to log download database", e)
            }
        }
    }

    private fun createAndRegisterObserver(downloadId: String): Observer<List<WorkInfo>> {
        Log.d(TAG, "Creating observer for download: $downloadId")
        
        // Create a new observer for this download
        val observer = Observer<List<WorkInfo>> { workInfos ->
            val workInfo = workInfos.firstOrNull() ?: return@Observer
            Log.d(TAG, "Work state changed: ${workInfo.state} for ID: $downloadId")
            
            when (workInfo.state) {
                WorkInfo.State.RUNNING -> {
                    val progress = workInfo.progress.getLong(DownloadWorker.KEY_PROGRESS, 0)
                    val total = workInfo.progress.getLong(DownloadWorker.KEY_TOTAL, 0)
                    Log.d(TAG, "Download progress: $progress/$total for ID: $downloadId")
                    sendProgressEvent(downloadId, progress, total)
                }
                WorkInfo.State.SUCCEEDED -> {
                    Log.d(TAG, "Download succeeded for ID: $downloadId")
                    scope.launch {
                        val downloadInfo = downloadDao.getDownload(downloadId)
                        if (downloadInfo != null) {
                            Log.d(TAG, "Sending completion event for ID: $downloadId")
                            sendCompletionEvent(downloadId, downloadInfo.destination)
                        } else {
                            Log.w(TAG, "Download info not found for completed download: $downloadId")
                        }
                            
                        // Log final database state after completion
                        logEntireDownloadDatabase()
                            
                        removeWorkObserver(downloadId)
                    }
                }
                WorkInfo.State.FAILED -> {
                    Log.e(TAG, "Download failed for ID: $downloadId")
                    scope.launch {
                        val downloadInfo = downloadDao.getDownload(downloadId)
                        if (downloadInfo != null) {
                            Log.e(TAG, "Error details for ID $downloadId: ${downloadInfo.error}")
                            sendFailureEvent(downloadId, downloadInfo.error ?: "Unknown error")
                        } else {
                            Log.w(TAG, "Download info not found for failed download: $downloadId")
                        }
                            
                        // Log final database state after failure
                        logEntireDownloadDatabase()
                            
                        removeWorkObserver(downloadId)
                    }
                }
                WorkInfo.State.CANCELLED -> {
                    Log.d(TAG, "Download cancelled for ID: $downloadId")
                    
                    // Log final database state after cancellation
                    scope.launch {
                        logEntireDownloadDatabase()
                        removeWorkObserver(downloadId)
                    }
                }
                else -> {
                    Log.d(TAG, "Work state: ${workInfo.state} for ID: $downloadId")
                }
            }
        }
        
        // Remove any existing observer
        workObservers[downloadId]?.let { oldObserver ->
            Log.d(TAG, "Removing existing observer for download: $downloadId")
            val workName = getWorkName(downloadId)
            workManager.getWorkInfosForUniqueWorkLiveData(workName)
                .removeObserver(oldObserver)
        }
        
        // Register the new observer
        workObservers[downloadId] = observer
        val workName = getWorkName(downloadId)
        workManager.getWorkInfosForUniqueWorkLiveData(workName)
            .observeForever(observer)
        
        return observer
    }

    companion object {
        private const val TAG = "DownloadModule"
        private fun getWorkName(downloadId: String) = "download_$downloadId"
    }
} 


================================================
FILE: android/app/src/main/java/com/pocketpalai/download/DownloadPackage.kt
================================================
package com.pocketpal.download

import com.facebook.react.ReactPackage
import com.facebook.react.bridge.NativeModule
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.uimanager.ViewManager

class DownloadPackage : ReactPackage {
    override fun createNativeModules(reactContext: ReactApplicationContext): List<NativeModule> {
        return listOf(DownloadModule(reactContext))
    }

    override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> {
        return emptyList()
    }
} 


================================================
FILE: android/app/src/main/java/com/pocketpalai/download/DownloadWorker.kt
================================================
package com.pocketpal.download

import android.content.Context
import android.util.Log
import androidx.work.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.*
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException
import kotlin.coroutines.suspendCoroutine

class DownloadWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {

    private val downloadDao = DownloadDatabase.getInstance(context).downloadDao()
    private val client = OkHttpClient.Builder()
        .addInterceptor(ProgressInterceptor())
        .build()
    private var lastProgressUpdate = 0L
    private var currentCall: Call? = null

    init {
        Log.d(TAG, "Initializing DownloadWorker")
    }

    private fun handleStopped() {
        Log.d(TAG, "Worker stopped, cancelling any ongoing network request")
        currentCall?.cancel()
    }

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        try {
            val downloadId = inputData.getString(KEY_DOWNLOAD_ID) ?: return@withContext Result.failure()
            Log.d(TAG, "Starting download work for ID: $downloadId")

            if (isStopped) {
                Log.d(TAG, "Work was cancelled before starting for ID: $downloadId")
                handleStopped()
                downloadDao.updateStatus(downloadId, DownloadStatus.CANCELLED, "Download cancelled")
                return@withContext Result.failure()
            }

            val progressInterval = inputData.getLong(KEY_PROGRESS_INTERVAL, DEFAULT_PROGRESS_INTERVAL)
            Log.d(TAG, "Progress update interval: $progressInterval ms")

            val download = downloadDao.getDownload(downloadId) ?: return@withContext Result.failure()
            Log.d(TAG, "Retrieved download info: $download")

            if (download.status == DownloadStatus.PAUSED) {
                Log.d(TAG, "Download is paused, returning retry for ID: $downloadId")
                return@withContext Result.retry()
            }

            val file = File(download.destination)
            Log.d(TAG, "Download destination: ${file.absolutePath}")
            
            // Check if file size and database are in sync
            if (file.exists() && file.length() > 0) {
                // If file exists but size doesn't match database, update database
                if (file.length() != download.downloadedBytes) {
                    Log.d(TAG, "File size (${file.length()}) doesn't match database (${download.downloadedBytes}). Updating database.")
                    downloadDao.updateProgress(downloadId, file.length(), download.totalBytes, download.status)
                    // Reload download info after update
                    val updatedDownload = downloadDao.getDownload(downloadId)
                    if (updatedDownload != null) {
                        Log.d(TAG, "Updated download info: $updatedDownload")
                    }
                }
            }
            
            val request = Request.Builder()
                .url(download.url)
                .apply {
                    if (file.exists() && file.length() > 0) {
                        val range = "bytes=${file.length()}-"
                        Log.d(TAG, "Resuming download from byte ${file.length()}")
                        addHeader("Range", range)
                    }
                    
                    // Add authorization header if token is available
                    download.authToken?.let { token ->
                        Log.d(TAG, "Adding Authorization header for authenticated download")
                        addHeader("Authorization", "Bearer $token")
                    }
                }
                .build()

            Log.d(TAG, "Updating status to RUNNING for ID: $downloadId")
            downloadDao.updateStatus(downloadId, DownloadStatus.RUNNING)

            Log.d(TAG, "Executing network request for ID: $downloadId")
            val response = suspendCoroutine { continuation ->
                val call = client.newCall(request)
                currentCall = call  // Store the call reference
                call.enqueue(object : Callback {
                    override fun onFailure(call: Call, e: IOException) {
                        if (call.isCanceled()) {
                            Log.d(TAG, "Network request was cancelled for ID: $downloadId")
                        } else {
                            Log.e(TAG, "Network request failed for ID: $downloadId", e)
                        }
                        continuation.resumeWithException(e)
                    }

                    override fun onResponse(call: Call, response: Response) {
                        Log.d(TAG, "Received response for ID: $downloadId, code: ${response.code}")
                        continuation.resume(response)
                    }
                })
            }
            currentCall = null  // Clear the reference after completion

            if (file.exists() && file.length() > 0 && response.code == 200) {
                Log.w(TAG, "Server ignored range request, returning full file. Restarting download from beginning.")
                if (file.exists()) {
                    Log.d(TAG, "Deleting partial file to restart download: ${file.absolutePath}")
                    file.delete()
                }
            } else if (!response.isSuccessful) {
                when (response.code) {
                    416 -> {
                        Log.e(TAG, "Server rejected the range request for ID: $downloadId")
                        
                        if (file.exists()) {
                            Log.d(TAG, "Deleting invalid partial file: ${file.absolutePath}")
                            file.delete()
                        }
                        
                        downloadDao.updateStatus(
                            downloadId,
                            DownloadStatus.FAILED,
                            "Download failed: The partial download was invalid or the file on server has changed"
                        )
                        
                        return@withContext Result.failure()
                    }
                    in 400..499 -> {
                        val error = "Client error: ${response.code}"
                        Log.e(TAG, error)
                        downloadDao.updateStatus(downloadId, DownloadStatus.FAILED, error)
                        return@withContext Result.failure()
                    }
                    in 500..599 -> {
                        val error = "Server error: ${response.code}"
                        Log.e(TAG, error)
                        downloadDao.updateStatus(downloadId, DownloadStatus.FAILED, error)
                        return@withContext Result.retry()
                    }
                    else -> {
                        val error = "Unexpected response: ${response.code}"
                        Log.e(TAG, error)
                        downloadDao.updateStatus(downloadId, DownloadStatus.FAILED, error)
                        return@withContext Result.failure()
                    }
                }
            }

            response.body?.let { body ->
                // Get content length from response
                val contentLength = body.contentLength()
                Log.d(TAG, "Content length from response: $contentLength bytes for ID: $downloadId")
                
                // Get existing bytes written
                var bytesWritten = if (file.exists()) file.length() else 0
                Log.d(TAG, "Existing bytes written: $bytesWritten for ID: $downloadId")
                
                // Calculate total expected size based on response code
                val totalBytes = when (response.code) {
                    206 -> {
                        // For partial content (206), the content-length is just the remaining bytes
                        // So add existing bytes to get total size
                        val total = bytesWritten + contentLength
                        Log.d(TAG, "Partial content (206): Total size = $bytesWritten + $contentLength = $total bytes")
                        total
                    }
                    200 -> {
                        // For full content (200), use the content length as total size
                        Log.d(TAG, "Full content (200): Total size = $contentLength bytes")
                        contentLength
                    }
                    else -> {
                        // For other responses, use the larger of content length or existing total
                        val total = maxOf(contentLength, download.totalBytes)
                        Log.d(TAG, "Other response (${response.code}): Using total size = $total bytes")
                        total
                    }
                }
                
                // Update database with correct progress information
                downloadDao.updateProgress(downloadId, bytesWritten, totalBytes, DownloadStatus.RUNNING)
                Log.d(TAG, "Updated database: $bytesWritten/$totalBytes bytes (${(bytesWritten.toFloat() / totalBytes * 100).toInt()}%) for ID: $downloadId")

                // Determine if we should append to the file
                val appendMode = file.exists() && response.code == 206
                Log.d(TAG, "Opening file in ${if (appendMode) "append" else "overwrite"} mode")
                
                FileOutputStream(file, appendMode).buffered().use { output ->
                    body.byteStream().buffered().use { input ->
                        val buffer = ByteArray(DEFAULT_BUFFER_SIZE)
                        var bytes = input.read(buffer)
                        
                        while (bytes >= 0) {
                            if (isStopped) {
                                Log.d(TAG, "Download cancelled during transfer for ID: $downloadId")
                                downloadDao.updateStatus(downloadId, DownloadStatus.CANCELLED, "Download cancelled")
                                if (file.exists()) {
                                    file.delete()
                                    Log.d(TAG, "Deleted partial download file: ${file.absolutePath}")
                                }
                                return@withContext Result.failure()
                            }

                            val currentDownload = downloadDao.getDownload(downloadId)
                            if (currentDownload?.status == DownloadStatus.PAUSED) {
                                Log.d(TAG, "Download paused during transfer for ID: $downloadId")
                                return@withContext Result.retry()
                            }

                            output.write(buffer, 0, bytes)
                            bytesWritten += bytes

                            val currentTime = System.currentTimeMillis()
                            if (currentTime - lastProgressUpdate >= progressInterval) {
                                val progress = workDataOf(
                                    KEY_PROGRESS to bytesWritten,
                                    KEY_TOTAL to totalBytes
                                )
                                Log.d(TAG, "Progress: $bytesWritten/$totalBytes bytes for ID: $downloadId")
                                setProgress(progress)
                                downloadDao.updateProgress(downloadId, bytesWritten, totalBytes, DownloadStatus.RUNNING)
                                lastProgressUpdate = currentTime
                            }
                            
                            bytes = input.read(buffer)
                        }
                    }
                }

                Log.d(TAG, "Download completed successfully for ID: $downloadId")
                downloadDao.updateProgress(downloadId, bytesWritten, totalBytes, DownloadStatus.COMPLETED)
                return@withContext Result.success()
            }

            Log.e(TAG, "No response body for ID: $downloadId")
            return@withContext Result.failure()
        } catch (e: Exception) {
            Log.e(TAG, "Download failed", e)
            val downloadId = inputData.getString(KEY_DOWNLOAD_ID)
            downloadId?.let {
                Log.e(TAG, "Updating status to FAILED for ID: $it")
                downloadDao.updateStatus(it, DownloadStatus.FAILED, e.message)
            }
            return@withContext Result.failure()
        }
    }

    companion object {
        private const val TAG = "DownloadWorker"
        const val KEY_DOWNLOAD_ID = "download_id"
        const val KEY_PROGRESS = "progress"
        const val KEY_TOTAL = "total"
        const val KEY_PROGRESS_INTERVAL = "progress_interval"
        const val DEFAULT_PROGRESS_INTERVAL = 1000L // 1 second default

        fun createWorkRequest(downloadId: String, progressInterval: Long = DEFAULT_PROGRESS_INTERVAL): OneTimeWorkRequest {
            Log.d(TAG, "Creating work request for download ID: $downloadId with progress interval: $progressInterval ms")
            val constraints = Constraints.Builder()
                .setRequiredNetworkType(androidx.work.NetworkType.CONNECTED)
                .build()

            return OneTimeWorkRequestBuilder<DownloadWorker>()
                .setConstraints(constraints)
                .setInputData(workDataOf(
                    KEY_DOWNLOAD_ID to downloadId,
                    KEY_PROGRESS_INTERVAL to progressInterval
                ))
                .setBackoffCriteria(
                    BackoffPolicy.EXPONENTIAL,
                    WorkRequest.MIN_BACKOFF_MILLIS,
                    java.util.concurrent.TimeUnit.MILLISECONDS
                )
                .build()
        }
    }
}

class ProgressInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val originalResponse = chain.proceed(chain.request())
        val originalBody = originalResponse.body
        
        return originalResponse.newBuilder()
            .body(if (originalBody != null) ProgressResponseBody(originalBody) else null)
            .build()
    }
} 


================================================
FILE: android/app/src/main/java/com/pocketpalai/download/ProgressResponseBody.kt
================================================
package com.pocketpal.download

import okhttp3.MediaType
import okhttp3.ResponseBody
import okio.*

class ProgressResponseBody(
    private val responseBody: ResponseBody
) : ResponseBody() {
    private var bufferedSource: BufferedSource? = null

    override fun contentType(): MediaType? = responseBody.contentType()

    override fun contentLength(): Long = responseBody.contentLength()

    override fun source(): BufferedSource {
        if (bufferedSource == null) {
            bufferedSource = source(responseBody.source()).buffer()
        }
        return bufferedSource!!
    }

    private fun source(source: Source): Source {
        return object : ForwardingSource(source) {
            var totalBytesRead = 0L

            override fun read(sink: Buffer, byteCount: Long): Long {
                val bytesRead = super.read(sink, byteCount)
                if (bytesRead != -1L) {
                    totalBytesRead += bytesRead
                }
                return bytesRead
            }
        }
    }
} 


================================================
FILE: android/app/src/main/res/drawable/rn_edit_text_material.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (C) 2014 The Android Open Source Project

     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-->
<inset xmlns:android="http://schemas.android.com/apk/res/android"
       android:insetLeft="@dimen/abc_edit_text_inset_horizontal_material"
       android:insetRight="@dimen/abc_edit_text_inset_horizontal_material"
       android:insetTop="@dimen/abc_edit_text_inset_top_material"
       android:insetBottom="@dimen/abc_edit_text_inset_bottom_material">

    <selector>
        <!--
          This file is a copy of abc_edit_text_material (https://bit.ly/3k8fX7I).
          The item below with state_pressed="false" and state_focused="false" causes a NullPointerException.
          NullPointerException:tempt to invoke virtual method 'android.graphics.drawable.Drawable android.graphics.drawable.Drawable$ConstantState.newDrawable(android.content.res.Resources)'

          <item android:state_pressed="false" android:state_focused="false" android:drawable="@drawable/abc_textfield_default_mtrl_alpha"/>

          For more info, see https://bit.ly/3CdLStv (react-native/pull/29452) and https://bit.ly/3nxOMoR.
        -->
        <item android:state_enabled="false" android:drawable="@drawable/abc_textfield_default_mtrl_alpha"/>
        <item android:drawable="@drawable/abc_textfield_activated_mtrl_alpha"/>
    </selector>

</inset>



================================================
FILE: android/app/src/main/res/values/strings.xml
================================================
<resources>
    <string name="app_name">PocketPal</string>
</resources>



================================================
FILE: android/app/src/main/res/values/styles.xml
================================================
<resources>

    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.DayNight.NoActionBar">
        <!-- Customize your theme here. -->
        <item name="android:editTextBackground">@drawable/rn_edit_text_material</item>
    </style>

</resources>



================================================
FILE: android/app/src/main/res/xml/backup_rules_12_plus.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
    <cloud-backup disableIfNoEncryptionCapabilities="true">
        <exclude domain="file" path="models/"/>
        <!-- only created in debuggable builds, but can be large and exceed
         25mb cloud backup limit which makes dev testing difficult -->
        <exclude domain="file" path="BridgeReactNativeDevBundle.js"/>
        <exclude domain="root" path="code_cache/"/>
    </cloud-backup>

    <device-transfer>
        <exclude domain="file" path="models/"/>
        <exclude domain="file" path="BridgeReactNativeDevBundle.js"/>
        <exclude domain="root" path="code_cache/"/>
    </device-transfer>
</data-extraction-rules>


================================================
FILE: android/app/src/main/res/xml/backup_rules_legacy.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<full-backup-content>
    <include domain="sharedpref" path="." requireFlags="clientSideEncryption" />
    <include domain="database" path="." requireFlags="clientSideEncryption"/>
    <include domain="file" path="profileInstalled" requireFlags="clientSideEncryption"/>
    <include domain="file" path="db-migration-complete.flag" requireFlags="clientSideEncryption"/>
    <include domain="root" path="pocketpalai.db" requireFlags="clientSideEncryption"/>
    <include domain="root" path="pocketpalai.db-wal" requireFlags="clientSideEncryption"/>
    <include domain="root" path="pocketpalai.db-shm" requireFlags="clientSideEncryption"/>
</full-backup-content>


================================================
FILE: android/fastlane/Fastfile
================================================
default_platform :android

platform :android do
  desc "Release Android app to Alpha track"
  lane :release_android_alpha do
    android_dir = File.expand_path('..', Dir.pwd)
    
    # Create google-services.json from GitHub secret
    File.write(
      File.join(android_dir, "app/google-services.json"),
      ENV["GOOGLE_SERVICES_JSON"]
    )
    
    # Build APK for GitHub Release
    gradle(
      task: "assemble",
      build_type: "Release",
      properties: {
        "android.injected.signing.store.file" => File.join(android_dir, "app/pocketpal-release-key.keystore"),
        "android.injected.signing.store.password" => ENV["KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["KEY_PASSWORD"]
      }
    )
    
    # Build Bundle for Play Store
    gradle(
      task: "bundle",
      build_type: "Release",
      properties: {
        "android.injected.signing.store.file" => File.join(android_dir, "app/pocketpal-release-key.keystore"),
        "android.injected.signing.store.password" => ENV["KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["KEY_PASSWORD"]
      }
    )

    upload_to_play_store(
      track: "alpha",
      package_name: "com.pocketpalai",
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      skip_upload_apk: true,
      json_key: File.join(android_dir, "play-store-key.json")
    )
  end
end



================================================
FILE: android/gradle/wrapper/gradle-wrapper.properties
================================================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.10.2-all.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionSha256Sum=2ab88d6de2c23e6adae7363ae6e29cbdd2a709e992929b48b6530fd0c7133bd6



================================================
FILE: assets/add_model_1.webp
================================================
[Binary file]


================================================
FILE: assets/add_model_2.webp
================================================
[Binary file]


================================================
FILE: assets/chat_1.webp
================================================
[Binary file]


================================================
FILE: assets/model_config_1.webp
================================================
[Binary file]


================================================
FILE: assets/model_config_2.webp
================================================
[Binary file]


================================================
FILE: assets/model_load.webp
================================================
[Binary file]


================================================
FILE: docs/getting_started.md
================================================
# Getting Started

Note: Part of this guide is outdated. It will be updated soon.

## Installation

**iPhone** users can grab it here: [PocketPal AI on the App Store](https://apps.apple.com/us/app/pocketpal-ai/id6502579498)

**Android** users can get it from here: [PocketPal AI on Google Play](https://play.google.com/store/apps/details?id=com.pocketpalai)

Note: This is a personal project, so I am working on it in my spare time. It might have bugs and issues, and obviously, I have not tested it on all devices. If you encounter any issues, open an issue, or even better, contribute to the project!


### Available Models
PocketPal AI comes pre-configured with some popular SLMs:

- Danube 2 and 3
- Phi
- Gemma 2
- Qwen

Modells need to be downloaded before use. You can download and use these models directly from the app and load any other GGUF models you like!

<div style="display: flex; justify-content: center;">
    <img src="../assets/models_page.webp" alt="Models Page" style="width: 33%;">
</div>

## Using PocketPal AI

### Downloading a Model

- Tap the burger menu
- Navigate to the ‚ÄúModels‚Äù page
- Choose your desired model and hit download


<div style="display: flex; justify-content: center;">
    <img src="../assets/add_model_1.webp" alt="Navigate to Models Page" style="width: 33%;">
    <img src="../assets/add_model_2.webp" alt="Download a Model" style="width: 33%;">
    <img src="../assets/add_model_3.webp" alt="Load a Model" style="width: 33%;">
</div>

### Loading a Model
After downloading, tap *Load* to bring the model into memory. Now you‚Äôre ready to chat!

### Tips

On iOS devices, Apple‚Äôs GPU API (Metal) is activated by default. If you experience any hiccups, try deactivating it.

#### iOS Metal

#### Auto Offload/Load

To keep the device running smoothly, PocketPal AI can automatically manage memory usage:

- Enable ‚ÄúAuto Offload/Load‚Äù on the model page (by default it is)
- The app will offload the model when in the background
- It‚Äôll reload when you return (give it a few seconds for larger models)

#### Advanced Settings

Click the chevron icon to access advanced LLM settings like:

- Temperature
- BOS token
- Chat template options
- etc.

<div style="display: flex;  justify-content: center;">
    <img src="../assets/model_config_1.webp" alt="Navigate to Models Page" style="width: 33%;">
    <img src="../assets/model_config_2.webp" alt="Download a Model" style="width: 33%;">
    <img src="../assets/model_load.webp" alt="Load a Model" style="width: 33%;">
</div>

### Finally, Let‚Äôs Chat!

Once your model is loaded, head to the ‚ÄúChat‚Äù page and start conversing with the loaded model!

The generation performance metric is also displayed. If interested, watch the chat bubble for real-time performance metrics: Tokens per second and Milliseconds per token.

<div style="display: flex; justify-content: center;">
    <img src="../assets/chat_1.webp" alt="Navigate to Models Page" style="width: 33%;">
    <img src="../assets/chat_2.webp" alt="Download a Model" style="width: 33%;">
</div>

### Copying Text

Important Note: As of now, I haven‚Äôt found an easy way to select and copy text from the generated responses while preserving the text formatting, particularly Markdown support.

In the meantime, here are the current options for copying text:
- Paragraph-level copying: Long-press on a specific paragraph to copy its content.
- Full response copying: Use the copy icon at the bottom of the text bubble to copy the entire AI-generated response.

I know these options might not be ideal, and this is one of my frustrations with using other apps. The difficulty of copying portions of text used to be a particularly annoying aspect of chat apps like ChatGPT and others.

**Developers**: PocketPal AI is built using React Native. Finding an easy solution that balances text selection with preserved formatting (especially Markdown support) has been tricky for me. If you have experience in this area, I‚Äôd love to hear from you!

## Feedback Welcome!

If you have suggestions for new models or features, please let us know by creating an issue.

Happy exploring! üöÄüì±‚ú®


================================================
FILE: fastlane/Fastfile
================================================
desc "Bump version for both Android and iOS"
lane :bump_version do |options|
  version_type = options[:version_type] || "patch"
  root_dir = File.expand_path('..', Dir.pwd)
  
  # Common paths
  package_json_path = File.join(root_dir, 'package.json')
  version_file_path = File.join(root_dir, '.version')

  # Bump version in package.json
  Dir.chdir(root_dir) do
    sh("yarn version --#{version_type} --no-git-tag-version")
  end
  
  new_version = JSON.parse(File.read(package_json_path))['version']
  sh("echo #{new_version} > #{version_file_path}")

  # For Android: Read current version code and increment it
  gradle_file = File.join(root_dir, "android/app/build.gradle")
  current_version_code = android_get_version_code(gradle_file: gradle_file).to_i
  new_version_code = current_version_code + 1

  # Update Android version
  android_set_version_code(
    gradle_file: gradle_file,
    version_code: new_version_code
  )
  
  android_set_version_name(
    gradle_file: gradle_file,
    version_name: new_version
  )

  # For iOS: Bump version and build number
  ios_dir = File.join(root_dir, 'ios')
  Dir.chdir(ios_dir) do
    increment_version_number_in_xcodeproj(
      version_number: new_version,
      xcodeproj: File.join(ios_dir, "PocketPal.xcodeproj")
    )
    increment_build_number_in_xcodeproj(
      xcodeproj: File.join(ios_dir, "PocketPal.xcodeproj")
    )
  end

  UI.message("Bumped versions:")
  UI.message("- Version name: #{new_version}")
  UI.message("- Android version code: #{new_version_code}")
  UI.message("- iOS build number: #{get_build_number_from_xcodeproj(xcodeproj: File.join(ios_dir, 'PocketPal.xcodeproj'))}")
end



================================================
FILE: fastlane/metadata/android/en-US/full_description.txt
================================================
Unlock the power of AI with Private AI Chat, the ultimate app for secure and private conversations with LLMs. The app brings the sophistication of cutting-edge AI directly to your device, ensuring your chats remain confidential and offline.

Key Features:
- Offline Chatting: Interact with advanced AI models directly on your device without the need for an internet connection.
- The app supports GGUF formats, allowing you to either load models locally or search directly in Hugging Face.
- Secure & Private: Your data never leaves your device. All conversations are processed locally, providing security and peace of mind.

How It Works:
- Download & Install: Get the app from the App store (or) Play store (or) F-Droid and install it on your device.
- Download Model Weights: Connect to the Internet to download the required model weights (in GGUF format, e.g., from Huggingface).
- Chat Offline: Once setup is complete, enjoy private, offline conversations with the model anytime, anywhere.



================================================
FILE: fastlane/metadata/android/en-US/short_description.txt
================================================
PocketPal is an app for secure and private conversation with open source LLMs



================================================
FILE: fastlane/metadata/android/en-US/title.txt
================================================
PocketPal



================================================
FILE: ios/link-assets-manifest.json
================================================
{
  "migIndex": 1,
  "data": [
    {
      "path": "src/assets/fonts/Inter-Bold.ttf",
      "sha1": "518a0361a245a66b49bc24ae0137f38328197bdc"
    },
    {
      "path": "src/assets/fonts/Inter-ExtraBold.ttf",
      "sha1": "d01b4a9a01dfdb6d9a5c6ec153d528d70706d885"
    },
    {
      "path": "src/assets/fonts/Inter-Light.ttf",
      "sha1": "6b041e6fc61656b930d8ef638a0b9d6a0ac8e084"
    },
    {
      "path": "src/assets/fonts/Inter-Medium.ttf",
      "sha1": "e2d21cdc9730ce4d4bdccb3476413a5b79fe7d52"
    },
    {
      "path": "src/assets/fonts/Inter-Regular.ttf",
      "sha1": "bd1976c1f019853ab6143ef1246e25aa66fd990e"
    },
    {
      "path": "src/assets/fonts/Inter-SemiBold.ttf",
      "sha1": "f3e44abd6661d5b861e66db22f4f79a6c466cd00"
    },
    {
      "path": "src/assets/fonts/Inter-Thin.ttf",
      "sha1": "4f2b3c3c97e618166627b4d3fff9322fa5198e81"
    }
  ]
}



================================================
FILE: ios/Podfile
================================================
# Resolve react_native_pods.rb with node to allow for hoisting
require Pod::Executable.execute_command('node', ['-p',
  'require.resolve(
    "react-native/scripts/react_native_pods.rb",
    {paths: [process.argv[1]]},
  )', __dir__]).strip

platform :ios, min_ios_version_supported
prepare_react_native_project!

linkage = ENV['USE_FRAMEWORKS']
if linkage != nil
  Pod::UI.puts "Configuring Pod with #{linkage}ally linked Frameworks".green
  use_frameworks! :linkage => linkage.to_sym
end

# Enable Firebase as a static framework
$RNFirebaseAsStaticFramework = true

ENV['RCT_NEW_ARCH_ENABLED'] = '0'

target 'PocketPal' do
  config = use_native_modules!

  use_react_native!(
    :path => config[:reactNativePath],
    # An absolute path to your application root.
    :app_path => "#{Pod::Config.instance.installation_root}/.."
  )

  target 'PocketPalTests' do
    inherit! :complete
    # Pods for testing
  end

  # Firebase (App Check)
  pod 'Firebase', :modular_headers => true
  pod 'FirebaseCore', :modular_headers => true
  pod 'FirebaseAppCheck', :modular_headers => true
  pod 'GoogleUtilities', :modular_headers => true

  # Uncomment this line if you're not using auto-linking or if auto-linking causes trouble
  # pod 'WatermelonDB', path: '../node_modules/@nozbe/watermelondb'
  
  # WatermelonDB dependency, should not be needed on modern React Native
  # (please file an issue if this causes issues for you)
  # pod 'React-jsi', path: '../node_modules/react-native/ReactCommon/jsi', modular_headers: true
  
  # WatermelonDB dependency
  pod 'simdjson', path: '../node_modules/@nozbe/simdjson', modular_headers: true


  post_install do |installer|
    # https://github.com/facebook/react-native/blob/main/packages/react-native/scripts/react_native_pods.rb#L197-L202
    react_native_post_install(
      installer,
      config[:reactNativePath],
      :mac_catalyst_enabled => false,
      # :ccache_enabled => true
    )
  end


end



================================================
FILE: ios/.xcode.env
================================================
# This `.xcode.env` file is versioned and is used to source the environment
# used when running script phases inside Xcode.
# To customize your local environment, you can create an `.xcode.env.local`
# file that is not versioned.

# NODE_BINARY variable contains the PATH to the node executable.
#
# Customize the NODE_BINARY variable here.
# For example, to use nvm with brew, add the following line
# . "$(brew --prefix nvm)/nvm.sh" --no-use
export NODE_BINARY=$(command -v node)



================================================
FILE: ios/fastlane/Fastfile
================================================
default_platform :ios

platform :ios do
  desc "Release iOS app to TestFlight"
  lane :release_ios_testflight do
    # Create GoogleService-Info.plist from GitHub secret
    File.write(
      File.join(Dir.pwd, "../GoogleService-Info.plist"),
      ENV["GOOGLE_SERVICES_PLIST"]
    )
    
    setup_ci(force: true)

    api_key = app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_API_ISSUER_ID'],
      key_content: ENV['APP_STORE_CONNECT_API_KEY_CONTENT'].gsub('\\n', "\n"),
      in_house: false
    )

    # Helper method to encode GitHub token
    def encoded_github_token
      require 'base64'
      Base64.strict_encode64("x-access-token:#{ENV['MATCH_GITHUB_TOKEN']}")
    end

    match(
      type: "development",
      readonly: true,
      api_key: api_key,
      git_branch: "master",
      git_basic_authorization: encoded_github_token
    )

    match(
      type: "appstore",
      readonly: true,
      api_key: api_key,
      git_branch: "master",
      #password: ENV['MATCH_PASSWORD'], # will be picked up from environment variables
      git_basic_authorization: encoded_github_token
    )

    build_ios_app(
      scheme: "PocketPal",
      export_method: "app-store",
      output_directory: "./build",
      clean: true,
      export_options: {
        provisioningProfiles: {
          "ai.pocketpal" => "match AppStore ai.pocketpal"
        },
        signingStyle: "manual"
      }
    )

    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: false,
      wait_processing_interval: 60, # Check every minute
      wait_for_uploaded_build: true,
      wait_processing_timeout_duration: 1800 # 30 minutes timeout
    )
  end
end



================================================
FILE: ios/fastlane/Matchfile
================================================
git_url(ENV['MATCH_GIT_URL'])
git_basic_authorization(ENV['MATCH_GITHUB_TOKEN'])

storage_mode("git")

type("appstore") # The default type, can be: appstore, adhoc, enterprise or development

app_identifier(["ai.pocketpal"]) 
username(ENV['APP_STORE_CONNECT_USER_ID'])

# app_identifier(["tools.fastlane.app", "tools.fastlane.app2"])
# username("user@fastlane.tools") # Your Apple Developer Portal username

# For all available options run `fastlane match --help`
# Remove the # in the beginning of the line to enable the other options

# The docs are available on https://docs.fastlane.tools/actions/match



================================================
FILE: ios/PocketPal/AppDelegate.h
================================================
#import <RCTAppDelegate.h>
#import <UIKit/UIKit.h>

@interface AppDelegate : RCTAppDelegate

@end



================================================
FILE: ios/PocketPal/AppDelegate.mm
================================================
#import "AppDelegate.h"

// App Check
#import "RNFBAppCheckModule.h" 
#import <Firebase.h>


#import <React/RCTBundleURLProvider.h>
#import <RNFSBackgroundDownloads.h>

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  // Initialize Firebase
  // This is used exclusively for sending model benchmarks (with user consent) to Firebase.
  // Firebase is used for App Check functionality, allowing unauthenticated users to submit their benchmark data securely.
  [RNFBAppCheckModule sharedInstance];
  [FIRApp configure]; 

  self.moduleName = @"PocketPal";
  // You can add your custom initial props in the dictionary below.
  // They will be passed down to the ViewController used by React Native.
  self.initialProps = @{};

  return [super application:application didFinishLaunchingWithOptions:launchOptions];
}

- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge
{
  return [self bundleURL];
}

- (NSURL *)bundleURL
{
#if DEBUG
  return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@"index"];
#else
  return [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"];
#endif
}

- (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler
{
  [RNFSBackgroundDownloads setCompletionHandlerForIdentifier:identifier completionHandler:completionHandler];
}

@end



================================================
FILE: ios/PocketPal/DeviceInfoModule.h
================================================
#import <React/RCTBridgeModule.h>

@interface DeviceInfoModule : NSObject <RCTBridgeModule>
@end



================================================
FILE: ios/PocketPal/DeviceInfoModule.m
================================================
#import "DeviceInfoModule.h"
#import <React/RCTLog.h>

@implementation DeviceInfoModule

RCT_EXPORT_MODULE(DeviceInfoModule);

RCT_EXPORT_METHOD(getCPUInfo:(RCTPromiseResolveBlock)resolve
                  rejecter:(RCTPromiseRejectBlock)reject)
{
  @try {
    NSUInteger numberOfCPUCores = [[NSProcessInfo processInfo] activeProcessorCount];
    NSDictionary *result = @{@"cores": @(numberOfCPUCores)};
    resolve(result);
  } @catch (NSException *exception) {
    reject(@"error_getting_cpu_info", @"Could not retrieve CPU info", nil);
  }
}

@end



================================================
FILE: ios/PocketPal/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>en</string>
	<key>CFBundleDisplayName</key>
	<string>PocketPal</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(MARKETING_VERSION)</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>$(CURRENT_PROJECT_VERSION)</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>NSAppTransportSecurity</key>
	<dict>
		<key>NSAllowsArbitraryLoads</key>
		<false/>
		<key>NSAllowsLocalNetworking</key>
		<true/>
	</dict>
	<key>NSCameraUsageDescription</key>
	<string>PocketPal uses your camera to capture images and video for local AI analysis only. All processing happens on your device and no images are transmitted to external servers.</string>
	<key>NSPhotoLibraryUsageDescription</key>
	<string>PocketPal accesses your photo library to select images for local AI analysis only. Selected images are processed entirely on your device and are never transmitted to external servers.</string>
	<key>UIAppFonts</key>
	<array>
		<string>MaterialIcons.ttf</string>
		<string>MaterialCommunityIcons.ttf</string>
		<string>Inter-Bold.ttf</string>
		<string>Inter-Light.ttf</string>
		<string>Inter-Medium.ttf</string>
		<string>Inter-Regular.ttf</string>
		<string>Inter-SemiBold.ttf</string>
		<string>Inter-Thin.ttf</string>
		<string>Inter-ExtraBold.ttf</string>
	</array>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIRequiredDeviceCapabilities</key>
	<array>
		<string>arm64</string>
	</array>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
		<string>UIInterfaceOrientationPortrait</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
	</array>
	<key>UIViewControllerBasedStatusBarAppearance</key>
	<false/>
	<key>FIREBASE_ANALYTICS_COLLECTION_ENABLED</key>
	<false/>
</dict>
</plist>



================================================
FILE: ios/PocketPal/KeepAwakeModule.h
================================================
#import <React/RCTBridgeModule.h>

@interface KeepAwakeModule : NSObject <RCTBridgeModule>
@end 


================================================
FILE: ios/PocketPal/KeepAwakeModule.m
================================================
#import "KeepAwakeModule.h"
#import <UIKit/UIKit.h>

@implementation KeepAwakeModule

RCT_EXPORT_MODULE(KeepAwakeModule);

RCT_EXPORT_METHOD(activate)
{
    dispatch_async(dispatch_get_main_queue(), ^{
        [[UIApplication sharedApplication] setIdleTimerDisabled:YES];
    });
}

RCT_EXPORT_METHOD(deactivate)
{
    dispatch_async(dispatch_get_main_queue(), ^{
        [[UIApplication sharedApplication] setIdleTimerDisabled:NO];
    });
}

@end 


================================================
FILE: ios/PocketPal/LaunchScreen.storyboard
================================================
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="15702" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <device id="retina4_7" orientation="portrait" appearance="light"/>
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="15704"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <rect key="frame" x="0.0" y="0.0" width="375" height="667"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <label opaque="NO" clipsSubviews="YES" userInteractionEnabled="NO" contentMode="left" horizontalHuggingPriority="251" verticalHuggingPriority="251" text="PocketPal" textAlignment="center" lineBreakMode="middleTruncation" baselineAdjustment="alignBaselines" minimumFontSize="18" translatesAutoresizingMaskIntoConstraints="NO" id="GJd-Yh-RWb">
                                <rect key="frame" x="0.0" y="202" width="375" height="43"/>
                                <fontDescription key="fontDescription" type="boldSystem" pointSize="36"/>
                                <nil key="highlightedColor"/>
                            </label>
                            <label opaque="NO" clipsSubviews="YES" userInteractionEnabled="NO" contentMode="left" horizontalHuggingPriority="251" verticalHuggingPriority="251" text="LLM Ventures" textAlignment="center" lineBreakMode="tailTruncation" baselineAdjustment="alignBaselines" minimumFontSize="9" translatesAutoresizingMaskIntoConstraints="NO" id="MN2-I3-ftu">
                                <rect key="frame" x="0.0" y="626" width="375" height="21"/>
                                <fontDescription key="fontDescription" type="system" pointSize="17"/>
                                <nil key="highlightedColor"/>
                            </label>
                        </subviews>
                        <color key="backgroundColor" systemColor="systemBackgroundColor" cocoaTouchSystemColor="whiteColor"/>
                        <constraints>
                            <constraint firstItem="Bcu-3y-fUS" firstAttribute="bottom" secondItem="MN2-I3-ftu" secondAttribute="bottom" constant="20" id="OZV-Vh-mqD"/>
                            <constraint firstItem="Bcu-3y-fUS" firstAttribute="centerX" secondItem="GJd-Yh-RWb" secondAttribute="centerX" id="Q3B-4B-g5h"/>
                            <constraint firstItem="MN2-I3-ftu" firstAttribute="centerX" secondItem="Bcu-3y-fUS" secondAttribute="centerX" id="akx-eg-2ui"/>
                            <constraint firstItem="MN2-I3-ftu" firstAttribute="leading" secondItem="Bcu-3y-fUS" secondAttribute="leading" id="i1E-0Y-4RG"/>
                            <constraint firstItem="GJd-Yh-RWb" firstAttribute="centerY" secondItem="Ze5-6b-2t3" secondAttribute="bottom" multiplier="1/3" constant="1" id="moa-c2-u7t"/>
                            <constraint firstItem="GJd-Yh-RWb" firstAttribute="leading" secondItem="Bcu-3y-fUS" secondAttribute="leading" symbolic="YES" id="x7j-FC-K8j"/>
                        </constraints>
                        <viewLayoutGuide key="safeArea" id="Bcu-3y-fUS"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="52.173913043478265" y="375"/>
        </scene>
    </scenes>
</document>



================================================
FILE: ios/PocketPal/main.m
================================================
#import <UIKit/UIKit.h>

#import "AppDelegate.h"

int main(int argc, char *argv[])
{
  @autoreleasepool {
    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
  }
}



================================================
FILE: ios/PocketPal/PrivacyInfo.xcprivacy
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>NSPrivacyAccessedAPITypes</key>
	<array>
		<dict>
			<key>NSPrivacyAccessedAPIType</key>
			<string>NSPrivacyAccessedAPICategoryUserDefaults</string>
			<key>NSPrivacyAccessedAPITypeReasons</key>
			<array>
				<string>CA92.1</string>
				<string>1C8F.1</string>
				<string>C56D.1</string>
			</array>
		</dict>
		<dict>
			<key>NSPrivacyAccessedAPIType</key>
			<string>NSPrivacyAccessedAPICategoryFileTimestamp</string>
			<key>NSPrivacyAccessedAPITypeReasons</key>
			<array>
				<string>C617.1</string>
				<string>0A2A.1</string>
				<string>3B52.1</string>
			</array>
		</dict>
		<dict>
			<key>NSPrivacyAccessedAPIType</key>
			<string>NSPrivacyAccessedAPICategorySystemBootTime</string>
			<key>NSPrivacyAccessedAPITypeReasons</key>
			<array>
				<string>35F9.1</string>
			</array>
		</dict>
		<dict>
			<key>NSPrivacyAccessedAPIType</key>
			<string>NSPrivacyAccessedAPICategoryDiskSpace</string>
			<key>NSPrivacyAccessedAPITypeReasons</key>
			<array>
				<string>85F4.1</string>
				<string>E174.1</string>
			</array>
		</dict>
	</array>
	<key>NSPrivacyCollectedDataTypes</key>
	<array>
		<dict>
			<key>NSPrivacyCollectedDataType</key>
			<string>NSPrivacyCollectedDataTypePerformance</string>
			<key>NSPrivacyCollectedDataTypeLinked</key>
			<false/>
			<key>NSPrivacyCollectedDataTypePurposes</key>
			<array>
				<string>NSPrivacyCollectedDataTypePurposeAnalytics</string>
			</array>
			<key>NSPrivacyCollectedDataTypeTracking</key>
			<false/>
		</dict>
	</array>
	<key>NSPrivacyTracking</key>
	<false/>
	<key>NSPrivacyTrackingDomains</key>
	<array/>
</dict>
</plist>



================================================
FILE: ios/PocketPal/Images.xcassets/Contents.json
================================================
{
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
FILE: ios/PocketPal/Images.xcassets/AppIcon.appiconset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "iPad_Notifications_20_2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "filename" : "iPhone_Notifications_20_3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "20x20"
    },
    {
      "filename" : "iPhone_Settings_29_2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "filename" : "iPhone_Settings_29_3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "29x29"
    },
    {
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "38x38"
    },
    {
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "38x38"
    },
    {
      "filename" : "iPhone_Spotlight_40_2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "filename" : "iPhone_Spotlight_40_3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "40x40"
    },
    {
      "filename" : "iPhone_App_60_2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "60x60"
    },
    {
      "filename" : "iPhone_App_60_3x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "60x60"
    },
    {
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "64x64"
    },
    {
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "3x",
      "size" : "64x64"
    },
    {
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "68x68"
    },
    {
      "filename" : "iPad_App_76_2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "76x76"
    },
    {
      "filename" : "iPad_Pro_App_83.5_2x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "scale" : "2x",
      "size" : "83.5x83.5"
    },
    {
      "filename" : "App_store_1024_1x.png",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: ios/PocketPalTests/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>en</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>BNDL</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>1</string>
</dict>
</plist>



================================================
FILE: ios/PocketPalTests/PocketPalTests.m
================================================
#import <UIKit/UIKit.h>
#import <XCTest/XCTest.h>

#import <React/RCTLog.h>
#import <React/RCTRootView.h>

#define TIMEOUT_SECONDS 600
#define TEXT_TO_LOOK_FOR @"Welcome to React"

@interface PocketPalTests : XCTestCase

@end

@implementation PocketPalTests

- (BOOL)findSubviewInView:(UIView *)view matching:(BOOL (^)(UIView *view))test
{
  if (test(view)) {
    return YES;
  }
  for (UIView *subview in [view subviews]) {
    if ([self findSubviewInView:subview matching:test]) {
      return YES;
    }
  }
  return NO;
}

- (void)testRendersWelcomeScreen
{
  UIViewController *vc = [[[RCTSharedApplication() delegate] window] rootViewController];
  NSDate *date = [NSDate dateWithTimeIntervalSinceNow:TIMEOUT_SECONDS];
  BOOL foundElement = NO;

  __block NSString *redboxError = nil;
#ifdef DEBUG
  RCTSetLogFunction(
      ^(RCTLogLevel level, RCTLogSource source, NSString *fileName, NSNumber *lineNumber, NSString *message) {
        if (level >= RCTLogLevelError) {
          redboxError = message;
        }
      });
#endif

  while ([date timeIntervalSinceNow] > 0 && !foundElement && !redboxError) {
    [[NSRunLoop mainRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.1]];
    [[NSRunLoop mainRunLoop] runMode:NSRunLoopCommonModes beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.1]];

    foundElement = [self findSubviewInView:vc.view
                                  matching:^BOOL(UIView *view) {
                                    if ([view.accessibilityLabel isEqualToString:TEXT_TO_LOOK_FOR]) {
                                      return YES;
                                    }
                                    return NO;
                                  }];
  }

#ifdef DEBUG
  RCTSetLogFunction(RCTDefaultLogFunction);
#endif

  XCTAssertNil(redboxError, @"RedBox error: %@", redboxError);
  XCTAssertTrue(foundElement, @"Couldn't find element with text '%@' in %d seconds", TEXT_TO_LOOK_FOR, TIMEOUT_SECONDS);
}

@end



================================================
FILE: jest/fixtures.ts
================================================
import {MessageType, Size, User} from '../src/utils/types';

export const defaultDerivedMessageProps = {
  nextMessageInGroup: false,
  offset: 12,
  showName: false,
  showStatus: true,
};

export const fileMessage: MessageType.File = {
  author: {
    id: 'userId',
  },
  createdAt: 2000000,
  id: 'file-uuidv4',
  mimeType: 'application/pdf',
  name: 'flyer.pdf',
  size: 15000,
  status: 'seen',
  type: 'file',
  uri: 'file:///Users/admin/flyer.pdf',
};

export const derivedFileMessage: MessageType.DerivedFile = {
  ...fileMessage,
  ...defaultDerivedMessageProps,
};

export const imageMessage: MessageType.Image = {
  author: {
    id: 'image-userId',
  },
  createdAt: 0,
  height: 100,
  id: 'image-uuidv4',
  name: 'name',
  size: 15000,
  status: 'sending',
  type: 'image',
  uri: 'https://avatars1.githubusercontent.com/u/59206044',
  width: 100,
};

export const derivedImageMessage: MessageType.DerivedImage = {
  ...imageMessage,
  ...defaultDerivedMessageProps,
};

export const size: Size = {
  height: 896,
  width: 414,
};

export const textMessage: MessageType.Text = {
  author: {
    id: 'userId',
  },
  createdAt: 0,
  id: 'uuidv4',
  text: 'text',
  type: 'text',
};

export const derivedTextMessage: MessageType.DerivedText = {
  ...textMessage,
  ...defaultDerivedMessageProps,
};

export const user: User = {
  id: 'userId',
};



================================================
FILE: jest/setup.ts
================================================
import 'react-native-gesture-handler/jestSetup';
import mockClipboard from '@react-native-clipboard/clipboard/jest/clipboard-mock.js';

import 'react-native-gesture-handler/jestSetup';

jest.mock('react-native-haptic-feedback');

jest.mock('react-native-keyboard-controller', () => {
  const KeyboardControllerMock = require('react-native-keyboard-controller/jest');
  return KeyboardControllerMock;
});

// Mock react-native-reanimated
//require('react-native-reanimated').setUpTests();
jest.mock('react-native-reanimated', () => {
  const Reanimated = require('react-native-reanimated/mock');

  Reanimated.default.call = () => {};

  Reanimated.useReducedMotion = jest.fn(() => false);

  Reanimated.useSharedValue = jest.fn(() => ({value: 0}));
  Reanimated.useAnimatedStyle = jest.fn(() => ({}));
  Reanimated.useAnimatedScrollHandler = jest.fn(() => ({}));
  Reanimated.useAnimatedProps = jest.fn(() => ({}));
  Reanimated.useAnimatedGestureHandler = jest.fn(() => ({}));
  Reanimated.withTiming = jest.fn(() => ({}));
  Reanimated.withSpring = jest.fn(() => ({}));
  Reanimated.cancelAnimation = jest.fn();

  Reanimated.default.createAnimatedComponent = (Component: any) => Component;

  return Reanimated;
});

jest.mock('@react-navigation/elements', () => ({
  ...jest.requireActual('@react-navigation/elements'),
  useHeaderHeight: jest.fn().mockReturnValue(56), // Provide a mock return value
}));

import {mockUiStore} from '../__mocks__/stores/uiStore';
import {mockHFStore} from '../__mocks__/stores/hfStore';
import {mockModelStore} from '../__mocks__/stores/modelStore';
import {mockChatSessionStore} from '../__mocks__/stores/chatSessionStore';
import {benchmarkStore as mockBenchmarkStore} from '../__mocks__/stores/benchmarkStore';
import {mockPalStore} from '../__mocks__/stores/palStore';

jest.mock('@react-native-clipboard/clipboard', () => mockClipboard);

jest.mock('react-native/Libraries/EventEmitter/NativeEventEmitter');

// Mock NativeModules.DeviceInfoModule specifically
const {NativeModules} = require('react-native');
NativeModules.DeviceInfoModule = {
  getCPUInfo: jest.fn(() => Promise.resolve({cores: 4})),
};

jest.mock('react-native-safe-area-context', () => {
  const inset = {top: 0, right: 0, bottom: 0, left: 0};
  return {
    ...jest.requireActual('react-native-safe-area-context'),
    SafeAreaProvider: jest.fn(({children}) => children),
    SafeAreaConsumer: jest.fn(({children}) => children(inset)),
    useSafeAreaInsets: jest.fn(() => inset),
    useSafeAreaFrame: jest.fn(() => ({x: 0, y: 0, width: 390, height: 844})),
  };
});

jest.mock('../src/store', () => {
  const {UIStore} = require('../__mocks__/stores/uiStore');
  return {
    modelStore: mockModelStore,
    UIStore,
    uiStore: mockUiStore,
    chatSessionStore: mockChatSessionStore,
    hfStore: mockHFStore,
    benchmarkStore: mockBenchmarkStore,
    palStore: mockPalStore,
  };
});

jest.mock('../src/hooks/useTheme', () => {
  const {themeFixtures} = require('./fixtures/theme');
  return {
    useTheme: jest.fn().mockReturnValue(themeFixtures.lightTheme),
  };
});

jest.mock('../src/hooks/useMemoryCheck', () => ({
  useMemoryCheck: jest.fn().mockReturnValue({
    memoryWarning: '',
    shortMemoryWarning: '',
    multimodalWarning: '',
  }),
  hasEnoughMemory: jest.fn().mockResolvedValue(true),
  isHighEndDevice: jest.fn().mockResolvedValue(true),
}));

jest.mock('../src/services/downloads', () => ({
  downloadManager: require('../__mocks__/services/downloads').downloadManager,
}));

jest.mock('uuid', () => ({
  v4: () => 'mock-uuid-12345' + Math.random(),
}));

jest.mock('../src/repositories/ChatSessionRepository', () => ({
  chatSessionRepository:
    require('../__mocks__/repositories/ChatSessionRepository')
      .chatSessionRepository,
}));

jest.mock('../src/utils/keepAwake', () => ({
  activateKeepAwake: jest.fn(),
  deactivateKeepAwake: jest.fn(),
}));

jest.mock('react-native-share', () => ({
  default: jest.fn(),
}));

jest.mock('react-native-image-picker');
jest.mock('react-native-vision-camera');



================================================
FILE: jest/test-utils.tsx
================================================
import React from 'react';
import {StyleSheet} from 'react-native';

import {PaperProvider} from 'react-native-paper';
import {render} from '@testing-library/react-native';
import {NavigationContainer} from '@react-navigation/native';
import {BottomSheetModalProvider} from '@gorhom/bottom-sheet';
import {SafeAreaProvider} from 'react-native-safe-area-context';
import {GestureHandlerRootView} from 'react-native-gesture-handler';

import {themeFixtures} from './fixtures/theme';

import {user as userFixture} from './fixtures';

import {UserContext} from '../src/utils';
import type {Theme} from '../src/utils/types';

type CustomRenderOptions = {
  theme?: Theme;
  user?: any;
  withNavigation?: boolean;
  withSafeArea?: boolean;
  withBottomSheetProvider?: boolean;
};

const customRender = (
  ui: React.ReactElement,
  {
    theme = themeFixtures.lightTheme,
    user = userFixture,
    withNavigation = false,
    withSafeArea = false,
    withBottomSheetProvider = false,
    ...renderOptions
  }: CustomRenderOptions = {},
) => {
  const Wrapper = ({children}: {children: React.ReactNode}) => {
    const withBottomSheetProviderWrapper = withBottomSheetProvider ? (
      <BottomSheetModalProvider>{children}</BottomSheetModalProvider>
    ) : (
      children
    );

    const withNavigationWrapper = withNavigation ? (
      <NavigationContainer>
        {withBottomSheetProviderWrapper}
      </NavigationContainer>
    ) : (
      withBottomSheetProviderWrapper
    );

    const withSafeAreaWrapper = withSafeArea ? (
      <SafeAreaProvider>{withNavigationWrapper}</SafeAreaProvider>
    ) : (
      withNavigationWrapper
    );

    return (
      <GestureHandlerRootView style={styles.root}>
        <BottomSheetModalProvider>
          <PaperProvider theme={theme}>
            <UserContext.Provider value={user}>
              {withSafeAreaWrapper}
            </UserContext.Provider>
          </PaperProvider>
        </BottomSheetModalProvider>
      </GestureHandlerRootView>
    );
  };

  return render(ui, {wrapper: Wrapper, ...renderOptions});
};

const styles = StyleSheet.create({
  root: {
    flex: 1,
  },
});

// Re-export everything
export * from '@testing-library/react-native';
export {customRender as render};



================================================
FILE: jest/fixtures/benchmark.ts
================================================
import {BenchmarkResult, DeviceInfo} from '../../src/utils/types';

export const mockResult: BenchmarkResult = {
  config: {
    pp: 512,
    tg: 256,
    pl: 1,
    nr: 3,
    label: 'Test Config',
  },
  modelDesc: 'Test Model',
  modelSize: 1000000,
  modelNParams: 7000000000,
  ppAvg: 20.5,
  ppStd: 1.2,
  tgAvg: 30.5,
  tgStd: 2.1,
  timestamp: '2024-03-20T10:00:00.000Z',
  modelId: 'test-model-id',
  modelName: 'Test Model',
  filename: 'test-model.gguf',
  uuid: 'test-uuid',
  oid: 'test-oid',
  rfilename: 'test-rfilename',
  peakMemoryUsage: {
    total: 1000000,
    used: 500000,
    percentage: 50,
  },
  wallTimeMs: 10000,
  submitted: false,
};

export const mockSubmittedResult: BenchmarkResult = {
  ...mockResult,
  submitted: true,
};

export const mockDeviceInfo: DeviceInfo = {
  model: 'Test Phone',
  systemName: 'iOS',
  systemVersion: '16.0',
  brand: 'Apple',
  cpuArch: ['arm64'],
  isEmulator: false,
  version: '16.0',
  buildNumber: '20A362',
  device: 'iPhone14,2',
  deviceId: 'test-device-id',
  totalMemory: 6144,
  chipset: 'Apple A15',
  cpu: 'hexa-core',
  cpuDetails: {
    cores: 6,
    processors: [
      {
        processor: '0',
        'model name': 'Apple A15',
        'cpu MHz': '3200',
        vendor_id: 'Apple',
      },
    ],
    socModel: 'Apple A15',
    features: ['fp16', 'neon'],
    hasFp16: true,
    hasDotProd: true,
    hasSve: false,
    hasI8mm: true,
  },
};



================================================
FILE: jest/fixtures/chatSessions.ts
================================================
import {MessageType} from '../../src/utils/types';

export const sessionFixtures = [
  {
    id: 'session-1',
    title: 'Session 1',
    date: '2024-10-12',
    messages: [{id: 'msg-1', text: 'Hello!', type: 'text'} as MessageType.Text],
  },
  {
    id: 'session-2',
    title: 'Session 2',
    date: '2024-10-11',
    messages: [
      {id: 'msg-2', text: 'Hey there!', type: 'text'} as MessageType.Text,
    ],
  },
];



================================================
FILE: jest/fixtures/device-info.ts
================================================
export const deviceInfo = {
  freeDiskStorage: 8 * 1000 ** 3,
  totalMemory: 4 * 1000 ** 3,
  usedMemory: 2 * 1000 ** 3,
  version: '1.0.0',
  buildNumber: '1',
};

export const deviceInfoIPhone = {
  ...deviceInfo,
  manufacturer: 'Apple',
  model: 'iPhone 12',
  systemVersion: '14.5',
};

export const deviceInfoAndroid = {
  ...deviceInfo,
  manufacturer: 'Samsung',
  model: 'Galaxy S21',
  systemVersion: '12',
};



================================================
FILE: jest/fixtures/models.ts
================================================
import {NativeLlamaContext} from '@pocketpalai/llama.rn';

import {deviceInfo} from './device-info';

import {
  GGUFSpecs,
  HuggingFaceModel,
  Model,
  ModelFile,
  ModelOrigin,
} from '../../src/utils/types';
import {CompletionParams} from '../../src/utils/completionTypes';

export const mockContextModel: NativeLlamaContext['model'] = {
  desc: '',
  size: 0,
  nEmbd: 0,
  nParams: 0,
  chatTemplates: {
    llamaChat: false,
    minja: {
      default: false,
      defaultCaps: {
        tools: false,
        toolCalls: false,
        toolResponses: false,
        systemRole: false,
        parallelToolCalls: false,
        toolCallId: false,
      },
      toolUse: false,
      toolUseCaps: {
        tools: false,
        toolCalls: false,
        toolResponses: false,
        systemRole: false,
        parallelToolCalls: false,
        toolCallId: false,
      },
    },
  },
  isChatTemplateSupported: false,
  metadata: {},
};

export const mockDefaultCompletionParams: CompletionParams = {
  prompt: '',
  n_predict: 400,
  temperature: 0.7,
  top_k: 40,
  top_p: 0.95,
  min_p: 0.05,
  xtc_threshold: 0.1,
  xtc_probability: 0.01,
  typical_p: 1.0,
  penalty_last_n: 64,
  penalty_repeat: 1.0,
  penalty_freq: 0.5,
  penalty_present: 0.4,
  mirostat: 0,
  mirostat_tau: 5,
  mirostat_eta: 0.1,
  seed: 0,
  n_probs: 0,
  stop: ['</s>'],
};

export const mockCompletionParams: CompletionParams = {
  ...mockDefaultCompletionParams,
  n_predict: 500,
  temperature: 0.01,
  stop: ['<stop1>', '<stop2>'],
};

export const mockDefaultChatTemplate = {
  addGenerationPrompt: true,
  name: 'default chat template name',
  bosToken: '<|default_bos|>',
  eosToken: '<|default_eos|>',
  chatTemplate: 'default chat template',
  systemPrompt: 'default system prompt',
};
export const mockChatTemplate = {
  addGenerationPrompt: true,
  name: 'chat template name',
  bosToken: '<|test_bos|>',
  eosToken: '<|test_eos|>',
  chatTemplate: 'test chat template',
  systemPrompt: 'test system prompt',
};

export const mockBasicModel: Model = {
  id: 'model-1',
  name: 'Test Model 1',
  author: 'test-author',
  type: 'Test Model Type',
  size: 2 * 10 ** 9,
  params: 2 * 10 ** 9,
  isDownloaded: false,
  downloadUrl: 'https://huggingface.co/test/test-model-1',
  hfUrl: 'https://huggingface.co/test/test-model-1',
  progress: 0,
  filename: 'test-model-1.gguf',
  isLocal: false,
  origin: ModelOrigin.PRESET,
  defaultChatTemplate: mockDefaultChatTemplate,
  chatTemplate: mockChatTemplate,
  defaultCompletionSettings: mockDefaultCompletionParams,
  completionSettings: mockCompletionParams,
  defaultStopWords: mockDefaultCompletionParams.stop,
  stopWords: mockCompletionParams.stop,
};

// Factory function for creating custom models
export const createModel = (overrides = {}) => ({
  ...mockBasicModel,
  ...overrides,
});

export const basicModel = createModel({
  id: 'model-1',
  name: 'basic model',
});

export const downloadedModel = createModel({
  id: 'model-2',
  name: 'downloaded model',
  isDownloaded: true,
});

export const downloadingModel = createModel({
  id: 'model-3',
  name: 'downloading model',
  isDownloaded: false,
  progress: 45,
});

export const largeDiskModel = createModel({
  id: 'model-4',
  name: 'large model',
  isDownloaded: false,
  size: deviceInfo.freeDiskStorage * 1.1, // 10% more than free disk storage
});

export const largeMemoryModel = createModel({
  id: 'model-5',
  name: 'large model for memory',
  isDownloaded: true,
  size: deviceInfo.totalMemory * 1.1, // 10% more than total memory
});

export const localModel = createModel({
  id: 'model-6',
  name: 'local model',
  isLocal: true,
  type: 'Local',
});

export const mockHFModelFiles1: ModelFile[] = [
  {
    rfilename: 'hf-model-name-1.Q4_K_M.gguf',
    size: deviceInfo.freeDiskStorage * 0.5, // can fit in disk
    url: 'https://huggingface.co/owner/hf-model-name-1/resolve/main/hf-model-name-1.Q4_K_M.gguf',
    oid: 'sha256:abc123def456',
    canFitInStorage: true,
  },
  {
    rfilename: 'hf-model-name-1.Q5_K_M.gguf',
    size: deviceInfo.freeDiskStorage * 1.5, // can't fit in disk
    url: 'https://huggingface.co/owner/hf-model-name-1/resolve/main/hf-model-name-1.Q5_K_M.gguf',
    oid: 'sha256:xyz789uvw123',
    canFitInStorage: false,
  },
];

export const mockHFModelFiles2: ModelFile[] = [
  {
    rfilename: 'hf-model-name-2.Q4_K_M.gguf',
    size: deviceInfo.freeDiskStorage * 0.3,
    url: 'https://huggingface.co/owner/hf-model-name-2/resolve/main/hf-model-name-2.Q4_K_M.gguf',
    oid: 'sha256:def456ghi789',
    canFitInStorage: true,
  },
  {
    rfilename: 'hf-model-name-2.Q5_K_M.gguf',
    size: deviceInfo.freeDiskStorage * 0.6,
    url: 'https://huggingface.co/owner/hf-model-name-2/resolve/main/hf-model-name-2.Q5_K_M.gguf',
    oid: 'sha256:jkl012mno345',
    canFitInStorage: true,
  },
];

export const mockGGUFSpecs1: GGUFSpecs = {
  _id: 'agent-1',
  id: 'owner/hf-model-name-1',
  gguf: {
    total: 7000000000, // 7B parameters
    architecture: 'llama',
    context_length: 4096,
    quantize_imatrix_file: 'quantize.dat',
    chat_template: '<s>[INST] {{prompt}} [/INST]',
    bos_token: '<s>',
    eos_token: '</s>',
  },
};

export const mockGGUFSpecs2: GGUFSpecs = {
  ...mockGGUFSpecs1,
  _id: 'agent-2',
  id: 'owner/hf-model-name-2',
  gguf: {
    ...mockGGUFSpecs1.gguf,
    context_length: 8192,
    architecture: 'mistral',
  },
};

export const mockHFModel1: HuggingFaceModel = {
  _id: 'hf-1',
  id: 'owner/hf-model-name-1',
  author: 'owner',
  gated: false,
  inference: 'private',
  lastModified: '2024-03-20',
  likes: 1000,
  trendingScore: 0.95,
  private: false,
  sha: 'abc123',
  downloads: 50000,
  tags: ['llama', 'gguf', 'chat'],
  library_name: 'llama',
  createdAt: '2024-01-01',
  model_id: 'owner/hf-model-name-1',
  url: 'https://huggingface.co/owner/hf-model-name-1',
  siblings: mockHFModelFiles1,
  specs: mockGGUFSpecs1,
};

export const mockHFModel2: HuggingFaceModel = {
  ...mockHFModel1,
  _id: 'hf-2',
  id: 'owner/hf-model-name-2',
  model_id: 'owner/hf-model-name-2',
  downloads: 75000,
  likes: 2000,
  trendingScore: 0.98,
  tags: ['mistral', 'gguf', 'chat'],
  url: 'https://huggingface.co/owner/hf-model-name-2',
  siblings: mockHFModelFiles2,
  specs: mockGGUFSpecs2,
};

export const hfModel1 = createModel({
  id: mockHFModel1.id + '/' + mockHFModel1.siblings[0].rfilename,
  name: 'hf-model-name-1',
  author: 'owner',
  type: 'GGUF',
  isDownloaded: false,
  origin: ModelOrigin.HF,
  hfModel: mockHFModel1,
  hfModelFile: mockHFModel1.siblings[0],
});

export const hfModel2 = createModel({
  id: mockHFModel2.id + '/' + mockHFModel2.siblings[0].rfilename,
  name: 'hf-model-name-2',
  author: 'owner',
  type: 'GGUF',
  isDownloaded: false,
  origin: ModelOrigin.HF,
  hfModel: mockHFModel2,
  hfModelFile: mockHFModel2.siblings[0],
});

export const modelsList: Model[] = [
  basicModel,
  downloadedModel,
  downloadingModel,
  largeDiskModel,
  largeMemoryModel,
  localModel,
  hfModel1,
  hfModel2,
];



================================================
FILE: jest/fixtures/theme.ts
================================================
import type {Theme} from '../../src/utils/types';
import {darkTheme, lightTheme} from '../../src/utils/theme';

export const themeFixtures = {
  lightTheme: lightTheme,
  darkTheme: darkTheme,

  // customization for individual tests
  createTheme: (overrides: {colors?: Record<string, string>}): Theme => ({
    ...themeFixtures.lightTheme,
    ...overrides,
    colors: {
      ...themeFixtures.lightTheme.colors,
      ...(overrides.colors || {}),
    },
  }),
};



================================================
FILE: src/global.d.ts
================================================
declare module 'react-native/Libraries/Blob/Blob' {
  class Blob {
    constructor(parts: Array<Blob | string>);

    get size(): number;
  }

  export default Blob;
}

declare module '*.png' {
  const value: any;
  export default value;
}

declare module '*.svg' {
  import React from 'react';
  import {SvgProps} from 'react-native-svg';
  const content: React.FC<SvgProps>;
  export default content;
}



================================================
FILE: src/api/benchmark.ts
================================================
import axios from 'axios';
import {Platform} from 'react-native';
import {urls} from '../config';
import {
  getAppCheckToken,
  checkConnectivity,
  NetworkError,
  AppCheckError,
  ServerError,
  initializeAppCheck,
} from '../utils';
import {BenchmarkResult, DeviceInfo} from '../utils/types';

type SubmissionData = {
  deviceInfo: DeviceInfo;
  benchmarkResult: BenchmarkResult;
};

/**
 * Submits benchmark data to the server with App Check verification
 */
export async function submitBenchmark(
  deviceInfo: DeviceInfo,
  benchmarkResult: BenchmarkResult,
): Promise<{message: string; id: number}> {
  try {
    // Check network connectivity first
    const isConnected = await checkConnectivity();
    if (!isConnected) {
      throw new NetworkError(
        'No internet connection. Please connect to the internet and try again.',
      );
    }

    const storeName =
      Platform.OS === 'android' ? 'Google Play Store' : 'Apple App Store';
    let errMessage = `App verification failed. Benchmark sharing is only available for official builds from ${storeName}.`;

    // Get App Check token
    let appCheckToken: string | null = null;
    try {
      initializeAppCheck();
      appCheckToken = await getAppCheckToken();
    } catch (error) {
      console.error('App Check error:', error);

      throw new AppCheckError(errMessage);
    }

    if (!appCheckToken) {
      throw new AppCheckError(errMessage);
    }

    // Prepare data and submit to server
    const data: SubmissionData = {
      deviceInfo,
      benchmarkResult,
    };

    try {
      const response = await axios.post(urls.benchmarkSubmit(), data, {
        headers: {
          'X-Firebase-AppCheck': appCheckToken,
          'Content-Type': 'application/json',
        },
        timeout: 10000,
      });
      return response.data;
    } catch (error) {
      if (axios.isAxiosError(error)) {
        if (!error.response) {
          throw new NetworkError(
            'Network error. Please check your internet connection and try again.',
          );
        }

        const status = error.response.status;
        if (status === 401 || status === 403) {
          throw new AppCheckError(
            'App verification failed. This could be due to an unofficial app installation.',
          );
        } else if (status >= 500) {
          throw new ServerError(
            'Our servers are experiencing issues. Please try again later.',
          );
        } else {
          throw new ServerError(
            `Server error: ${error.response.data?.message || 'Unknown error'}`,
          );
        }
      }
      throw error;
    }
  } catch (error) {
    console.error('Error submitting benchmark:', error);

    if (
      error instanceof NetworkError ||
      error instanceof AppCheckError ||
      error instanceof ServerError
    ) {
      throw error;
    }

    throw new Error(
      error instanceof Error
        ? `Failed to submit benchmark: ${error.message}`
        : 'An unexpected error occurred',
    );
  }
}



================================================
FILE: src/api/feedback.ts
================================================
import {Platform} from 'react-native';

import axios from 'axios';
import DeviceInfo from 'react-native-device-info';

import {urls} from '../config';
import {feedbackStore} from '../store';
import {
  getAppCheckToken,
  checkConnectivity,
  NetworkError,
  AppCheckError,
  ServerError,
  initializeAppCheck,
} from '../utils';

type FeedbackData = {
  useCase: string;
  featureRequests: string;
  generalFeedback: string;
  usageFrequency: string;
  appFeedbackId: string;
};

export type ContentReportData = {
  category: string;
  description: string;
  includeModelInfo: boolean;
  modelId?: string;
  modelOid?: string;
  appFeedbackId: string;
  isContentReport: true;
};

/**
 * Submits content report data to the server with App Check verification
 */
export async function submitContentReport(
  reportData: Omit<ContentReportData, 'appFeedbackId'>,
): Promise<{message: string}> {
  try {
    console.log('reportData: ', reportData);

    // Check network connectivity first
    const isConnected = await checkConnectivity();
    if (!isConnected) {
      throw new NetworkError(
        'No internet connection. Please connect to the internet and try again.',
      );
    }

    const storeName =
      Platform.OS === 'android' ? 'Google Play Store' : 'Apple App Store';
    let errMessage = `App verification failed. Content reporting is only available for official builds from ${storeName}.`;

    // Get App Check token
    let appCheckToken: string | null = null;
    try {
      initializeAppCheck();
      appCheckToken = await getAppCheckToken();
    } catch (error) {
      console.error('App Check error:', error);
      throw new AppCheckError(errMessage);
    }

    if (!appCheckToken) {
      throw new AppCheckError(errMessage);
    }

    try {
      const response = await axios.post(
        urls.feedbackSubmit(),
        {
          ...reportData,
          appFeedbackId: feedbackStore.feedbackId,
          appVersion: DeviceInfo.getVersion(),
          appBuild: DeviceInfo.getBuildNumber(),
        },
        {
          headers: {
            'X-Firebase-AppCheck': appCheckToken,
            'Content-Type': 'application/json',
          },
          timeout: 10000,
        },
      );
      return response.data;
    } catch (error) {
      if (axios.isAxiosError(error)) {
        if (!error.response) {
          throw new NetworkError(
            'Network error. Please check your internet connection and try again.',
          );
        }

        const status = error.response.status;
        if (status === 401 || status === 403) {
          throw new AppCheckError(
            'App verification failed. This could be due to an unofficial app installation.',
          );
        } else if (status >= 500) {
          throw new ServerError(
            'Our servers are experiencing issues. Please try again later.',
          );
        } else {
          throw new ServerError(
            `Server error: ${error.response.data?.message || 'Unknown error'}`,
          );
        }
      }
      throw error;
    }
  } catch (error) {
    console.error('Content report submission error:', error);
    throw error;
  }
}

/**
 * Submits feedback data to the server with App Check verification
 */
export async function submitFeedback(
  feedbackData: Omit<FeedbackData, 'appFeedbackId'>,
): Promise<{message: string}> {
  try {
    // Check network connectivity first
    const isConnected = await checkConnectivity();
    if (!isConnected) {
      throw new NetworkError(
        'No internet connection. Please connect to the internet and try again.',
      );
    }

    const storeName =
      Platform.OS === 'android' ? 'Google Play Store' : 'Apple App Store';
    let errMessage = `App verification failed. Feedback submission is only available for official builds from ${storeName}.`;

    // Get App Check token
    let appCheckToken: string | null = null;
    try {
      initializeAppCheck();
      appCheckToken = await getAppCheckToken();
    } catch (error) {
      console.error('App Check error:', error);
      throw new AppCheckError(errMessage);
    }

    if (!appCheckToken) {
      throw new AppCheckError(errMessage);
    }

    try {
      const response = await axios.post(
        urls.feedbackSubmit(),
        {
          ...feedbackData,
          appFeedbackId: feedbackStore.feedbackId,
          appVersion: DeviceInfo.getVersion(),
          appBuild: DeviceInfo.getBuildNumber(),
        },
        {
          headers: {
            'X-Firebase-AppCheck': appCheckToken,
            'Content-Type': 'application/json',
          },
          timeout: 10000,
        },
      );
      return response.data;
    } catch (error) {
      if (axios.isAxiosError(error)) {
        if (!error.response) {
          throw new NetworkError(
            'Network error. Please check your internet connection and try again.',
          );
        }

        const status = error.response.status;
        if (status === 401 || status === 403) {
          throw new AppCheckError(
            'App verification failed. This could be due to an unofficial app installation.',
          );
        } else if (status >= 500) {
          throw new ServerError(
            'Our servers are experiencing issues. Please try again later.',
          );
        } else {
          throw new ServerError(
            `Server error: ${error.response.data?.message || 'Unknown error'}`,
          );
        }
      }
      throw error;
    }
  } catch (error) {
    console.error('Error submitting feedback:', error);

    if (
      error instanceof NetworkError ||
      error instanceof AppCheckError ||
      error instanceof ServerError
    ) {
      throw error;
    }

    throw new Error(
      error instanceof Error
        ? `Failed to submit feedback: ${error.message}`
        : 'An unexpected error occurred',
    );
  }
}



================================================
FILE: src/api/hf.ts
================================================
import axios from 'axios';

import {urls} from '../config';

import {
  GGUFSpecs,
  HuggingFaceModel,
  HuggingFaceModelsResponse,
  ModelFileDetails,
} from '../utils/types';

/**
 * Get information from all models in the Hub.
 * The response is paginated, use the Link header to get the next pages.
 *
 * search: Filter based on substrings for repos and their usernames, such as resnet or microsoft
 * author: Filter models by an author or organization, such as huggingface or microsoft
 * filter: Filter based on tags, such as text-classification or spacy.
 * sort: Property to use when sorting, such as downloads or author.
 * direction: Direction in which to sort, such as -1 for descending, and anything else for ascending.
 * limit: Limit the number of models fetched.
 * full: Whether to fetch most model data, such as all tags, the files, etc.
 * config: Whether to also fetch the repo config.
 *
 * @see https://huggingface.co/docs/api-reference/api-endpoints#get-models
 */
export async function fetchModels({
  search,
  author,
  filter,
  sort,
  direction,
  limit,
  full,
  config,
  nextPageUrl,
  authToken,
}: {
  search?: string;
  author?: string;
  filter?: string;
  sort?: string;
  direction?: string;
  limit?: number;
  full?: boolean;
  config?: boolean;
  nextPageUrl?: string;
  authToken?: string | null;
}): Promise<HuggingFaceModelsResponse> {
  try {
    const headers: Record<string, string> = {};

    if (authToken) {
      headers.Authorization = `Bearer ${authToken}`;
    }

    const response = await axios.get(nextPageUrl || urls.modelsList(), {
      params: {
        search,
        author,
        filter,
        sort,
        direction,
        limit,
        full,
        config,
      },
      headers,
    });

    const linkHeader = response.headers.link;
    let nextLink = null;

    if (linkHeader) {
      const match = linkHeader.match(/<([^>]*)>/);
      if (match) {
        nextLink = match[1];
      }
    }

    return {
      models: response.data as HuggingFaceModel[],
      nextLink,
    };
  } catch (error) {
    console.error('Error fetching models:', error);
    throw error;
  }
}

/**
 * Fetches the details of the model's files. Mainly the size is used.
 * @param modelId - The ID of the model.
 * @param authToken - Optional authentication token for accessing private models
 * @returns An array of ModelFileDetails.
 */
export const fetchModelFilesDetails = async (
  modelId: string,
  authToken?: string | null,
): Promise<ModelFileDetails[]> => {
  const url = `${urls.modelTree(modelId)}?recursive=true`;

  try {
    const headers: Record<string, string> = {};
    if (authToken) {
      headers.Authorization = `Bearer ${authToken}`;
    }

    const response = await fetch(url, {headers});

    if (!response.ok) {
      throw new Error(`Error fetching model files: ${response.statusText}`);
    }

    const data: ModelFileDetails[] = await response.json();
    return data;
  } catch (error) {
    console.error('Failed to fetch model files:', error);
    throw error;
  }
};

/**
 * Fetches the specs of the GGUF for a specific model.
 * @param modelId - The ID of the model.
 * @param authToken - Optional authentication token for accessing private models
 * @returns The GGUF specs.
 */
export const fetchGGUFSpecs = async (
  modelId: string,
  authToken?: string | null,
): Promise<GGUFSpecs> => {
  const url = `${urls.modelSpecs(modelId)}?expand[]=gguf`;

  try {
    const headers: Record<string, string> = {};
    if (authToken) {
      headers.Authorization = `Bearer ${authToken}`;
    }

    const response = await fetch(url, {headers});

    if (!response.ok) {
      throw new Error(`Error fetching GGUF specs: ${response.statusText}`);
    }

    const data: GGUFSpecs = await response.json();
    return data;
  } catch (error) {
    console.error('Failed to fetch GGUF specs:', error);
    throw error;
  }
};



================================================
FILE: src/api/__tests__/benchmark.test.ts
================================================
import axios from 'axios';
import {submitBenchmark} from '../benchmark';
import * as utils from '../../utils/fb';
import * as networkUtils from '../../utils';
import {urls} from '../../config';
import {DeviceInfo, BenchmarkResult} from '../../utils/types';

jest.mock('axios');
jest.mock('../../utils/fb');
jest.mock('../../utils', () => {
  const originalModule = jest.requireActual('../../utils');
  return {
    ...originalModule,
    checkConnectivity: jest.fn(),
    initializeAppCheck: jest.fn(),
    NetworkError: class NetworkError extends Error {
      constructor(message) {
        super(message);
        this.name = 'NetworkError';
      }
    },
    AppCheckError: class AppCheckError extends Error {
      constructor(message) {
        super(message);
        this.name = 'AppCheckError';
      }
    },
    ServerError: class ServerError extends Error {
      constructor(message) {
        super(message);
        this.name = 'ServerError';
      }
    },
  };
});

const mockedAxios = axios as jest.Mocked<typeof axios>;
const mockedFb = utils as jest.Mocked<typeof utils>;
const mockedNetworkUtils = networkUtils as jest.Mocked<typeof networkUtils>;

describe('submitBenchmark', () => {
  const mockDeviceInfo: DeviceInfo = {
    model: 'Test Phone',
    systemName: 'iOS',
    systemVersion: '16.0',
    brand: 'Apple',
    cpuArch: ['arm64'],
    isEmulator: false,
    version: '16.0',
    buildNumber: '20A362',
    device: 'iPhone14,2',
    deviceId: 'test-device-id',
    totalMemory: 6144,
    chipset: 'Apple A15',
    cpu: 'hexa-core',
    cpuDetails: {
      cores: 6,
      processors: [
        {
          processor: '0',
          'model name': 'Apple A15',
          'cpu MHz': '3200',
          vendor_id: 'Apple',
        },
      ],
      socModel: 'Apple A15',
      features: ['fp16', 'neon'],
      hasFp16: true,
      hasDotProd: true,
      hasSve: false,
      hasI8mm: true,
    },
  };

  const mockBenchmarkResult: BenchmarkResult = {
    config: {
      pp: 1,
      tg: 1,
      pl: 512,
      nr: 3,
      label: 'Test Config',
    },
    modelDesc: 'Test Model',
    modelSize: 1000000,
    modelNParams: 7000000000,
    ppAvg: 20.5,
    ppStd: 1.2,
    tgAvg: 30.5,
    tgStd: 2.1,
    timestamp: new Date().toISOString(),
    modelId: 'test-model-id',
    modelName: 'Test Model',
    filename: 'test-model.gguf',
    uuid: 'test-uuid',
  };

  const mockAppCheckToken = 'mock-app-check-token';
  const mockResponse = {
    data: {
      message: 'Success',
      id: 123,
    },
  };

  beforeEach(() => {
    jest.clearAllMocks();

    mockedFb.getAppCheckToken.mockResolvedValue(mockAppCheckToken);
    mockedNetworkUtils.checkConnectivity.mockResolvedValue(true);
    mockedAxios.post.mockResolvedValue(mockResponse);
    mockedAxios.isAxiosError.mockReturnValue(true);
  });

  it('should successfully submit benchmark data', async () => {
    const result = await submitBenchmark(mockDeviceInfo, mockBenchmarkResult);

    // Verify AppCheck initialization and token retrieval
    expect(mockedFb.getAppCheckToken).toHaveBeenCalled();

    // Verify API call
    expect(mockedAxios.post).toHaveBeenCalledWith(
      urls.benchmarkSubmit(),
      {
        deviceInfo: mockDeviceInfo,
        benchmarkResult: mockBenchmarkResult,
      },
      {
        headers: {
          'X-Firebase-AppCheck': mockAppCheckToken,
          'Content-Type': 'application/json',
        },
        timeout: 10000,
      },
    );

    // Verify response
    expect(result).toEqual({
      message: 'Success',
      id: 123,
    });
  });

  it('should throw NetworkError when there is no internet connection', async () => {
    mockedNetworkUtils.checkConnectivity.mockResolvedValue(false);

    await expect(
      submitBenchmark(mockDeviceInfo, mockBenchmarkResult),
    ).rejects.toThrowError(networkUtils.NetworkError);

    expect(mockedAxios.post).not.toHaveBeenCalled();
  });

  it('should throw AppCheckError when AppCheck token is not available', async () => {
    mockedFb.getAppCheckToken.mockResolvedValue('');

    await expect(
      submitBenchmark(mockDeviceInfo, mockBenchmarkResult),
    ).rejects.toThrowError(networkUtils.AppCheckError);

    expect(mockedAxios.post).not.toHaveBeenCalled();
  });

  it('should throw NetworkError on axios network error', async () => {
    const error = {
      isAxiosError: true,
      response: undefined,
    };
    mockedAxios.post.mockRejectedValue(error);

    await expect(
      submitBenchmark(mockDeviceInfo, mockBenchmarkResult),
    ).rejects.toThrowError(networkUtils.NetworkError);
  });

  it('should throw AppCheckError on 401/403 responses', async () => {
    const unauthorizedError = {
      isAxiosError: true,
      response: {
        status: 401,
        data: {},
      },
    };
    mockedAxios.post.mockRejectedValue(unauthorizedError);

    await expect(
      submitBenchmark(mockDeviceInfo, mockBenchmarkResult),
    ).rejects.toThrowError(networkUtils.AppCheckError);

    // Test 403 error
    const forbiddenError = {
      isAxiosError: true,
      response: {
        status: 403,
        data: {},
      },
    };
    mockedAxios.post.mockRejectedValue(forbiddenError);

    await expect(
      submitBenchmark(mockDeviceInfo, mockBenchmarkResult),
    ).rejects.toThrowError(networkUtils.AppCheckError);
  });

  it('should throw ServerError on 500+ responses', async () => {
    const serverError = {
      isAxiosError: true,
      response: {
        status: 500,
        data: {
          message: 'Internal Server Error',
        },
      },
    };
    mockedAxios.post.mockRejectedValue(serverError);

    await expect(
      submitBenchmark(mockDeviceInfo, mockBenchmarkResult),
    ).rejects.toThrowError(networkUtils.ServerError);
  });

  it('should throw ServerError with error message from server if available', async () => {
    const serverError = {
      isAxiosError: true,
      response: {
        status: 400,
        data: {
          message: 'Invalid benchmark data',
        },
      },
    };
    mockedAxios.post.mockRejectedValue(serverError);

    await expect(
      submitBenchmark(mockDeviceInfo, mockBenchmarkResult),
    ).rejects.toThrowError(networkUtils.ServerError);
  });

  it('should handle AppCheck initialization errors', async () => {
    mockedNetworkUtils.initializeAppCheck.mockImplementation(() => {
      throw new Error('AppCheck init error');
    });

    await expect(
      submitBenchmark(mockDeviceInfo, mockBenchmarkResult),
    ).rejects.toThrowError(networkUtils.AppCheckError);
  });
});



================================================
FILE: src/api/__tests__/feedback.test.ts
================================================
import axios from 'axios';
import {Platform} from 'react-native';
import DeviceInfo from 'react-native-device-info';
import {submitFeedback} from '../feedback';
import * as utils from '../../utils';
import {urls} from '../../config';

// Mock dependencies
jest.mock('axios');
jest.mock('react-native-device-info');
jest.mock('../../utils', () => {
  const originalModule = jest.requireActual('../../utils');
  return {
    ...originalModule,
    checkConnectivity: jest.fn(),
    getAppCheckToken: jest.fn(),
    initializeAppCheck: jest.fn(),
    NetworkError: class NetworkError extends Error {
      constructor(message) {
        super(message);
        this.name = 'NetworkError';
      }
    },
    AppCheckError: class AppCheckError extends Error {
      constructor(message) {
        super(message);
        this.name = 'AppCheckError';
      }
    },
    ServerError: class ServerError extends Error {
      constructor(message) {
        super(message);
        this.name = 'ServerError';
      }
    },
  };
});
jest.mock('../../store', () => ({
  feedbackStore: {
    feedbackId: 'mock-feedback-id',
  },
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;
const mockedUtils = utils as jest.Mocked<typeof utils>;
const mockedDeviceInfo = DeviceInfo as jest.Mocked<typeof DeviceInfo>;

describe('submitFeedback', () => {
  const mockFeedbackData = {
    useCase: 'Test use case',
    featureRequests: 'Test feature request',
    generalFeedback: 'Test feedback',
    usageFrequency: 'daily',
  };

  const mockAppCheckToken = 'mock-app-check-token';
  const mockResponse = {
    data: {
      message: 'Feedback submitted successfully',
    },
  };

  beforeEach(() => {
    jest.clearAllMocks();

    // Default mocks for success case
    Platform.OS = 'ios';
    mockedUtils.checkConnectivity.mockResolvedValue(true);
    mockedUtils.getAppCheckToken.mockResolvedValue(mockAppCheckToken);
    mockedDeviceInfo.getVersion.mockReturnValue('1.0.0');
    mockedDeviceInfo.getBuildNumber.mockReturnValue('100');
    mockedAxios.post.mockResolvedValue(mockResponse);
    mockedAxios.isAxiosError.mockReturnValue(true);
  });

  it('should successfully submit feedback', async () => {
    const result = await submitFeedback(mockFeedbackData);

    // Verify connectivity check
    expect(mockedUtils.checkConnectivity).toHaveBeenCalled();

    // Verify AppCheck initialization and token retrieval
    expect(mockedUtils.initializeAppCheck).toHaveBeenCalled();
    expect(mockedUtils.getAppCheckToken).toHaveBeenCalled();

    // Verify API call
    expect(mockedAxios.post).toHaveBeenCalledWith(
      urls.feedbackSubmit(),
      {
        ...mockFeedbackData,
        appFeedbackId: 'mock-feedback-id',
        appVersion: '1.0.0',
        appBuild: '100',
      },
      {
        headers: {
          'X-Firebase-AppCheck': mockAppCheckToken,
          'Content-Type': 'application/json',
        },
        timeout: 10000,
      },
    );

    // Verify response
    expect(result).toEqual({
      message: 'Feedback submitted successfully',
    });
  });

  it('should throw NetworkError when there is no internet connection', async () => {
    mockedUtils.checkConnectivity.mockResolvedValue(false);

    await expect(submitFeedback(mockFeedbackData)).rejects.toThrowError(
      utils.NetworkError,
    );

    expect(mockedAxios.post).not.toHaveBeenCalled();
  });

  it('should throw AppCheckError when AppCheck token is not available', async () => {
    mockedUtils.getAppCheckToken.mockResolvedValue('');

    await expect(submitFeedback(mockFeedbackData)).rejects.toThrowError(
      utils.AppCheckError,
    );

    expect(mockedAxios.post).not.toHaveBeenCalled();
  });

  it('should throw NetworkError on axios network error', async () => {
    const error = {
      isAxiosError: true,
      response: undefined,
    };
    mockedAxios.post.mockRejectedValue(error);

    await expect(submitFeedback(mockFeedbackData)).rejects.toThrowError(
      utils.NetworkError,
    );
  });

  it('should throw AppCheckError on 401/403 responses', async () => {
    const unauthorizedError = {
      isAxiosError: true,
      response: {
        status: 401,
        data: {},
      },
    };
    mockedAxios.post.mockRejectedValue(unauthorizedError);

    await expect(submitFeedback(mockFeedbackData)).rejects.toThrowError(
      utils.AppCheckError,
    );

    // Test 403 error
    const forbiddenError = {
      isAxiosError: true,
      response: {
        status: 403,
        data: {},
      },
    };
    mockedAxios.post.mockRejectedValue(forbiddenError);

    await expect(submitFeedback(mockFeedbackData)).rejects.toThrowError(
      utils.AppCheckError,
    );
  });

  it('should throw ServerError on 500+ responses', async () => {
    const serverError = {
      isAxiosError: true,
      response: {
        status: 500,
        data: {
          message: 'Internal Server Error',
        },
      },
    };
    mockedAxios.post.mockRejectedValue(serverError);

    await expect(submitFeedback(mockFeedbackData)).rejects.toThrowError(
      utils.ServerError,
    );
  });

  it('should throw ServerError with error message from server if available', async () => {
    const serverError = {
      isAxiosError: true,
      response: {
        status: 400,
        data: {
          message: 'Invalid feedback data',
        },
      },
    };
    mockedAxios.post.mockRejectedValue(serverError);

    await expect(submitFeedback(mockFeedbackData)).rejects.toThrowError(
      utils.ServerError,
    );
  });

  it('should handle AppCheck initialization errors', async () => {
    mockedUtils.initializeAppCheck.mockImplementation(() => {
      throw new Error('AppCheck init error');
    });

    await expect(submitFeedback(mockFeedbackData)).rejects.toThrowError(
      utils.AppCheckError,
    );
  });

  it('should propagate unknown errors', async () => {
    const unknownError = new Error('Unknown error');
    mockedAxios.post.mockRejectedValue(unknownError);
    mockedAxios.isAxiosError.mockReturnValue(false);

    await expect(submitFeedback(mockFeedbackData)).rejects.toThrow(
      'App verification failed. Feedback submission is only available for official builds from Apple App Store.',
    );
  });

  it('should handle different platform messages', async () => {
    Platform.OS = 'android';
    mockedUtils.getAppCheckToken.mockResolvedValue('');

    await expect(submitFeedback(mockFeedbackData)).rejects.toThrowError(
      utils.AppCheckError,
    );
  });
});



================================================
FILE: src/api/__tests__/hf.test.ts
================================================
import axios from 'axios';
import {fetchGGUFSpecs, fetchModelFilesDetails, fetchModels} from '../hf';

jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

describe('fetchModels', () => {
  it('should fetch models with basic parameters', async () => {
    const mockResponse = {
      data: [{id: 'model1'}],
      headers: {link: '<next-page-link>'},
    };
    mockedAxios.get.mockResolvedValueOnce(mockResponse);

    const result = await fetchModels({search: 'test'});

    expect(mockedAxios.get).toHaveBeenCalledWith(
      expect.any(String),
      expect.objectContaining({
        params: expect.objectContaining({search: 'test'}),
      }),
    );
    expect(result).toEqual({
      models: [{id: 'model1'}],
      nextLink: 'next-page-link',
    });
  });

  it('should handle missing pagination link', async () => {
    const mockResponse = {
      data: [{id: 'model1'}],
      headers: {},
    };
    mockedAxios.get.mockResolvedValueOnce(mockResponse);

    const result = await fetchModels({});
    expect(result.nextLink).toBeNull();
  });
});

describe('API error handling', () => {
  it('should handle network errors in fetchModels', async () => {
    const error = new Error('Network error');
    mockedAxios.get.mockRejectedValueOnce(error);

    await expect(fetchModels({})).rejects.toThrow('Network error');
  });

  it('should handle non-ok responses in fetchModelFilesDetails', async () => {
    global.fetch = jest.fn().mockResolvedValueOnce({
      ok: false,
      statusText: 'Not Found',
    });

    await expect(fetchModelFilesDetails('model1')).rejects.toThrow(
      'Error fetching model files: Not Found',
    );
  });
});

describe('fetchGGUFSpecs', () => {
  it('should parse GGUF specs correctly', async () => {
    const mockSpecs = {
      gguf: {
        params: 7,
        type: 'f16',
      },
    };
    global.fetch = jest.fn().mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve(mockSpecs),
    });

    const result = await fetchGGUFSpecs('model1');
    expect(result).toEqual(mockSpecs);
  });
});



================================================
FILE: src/assets/icons/index.ts
================================================
export {default as AlertIcon} from './alert.svg';
export {default as AtomIcon} from './atom.svg';
export {default as BenchmarkIcon} from './benchmark.svg';
export {default as CameraIcon} from './camera.svg';
export {default as ChatIcon} from './chat.svg';
export {default as CheckCircleIcon} from './check-circle.svg';
export {default as ChevronDownIcon} from './chevron-down.svg';
export {default as ChevronRightIcon} from './chevron-right.svg';
export {default as ChevronUpIcon} from './chevron-up.svg';
export {default as ClockFastForwardIcon} from './clock-fast-forward.svg';
export {default as CloseIcon} from './close.svg';
export {default as CopyIcon} from './copy.svg';
export {default as CpuChipIcon} from './cpu-chip.svg';
export {default as DownloadIcon} from './download.svg';
export {default as DotsVerticalIcon} from './dots-vertical.svg';
export {default as DuplicateIcon} from './duplicate.svg';
export {default as EditBoxIcon} from './edit-box.svg';
export {default as EditIcon} from './edit.svg';
export {default as EyeIcon} from './eye.svg';
export {default as EyeOffIcon} from './eye-off.svg';
export {default as GithubIcon} from './github-outline.svg';
export {default as GlobeIcon} from './globe.svg';
export {default as GridIcon} from './grid.svg';
export {default as HeartIcon} from './heart.svg';
export {default as MenuIcon} from './menu.svg';
export {default as ModelIcon} from './model.svg';
export {default as MoonIcon} from './moon.svg';
export {default as PalIcon} from './pal.svg';
export {default as PencilLineIcon} from './pencil-line.svg';
export {default as PlaceholderIcon} from './placeholder.svg';
export {default as PlusIcon} from './plus.svg';
export {default as RefreshIcon} from './refresh.svg';
export {default as ReverseLeftIcon} from './reverse-left.svg';
export {default as SendIcon} from './send.svg';
export {default as SettingsIcon} from './settings.svg';
export {default as StopIcon} from './stop.svg';
export {default as ShareIcon} from './share.svg';
export {default as TrashIcon} from './trash.svg';
export {default as UploadIcon} from './upload.svg';
export {default as VideoRecorderIcon} from './video-recorder.svg';
export {default as AppInfoIcon} from './app-info.svg';



================================================
FILE: src/components/index.ts
================================================
export * from './AttachmentButton';
export * from './Avatar';
export * from './BottomSheetSearchbar';
export * from './Bubble';
export * from './ChatGenerationSettingsSheet';
export * from './ChatInput';
export * from './ChatView';
export * from './ChatHeader';
export * from './ChatPalModelPickerSheet';
export * from './ChatEmptyPlaceholder';
export * from './ContentReportSheet';
export * from './Checkbox';
export * from './CircularActivityIndicator';
export * from './CompletionSettings';
export * from './DatabaseMigration';
export * from './Dialog';
export * from './Divider';
export * from './DownloadErrorDialog';
export * from './EmbeddedVideoView';
export * from './ErrorSnackbar';
export * from './FileMessage';
export * from './HeaderRight';
export * from './HeaderLeft';
export * from './HFTokenSheet';
export * from './ImageMessage';
export * from './KeyboardAccessoryView';
export * from './LoadingBubble';
export * from './MarkdownView';
export * from './Menu';
export * from './Message';
export * from './ModelsHeaderRight';
export * from './ModelsResetDialog';
export * from './ModelSettingsSheet';
export * from './ModelTypeTag';
export * from './ProjectionModelSelector';
export * from './RenameModal';
export * from './ResponseBubble';
export * from './Searchbar';
export * from './SendButton';
export * from './SidebarContent';
export * from './Sheet';
export * from './SkillsDisplay';
export * from './StopButton';
export * from './StatusIcon';
export * from './TextDivider';
export * from './TextInput';
export * from './TextMessage';
export * from './UsageStats';
export * from './VideoPalEmptyPlaceholder';
export * from './VisionDownloadSheet';
export * from './VisionControlSheet';
export * from './PalHeaderRight';



================================================
FILE: src/components/AttachmentButton/AttachmentButton.tsx
================================================
import * as React from 'react';
import {
  GestureResponderEvent,
  Image,
  StyleSheet,
  TouchableOpacity,
  TouchableOpacityProps,
} from 'react-native';

import {useTheme} from '../../hooks';

import {L10nContext} from '../../utils';

export interface AttachmentButtonAdditionalProps {
  touchableOpacityProps?: TouchableOpacityProps;
}

export interface AttachmentButtonProps extends AttachmentButtonAdditionalProps {
  /** Callback for attachment button tap event */
  onPress?: () => void;
}

export const AttachmentButton = ({
  onPress,
  touchableOpacityProps,
}: AttachmentButtonProps) => {
  const l10n = React.useContext(L10nContext);
  const theme = useTheme();

  const handlePress = (event: GestureResponderEvent) => {
    onPress?.();
    touchableOpacityProps?.onPress?.(event);
  };

  return (
    <TouchableOpacity
      accessibilityLabel={
        l10n.components.attachmentButton.attachmentButtonAccessibilityLabel
      }
      accessibilityRole="button"
      testID="attachment-button"
      {...touchableOpacityProps}
      onPress={handlePress}>
      {theme.icons?.attachmentButtonIcon?.() ?? (
        <Image
          source={require('../../assets/icon-attachment.png')}
          style={[styles.image, {tintColor: theme.colors.onSurface}]}
        />
      )}
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  image: {
    marginRight: 16,
  },
});



================================================
FILE: src/components/AttachmentButton/index.ts
================================================
export * from './AttachmentButton';



================================================
FILE: src/components/Avatar/Avatar.tsx
================================================
import * as React from 'react';
import {Image, StyleSheet, Text, View} from 'react-native';

import {MessageType, Theme} from '../../utils/types';
import {getUserAvatarNameColor, getUserInitials} from '../../utils';

// TDOD: Add model name and the user's name?
export const Avatar = React.memo(
  ({
    author,
    currentUserIsAuthor,
    showAvatar,
    showUserAvatars,
    theme,
  }: {
    author: MessageType.Any['author'];
    currentUserIsAuthor: boolean;
    showAvatar: boolean;
    showUserAvatars?: boolean;
    theme: Theme;
  }) => {
    const renderAvatar = () => {
      const color = getUserAvatarNameColor(
        author,
        theme.colors.userAvatarNameColors,
      );
      const initials = getUserInitials(author);

      if (author.imageUrl) {
        return (
          <Image
            accessibilityRole="image"
            testID="avatar-image"
            resizeMode="cover"
            source={{uri: author.imageUrl}}
            style={[styles.image]}
          />
        );
      }

      return (
        <View style={[styles.avatarBackground, {backgroundColor: color}]}>
          <Text>{initials}</Text>
        </View>
      );
    };

    return !currentUserIsAuthor && showUserAvatars ? (
      <View testID="AvatarContainer">
        {showAvatar ? renderAvatar() : <View style={styles.placeholder} />}
      </View>
    ) : null;
  },
);

const styles = StyleSheet.create({
  avatarBackground: {
    alignItems: 'center',
    borderRadius: 16,
    height: 32,
    justifyContent: 'center',
    marginRight: 8,
    width: 32,
  },
  image: {
    alignItems: 'center',
    borderRadius: 16,
    height: 32,
    justifyContent: 'center',
    marginRight: 8,
    width: 32,
  },
  placeholder: {
    width: 40,
  },
});



================================================
FILE: src/components/Avatar/index.ts
================================================
export * from './Avatar';



================================================
FILE: src/components/Avatar/__tests__/Avatar.test.tsx
================================================
import {render} from '@testing-library/react-native';
import * as React from 'react';

import {user} from '../../../../jest/fixtures';
import {Avatar} from '../Avatar';
import {lightTheme} from '../../../utils/theme';

describe('avatar', () => {
  it(`should render container with a placeholder`, () => {
    expect.assertions(1);
    const {getByTestId} = render(
      <Avatar
        author={user}
        currentUserIsAuthor={false}
        showAvatar={false}
        showUserAvatars
        theme={lightTheme}
      />,
    );
    expect(getByTestId('AvatarContainer')).toBeDefined();
  });

  it('should render background with a first letter', () => {
    expect.assertions(1);
    const authorWithName = {...user, firstName: 'John'};
    const {getByText} = render(
      <Avatar
        author={authorWithName}
        currentUserIsAuthor={false}
        showAvatar
        showUserAvatars
        theme={lightTheme}
      />,
    );
    expect(getByText(authorWithName.firstName[0])).toBeDefined();
  });

  it('should render image background', () => {
    expect.assertions(2);
    const imageUrl = 'https://avatars.githubusercontent.com/u/14123304?v=4';
    const {getByTestId} = render(
      <Avatar
        author={{
          ...user,
          imageUrl,
        }}
        currentUserIsAuthor={false}
        showAvatar
        showUserAvatars
        theme={lightTheme}
      />,
    );
    const image = getByTestId('avatar-image');
    expect(image).toBeDefined();
    expect(image.props.source).toHaveProperty('uri', imageUrl);
  });
});



================================================
FILE: src/components/BottomSheetSearchbar/BottomSheetSearchbar.tsx
================================================
import React, {memo, useCallback, forwardRef, useEffect} from 'react';
import type {NativeSyntheticEvent, TextInputFocusEventData} from 'react-native';

import {Searchbar} from 'react-native-paper';
import type {SearchbarProps} from 'react-native-paper';
import {useBottomSheetInternal} from '@gorhom/bottom-sheet';

interface BottomSheetSearchbarProps extends SearchbarProps {}

const BottomSheetSearchbarComponent = forwardRef<
  React.ComponentRef<typeof Searchbar>,
  BottomSheetSearchbarProps
>(({onFocus, onBlur, ...rest}, ref) => {
  //#region hooks
  const {shouldHandleKeyboardEvents} = useBottomSheetInternal();
  //#endregion

  //#region callbacks
  const handleOnFocus = useCallback(
    (args: NativeSyntheticEvent<TextInputFocusEventData>) => {
      shouldHandleKeyboardEvents.value = true;
      if (onFocus) {
        onFocus(args);
      }
    },
    [onFocus, shouldHandleKeyboardEvents],
  );

  const handleOnBlur = useCallback(
    (args: NativeSyntheticEvent<TextInputFocusEventData>) => {
      shouldHandleKeyboardEvents.value = false;
      if (onBlur) {
        onBlur(args);
      }
    },
    [onBlur, shouldHandleKeyboardEvents],
  );
  //#endregion

  //#region effects
  useEffect(() => {
    return () => {
      // Reset the flag on unmount
      shouldHandleKeyboardEvents.value = false;
    };
  }, [shouldHandleKeyboardEvents]);
  //#endregion

  return (
    <Searchbar
      ref={ref}
      onFocus={handleOnFocus}
      onBlur={handleOnBlur}
      {...rest}
    />
  );
});

const BottomSheetSearchbar = memo(BottomSheetSearchbarComponent);
BottomSheetSearchbar.displayName = 'BottomSheetSearchbar';

export {BottomSheetSearchbar};
export type {BottomSheetSearchbarProps};



================================================
FILE: src/components/BottomSheetSearchbar/index.ts
================================================
export * from './BottomSheetSearchbar';



================================================
FILE: src/components/BottomSheetSearchbar/__tests__/BottomSheetSearchbar.test.tsx
================================================
import React from 'react';
import {render, fireEvent} from '@testing-library/react-native';
import {BottomSheetSearchbar} from '../BottomSheetSearchbar';
import {useBottomSheetInternal} from '@gorhom/bottom-sheet';

jest.mock('@gorhom/bottom-sheet', () => ({
  useBottomSheetInternal: jest.fn(),
}));

describe('BottomSheetSearchbar', () => {
  const mockShouldHandleKeyboardEvents = {value: false};

  beforeEach(() => {
    (useBottomSheetInternal as jest.Mock).mockReturnValue({
      shouldHandleKeyboardEvents: mockShouldHandleKeyboardEvents,
    });
  });

  it('should handle focus event correctly', () => {
    const onFocus = jest.fn();
    const {getByTestId} = render(
      <BottomSheetSearchbar
        testID="searchbar"
        onFocus={onFocus}
        value="test"
      />,
    );

    fireEvent(getByTestId('searchbar'), 'focus');

    expect(mockShouldHandleKeyboardEvents.value).toBe(true);
    expect(onFocus).toHaveBeenCalled();
  });

  it('should handle blur event correctly', () => {
    const onBlur = jest.fn();
    const {getByTestId} = render(
      <BottomSheetSearchbar testID="searchbar" onBlur={onBlur} value="test" />,
    );

    fireEvent(getByTestId('searchbar'), 'blur');

    expect(mockShouldHandleKeyboardEvents.value).toBe(false);
    expect(onBlur).toHaveBeenCalled();
  });

  it('should reset keyboard events flag on unmount', () => {
    const {unmount} = render(<BottomSheetSearchbar value="test" />);

    unmount();

    expect(mockShouldHandleKeyboardEvents.value).toBe(false);
  });

  it('should forward props to Searchbar component', () => {
    const placeholder = 'Search...';
    const value = 'test';
    const onChangeText = jest.fn();

    const {getByPlaceholderText} = render(
      <BottomSheetSearchbar
        placeholder={placeholder}
        value={value}
        onChangeText={onChangeText}
      />,
    );

    const searchbar = getByPlaceholderText(placeholder);
    expect(searchbar.props.value).toBe(value);

    fireEvent.changeText(searchbar, 'new value');
    expect(onChangeText).toHaveBeenCalledWith('new value');
  });
});



================================================
FILE: src/components/Bubble/Bubble.tsx
================================================
import type {ReactNode} from 'react';
import React, {useContext} from 'react';
import {View, TouchableOpacity, Animated} from 'react-native';

import {Text} from 'react-native-paper';
import Clipboard from '@react-native-clipboard/clipboard';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import ReactNativeHapticFeedback from 'react-native-haptic-feedback';

import {useTheme} from '../../hooks';

import {styles} from './styles';

import {UserContext, L10nContext} from '../../utils';
import {MessageType} from '../../utils/types';

const hapticOptions = {
  enableVibrateFallback: true,
  ignoreAndroidSystemSettings: false,
};

export const Bubble = ({
  child,
  message,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  nextMessageInGroup,
  scale = new Animated.Value(1),
}: {
  child: ReactNode;
  message: MessageType.Any;
  nextMessageInGroup: boolean;
  scale?: Animated.Value;
}) => {
  const theme = useTheme();
  const user = useContext(UserContext);
  const l10n = useContext(L10nContext);
  const currentUserIsAuthor = user?.id === message.author.id;
  const {copyable, timings} = message.metadata || {};

  const timingsString = l10n.components.bubble.timingsString
    .replace('{{predictedMs}}', timings?.predicted_per_token_ms?.toFixed())
    .replace(
      '{{predictedPerSecond}}',
      timings?.predicted_per_second?.toFixed(2),
    );

  // Add time to first token if available
  const timeToFirstTokenString =
    timings?.time_to_first_token_ms !== undefined &&
    timings?.time_to_first_token_ms !== null
      ? `, ${timings.time_to_first_token_ms}ms TTFT`
      : '';

  const fullTimingsString = timingsString + timeToFirstTokenString;

  const {contentContainer, dateHeaderContainer, dateHeader, iconContainer} =
    styles({
      currentUserIsAuthor,
      message,
      roundBorder: true,
      theme,
    });

  const copyToClipboard = () => {
    if (message.type === 'text') {
      ReactNativeHapticFeedback.trigger('impactLight', hapticOptions);
      Clipboard.setString(message.text.trim());
    }
  };

  return (
    <Animated.View
      style={[
        contentContainer,
        {
          transform: [{scale}],
        },
      ]}>
      {child}
      {timings && (
        <View style={dateHeaderContainer}>
          {copyable && (
            <TouchableOpacity onPress={copyToClipboard}>
              <Icon name="content-copy" style={iconContainer} />
            </TouchableOpacity>
          )}
          {timings && <Text style={dateHeader}>{fullTimingsString}</Text>}
        </View>
      )}
    </Animated.View>
  );
};



================================================
FILE: src/components/Bubble/index.ts
================================================
export * from './Bubble';



================================================
FILE: src/components/Bubble/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {MessageType, Theme} from '../../utils/types';

export const styles = ({
  currentUserIsAuthor,
  message,
  roundBorder,
  theme,
}: {
  currentUserIsAuthor: boolean;
  message: MessageType.Any;
  roundBorder: boolean;
  theme: Theme;
}) => {
  return StyleSheet.create({
    contentContainer: {
      backgroundColor:
        !currentUserIsAuthor || message.type === 'image'
          ? 'transparent' //theme.colors.secondary
          : theme.colors.authorBubbleBackground,
      borderBottomLeftRadius:
        currentUserIsAuthor || roundBorder
          ? theme.borders.messageBorderRadius
          : 0,
      borderBottomRightRadius: currentUserIsAuthor
        ? roundBorder
          ? theme.borders.messageBorderRadius
          : 0
        : theme.borders.messageBorderRadius,
      borderColor: 'transparent',
      borderRadius: theme.borders.messageBorderRadius,
      overflow: 'hidden',
    },
    dateHeader0: {
      alignItems: 'center',
      justifyContent: 'center',
      marginBottom: 32,
      marginTop: 16,
    },
    dateHeaderContainer: {
      textAlign: 'right',
      paddingBottom: 12,
      marginTop: -8,
      marginLeft: 20,
      flexDirection: 'row', // Added to align items horizontally
      alignItems: 'center', // Align items vertically centered
    },
    dateHeader: {
      //textAlign: 'right',
      color: theme.colors.textSecondary,
      fontSize: 10,
    },
    iconContainer: {
      marginRight: 5,
      color: theme.colors.textSecondary,
      fontSize: 16,
    },
  });
};



================================================
FILE: src/components/Bubble/__tests__/Bubble.test.tsx
================================================
import React from 'react';

import {Text} from 'react-native-paper';

import {render, fireEvent} from '../../../../jest/test-utils';

import {Bubble} from '../Bubble';

jest.mock('react-native-vector-icons/MaterialCommunityIcons', () => {
  const {Text: PaperText} = require('react-native-paper');
  return props => <PaperText>{props.name}</PaperText>;
});

jest.mock('@react-native-clipboard/clipboard', () => ({
  setString: jest.fn(),
}));

describe('Bubble', () => {
  let mockMessage;

  beforeEach(() => {
    jest.clearAllMocks();
    mockMessage = {
      author: {id: 'user1'},
      createdAt: 0,
      id: 'uuidv4',
      text: 'Hello, world!',
      type: 'text',
      metadata: {
        copyable: true,
        timings: {
          predicted_per_token_ms: 10,
          predicted_per_second: 100,
        },
      },
    };
  });

  const renderBubble = (message, child = 'Child content') => {
    return render(
      <Bubble
        child={<Text testID="child">{child}</Text>}
        message={message}
        nextMessageInGroup={false}
      />,
    );
  };

  it('renders correctly with all props', () => {
    const {getByText, getByTestId} = renderBubble(mockMessage);
    expect(getByTestId('child')).toBeTruthy();
    expect(getByText('10ms/token, 100.00 tokens/sec')).toBeTruthy();
    expect(getByText('content-copy')).toBeTruthy();
  });

  it('does not render copy icon when message is not copyable', () => {
    const nonCopyableMessage = {
      ...mockMessage,
      metadata: {...mockMessage.metadata, copyable: false},
    };
    const {queryByText} = renderBubble(nonCopyableMessage);
    expect(queryByText('content-copy')).toBeNull();
  });

  it('calls Clipboard.setString when copy icon is pressed', () => {
    const {getByText} = renderBubble(mockMessage);
    fireEvent.press(getByText('content-copy'));
    expect(
      require('@react-native-clipboard/clipboard').setString,
    ).toHaveBeenCalledWith('Hello, world!');
  });

  it('does not crash when message.metadata is undefined', () => {
    const messageWithoutMetadata = {...mockMessage, metadata: undefined};
    const {getByText} = renderBubble(messageWithoutMetadata);
    expect(getByText('Child content')).toBeTruthy();
  });

  it('displays time to first token when available', () => {
    const messageWithTimeToFirstToken = {
      ...mockMessage,
      metadata: {
        copyable: true,
        timings: {
          predicted_per_token_ms: 10,
          predicted_per_second: 100,
          time_to_first_token_ms: 250,
        },
      },
    };

    const {getByText} = renderBubble(messageWithTimeToFirstToken);

    // Should display the time to first token in addition to the regular timing info
    expect(getByText(/250ms TTF/)).toBeTruthy();
  });

  it('does not display time to first token when null', () => {
    const messageWithNullTimeToFirstToken = {
      ...mockMessage,
      metadata: {
        copyable: true,
        timings: {
          predicted_per_token_ms: 10,
          predicted_per_second: 100,
          time_to_first_token_ms: null,
        },
      },
    };

    const {queryByText} = renderBubble(messageWithNullTimeToFirstToken);

    // Should not display time to first token when it's null
    expect(queryByText(/to first token/)).toBeNull();
  });

  it('does not display time to first token when undefined', () => {
    const messageWithoutTimeToFirstToken = {
      ...mockMessage,
      metadata: {
        copyable: true,
        timings: {
          predicted_per_token_ms: 10,
          predicted_per_second: 100,
          // time_to_first_token_ms is undefined
        },
      },
    };

    const {queryByText} = renderBubble(messageWithoutTimeToFirstToken);

    // Should not display time to first token when it's undefined
    expect(queryByText(/to first token/)).toBeNull();
  });
});



================================================
FILE: src/components/ChatEmptyPlaceholder/ChatEmptyPlaceholder.tsx
================================================
import React, {useContext} from 'react';
import {Image, View} from 'react-native';
import {Button, Text} from 'react-native-paper';
import {observer} from 'mobx-react';

import {useTheme} from '../../hooks';
import {createStyles} from './styles';
import {modelStore} from '../../store';
import {useNavigation} from '@react-navigation/native';
import {NavigationProp} from '@react-navigation/native';
import {L10nContext} from '../../utils';

interface ChatEmptyPlaceholderProps {
  onSelectModel: () => void;
  bottomComponentHeight: number;
}

export const ChatEmptyPlaceholder = observer(
  ({onSelectModel, bottomComponentHeight}: ChatEmptyPlaceholderProps) => {
    const theme = useTheme();
    const navigation = useNavigation<NavigationProp<any>>();
    const l10n = useContext(L10nContext);
    const styles = createStyles({theme});

    const hasAvailableModels = modelStore.availableModels.length > 0;
    const hasActiveModel = modelStore.activeModelId !== undefined;

    const getContent = () => {
      if (!hasAvailableModels) {
        return {
          title: l10n.components.chatEmptyPlaceholder.noModelsTitle,
          description: l10n.components.chatEmptyPlaceholder.noModelsDescription,
          buttonText: l10n.components.chatEmptyPlaceholder.noModelsButton,
          onPress: () => {
            navigation.navigate('Models');
          },
        };
      }

      return {
        title: l10n.components.chatEmptyPlaceholder.activateModelTitle,
        description:
          l10n.components.chatEmptyPlaceholder.activateModelDescription,
        buttonText: l10n.components.chatEmptyPlaceholder.activateModelButton,
        onPress: onSelectModel,
      };
    };

    const {title, description, buttonText, onPress} = getContent();

    if (hasActiveModel) {
      return null;
    }
    return (
      <View
        style={[styles.container, {marginBottom: bottomComponentHeight + 100}]}>
        <Image
          source={require('../../assets/pocketpal-dark-v2.png')}
          style={styles.logo}
          resizeMode="contain"
        />
        <View>
          <Text style={styles.title}>{title}</Text>
          <Text style={styles.description}>{description}</Text>
        </View>
        <Button
          mode="contained"
          onPress={onPress}
          style={styles.button}
          loading={modelStore.isContextLoading}
          disabled={hasActiveModel}>
          {modelStore.isContextLoading
            ? l10n.components?.chatEmptyPlaceholder?.loading
            : buttonText}
        </Button>
      </View>
    );
  },
);



================================================
FILE: src/components/ChatEmptyPlaceholder/index.ts
================================================
export {ChatEmptyPlaceholder} from './ChatEmptyPlaceholder';



================================================
FILE: src/components/ChatEmptyPlaceholder/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {Theme} from '../../utils/types';

export const createStyles = ({theme}: {theme: Theme}) =>
  StyleSheet.create({
    container: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      paddingHorizontal: 32,
      gap: theme.spacing.default,
    },
    title: {
      color: theme.colors.onSurface,
      textAlign: 'center',
      marginBottom: 8,
      ...theme.fonts.titleMedium,
    },
    description: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      ...theme.fonts.bodyMedium,
    },
    button: {
      minWidth: 200,
    },
    logo: {
      width: 112,
      height: 112,
      borderRadius: 30,
    },
  });



================================================
FILE: src/components/ChatGenerationSettingsSheet/ChatGenerationSettingsSheet.tsx
================================================
import React, {useContext, useEffect, useState} from 'react';
import {Sheet} from '../Sheet/Sheet';
import {CompletionSettings} from '..';
import {CompletionParams} from '../../utils/completionTypes';
import {chatSessionStore, defaultCompletionSettings} from '../../store';
import {styles} from './styles';
import {
  COMPLETION_PARAMS_METADATA,
  validateCompletionSettings,
} from '../../utils/modelSettings';
import {Alert, View} from 'react-native';
import {Button} from 'react-native-paper';
import {L10nContext} from '../../utils';
import {ChevronDownIcon} from '../../assets/icons';
import {Menu} from '../Menu';
interface ResetButtonProps {
  session: any;
  resetMenuVisible: boolean;
  setResetMenuVisible: (visible: boolean) => void;
  handleResetToDefault: () => void;
  handleResetToPreset: () => void;
}

const ChevronDownButtonIcon = ({color}: {color: string}) => (
  <ChevronDownIcon width={16} height={16} stroke={color} />
);

// Reset button component - conditionally renders based on session
const ResetButton = ({
  session,
  resetMenuVisible,
  setResetMenuVisible,
  handleResetToDefault,
  handleResetToPreset,
}: ResetButtonProps) => {
  const l10n = useContext(L10nContext);

  if (!session) {
    // Simple button for preset settings
    return (
      <Button
        mode="text"
        onPress={handleResetToDefault}
        style={styles.resetButton}>
        {l10n.components.chatGenerationSettingsSheet.resetToSystemDefaults}
      </Button>
    );
  }

  // Menu button for session settings
  return (
    <Menu
      visible={resetMenuVisible}
      onDismiss={() => setResetMenuVisible(false)}
      anchor={
        <View style={styles.resetWrapper}>
          <Button
            mode="text"
            onPress={() => setResetMenuVisible(true)}
            style={styles.resetButton}
            contentStyle={styles.resetButtonContent}
            icon={ChevronDownButtonIcon}>
            {l10n.common.reset}
          </Button>
        </View>
      }>
      <Menu.Item
        onPress={handleResetToPreset}
        label={l10n.components.chatGenerationSettingsSheet.resetToPreset}
      />
      <Menu.Item
        onPress={handleResetToDefault}
        label={
          l10n.components.chatGenerationSettingsSheet.resetToSystemDefaults
        }
      />
    </Menu>
  );
};

export const ChatGenerationSettingsSheet = ({
  isVisible,
  onClose,
}: {
  isVisible: boolean;
  onClose: () => void;
}) => {
  const l10n = useContext(L10nContext);
  const session = chatSessionStore.sessions.find(
    item => item.id === chatSessionStore.activeSessionId,
  );

  const [settings, setSettings] = useState<CompletionParams>(
    session?.completionSettings ?? chatSessionStore.newChatCompletionSettings,
  );

  const [resetMenuVisible, setResetMenuVisible] = useState(false);

  const isEditingPresetSettings = !session;

  useEffect(() => {
    setSettings(
      session?.completionSettings ?? chatSessionStore.newChatCompletionSettings,
    );
  }, [session]);

  const updateSettings = (name: string, value: any) => {
    setSettings(prev => ({...prev, [name]: value}));
  };

  const onCloseSheet = () => {
    setSettings(
      session?.completionSettings ?? chatSessionStore.newChatCompletionSettings,
    );
    onClose();
  };

  const handleSaveSettings = async () => {
    // Convert string values to numbers where needed
    const processedSettings = Object.entries(settings).reduce(
      (acc, [key, value]) => {
        const metadata = COMPLETION_PARAMS_METADATA[key];
        if (metadata?.validation.type === 'numeric') {
          // Handle numeric conversion
          let numValue: number;
          if (typeof value === 'string') {
            numValue = Number(value);
          } else if (typeof value === 'number') {
            numValue = value;
          } else {
            // If it's neither string nor number, treat as invalid. Most probably won't happen.
            acc.errors[key] =
              l10n.components.chatGenerationSettingsSheet.invalidNumericValuesMessage;
            return acc;
          }

          if (Number.isNaN(numValue)) {
            acc.errors[key] =
              l10n.components.chatGenerationSettingsSheet.invalidNumericValuesMessage;
          } else {
            acc.settings[key] = numValue;
          }
        } else {
          // For non-numeric values, keep as is
          acc.settings[key] = value;
        }
        return acc;
      },
      {settings: {}, errors: {}} as {
        settings: typeof settings;
        errors: Record<string, string>;
      },
    );

    // Validate the converted values
    const validationResult = validateCompletionSettings(
      processedSettings.settings,
    );
    const allErrors = {
      ...processedSettings.errors,
      ...validationResult.errors,
    };

    if (Object.keys(allErrors).length > 0) {
      Alert.alert(
        l10n.components.chatGenerationSettingsSheet.invalidValues,
        l10n.components.chatGenerationSettingsSheet.pleaseCorrect +
          '\n' +
          Object.entries(allErrors)
            .map(([key, msg]) => `‚Ä¢ ${key}: ${msg}`)
            .join('\n'),
        [{text: l10n.components.chatGenerationSettingsSheet.ok}],
      );
      return;
    }

    if (session) {
      await chatSessionStore.updateSessionCompletionSettings(
        processedSettings.settings,
      );
    } else {
      await chatSessionStore.setNewChatCompletionSettings(
        processedSettings.settings,
      );
    }
    onCloseSheet();
  };

  const handleApplyToPreset = async () => {
    if (session) {
      // Apply current session settings to preset settings
      await handleSaveSettings(); // First save the current UI settings to the session
      await chatSessionStore.applySessionSettingsToGlobal();
      Alert.alert(
        l10n.components.chatGenerationSettingsSheet.applytoPresetAlert.title,
        l10n.components.chatGenerationSettingsSheet.applytoPresetAlert.message,
        [{text: l10n.components.chatGenerationSettingsSheet.ok}],
      );
    }
  };

  const handleResetToPreset = () => {
    if (session) {
      // For session-specific settings, reset to match Preset settings
      setSettings({...chatSessionStore.newChatCompletionSettings});
    }
    setResetMenuVisible(false);
  };

  const handleResetToDefault = () => {
    // Reset to system defaults
    setSettings({...defaultCompletionSettings});
    setResetMenuVisible(false);
  };

  return (
    <Sheet
      title={
        session
          ? l10n.components.chatGenerationSettingsSheet.title_session
          : l10n.components.chatGenerationSettingsSheet.title_preset
      }
      isVisible={isVisible}
      onClose={onCloseSheet}>
      <Sheet.ScrollView
        bottomOffset={16}
        contentContainerStyle={styles.scrollviewContainer}>
        <CompletionSettings settings={settings} onChange={updateSettings} />
      </Sheet.ScrollView>
      <Sheet.Actions>
        <View style={styles.actionsContainer}>
          <ResetButton
            session={session}
            resetMenuVisible={resetMenuVisible}
            setResetMenuVisible={setResetMenuVisible}
            handleResetToDefault={handleResetToDefault}
            handleResetToPreset={handleResetToPreset}
          />
          <View style={styles.rightButtons}>
            {!isEditingPresetSettings && (
              <Button
                mode="contained-tonal"
                onPress={handleApplyToPreset}
                style={styles.button}>
                {l10n.components.chatGenerationSettingsSheet.saveAsPreset}
              </Button>
            )}
            <Button mode="contained" onPress={handleSaveSettings}>
              {session
                ? l10n.common.save
                : l10n.components.chatGenerationSettingsSheet.saveChanges}
            </Button>
          </View>
        </View>
      </Sheet.Actions>
    </Sheet>
  );
};



================================================
FILE: src/components/ChatGenerationSettingsSheet/index.ts
================================================
export * from './ChatGenerationSettingsSheet';



================================================
FILE: src/components/ChatGenerationSettingsSheet/styles.ts
================================================
import {StyleSheet} from 'react-native';

export const styles = StyleSheet.create({
  scrollviewContainer: {
    padding: 16,
  },
  secondaryButtons: {
    flexDirection: 'row',
    gap: 8,
  },
  actionsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    width: '100%',
  },
  resetWrapper: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  resetButton: {
    marginRight: 0,
  },
  resetButtonContent: {
    flexDirection: 'row-reverse',
  },
  rightButtons: {
    flexDirection: 'row',
    gap: 8,
    alignItems: 'center',
    maxWidth: '70%',
  },
  button: {
    flex: 1,
  },
});



================================================
FILE: src/components/ChatGenerationSettingsSheet/__tests__/ChatGenerationSettingsSheet.test.tsx
================================================
import React from 'react';
import {fireEvent, render, act} from '../../../../jest/test-utils';
import {Alert} from 'react-native';
import {ChatGenerationSettingsSheet} from '../ChatGenerationSettingsSheet';
import {chatSessionStore, defaultCompletionSettings} from '../../../store';
import {validateCompletionSettings} from '../../../utils/modelSettings';

// Mock modelSettings validation
jest.mock('../../../utils/modelSettings', () => ({
  COMPLETION_PARAMS_METADATA: {
    temperature: {
      validation: {type: 'numeric', min: 0, max: 2, required: true},
    },
  },
  validateCompletionSettings: jest.fn().mockReturnValue({errors: {}}),
}));

// Mock Alert
jest.spyOn(Alert, 'alert');

// Mock the CompletionSettings component
jest.mock('../../CompletionSettings', () => {
  const {View, TouchableOpacity} = require('react-native');
  return {
    CompletionSettings: ({onChange}) => (
      <View testID="completion-settings">
        <TouchableOpacity
          testID="mock-settings-update"
          onPress={() => onChange('temperature', '3.0')} // Value above max of 2
        />
      </View>
    ),
  };
});

// Mock Sheet component
jest.mock('../../Sheet/Sheet', () => {
  const {View, Button} = require('react-native');
  const MockSheet = ({children, isVisible, onClose, title}) => {
    if (!isVisible) {
      return null;
    }
    return (
      <View testID="sheet">
        <View testID="sheet-title">{title}</View>
        <Button title="Close" onPress={onClose} testID="sheet-close-button" />
        {children}
      </View>
    );
  };
  MockSheet.ScrollView = ({children}) => (
    <View testID="sheet-scroll-view">{children}</View>
  );
  MockSheet.Actions = ({children}) => (
    <View testID="sheet-actions">{children}</View>
  );
  return {Sheet: MockSheet};
});

// Mock the stores
jest.mock('../../../store', () => ({
  chatSessionStore: {
    sessions: [
      {
        id: 'test-session',
        completionSettings: {
          temperature: 1.0,
          top_k: 40,
          top_p: 0.9,
        },
      },
    ],
    activeSessionId: 'test-session',
    newChatCompletionSettings: {
      temperature: 0.8,
      top_k: 50,
      top_p: 0.95,
    },
    updateSessionCompletionSettings: jest.fn(),
    setNewChatCompletionSettings: jest.fn(),
  },
  defaultCompletionSettings: {
    temperature: 0.7,
    top_k: 40,
    top_p: 0.9,
  },
}));

describe('ChatGenerationSettingsSheet', () => {
  const defaultProps = {
    isVisible: true,
    onClose: jest.fn(),
  };

  beforeEach(() => {
    jest.clearAllMocks();
    // Reset validateCompletionSettings to return success by default
    (validateCompletionSettings as jest.Mock).mockReturnValue({errors: {}});
  });

  it('renders correctly when visible', () => {
    const {getByTestId} = render(
      <ChatGenerationSettingsSheet {...defaultProps} />,
    );

    expect(getByTestId('sheet')).toBeTruthy();
    expect(getByTestId('completion-settings')).toBeTruthy();
  });

  it('does not render when not visible', () => {
    const {queryByTestId} = render(
      <ChatGenerationSettingsSheet {...defaultProps} isVisible={false} />,
    );

    expect(queryByTestId('sheet')).toBeNull();
  });

  it('loads active session settings when available', () => {
    const {getByTestId} = render(
      <ChatGenerationSettingsSheet {...defaultProps} />,
    );

    expect(getByTestId('completion-settings')).toBeTruthy();
    // Settings from active session should be loaded
  });

  it('loads new chat settings when no active session', () => {
    // Temporarily modify the mock to simulate no active session
    const originalSessions = chatSessionStore.sessions;
    chatSessionStore.sessions = [];

    const {getByTestId} = render(
      <ChatGenerationSettingsSheet {...defaultProps} />,
    );

    expect(getByTestId('completion-settings')).toBeTruthy();
    // New chat settings should be loaded

    // Restore the original sessions
    chatSessionStore.sessions = originalSessions;
  });

  it('handles save settings correctly for active session', async () => {
    const {getByText} = render(
      <ChatGenerationSettingsSheet {...defaultProps} />,
    );

    await act(async () => {
      fireEvent.press(getByText('Save'));
    });

    expect(chatSessionStore.updateSessionCompletionSettings).toHaveBeenCalled();
    expect(defaultProps.onClose).toHaveBeenCalled();
  });

  it('handles save settings correctly for new chat', async () => {
    // Temporarily modify the mock to simulate no active session
    const originalSessions = chatSessionStore.sessions;
    chatSessionStore.sessions = [];

    const {getByText} = render(
      <ChatGenerationSettingsSheet {...defaultProps} />,
    );

    await act(async () => {
      fireEvent.press(getByText('Save Changes'));
    });

    expect(chatSessionStore.setNewChatCompletionSettings).toHaveBeenCalled();
    expect(defaultProps.onClose).toHaveBeenCalled();

    // Restore the original sessions
    chatSessionStore.sessions = originalSessions;
  });

  it('handles reset settings correctly', async () => {
    const {getByText} = render(
      <ChatGenerationSettingsSheet {...defaultProps} />,
    );

    await act(async () => {
      fireEvent.press(getByText('Reset'));
    });

    await act(async () => {
      fireEvent.press(getByText('Reset to System Defaults'));
    });

    // After reset, saving should use default settings
    await act(async () => {
      fireEvent.press(getByText('Save'));
    });

    expect(
      chatSessionStore.updateSessionCompletionSettings,
    ).toHaveBeenCalledWith(defaultCompletionSettings);
  });

  it('validates numeric values before saving', async () => {
    // Mock validation to return an error for this specific test
    (validateCompletionSettings as jest.Mock).mockReturnValueOnce({
      errors: {
        temperature: 'Must be between 0 and 2',
      },
    });

    const {getByTestId, getByText} = render(
      <ChatGenerationSettingsSheet {...defaultProps} />,
    );

    // Trigger an invalid update
    await act(async () => {
      fireEvent.press(getByTestId('mock-settings-update')); // This sets temperature to '3.0'
    });

    await act(async () => {
      fireEvent.press(getByText('Save'));
    });

    // Should show alert for invalid value
    expect(Alert.alert).toHaveBeenCalledWith(
      'Invalid Values',
      expect.stringContaining('temperature: Must be between 0 and 2'),
      expect.anything(),
    );
    expect(
      chatSessionStore.updateSessionCompletionSettings,
    ).not.toHaveBeenCalled();
  });
});



================================================
FILE: src/components/ChatHeader/ChatHeader.tsx
================================================
import React from 'react';
import {Platform, View} from 'react-native';
import {observer} from 'mobx-react';

import {createStyles} from './styles';
import {HeaderRight} from '../HeaderRight';
import {ChatHeaderTitle} from '../ChatHeaderTitle';
import {
  useSafeAreaFrame,
  useSafeAreaInsets,
} from 'react-native-safe-area-context';
import {getDefaultHeaderHeight} from '@react-navigation/elements';
import {useTheme} from '../../hooks';
import {chatSessionStore} from '../../store';
import {HeaderLeft} from '../HeaderLeft';

export const ChatHeader: React.FC = observer(() => {
  const theme = useTheme();

  const insets = useSafeAreaInsets();
  const layout = useSafeAreaFrame();

  // On models with Dynamic Island the status bar height is smaller than the safe area top inset.
  // https://github.com/react-navigation/react-navigation/blob/e4815c538536ddccf4207b87bf3e2f1603dedd84/packages/elements/src/Header/Header.tsx#L52
  // NOTE: in v7, this is fixed and getDefaultHeaderHeight returns the correct height.

  const hasDynamicIsland = Platform.OS === 'ios' && insets.top > 50;
  const statusBarHeight = hasDynamicIsland ? insets.top - 5 : insets.top;

  const headerHeight = getDefaultHeaderHeight(layout, false, statusBarHeight);

  const styles = createStyles({theme, insets, headerHeight});

  const headerStyle = chatSessionStore?.shouldShowHeaderDivider
    ? styles.headerWithDivider
    : styles.headerWithoutDivider;

  return (
    <View testID="header-view" style={[styles.container, headerStyle]}>
      <View style={styles.leftSection}>
        <HeaderLeft />
        <ChatHeaderTitle />
      </View>
      <HeaderRight />
    </View>
  );
});



================================================
FILE: src/components/ChatHeader/index.ts
================================================
export {ChatHeader} from './ChatHeader';



================================================
FILE: src/components/ChatHeader/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {Theme} from '../../utils/types';
import {EdgeInsets} from 'react-native-safe-area-context';

export const createStyles = ({
  theme,
  insets,
  headerHeight,
}: {
  theme: Theme;
  insets: EdgeInsets;
  headerHeight: number;
}) =>
  StyleSheet.create({
    container: {
      height: headerHeight,
      paddingTop: insets.top,
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      gap: 10,
    },
    leftSection: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 10,
      flexShrink: 1,
    },
    menuIcon: {
      height: 40,
      width: 40,
      justifyContent: 'center',
      alignItems: 'center',
    },
    headerWithoutDivider: {
      elevation: 0,
      shadowOpacity: 0,
      borderBottomWidth: 0,
      backgroundColor: theme.colors.background,
    },
    headerWithDivider: {
      backgroundColor: theme.colors.background,
    },
  });



================================================
FILE: src/components/ChatHeader/__tests__/ChatHeader.test.tsx
================================================
import React from 'react';
import {render} from '../../../../jest/test-utils';
import {ChatHeader} from '../ChatHeader';

// Mock the child components
jest.mock('../../HeaderLeft', () => ({
  HeaderLeft: () => {
    const {View} = require('react-native');
    return <View testID="header-left" />;
  },
}));

jest.mock('../../HeaderRight', () => ({
  HeaderRight: () => {
    const {View} = require('react-native');
    return <View testID="header-right" />;
  },
}));

jest.mock('../../ChatHeaderTitle', () => ({
  ChatHeaderTitle: () => {
    const {View} = require('react-native');
    return <View testID="chat-header-title" />;
  },
}));

// Create a mock store object
const mockChatSessionStore = {
  shouldShowHeaderDivider: false,
};

// Mock the stores
jest.mock('../../../store', () => ({
  chatSessionStore: mockChatSessionStore,
}));

describe('ChatHeader', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    // Reset the mock store value
    mockChatSessionStore.shouldShowHeaderDivider = false;
  });

  it('renders all child components', () => {
    const {getByTestId} = render(<ChatHeader />);

    expect(getByTestId('header-view')).toBeTruthy();
    expect(getByTestId('header-left')).toBeTruthy();
    expect(getByTestId('header-right')).toBeTruthy();
    expect(getByTestId('chat-header-title')).toBeTruthy();
  });

  it('applies correct styles when header divider should not be shown', () => {
    mockChatSessionStore.shouldShowHeaderDivider = false;
    const {getByTestId} = render(<ChatHeader />, {withSafeArea: true});

    const headerView = getByTestId('header-view');
    expect(headerView.props.style[1]).toMatchObject({
      elevation: 0,
      shadowOpacity: 0,
      borderBottomWidth: 0,
      backgroundColor: expect.any(String),
    });
  });

  it('applies correct styles when header divider should be shown', () => {
    mockChatSessionStore.shouldShowHeaderDivider = true;
    const {getByTestId} = render(<ChatHeader />, {withSafeArea: true});

    const headerView = getByTestId('header-view');
    expect(headerView.props.style[1]).toMatchObject({
      backgroundColor: expect.any(String),
    });
  });
});



================================================
FILE: src/components/ChatHeaderTitle/ChatHeaderTitle.tsx
================================================
import React, {useContext} from 'react';
import {View} from 'react-native';
import {observer} from 'mobx-react';
import {Text} from 'react-native-paper';

import {styles} from './styles';
import {chatSessionStore, modelStore} from '../../store';
import {L10nContext} from '../../utils';

export const ChatHeaderTitle: React.FC = observer(() => {
  const l10n = useContext(L10nContext);
  const activeSessionId = chatSessionStore.activeSessionId;
  const activeSession = chatSessionStore.sessions.find(
    session => session.id === activeSessionId,
  );
  const activeModel = modelStore.activeModel;

  return (
    <View style={styles.container}>
      <Text numberOfLines={1} variant="titleSmall">
        {activeSession?.title || l10n.components.chatHeaderTitle.defaultTitle}
      </Text>
      {activeModel?.name && (
        <Text numberOfLines={1} variant="bodySmall">
          {activeModel?.name}
        </Text>
      )}
    </View>
  );
});



================================================
FILE: src/components/ChatHeaderTitle/index.ts
================================================
export * from './ChatHeaderTitle';



================================================
FILE: src/components/ChatHeaderTitle/styles.ts
================================================
import {StyleSheet} from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flexShrink: 1,
  },
});



================================================
FILE: src/components/ChatHeaderTitle/__tests__/ChatHeaderTitle.test.tsx
================================================
import React from 'react';
import {render} from '../../../../jest/test-utils';
import {ChatHeaderTitle} from '../ChatHeaderTitle';
import {chatSessionStore, modelStore} from '../../../store';
import {runInAction} from 'mobx';
import {basicModel, downloadedModel} from '../../../../jest/fixtures/models';

describe('ChatHeaderTitle', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders "Chat" when no active session exists', () => {
    runInAction(() => {
      chatSessionStore.resetActiveSession();
      chatSessionStore.sessions = [];
    });
    const {getByText} = render(<ChatHeaderTitle />);
    expect(getByText('Chat')).toBeTruthy();
  });

  it('renders session title when active session exists', () => {
    const mockSession = {
      id: '123',
      title: 'Test Session',
      date: new Date().toISOString(),
      messages: [],
    };
    runInAction(() => {
      Object.assign(chatSessionStore, {
        activeSessionId: mockSession.id,
        sessions: [mockSession],
      });
    });

    const {getByText} = render(<ChatHeaderTitle />);
    expect(getByText('Test Session')).toBeTruthy();
  });

  it('renders model name when active model exists', () => {
    runInAction(() => {
      modelStore.models = [basicModel];
      modelStore.setActiveModel(basicModel.id);
    });

    const {getByText} = render(<ChatHeaderTitle />);
    expect(getByText('basic model')).toBeTruthy();
  });

  it('updates when active model changes', () => {
    // Initial model
    runInAction(() => {
      modelStore.models = [basicModel];
      modelStore.setActiveModel(basicModel.id);
    });

    const {getByText, rerender} = render(<ChatHeaderTitle />);
    expect(getByText('basic model')).toBeTruthy();

    // Change model
    runInAction(() => {
      modelStore.models = [downloadedModel];
      modelStore.setActiveModel(downloadedModel.id);
    });

    rerender(<ChatHeaderTitle />);
    expect(getByText('downloaded model')).toBeTruthy();
  });
});



================================================
FILE: src/components/ChatInput/ChatInput.tsx
================================================
import * as React from 'react';
import {
  TextInput,
  TextInputProps,
  View,
  Animated,
  TouchableOpacity,
  Alert,
  ScrollView,
  Image,
} from 'react-native';
import {launchCamera, launchImageLibrary} from 'react-native-image-picker';
import {useCameraPermission} from 'react-native-vision-camera';

import {observer} from 'mobx-react';
import {IconButton, Text} from 'react-native-paper';

import {PalType} from '../PalsSheets/types';

import {
  ChevronUpIcon,
  VideoRecorderIcon,
  PlusIcon,
  AtomIcon,
} from '../../assets/icons';

import {useTheme} from '../../hooks';

import {createStyles} from './styles';

import {chatSessionStore, modelStore, palStore, uiStore} from '../../store';

import {MessageType} from '../../utils/types';
import {L10nContext, UserContext} from '../../utils';

import {SendButton, StopButton, Menu} from '..';

export interface ChatInputTopLevelProps {
  /** Whether the AI is currently streaming tokens */
  isStreaming?: boolean;
  /** Will be called on {@link SendButton} tap. Has {@link MessageType.PartialText} which can
   * be transformed to {@link MessageType.Text} and added to the messages list. */
  onSendPress: (message: MessageType.PartialText) => void;
  onStopPress?: () => void;
  onCancelEdit?: () => void;
  onPalBtnPress?: () => void;
  isStopVisible?: boolean;
  /** Controls the visibility behavior of the {@link SendButton} based on the
   * `TextInput` state. Defaults to `editing`. */
  sendButtonVisibilityMode?: 'always' | 'editing';
  textInputProps?: TextInputProps;
  isPickerVisible?: boolean;
  inputBackgroundColor?: string;
  /** External control for selected images (for edit mode) */
  defaultImages?: string[];
  onDefaultImagesChange?: (images: string[]) => void;
  /** Type of Pal being used, affects the input rendering */
  palType?: PalType;
  /** Camera-specific props */
  isCameraActive?: boolean;
  onStartCamera?: () => void;
  /** For camera input, allows direct editing of the prompt text */
  promptText?: string;
  onPromptTextChange?: (text: string) => void;
  /** Whether to show the image upload button */
  showImageUpload?: boolean;
  isVisionEnabled?: boolean;
  /** Whether to show the thinking toggle button */
  showThinkingToggle?: boolean;
  /** Whether thinking mode is currently enabled */
  isThinkingEnabled?: boolean;
  /** Callback when thinking toggle is pressed */
  onThinkingToggle?: (enabled: boolean) => void;
}

export interface ChatInputAdditionalProps {
  /** Type of Pal being used, affects the input rendering */
  palType?: PalType;
  /** Camera-specific props */
  isCameraActive?: boolean;
  onStartCamera?: () => void;
  /** For camera input, allows direct editing of the prompt text */
  promptText?: string;
  onPromptTextChange?: (text: string) => void;
  /** Whether to show the image upload button */
  showImageUpload?: boolean;
  /** Whether to show the thinking toggle button */
  showThinkingToggle?: boolean;
  /** Whether thinking mode is currently enabled */
  isThinkingEnabled?: boolean;
  /** Callback when thinking toggle is pressed */
  onThinkingToggle?: (enabled: boolean) => void;
}

export type ChatInputProps = ChatInputTopLevelProps & ChatInputAdditionalProps;

/** Bottom bar input component with a text input, attachment and
 * send buttons inside. By default hides send button when text input is empty. */
export const ChatInput = observer(
  ({
    isStreaming = false,
    onSendPress,
    onStopPress,
    onCancelEdit,
    onPalBtnPress,
    isStopVisible,
    sendButtonVisibilityMode,
    textInputProps,
    isPickerVisible,
    inputBackgroundColor,
    palType,
    isCameraActive = false,
    onStartCamera,
    promptText,
    onPromptTextChange,
    showImageUpload = false,
    isVisionEnabled = false,
    defaultImages,
    onDefaultImagesChange,
    showThinkingToggle = false,
    isThinkingEnabled = false,
    onThinkingToggle,
  }: ChatInputProps) => {
    const l10n = React.useContext(L10nContext);
    const theme = useTheme();
    const user = React.useContext(UserContext);
    const inputRef = React.useRef<TextInput>(null);
    const editBarHeight = React.useRef(new Animated.Value(0)).current;
    const iconRotation = React.useRef(new Animated.Value(0)).current;
    const activePalId = chatSessionStore.activePalId;
    const activePal = palStore.pals.find(pal => pal.id === activePalId);

    // Camera permission hook from react-native-vision-camera
    const {hasPermission, requestPermission} = useCameraPermission();

    const hasActiveModel = !!modelStore.activeModelId;

    // Use `defaultValue` if provided
    const [text, setText] = React.useState(textInputProps?.defaultValue ?? '');
    // State for selected images - use external control when provided
    const [internalSelectedImages, setInternalSelectedImages] = React.useState<
      string[]
    >([]);
    const selectedImages = defaultImages ?? internalSelectedImages;
    const setSelectedImages =
      onDefaultImagesChange ?? setInternalSelectedImages;
    // State for image upload menu
    const [showImageUploadMenu, setShowImageUploadMenu] = React.useState(false);
    const isEditMode = chatSessionStore.isEditMode;

    const styles = createStyles({theme, isEditMode});

    // For camera input, use promptText if provided
    const value =
      palType === PalType.VIDEO && promptText !== undefined
        ? promptText
        : textInputProps?.value ?? text;

    React.useEffect(() => {
      if (isEditMode) {
        // Animate edit bar height
        Animated.spring(editBarHeight, {
          toValue: 28,
          useNativeDriver: false,
          friction: 8,
        }).start();
        // Focus input
        inputRef.current?.focus();
      } else {
        Animated.spring(editBarHeight, {
          toValue: 0,
          useNativeDriver: false,
          friction: 8,
        }).start();
        onCancelEdit?.();
      }
    }, [isEditMode, editBarHeight, onCancelEdit]);

    React.useEffect(() => {
      Animated.spring(iconRotation, {
        toValue: isPickerVisible ? 1 : 0,
        useNativeDriver: true,
        friction: 8,
      }).start();
    }, [isPickerVisible, iconRotation]);

    const handleChangeText = (newText: string) => {
      if (palType === PalType.VIDEO && onPromptTextChange) {
        onPromptTextChange(newText);
      } else {
        setText(newText);
        textInputProps?.onChangeText?.(newText);
      }
    };

    const handleSend = () => {
      const trimmedValue = value.trim();
      if (trimmedValue) {
        // Include imageUris in the message object
        onSendPress({
          text: trimmedValue,
          type: 'text',
          imageUris: selectedImages.length > 0 ? selectedImages : undefined,
        });
        setText('');
        // Clear selected images after sending
        setSelectedImages([]);
      }
    };

    // Handle plus button press to show image upload menu
    const handlePlusButtonPress = () => {
      setShowImageUploadMenu(true);
    };

    // Need to figure this out:
    // Handle taking a photo with the camera using react-native-image-picker
    // but with permission checking from react-native-vision-camera
    const handleTakePhoto = async () => {
      try {
        if (!hasPermission) {
          const permissionResult = await requestPermission();
          if (!permissionResult) {
            Alert.alert(
              l10n.camera.permissionTitle,
              l10n.camera.permissionMessage,
            );
            setShowImageUploadMenu(false);
            return;
          }
        }

        // Disable auto-release during camera operation
        // this is only needed on Android.
        modelStore.disableAutoRelease('camera-photo');

        const result = await launchCamera({
          mediaType: 'photo',
          quality: 0.8,
        });

        if (result.assets && result.assets.length > 0 && result.assets[0].uri) {
          const newImages = [...selectedImages, result.assets[0].uri];
          setSelectedImages(newImages);
        }
        setShowImageUploadMenu(false);
      } catch (error) {
        console.error('Error taking photo:', error);
        Alert.alert(
          l10n.errors.cameraErrorTitle,
          l10n.errors.cameraErrorMessage,
        );
      } finally {
        // Re-enable auto-release after camera operation
        modelStore.enableAutoRelease('camera-photo');
      }
    };

    // Handle selecting images from the gallery
    const handleSelectImages = async () => {
      try {
        // Disable auto-release during gallery operation
        // this is only needed on Android.
        modelStore.disableAutoRelease('image-gallery');

        const result = await launchImageLibrary({
          mediaType: 'photo',
          selectionLimit: 5, // Allow multiple images
          quality: 0.8,
        });

        if (result.assets && result.assets.length > 0) {
          const newUris = result.assets
            .filter(asset => asset.uri)
            .map(asset => asset.uri as string);

          if (newUris.length > 0) {
            const newImages = [...selectedImages, ...newUris];
            setSelectedImages(newImages);
          }
        }
        setShowImageUploadMenu(false);
      } catch (error) {
        console.error('Error selecting images:', error);
        Alert.alert(
          l10n.errors.galleryErrorTitle,
          l10n.errors.galleryErrorMessage,
        );
      } finally {
        // Re-enable auto-release after gallery operation
        modelStore.enableAutoRelease('image-gallery');
      }
    };

    // Remove an image from the selection
    const handleRemoveImage = (index: number) => {
      const newImages = [...selectedImages];
      newImages.splice(index, 1);
      setSelectedImages(newImages);
    };

    const handleCancel = () => {
      setText('');
      onCancelEdit?.();
    };

    const isSendButtonVisible =
      !isStreaming &&
      !isStopVisible &&
      user &&
      palType !== PalType.VIDEO && // Hide send button for video pals
      (sendButtonVisibilityMode === 'always' || value.trim());
    const isSendButtonEnabled = value.trim().length > 0;
    const sendButtonOpacity = isSendButtonEnabled ? 1 : 0.4;

    const rotateInterpolate = iconRotation.interpolate({
      inputRange: [0, 1],
      outputRange: ['0deg', '180deg'],
    });

    const onSurfaceColor = activePal?.color?.[0] || theme.colors.text;
    const onSurfaceColorVariant = onSurfaceColor + '55'; // for disabled state or placeholder text
    // // Plus button state
    const isPlusButtonEnabled = !isStreaming && isVisionEnabled;
    const plusColor = isPlusButtonEnabled
      ? onSurfaceColor
      : onSurfaceColorVariant;

    return (
      <View style={styles.container}>
        <View style={styles.inputContainer}>
          {/* Edit Bar (when in edit mode) */}
          {isEditMode && (
            <Animated.View
              style={[
                styles.editBar,
                {
                  height: editBarHeight,
                },
              ]}>
              <Text variant="labelSmall" style={styles.editBarText}>
                Editing message
              </Text>
              <IconButton
                icon="close"
                size={16}
                onPress={handleCancel}
                style={styles.editBarButton}
                iconColor={theme.colors.onSurfaceVariant}
              />
            </Animated.View>
          )}

          {/* Image Preview Section */}
          {selectedImages.length > 0 && (
            <View
              style={[
                styles.imagePreviewContainer,
                isEditMode && styles.imagePreviewContainerEditMode,
              ]}>
              <ScrollView
                horizontal
                showsHorizontalScrollIndicator={false}
                contentContainerStyle={styles.imageScrollContent}>
                {selectedImages.map((uri, index) => (
                  <View key={`${uri}-${index}`} style={styles.imageContainer}>
                    <Image
                      source={{uri}}
                      style={styles.previewImage}
                      accessibilityLabel={`Image preview ${index + 1} of ${
                        selectedImages.length
                      }`}
                    />
                    <IconButton
                      icon="close-circle"
                      size={20}
                      iconColor={theme.colors.error}
                      style={styles.removeImageButton}
                      onPress={() => handleRemoveImage(index)}
                      accessibilityLabel={`Remove image ${index + 1}`}
                    />
                  </View>
                ))}
              </ScrollView>
            </View>
          )}

          {/* Text Input Area (Top Row) */}
          <View
            style={[
              styles.textInputArea,
              {
                paddingTop: isEditMode
                  ? selectedImages.length > 0
                    ? 8 // Reduced padding when images present in edit mode
                    : 48 // Edit bar height (28px) + normal padding (20px)
                  : selectedImages.length > 0
                  ? 0
                  : 20,
              },
            ]}>
            {/* Subtle Prompt Label for Video Pals */}
            {palType === PalType.VIDEO && (
              <Text
                variant="labelSmall"
                style={[styles.promptLabel, {color: onSurfaceColorVariant}]}>
                {l10n.palsScreen.prompt}:
              </Text>
            )}
            <TextInput
              ref={inputRef}
              multiline
              placeholder={
                palType === PalType.VIDEO
                  ? l10n.video.promptPlaceholder
                  : l10n.components.chatInput.inputPlaceholder
              }
              placeholderTextColor={onSurfaceColorVariant}
              underlineColorAndroid="transparent"
              {...textInputProps}
              style={[
                styles.input,
                textInputProps?.style,
                {
                  color: onSurfaceColor,
                },
                palType === PalType.VIDEO && styles.inputWithLabel,
              ]}
              onChangeText={handleChangeText}
              value={value}
              editable={
                palType === PalType.VIDEO
                  ? !isStreaming && !isCameraActive
                  : textInputProps?.editable !== false
              }
            />
          </View>

          {/* Control Bar (Bottom Row) */}
          <View style={styles.controlBar}>
            {/* Left Controls */}
            <View style={styles.leftControls}>
              {/* Plus Button for Image Upload (only for regular chat) */}
              {showImageUpload && palType !== PalType.VIDEO && (
                <Menu
                  visible={showImageUploadMenu}
                  onDismiss={() => setShowImageUploadMenu(false)}
                  anchorPosition="top"
                  anchor={
                    <TouchableOpacity
                      style={styles.plusButton}
                      disabled={!isPlusButtonEnabled}
                      onPress={
                        isPlusButtonEnabled ? handlePlusButtonPress : () => {}
                      }
                      accessibilityLabel="Add image"
                      accessibilityRole="button">
                      <PlusIcon width={20} height={20} stroke={plusColor} />
                    </TouchableOpacity>
                  }>
                  <Menu.Item
                    label={l10n.camera?.takePhoto || 'Camera'}
                    icon="camera"
                    onPress={handleTakePhoto}
                  />
                  <Menu.Item
                    label={l10n.common?.gallery || 'Gallery'}
                    icon="image"
                    onPress={handleSelectImages}
                  />
                </Menu>
              )}

              {/* Pal Selector */}
              <View style={styles.palSelector}>
                <TouchableOpacity
                  style={[
                    styles.palBtn,
                    {
                      backgroundColor:
                        uiStore.colorScheme === 'dark'
                          ? theme.colors.inverseOnSurface
                          : theme.colors.inverseSurface,
                    },
                    activePal?.color && {
                      backgroundColor: activePal?.color?.[0],
                    },
                  ]}
                  onPress={onPalBtnPress}
                  accessibilityLabel="Select Pal"
                  accessibilityRole="button">
                  <Animated.View
                    style={{
                      transform: [{rotate: rotateInterpolate}],
                    }}>
                    <ChevronUpIcon stroke={inputBackgroundColor} />
                  </Animated.View>
                </TouchableOpacity>

                {/* Pal Name Display */}
                {activePal?.name && hasActiveModel && (
                  <Text
                    style={[
                      styles.palNameCompact,
                      {
                        color: onSurfaceColor,
                      },
                    ]}>
                    Pal:{' '}
                    <Text
                      style={[
                        styles.palNameValueCompact,
                        {
                          color: onSurfaceColor,
                        },
                      ]}>
                      {activePal?.name}
                    </Text>
                  </Text>
                )}
              </View>

              {/* Thinking Toggle Button */}
              {showThinkingToggle && !isCameraActive && (
                <TouchableOpacity
                  style={[
                    styles.thinkingToggleLeft,
                    isThinkingEnabled && {backgroundColor: onSurfaceColor},
                    {borderColor: onSurfaceColorVariant},
                  ]}
                  onPress={() => onThinkingToggle?.(!isThinkingEnabled)}
                  accessibilityLabel={
                    isThinkingEnabled
                      ? l10n.components.chatInput.thinkingToggle.disableThinking
                      : l10n.components.chatInput.thinkingToggle.enableThinking
                  }
                  accessibilityRole="button">
                  <AtomIcon
                    width={14}
                    height={14}
                    stroke={
                      isThinkingEnabled
                        ? inputBackgroundColor
                        : onSurfaceColorVariant
                    }
                    strokeWidth={2}
                  />
                  <Text
                    style={[
                      styles.thinkingToggleText,
                      isThinkingEnabled
                        ? {color: inputBackgroundColor}
                        : {color: onSurfaceColorVariant},
                    ]}>
                    {l10n.components.chatInput.thinkingToggle.thinkText}
                  </Text>
                </TouchableOpacity>
              )}
            </View>

            {/* Right Controls */}
            <View style={styles.rightControls}>
              {/* Send/Stop Button */}
              {isStopVisible ? (
                <StopButton color={onSurfaceColor} onPress={onStopPress} />
              ) : palType === PalType.VIDEO && !isCameraActive ? (
                /* Compact Start Video Button for Video Pals */
                <TouchableOpacity
                  style={[
                    styles.compactVideoButton,
                    {
                      backgroundColor: onSurfaceColor,
                    },
                  ]}
                  onPress={onStartCamera}
                  accessibilityLabel="Start video analysis"
                  accessibilityRole="button">
                  <VideoRecorderIcon
                    width={16}
                    height={16}
                    stroke="white"
                    strokeWidth={2}
                  />
                  <Text style={styles.compactButtonText}>
                    {l10n.video.startCamera}
                  </Text>
                </TouchableOpacity>
              ) : (
                isSendButtonVisible && (
                  <View style={{opacity: sendButtonOpacity}}>
                    <SendButton
                      color={onSurfaceColor}
                      onPress={isSendButtonEnabled ? handleSend : () => {}}
                      touchableOpacityProps={{
                        disabled: !isSendButtonEnabled,
                      }}
                    />
                  </View>
                )
              )}
            </View>
          </View>
        </View>
      </View>
    );
  },
);



================================================
FILE: src/components/ChatInput/index.ts
================================================
export * from './ChatInput';



================================================
FILE: src/components/ChatInput/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {Theme} from '../../utils/types';
import {fontStyles} from '../../utils/theme';

export const createStyles = ({
  theme,
  isEditMode,
}: {
  theme: Theme;
  isEditMode: boolean;
}) =>
  StyleSheet.create({
    container: {
      flexDirection: 'column',
    },
    palBtn: {
      height: 28,
      width: 28,
      alignItems: 'center',
      justifyContent: 'center',
      borderRadius: 100,
    },
    plusButton: {
      height: 28,
      width: 28,
      alignItems: 'center',
      justifyContent: 'center',
      borderRadius: 100,
      opacity: 0.9,
    },
    thinkingToggle: {
      height: 28,
      width: 28,
      alignItems: 'center',
      justifyContent: 'center',
      borderRadius: 100,
      borderWidth: 1,
      marginRight: 8,
    },
    thinkingToggleLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      borderRadius: 16,
      borderWidth: 1,
      paddingHorizontal: 8,
      paddingVertical: 4,
      marginLeft: 8,
    },
    thinkingToggleLeftDisabled: {
      backgroundColor: 'transparent',
    },
    thinkingToggleText: {
      fontSize: 12,
      fontWeight: '500',
      marginLeft: 4,
    },
    thinkingToggleTextDisabled: {
      // Dynamic color will be applied via theme
    },
    palSelector: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 4,
    },
    inputWrapper: {
      flexDirection: 'row',
      alignItems: 'flex-start',
      gap: 13,
      flexShrink: 1,
    },
    input: {
      ...theme.fonts.inputTextStyle,
      color: theme.colors.inverseOnSurface,
      flex: 1,
      maxHeight: 150,
      paddingVertical: 0,
    },
    marginRight: {
      marginRight: 16,
    },
    inputContainer: {
      flex: 1,
      flexDirection: 'column',
      borderRadius: 12,
      overflow: 'hidden',
    },
    textInputArea: {
      flex: 1,
      paddingHorizontal: 24,
      paddingTop: 20,
      paddingBottom: 8,
    },
    controlBar: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 24,
      paddingVertical: 10,
      minHeight: 36,
    },
    leftControls: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 10,
      flex: 1,
    },
    rightControls: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    editBar: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      backgroundColor: theme.colors.surfaceVariant,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 12,
      borderTopLeftRadius: 12,
      borderTopRightRadius: 12,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outlineVariant,
      zIndex: 10, // Ensure edit bar stays above other elements
    },
    editBarText: {
      color: theme.colors.onSurfaceVariant,
    },
    editBarButton: {
      margin: 0,
    },
    inputRow: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'flex-end',
      paddingHorizontal: 24,
      paddingVertical: 20,
      marginTop: isEditMode ? 28 : 0,
    },
    palNameWrapper: {
      ...fontStyles.regular,
      color: theme.colors.inverseOnSurface,
      fontSize: 12,
    },
    palName: {
      fontSize: 12,
      color: theme.colors.inverseOnSurface,
      ...fontStyles.semibold,
    },
    // New compact pal name styles for control bar
    palNameCompact: {
      fontSize: 10,
      ...fontStyles.regular,
      color: theme.colors.inverseOnSurface,
    },
    palNameValueCompact: {
      fontSize: 10,
      ...fontStyles.semibold,
      color: theme.colors.inverseOnSurface,
    },
    // Image preview styles
    imagePreviewContainer: {
      marginVertical: 8,
      paddingHorizontal: 16,
    },
    imagePreviewContainerEditMode: {
      marginTop: 36, // Account for edit bar height (28px) + extra spacing (8px)
    },
    imageScrollContent: {
      paddingHorizontal: 4,
    },
    imageContainer: {
      marginHorizontal: 4,
      position: 'relative',
    },
    previewImage: {
      width: 80,
      height: 80,
      borderRadius: 8,
      backgroundColor: theme.colors.surfaceVariant,
    },
    removeImageButton: {
      position: 'absolute',
      top: 0,
      right: 0,
      margin: 0,
      padding: 0,
      backgroundColor: theme.colors.surface,
      borderRadius: 8,
      width: 25,
      height: 25,
    },
    inputInnerContainer: {
      flexShrink: 1,
      flexGrow: 1,
    },
    // Camera-specific styles
    cameraButton: {
      width: 40,
      height: 40,
      borderRadius: 24,
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: 8,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
      elevation: 5,
    },

    stopButton: {
      width: 48,
      height: 48,
      borderRadius: 24,
      justifyContent: 'center',
      alignItems: 'center',
      marginBottom: 8,
    },

    // Compact Video Button (for right side)
    compactVideoButton: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      paddingHorizontal: 14,
      paddingVertical: 8,
      borderRadius: 16,
      gap: 6,
      minWidth: 85,
    },
    compactButtonText: {
      color: 'white',
      fontSize: 12,
      fontWeight: '600',
    },
    // Prompt Label for Video Pals
    promptLabel: {
      marginBottom: 4,
    },
    inputWithLabel: {
      marginTop: 0,
    },
  });



================================================
FILE: src/components/ChatInput/__tests__/ChatInput.test.tsx
================================================
import {fireEvent, waitFor} from '@testing-library/react-native';
import * as React from 'react';
import {ScrollView, Alert} from 'react-native';
import {launchCamera, launchImageLibrary} from 'react-native-image-picker';
import {runInAction} from 'mobx';

import {user} from '../../../../jest/fixtures';
import {l10n} from '../../../utils/l10n';
import {UserContext} from '../../../utils';
import {ChatInput} from '../ChatInput';
import {PalType} from '../../PalsSheets/types';
import {render} from '../../../../jest/test-utils';
import {chatSessionStore} from '../../../store';

// Mock react-native-image-picker
jest.mock('react-native-image-picker', () => ({
  launchCamera: jest.fn(),
  launchImageLibrary: jest.fn(),
}));

jest.spyOn(Alert, 'alert');

const renderScrollable = () => <ScrollView />;

describe('input', () => {
  it('send button', () => {
    expect.assertions(2);
    const onSendPress = jest.fn();
    const {getByPlaceholderText, getByLabelText} = render(
      <UserContext.Provider value={user}>
        <ChatInput
          {...{
            onSendPress,
            sendButtonVisibilityMode: 'editing',
            textInputProps: {value: 'text'},
          }}
        />
      </UserContext.Provider>,
    );
    const textInput = getByPlaceholderText(
      l10n.en.components.chatInput.inputPlaceholder,
    );
    fireEvent.changeText(textInput, 'text');
    const button = getByLabelText(
      l10n.en.components.sendButton.accessibilityLabel,
    );
    fireEvent.press(button);
    expect(onSendPress).toHaveBeenCalledWith({text: 'text', type: 'text'});
    expect(textInput.props).toHaveProperty('value', 'text');
  });

  it('sends a text message', () => {
    expect.assertions(2);
    const onSendPress = jest.fn();
    const {getByPlaceholderText, getByLabelText} = render(
      <UserContext.Provider value={user}>
        <ChatInput
          {...{
            onSendPress,
            renderScrollable,
            sendButtonVisibilityMode: 'editing',
          }}
        />
      </UserContext.Provider>,
    );
    const textInput = getByPlaceholderText(
      l10n.en.components.chatInput.inputPlaceholder,
    );
    fireEvent.changeText(textInput, 'text');
    const button = getByLabelText(
      l10n.en.components.sendButton.accessibilityLabel,
    );
    fireEvent.press(button);
    expect(onSendPress).toHaveBeenCalledWith({text: 'text', type: 'text'});
    expect(textInput.props).toHaveProperty('value', '');
  });

  it('sends a text message if onChangeText and value are provided', () => {
    expect.assertions(2);
    const onSendPress = jest.fn();
    const value = 'value';
    const onChangeText = jest.fn(newValue => {
      rerender(
        <UserContext.Provider value={user}>
          <ChatInput
            {...{
              onSendPress,
              renderScrollable,
              sendButtonVisibilityMode: 'editing',
              textInputProps: {onChangeText, value: newValue},
            }}
          />
        </UserContext.Provider>,
      );
    });
    const {getByPlaceholderText, getByLabelText, rerender} = render(
      <UserContext.Provider value={user}>
        <ChatInput
          {...{
            onSendPress,
            renderScrollable,
            sendButtonVisibilityMode: 'editing',
            textInputProps: {onChangeText, value},
          }}
        />
      </UserContext.Provider>,
    );
    const textInput = getByPlaceholderText(
      l10n.en.components.chatInput.inputPlaceholder,
    );
    fireEvent.changeText(textInput, 'text');
    const button = getByLabelText(
      l10n.en.components.sendButton.accessibilityLabel,
    );
    fireEvent.press(button);
    expect(onSendPress).toHaveBeenCalledWith({text: 'text', type: 'text'});
    expect(textInput.props).toHaveProperty('value', 'text');
  });

  it('sends a text message if onChangeText is provided', () => {
    expect.assertions(2);
    const onSendPress = jest.fn();
    const onChangeText = jest.fn();
    const {getByPlaceholderText, getByLabelText} = render(
      <UserContext.Provider value={user}>
        <ChatInput
          {...{
            onSendPress,
            renderScrollable,
            sendButtonVisibilityMode: 'editing',
            textInputProps: {onChangeText},
          }}
        />
      </UserContext.Provider>,
    );
    const textInput = getByPlaceholderText(
      l10n.en.components.chatInput.inputPlaceholder,
    );
    fireEvent.changeText(textInput, 'text');
    const button = getByLabelText(
      l10n.en.components.sendButton.accessibilityLabel,
    );
    fireEvent.press(button);
    expect(onSendPress).toHaveBeenCalledWith({text: 'text', type: 'text'});
    expect(textInput.props).toHaveProperty('value', '');
  });

  it('sends a text message if value is provided', async () => {
    expect.assertions(2);
    const onSendPress = jest.fn();
    const value = 'value';
    const {getByPlaceholderText, getByLabelText} = render(
      <UserContext.Provider value={user}>
        <ChatInput
          {...{
            onSendPress,
            renderScrollable,
            sendButtonVisibilityMode: 'editing',
            textInputProps: {value},
          }}
        />
      </UserContext.Provider>,
    );
    const textInput = getByPlaceholderText(
      l10n.en.components.chatInput.inputPlaceholder,
    );
    await waitFor(() => fireEvent.changeText(textInput, 'text')); // Wait for the input to update

    const button = getByLabelText(
      l10n.en.components.sendButton.accessibilityLabel,
    );
    await waitFor(() => fireEvent.press(button)); // Wait for the press event to be processed

    expect(onSendPress).toHaveBeenCalledWith({text: value, type: 'text'});
    expect(textInput.props).toHaveProperty('value', value);
  });

  it('sends a text message if defaultValue is provided', () => {
    expect.assertions(2);
    const onSendPress = jest.fn();
    const defaultValue = 'defaultValue';
    const {getByPlaceholderText, getByLabelText} = render(
      <UserContext.Provider value={user}>
        <ChatInput
          {...{
            onSendPress,
            renderScrollable,
            sendButtonVisibilityMode: 'editing',
            textInputProps: {defaultValue},
          }}
        />
      </UserContext.Provider>,
    );
    const textInput = getByPlaceholderText(
      l10n.en.components.chatInput.inputPlaceholder,
    );
    const button = getByLabelText(
      l10n.en.components.sendButton.accessibilityLabel,
    );
    fireEvent.press(button);
    expect(onSendPress).toHaveBeenCalledWith({
      text: defaultValue,
      type: 'text',
    });
    expect(textInput.props).toHaveProperty('value', '');
  });

  it('shows stop button when isStopVisible is true', () => {
    expect.assertions(1);
    const onStopPress = jest.fn();
    const onSendPress = jest.fn();
    const {getByTestId} = render(
      <UserContext.Provider value={user}>
        <ChatInput
          {...{
            onSendPress,
            onStopPress,
            isStopVisible: true,
            sendButtonVisibilityMode: 'editing',
          }}
        />
      </UserContext.Provider>,
    );
    const stopButton = getByTestId('stop-button');
    fireEvent.press(stopButton);
    expect(onStopPress).toHaveBeenCalledTimes(1);
  });

  it('shows plus button for image upload when showImageUpload is true', () => {
    expect.assertions(1);
    const onSendPress = jest.fn();
    const {getByLabelText} = render(
      <UserContext.Provider value={user}>
        <ChatInput
          {...{
            onSendPress,
            showImageUpload: true,
            sendButtonVisibilityMode: 'editing',
          }}
        />
      </UserContext.Provider>,
    );

    const plusButton = getByLabelText('Add image');
    expect(plusButton).toBeDefined();
  });

  it('does not show plus button when showImageUpload is false', () => {
    expect.assertions(1);
    const onSendPress = jest.fn();
    const {queryByLabelText} = render(
      <UserContext.Provider value={user}>
        <ChatInput
          {...{
            onSendPress,
            showImageUpload: false,
            sendButtonVisibilityMode: 'editing',
          }}
        />
      </UserContext.Provider>,
    );

    const plusButton = queryByLabelText('Add image');
    expect(plusButton).toBeNull();
  });

  it('renders plus button correctly when vision is enabled', () => {
    expect.assertions(2);
    const onSendPress = jest.fn();
    const {getByLabelText} = render(
      <UserContext.Provider value={user}>
        <ChatInput
          {...{
            onSendPress,
            showImageUpload: true,
            isVisionEnabled: true,
            sendButtonVisibilityMode: 'editing',
          }}
        />
      </UserContext.Provider>,
    );

    const plusButton = getByLabelText('Add image');
    expect(plusButton).toBeTruthy();
    expect(plusButton.props.accessibilityState.disabled).toBe(false);
  });

  it('shows pal selector button', () => {
    expect.assertions(1);
    const onSendPress = jest.fn();
    const onPalBtnPress = jest.fn();
    const {getByLabelText} = render(
      <UserContext.Provider value={user}>
        <ChatInput
          {...{
            onSendPress,
            onPalBtnPress,
            sendButtonVisibilityMode: 'editing',
          }}
        />
      </UserContext.Provider>,
    );

    const palButton = getByLabelText('Select Pal');
    fireEvent.press(palButton);
    expect(onPalBtnPress).toHaveBeenCalledTimes(1);
  });

  it('shows video button for video pal type', () => {
    expect.assertions(1);
    const onSendPress = jest.fn();
    const onStartCamera = jest.fn();
    const {getByText} = render(
      <UserContext.Provider value={user}>
        <ChatInput
          {...{
            onSendPress,
            onStartCamera,
            palType: PalType.VIDEO,
            sendButtonVisibilityMode: 'editing',
          }}
        />
      </UserContext.Provider>,
    );

    const videoButton = getByText('Start Camera');
    fireEvent.press(videoButton);
    expect(onStartCamera).toHaveBeenCalledTimes(1);
  });

  it('handles prompt text change for video pal', () => {
    expect.assertions(1);
    const onSendPress = jest.fn();
    const onPromptTextChange = jest.fn();
    const {getByPlaceholderText} = render(
      <UserContext.Provider value={user}>
        <ChatInput
          {...{
            onSendPress,
            onPromptTextChange,
            palType: PalType.VIDEO,
            promptText: 'initial text',
            sendButtonVisibilityMode: 'editing',
          }}
        />
      </UserContext.Provider>,
    );

    const textInput = getByPlaceholderText(l10n.en.video.promptPlaceholder);
    fireEvent.changeText(textInput, 'new text');
    expect(onPromptTextChange).toHaveBeenCalledWith('new text');
  });

  it('disables plus button when vision is not enabled', () => {
    expect.assertions(1);
    const onSendPress = jest.fn();
    const {getByLabelText} = render(
      <UserContext.Provider value={user}>
        <ChatInput
          {...{
            onSendPress,
            showImageUpload: true,
            isVisionEnabled: false,
            sendButtonVisibilityMode: 'editing',
          }}
        />
      </UserContext.Provider>,
    );

    const plusButton = getByLabelText('Add image');
    expect(plusButton.props.accessibilityState.disabled).toBe(true);
  });

  it('enables plus button when vision is enabled', () => {
    expect.assertions(1);
    const onSendPress = jest.fn();
    const {getByLabelText} = render(
      <UserContext.Provider value={user}>
        <ChatInput
          {...{
            onSendPress,
            showImageUpload: true,
            isVisionEnabled: true,
            sendButtonVisibilityMode: 'editing',
          }}
        />
      </UserContext.Provider>,
    );

    const plusButton = getByLabelText('Add image');
    expect(plusButton.props.accessibilityState.disabled).toBe(false);
  });

  it('shows send button with always visibility mode', () => {
    expect.assertions(1);
    const onSendPress = jest.fn();
    const {getByLabelText} = render(
      <UserContext.Provider value={user}>
        <ChatInput
          {...{
            onSendPress,
            sendButtonVisibilityMode: 'always',
          }}
        />
      </UserContext.Provider>,
    );

    const sendButton = getByLabelText(
      l10n.en.components.sendButton.accessibilityLabel,
    );
    expect(sendButton).toBeTruthy();
  });

  it('sends message with images when images are selected', () => {
    expect.assertions(1);
    const onSendPress = jest.fn();
    const {getByPlaceholderText, getByLabelText} = render(
      <UserContext.Provider value={user}>
        <ChatInput
          {...{
            onSendPress,
            sendButtonVisibilityMode: 'editing',
          }}
        />
      </UserContext.Provider>,
    );

    const textInput = getByPlaceholderText(
      l10n.en.components.chatInput.inputPlaceholder,
    );
    fireEvent.changeText(textInput, 'test message');

    const sendButton = getByLabelText(
      l10n.en.components.sendButton.accessibilityLabel,
    );
    fireEvent.press(sendButton);

    expect(onSendPress).toHaveBeenCalledWith({
      text: 'test message',
      type: 'text',
    });
  });

  describe('Image Upload Functionality', () => {
    beforeEach(() => {
      jest.clearAllMocks();
    });

    it('opens image upload menu when plus button is pressed', () => {
      const onSendPress = jest.fn();
      const {getByLabelText} = render(
        <UserContext.Provider value={user}>
          <ChatInput
            {...{
              onSendPress,
              showImageUpload: true,
              isVisionEnabled: true,
              sendButtonVisibilityMode: 'editing',
            }}
          />
        </UserContext.Provider>,
      );

      const plusButton = getByLabelText('Add image');
      fireEvent.press(plusButton);

      // Menu should be visible after pressing plus button
      // This would need to be tested with the actual menu implementation
    });

    it('handles camera photo capture successfully', async () => {
      const mockResult = {
        assets: [{uri: 'file://test-photo.jpg'}],
      };
      (launchCamera as jest.Mock).mockResolvedValue(mockResult);

      const onSendPress = jest.fn();
      const {getByLabelText} = render(
        <UserContext.Provider value={user}>
          <ChatInput
            {...{
              onSendPress,
              showImageUpload: true,
              isVisionEnabled: true,
              sendButtonVisibilityMode: 'editing',
            }}
          />
        </UserContext.Provider>,
      );

      const plusButton = getByLabelText('Add image');
      fireEvent.press(plusButton);

      // Since testing the menu interaction is complex, let's test that the camera function works
      // by calling it directly (this tests the core functionality)
      expect(launchCamera).toHaveBeenCalledTimes(0); // Initially not called

      // The plus button should open the menu, but testing menu interaction is complex
      // For now, we'll test that the component renders correctly with image upload enabled
      expect(plusButton).toBeTruthy();
    });

    it('handles camera error gracefully', async () => {
      const mockError = new Error('Camera error');
      (launchCamera as jest.Mock).mockRejectedValue(mockError);

      const onSendPress = jest.fn();
      const {getByLabelText} = render(
        <UserContext.Provider value={user}>
          <ChatInput
            {...{
              onSendPress,
              showImageUpload: true,
              isVisionEnabled: true,
              sendButtonVisibilityMode: 'editing',
            }}
          />
        </UserContext.Provider>,
      );

      const plusButton = getByLabelText('Add image');
      fireEvent.press(plusButton);

      // Test that the component renders correctly even when camera errors are configured
      expect(plusButton).toBeTruthy();
      expect(launchCamera).toHaveBeenCalledTimes(0); // Not called until menu interaction
    });

    it('handles image library selection successfully', async () => {
      const mockResult = {
        assets: [{uri: 'file://test-library-photo.jpg'}],
      };
      (launchImageLibrary as jest.Mock).mockResolvedValue(mockResult);

      const onSendPress = jest.fn();
      const {getByLabelText} = render(
        <UserContext.Provider value={user}>
          <ChatInput
            {...{
              onSendPress,
              showImageUpload: true,
              isVisionEnabled: true,
              sendButtonVisibilityMode: 'editing',
            }}
          />
        </UserContext.Provider>,
      );

      const plusButton = getByLabelText('Add image');
      fireEvent.press(plusButton);

      // Test that the component renders correctly with image library functionality
      expect(plusButton).toBeTruthy();
      expect(launchImageLibrary).toHaveBeenCalledTimes(0); // Not called until menu interaction
    });

    it('sends message with selected images', () => {
      const onSendPress = jest.fn();
      const defaultImages = ['file://image1.jpg', 'file://image2.jpg'];
      const {getByPlaceholderText, getByLabelText} = render(
        <UserContext.Provider value={user}>
          <ChatInput
            {...{
              onSendPress,
              showImageUpload: true,
              isVisionEnabled: true,
              sendButtonVisibilityMode: 'editing',
              defaultImages,
            }}
          />
        </UserContext.Provider>,
      );

      const textInput = getByPlaceholderText(
        l10n.en.components.chatInput.inputPlaceholder,
      );
      fireEvent.changeText(textInput, 'test with images');

      const sendButton = getByLabelText(
        l10n.en.components.sendButton.accessibilityLabel,
      );
      fireEvent.press(sendButton);

      expect(onSendPress).toHaveBeenCalledWith({
        text: 'test with images',
        type: 'text',
        imageUris: defaultImages,
      });
    });
  });

  describe('Edit Mode Functionality', () => {
    beforeEach(() => {
      jest.clearAllMocks();
    });

    it('shows edit bar when in edit mode', () => {
      runInAction(() => {
        chatSessionStore.isEditMode = true;
      });
      const onSendPress = jest.fn();
      const onCancelEdit = jest.fn();

      render(
        <UserContext.Provider value={user}>
          <ChatInput
            {...{
              onSendPress,
              onCancelEdit,
              sendButtonVisibilityMode: 'editing',
            }}
          />
        </UserContext.Provider>,
      );

      expect(onCancelEdit).not.toHaveBeenCalled(); // Should not be called on render
    });

    it('calls onCancelEdit when cancel button is pressed', () => {
      const onSendPress = jest.fn();
      const onCancelEdit = jest.fn();

      // Start with edit mode enabled
      runInAction(() => {
        chatSessionStore.isEditMode = true;
      });

      const {getByTestId} = render(
        <UserContext.Provider value={user}>
          <ChatInput
            {...{
              onSendPress,
              onCancelEdit,
              sendButtonVisibilityMode: 'editing',
            }}
          />
        </UserContext.Provider>,
      );

      // Find and press the cancel button in the edit bar
      const cancelButton = getByTestId('icon-button');
      fireEvent.press(cancelButton);

      expect(onCancelEdit).toHaveBeenCalledTimes(1);
    });
  });
});



================================================
FILE: src/components/ChatInput/__tests__/ChatInputThinking.test.tsx
================================================
/**
 * Tests for ChatInput thinking toggle functionality
 */

import React from 'react';
import {render, fireEvent} from '@testing-library/react-native';
import {ChatInput} from '../ChatInput';
import {UserContext} from '../../../utils';

// Mock the theme hook
jest.mock('../../../hooks', () => ({
  useTheme: () => ({
    colors: {
      primary: '#007AFF',
      onPrimary: '#FFFFFF',
      surface: '#FFFFFF',
      onSurface: '#000000',
      inverseOnSurface: '#FFFFFF',
      inverseSurface: '#000000',
      onSurfaceVariant: '#666666',
    },
    fonts: {
      inputTextStyle: {
        fontSize: 16,
        fontFamily: 'System',
      },
    },
  }),
}));

// Mock the stores
jest.mock('../../../store', () => ({
  chatSessionStore: {
    activePalId: null,
  },
  modelStore: {
    activeModel: null,
  },
  palStore: {
    pals: [],
  },
  uiStore: {
    colorScheme: 'light',
  },
}));

// Mock the icons
jest.mock('../../../assets/icons', () => ({
  ChevronUpIcon: 'ChevronUpIcon',
  VideoRecorderIcon: 'VideoRecorderIcon',
  PlusIcon: 'PlusIcon',
  AtomIcon: 'AtomIcon',
}));

// Mock the components
jest.mock('../../SendButton', () => ({
  SendButton: 'SendButton',
}));

jest.mock('../../StopButton', () => ({
  StopButton: 'StopButton',
}));

jest.mock('../../Menu', () => ({
  Menu: {
    Item: 'MenuItem',
  },
}));

const mockUser = {
  id: 'test-user',
  firstName: 'Test',
  lastName: 'User',
};

describe('ChatInput Thinking Toggle', () => {
  const defaultProps = {
    onSendPress: jest.fn(),
    onStopPress: jest.fn(),
    onPalBtnPress: jest.fn(),
    isStopVisible: false,
    sendButtonVisibilityMode: 'editing' as const,
    isPickerVisible: false,
    textInputProps: {},
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should not render thinking toggle when showThinkingToggle is false', () => {
    const {queryByLabelText} = render(
      <UserContext.Provider value={mockUser}>
        <ChatInput
          {...defaultProps}
          showThinkingToggle={false}
          isThinkingEnabled={false}
          onThinkingToggle={jest.fn()}
        />
      </UserContext.Provider>,
    );

    expect(queryByLabelText(/thinking mode/i)).toBeNull();
  });

  it('should render thinking toggle when showThinkingToggle is true', () => {
    const {getByLabelText} = render(
      <UserContext.Provider value={mockUser}>
        <ChatInput
          {...defaultProps}
          showThinkingToggle={true}
          isThinkingEnabled={false}
          onThinkingToggle={jest.fn()}
        />
      </UserContext.Provider>,
    );

    expect(getByLabelText('Enable thinking mode')).toBeTruthy();
  });

  it('should show correct accessibility label when thinking is disabled', () => {
    const {getByLabelText} = render(
      <UserContext.Provider value={mockUser}>
        <ChatInput
          {...defaultProps}
          showThinkingToggle={true}
          isThinkingEnabled={false}
          onThinkingToggle={jest.fn()}
        />
      </UserContext.Provider>,
    );

    expect(getByLabelText('Enable thinking mode')).toBeTruthy();
  });

  it('should show correct accessibility label when thinking is enabled', () => {
    const {getByLabelText} = render(
      <UserContext.Provider value={mockUser}>
        <ChatInput
          {...defaultProps}
          showThinkingToggle={true}
          isThinkingEnabled={true}
          onThinkingToggle={jest.fn()}
        />
      </UserContext.Provider>,
    );

    expect(getByLabelText('Disable thinking mode')).toBeTruthy();
  });

  it('should call onThinkingToggle with correct value when pressed', () => {
    const mockOnThinkingToggle = jest.fn();
    const {getByLabelText} = render(
      <UserContext.Provider value={mockUser}>
        <ChatInput
          {...defaultProps}
          showThinkingToggle={true}
          isThinkingEnabled={false}
          onThinkingToggle={mockOnThinkingToggle}
        />
      </UserContext.Provider>,
    );

    const toggleButton = getByLabelText('Enable thinking mode');
    fireEvent.press(toggleButton);

    expect(mockOnThinkingToggle).toHaveBeenCalledWith(true);
  });

  it('should call onThinkingToggle with false when thinking is enabled and pressed', () => {
    const mockOnThinkingToggle = jest.fn();
    const {getByLabelText} = render(
      <UserContext.Provider value={mockUser}>
        <ChatInput
          {...defaultProps}
          showThinkingToggle={true}
          isThinkingEnabled={true}
          onThinkingToggle={mockOnThinkingToggle}
        />
      </UserContext.Provider>,
    );

    const toggleButton = getByLabelText('Disable thinking mode');
    fireEvent.press(toggleButton);

    expect(mockOnThinkingToggle).toHaveBeenCalledWith(false);
  });

  it('should render thinking toggle even when streaming', () => {
    const {getByLabelText} = render(
      <UserContext.Provider value={mockUser}>
        <ChatInput
          {...defaultProps}
          isStreaming={true}
          showThinkingToggle={true}
          isThinkingEnabled={false}
          onThinkingToggle={jest.fn()}
        />
      </UserContext.Provider>,
    );

    expect(getByLabelText('Enable thinking mode')).toBeTruthy();
  });

  it('should render thinking toggle even when stop is visible', () => {
    const {getByLabelText} = render(
      <UserContext.Provider value={mockUser}>
        <ChatInput
          {...defaultProps}
          isStopVisible={true}
          showThinkingToggle={true}
          isThinkingEnabled={false}
          onThinkingToggle={jest.fn()}
        />
      </UserContext.Provider>,
    );

    expect(getByLabelText('Enable thinking mode')).toBeTruthy();
  });

  it('should handle missing onThinkingToggle callback gracefully', () => {
    const {getByLabelText} = render(
      <UserContext.Provider value={mockUser}>
        <ChatInput
          {...defaultProps}
          showThinkingToggle={true}
          isThinkingEnabled={false}
          onThinkingToggle={undefined}
        />
      </UserContext.Provider>,
    );

    const toggleButton = getByLabelText('Enable thinking mode');

    // Should not throw when pressed
    expect(() => fireEvent.press(toggleButton)).not.toThrow();
  });
});



================================================
FILE: src/components/ChatPalModelPickerSheet/ChatPalModelPickerSheet.tsx
================================================
import React, {useRef, useEffect, useContext} from 'react';
import {Alert, Dimensions, View, Pressable} from 'react-native';
import {observer} from 'mobx-react';
import {Text} from 'react-native-paper';
import BottomSheet, {
  BottomSheetFlatList,
  BottomSheetFlatListMethods,
  BottomSheetScrollView,
  BottomSheetView,
} from '@gorhom/bottom-sheet';

import {useTheme} from '../../hooks';
import {createStyles} from './styles';
import {modelStore, palStore, chatSessionStore} from '../../store';
import {CustomBackdrop} from '../Sheet/CustomBackdrop';
import {getModelSkills, L10nContext, Model} from '../../utils';
//import {useSafeAreaInsets} from 'react-native-safe-area-context';
import {CloseIcon} from '../../assets/icons';
import {PalType} from '../PalsSheets/types';
import {SkillsDisplay} from '../SkillsDisplay';

type Tab = 'models' | 'pals';

interface ChatPalModelPickerSheetProps {
  isVisible: boolean;
  chatInputHeight: number;
  onClose: () => void;
  onModelSelect?: (modelId: string) => void;
  onPalSelect?: (palId: string | undefined) => void;
  keyboardHeight: number;
}

const ObservedSkillsDisplay = observer(({model}) => {
  const hasProjectionModelWarning =
    model.supportsMultimodal &&
    model.visionEnabled &&
    modelStore.getProjectionModelStatus(model).state === 'missing';

  const toggleVision = async () => {
    if (!model.supportsMultimodal) {
      return;
    }
    try {
      await modelStore.setModelVisionEnabled(
        model.id,
        !modelStore.getModelVisionPreference(model),
      );
    } catch (error) {
      console.error('Failed to toggle vision setting:', error);
      // The error is already handled in setModelVisionEnabled (vision state is reverted)
      // We could show a toast/snackbar here if needed
    }
  };
  const visionEnabled = modelStore.getModelVisionPreference(model);

  return (
    <SkillsDisplay
      model={model}
      hasProjectionModelWarning={hasProjectionModelWarning}
      onVisionPress={toggleVision}
      onProjectionWarningPress={() =>
        model.defaultProjectionModel &&
        modelStore.checkSpaceAndDownload(model.defaultProjectionModel)
      }
      visionEnabled={visionEnabled}
    />
  );
});

export const ChatPalModelPickerSheet = observer(
  ({
    isVisible,
    onClose,
    onModelSelect,
    onPalSelect,
    chatInputHeight,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    keyboardHeight,
  }: ChatPalModelPickerSheetProps) => {
    const [activeTab, setActiveTab] = React.useState<Tab>('models');
    const theme = useTheme();
    const l10n = useContext(L10nContext);
    // const insets = useSafeAreaInsets();
    const styles = createStyles({theme});
    const bottomSheetRef = useRef<BottomSheet>(null);
    const flatListRef = useRef<BottomSheetFlatListMethods>(null);

    const TABS = React.useMemo(
      () => [
        {
          id: 'models' as Tab,
          label: l10n.components.chatPalModelPickerSheet.modelsTab,
        },
        {
          id: 'pals' as Tab,
          label: l10n.components.chatPalModelPickerSheet.palsTab,
        },
      ],
      [
        l10n.components.chatPalModelPickerSheet.modelsTab,
        l10n.components.chatPalModelPickerSheet.palsTab,
      ],
    );

    useEffect(() => {
      if (isVisible) {
        bottomSheetRef.current?.expand();
      } else {
        bottomSheetRef.current?.close();
      }
    }, [isVisible]);

    const handleTabPress = (tab: Tab, index: number) => {
      setActiveTab(tab);
      flatListRef.current?.scrollToIndex({
        index,
        animated: true,
      });
    };

    const renderTab = (tab: Tab, label: string, index: number) => (
      <Pressable
        key={tab}
        style={[styles.tab, activeTab === tab && styles.activeTab]}
        onPress={() => handleTabPress(tab, index)}>
        <Text
          style={[styles.tabText, activeTab === tab && styles.activeTabText]}>
          {label}
        </Text>
      </Pressable>
    );

    const handleModelSelect = React.useCallback(
      async (model: (typeof modelStore.availableModels)[0]) => {
        try {
          onModelSelect?.(model.id);
          onClose();
          modelStore.initContext(model);
        } catch (e) {
          console.log(`Error: ${e}`);
        }
      },
      [onModelSelect, onClose],
    );

    const handlePalSelect = React.useCallback(
      async (pal: (typeof palStore.pals)[0] | undefined) => {
        await chatSessionStore.setActivePal(pal?.id);
        if (
          pal?.defaultModel &&
          modelStore.activeModel &&
          pal.defaultModel?.id !== modelStore.activeModelId
        ) {
          const palDefaultModel = modelStore.availableModels.find(
            m => m.id === pal.defaultModel?.id,
          );
          if (palDefaultModel) {
            Alert.alert(
              l10n.components.chatPalModelPickerSheet.confirmationTitle,
              l10n.components.chatPalModelPickerSheet.modelSwitchMessage.replace(
                '{{modelName}}',
                palDefaultModel.name,
              ),
              [
                {
                  text: l10n.components.chatPalModelPickerSheet.keepButton,
                  style: 'cancel',
                },
                {
                  text: l10n.components.chatPalModelPickerSheet.switchButton,
                  onPress: () => {
                    modelStore.initContext(palDefaultModel);
                  },
                },
              ],
            );
          }
        }
        onPalSelect?.(pal?.id);
        onClose();
      },
      [onPalSelect, onClose, l10n.components.chatPalModelPickerSheet],
    );

    const renderDisablePalItem = React.useCallback(() => {
      const noActivePal = !chatSessionStore.activePalId;
      if (noActivePal) {
        return null;
      }
      return (
        <Pressable
          key="disable-pal"
          style={styles.listItem}
          onPress={() => handlePalSelect(undefined)}>
          <CloseIcon stroke={theme.colors.onSurface} />
          <View style={styles.itemContent}>
            <Text style={styles.itemTitle}>
              {l10n.components.chatPalModelPickerSheet.noPal}
            </Text>
            <Text style={styles.itemSubtitle}>
              {l10n.components.chatPalModelPickerSheet.disablePal}
            </Text>
          </View>
        </Pressable>
      );
    }, [
      styles,
      theme.colors.onSurface,
      l10n.components.chatPalModelPickerSheet.noPal,
      l10n.components.chatPalModelPickerSheet.disablePal,
      handlePalSelect,
    ]);

    const renderModelItem = React.useCallback(
      (model: Model) => {
        const isActiveModel = model.id === modelStore.activeModelId;
        const modelSkills = getModelSkills(model)
          .flatMap(skill => skill.labelKey)
          .join(', ');
        return (
          <Pressable
            key={model.id}
            style={[styles.listItem, isActiveModel && styles.activeListItem]}
            onPress={() => handleModelSelect(model)}>
            <View style={styles.itemContent}>
              <Text
                style={[
                  styles.itemTitle,
                  isActiveModel && styles.activeItemTitle,
                ]}>
                {model.name}
              </Text>
              {modelSkills && <ObservedSkillsDisplay model={model} />}
            </View>
          </Pressable>
        );
      },
      [styles, handleModelSelect],
    );

    const palTypeText = React.useCallback(
      (palType: PalType): string => {
        switch (palType) {
          case PalType.ASSISTANT:
            return l10n.components.chatPalModelPickerSheet.assistantType;
          case PalType.ROLEPLAY:
            return l10n.components.chatPalModelPickerSheet.roleplayType;
          case PalType.VIDEO:
            return l10n.components.chatPalModelPickerSheet.videoType;
          default:
            return '';
        }
      },
      [l10n.components.chatPalModelPickerSheet],
    );

    const renderPalItem = React.useCallback(
      (pal: (typeof palStore.pals)[0]) => {
        const isActivePal = pal.id === chatSessionStore.activePalId;
        return (
          <Pressable
            key={pal.id}
            style={[styles.listItem, isActivePal && styles.activeListItem]}
            onPress={() => handlePalSelect(pal)}>
            <View style={styles.itemContent}>
              <Text
                style={[
                  styles.itemTitle,
                  isActivePal && styles.activeItemTitle,
                ]}>
                {pal.name}
              </Text>
              <Text
                style={[
                  styles.itemSubtitle,
                  isActivePal && styles.activeItemSubtitle,
                ]}>
                {palTypeText(pal.palType)}
              </Text>
            </View>
          </Pressable>
        );
      },
      [
        styles.listItem,
        styles.activeListItem,
        styles.itemContent,
        styles.itemTitle,
        styles.activeItemTitle,
        styles.itemSubtitle,
        styles.activeItemSubtitle,
        palTypeText,
        handlePalSelect,
      ],
    );

    const renderContent = React.useCallback(
      ({item}: {item: (typeof TABS)[0]}) => (
        <View style={{width: Dimensions.get('window').width}}>
          <BottomSheetScrollView
            contentContainerStyle={{paddingBottom: chatInputHeight + 66}}>
            {item.id === 'models'
              ? modelStore.availableModels.map(renderModelItem)
              : [renderDisablePalItem(), ...palStore.pals.map(renderPalItem)]}
          </BottomSheetScrollView>
        </View>
      ),
      [chatInputHeight, renderDisablePalItem, renderModelItem, renderPalItem],
    );

    const onViewableItemsChanged = React.useCallback(
      ({viewableItems}: {viewableItems: any[]}) => {
        if (viewableItems[0]) {
          setActiveTab(viewableItems[0].item.id);
        }
      },
      [],
    );

    const viewabilityConfig = React.useRef({
      itemVisiblePercentThreshold: 90,
      minimumViewTime: 100,
    }).current;

    // If the snapPoints not memoized, the sheet gets closed when the tab is changed for the first time.
    const snapPoints = React.useMemo(() => ['70%'], []);

    return (
      <BottomSheet
        ref={bottomSheetRef}
        index={-1}
        onClose={onClose}
        enablePanDownToClose
        snapPoints={snapPoints} // Dynamic sizing is not working properly in all situations, like keyboard open/close android/ios ...
        enableDynamicSizing={false}
        backdropComponent={isVisible ? CustomBackdrop : null} // on android we need this check to ensure it doenst' block interaction
        backgroundStyle={{
          backgroundColor: theme.colors.background,
        }}
        // Dynamic sizing is not working properly in all situations, like keyboard open/close android/ios ...
        //maxDynamicContentSize={
        //  Dimensions.get('screen').height - insets.top - 16 - keyboardHeight
        //}
        handleIndicatorStyle={{
          backgroundColor: theme.colors.primary,
        }}
        // Add these props to better handle gestures
        enableContentPanningGesture={false}
        enableHandlePanningGesture>
        <BottomSheetView>
          <View style={styles.tabs}>
            {TABS.map((tab, index) => renderTab(tab.id, tab.label, index))}
          </View>
          <BottomSheetFlatList
            ref={flatListRef}
            data={TABS}
            renderItem={renderContent}
            bounces={false}
            showsVerticalScrollIndicator={false}
            keyExtractor={item => item.id}
            horizontal
            pagingEnabled
            showsHorizontalScrollIndicator={false}
            onViewableItemsChanged={onViewableItemsChanged}
            viewabilityConfig={viewabilityConfig}
          />
        </BottomSheetView>
      </BottomSheet>
    );
  },
);



================================================
FILE: src/components/ChatPalModelPickerSheet/index.ts
================================================
export {ChatPalModelPickerSheet} from './ChatPalModelPickerSheet';



================================================
FILE: src/components/ChatPalModelPickerSheet/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {Theme} from '../../utils/types';

export const createStyles = ({theme}: {theme: Theme}) =>
  StyleSheet.create({
    sheetContainer: {
      backgroundColor: theme.colors.surface,
      flex: 1,
    },
    handle: {
      backgroundColor: theme.colors.outline,
      width: 40,
      height: 4,
      borderRadius: 2,
    },
    title: {
      fontSize: 20,
      fontWeight: '600',
      color: theme.colors.onSurface,
      textAlign: 'center',
      marginVertical: 16,
    },
    tabs: {
      flexDirection: 'row',
      paddingHorizontal: 16,
      alignItems: 'center',
      height: 50,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outline,
    },
    tab: {
      paddingVertical: 8,
      paddingHorizontal: 16,
      marginRight: 8,
      borderRadius: 8,
    },
    activeTab: {
      backgroundColor: theme.colors.primaryContainer,
    },
    tabText: {
      color: theme.colors.onSurface,
    },
    activeTabText: {
      color: theme.colors.onPrimaryContainer,
    },
    listItem: {
      flexDirection: 'row',
      alignItems: 'center',
      padding: 16,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.outline,
    },
    activeListItem: {
      backgroundColor: theme.colors.tertiaryContainer,
      borderColor: theme.colors.primary,
    },
    itemContent: {
      flex: 1,
      marginLeft: 12,
    },
    itemTitle: {
      fontSize: 16,
      color: theme.colors.onSurface,
      marginBottom: 4,
    },
    activeItemTitle: {
      color: theme.colors.onTertiaryContainer,
    },
    itemSubtitle: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    activeItemSubtitle: {
      color: theme.colors.onTertiaryContainer,
    },
    scrollviewContainer: {
      paddingBottom: theme.spacing.default,
    },
    tabList: {
      flexGrow: 0,
    },
  });



================================================
FILE: src/components/ChatPalModelPickerSheet/__tests__/ChatPalModelPickerSheet.test.tsx
================================================
import React from 'react';
import {render, fireEvent, waitFor} from '@testing-library/react-native';
import {Alert} from 'react-native';

import {ChatPalModelPickerSheet} from '../ChatPalModelPickerSheet';
import {modelStore, chatSessionStore} from '../../../store';
import {user} from '../../../../jest/fixtures';
import {UserContext, L10nContext} from '../../../utils';
import {l10n} from '../../../utils/l10n';

// Mock stores
jest.mock('../../../store', () => ({
  modelStore: {
    availableModels: [
      {
        id: 'model1',
        name: 'Test Model 1',
        isDownloaded: true,
        supportsMultimodal: false,
      },
      {
        id: 'model2',
        name: 'Test Model 2',
        isDownloaded: true,
        supportsMultimodal: true,
      },
    ],
    activeModel: {id: 'model1', name: 'Test Model 1'},
    activeModelId: 'model1',
    initContext: jest.fn(),
    hasRequiredProjectionModel: jest.fn().mockReturnValue(true),
    getProjectionModelStatus: jest.fn().mockReturnValue({
      isAvailable: true,
      state: 'not_needed',
    }),
    getModelVisionPreference: jest.fn().mockReturnValue(true),
  },
  palStore: {
    pals: [
      {
        id: 'pal1',
        name: 'Test Assistant',
        palType: 'assistant', // Use string literal instead of enum
        defaultModel: {id: 'model1', name: 'Test Model 1'},
      },
      {
        id: 'pal2',
        name: 'Test Roleplay',
        palType: 'roleplay', // Use string literal instead of enum
        defaultModel: {id: 'model2', name: 'Test Model 2'},
      },
    ],
  },
  chatSessionStore: {
    activePalId: 'pal1',
    setActivePal: jest.fn(),
  },
}));

// Mock @gorhom/bottom-sheet
jest.mock('@gorhom/bottom-sheet', () => {
  const mockReact = require('react');
  return {
    __esModule: true,
    default: mockReact.forwardRef(({children}: any, ref: any) =>
      mockReact.createElement('View', {ref, testID: 'bottom-sheet'}, children),
    ),
    BottomSheetFlatList: ({data, renderItem}: any) =>
      mockReact.createElement(
        'View',
        {testID: 'bottom-sheet-flatlist'},
        data?.map((item: any, index: number) =>
          mockReact.createElement(
            'View',
            {key: item.id},
            renderItem({item, index}),
          ),
        ),
      ),
    BottomSheetFlatListMethods: {},
    BottomSheetScrollView: ({children}: any) =>
      mockReact.createElement(
        'View',
        {testID: 'bottom-sheet-scrollview'},
        children,
      ),
    BottomSheetView: ({children}: any) =>
      mockReact.createElement('View', {testID: 'bottom-sheet-view'}, children),
  };
});

// Mock Alert
jest.spyOn(Alert, 'alert');

const defaultProps = {
  isVisible: true,
  chatInputHeight: 60,
  onClose: jest.fn(),
  onModelSelect: jest.fn(),
  onPalSelect: jest.fn(),
  keyboardHeight: 0,
};

describe('ChatPalModelPickerSheet', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders correctly when visible', () => {
    const {getByTestId} = render(
      <UserContext.Provider value={user}>
        <L10nContext.Provider value={l10n.en}>
          <ChatPalModelPickerSheet {...defaultProps} />
        </L10nContext.Provider>
      </UserContext.Provider>,
    );

    expect(getByTestId('bottom-sheet')).toBeTruthy();
    expect(getByTestId('bottom-sheet-view')).toBeTruthy();
  });

  it('does not render when not visible', () => {
    const {queryByTestId} = render(
      <UserContext.Provider value={user}>
        <L10nContext.Provider value={l10n.en}>
          <ChatPalModelPickerSheet {...defaultProps} isVisible={false} />
        </L10nContext.Provider>
      </UserContext.Provider>,
    );

    expect(queryByTestId('bottom-sheet')).toBeTruthy(); // Component still renders but sheet is closed
  });

  it('displays models and pals tabs', () => {
    const {getByText} = render(
      <UserContext.Provider value={user}>
        <L10nContext.Provider value={l10n.en}>
          <ChatPalModelPickerSheet {...defaultProps} />
        </L10nContext.Provider>
      </UserContext.Provider>,
    );

    expect(
      getByText(l10n.en.components.chatPalModelPickerSheet.modelsTab),
    ).toBeTruthy();
    expect(
      getByText(l10n.en.components.chatPalModelPickerSheet.palsTab),
    ).toBeTruthy();
  });

  it('switches tabs when tab is pressed', () => {
    const {getByText} = render(
      <UserContext.Provider value={user}>
        <L10nContext.Provider value={l10n.en}>
          <ChatPalModelPickerSheet {...defaultProps} />
        </L10nContext.Provider>
      </UserContext.Provider>,
    );

    const palsTab = getByText(
      l10n.en.components.chatPalModelPickerSheet.palsTab,
    );
    fireEvent.press(palsTab);

    // Tab should be active after press
    expect(palsTab).toBeTruthy();
  });

  it('calls onModelSelect when model is selected', async () => {
    const {getByText} = render(
      <UserContext.Provider value={user}>
        <L10nContext.Provider value={l10n.en}>
          <ChatPalModelPickerSheet {...defaultProps} />
        </L10nContext.Provider>
      </UserContext.Provider>,
    );

    // Find and press a model (this would need to be adjusted based on actual rendering)
    const modelItem = getByText('Test Model 1');
    fireEvent.press(modelItem);

    await waitFor(() => {
      expect(defaultProps.onModelSelect).toHaveBeenCalledWith('model1');
      expect(defaultProps.onClose).toHaveBeenCalled();
      expect(modelStore.initContext).toHaveBeenCalled();
    });
  });

  it('calls onPalSelect when pal is selected', async () => {
    const {getByText} = render(
      <UserContext.Provider value={user}>
        <L10nContext.Provider value={l10n.en}>
          <ChatPalModelPickerSheet {...defaultProps} />
        </L10nContext.Provider>
      </UserContext.Provider>,
    );

    // Switch to pals tab first
    const palsTab = getByText(
      l10n.en.components.chatPalModelPickerSheet.palsTab,
    );
    fireEvent.press(palsTab);

    // Find and press a pal
    const palItem = getByText('Test Assistant');
    fireEvent.press(palItem);

    await waitFor(() => {
      expect(chatSessionStore.setActivePal).toHaveBeenCalledWith('pal1');
      expect(defaultProps.onPalSelect).toHaveBeenCalledWith('pal1');
      expect(defaultProps.onClose).toHaveBeenCalled();
    });
  });

  it('shows model switch confirmation when pal has different default model', async () => {
    const {getByText} = render(
      <UserContext.Provider value={user}>
        <L10nContext.Provider value={l10n.en}>
          <ChatPalModelPickerSheet {...defaultProps} />
        </L10nContext.Provider>
      </UserContext.Provider>,
    );

    // Switch to pals tab
    const palsTab = getByText(
      l10n.en.components.chatPalModelPickerSheet.palsTab,
    );
    fireEvent.press(palsTab);

    // Select pal with different default model
    const palItem = getByText('Test Roleplay');
    fireEvent.press(palItem);

    await waitFor(() => {
      expect(Alert.alert).toHaveBeenCalledWith(
        l10n.en.components.chatPalModelPickerSheet.confirmationTitle,
        expect.stringContaining('Test Model 2'),
        expect.arrayContaining([
          expect.objectContaining({
            text: l10n.en.components.chatPalModelPickerSheet.keepButton,
          }),
          expect.objectContaining({
            text: l10n.en.components.chatPalModelPickerSheet.switchButton,
          }),
        ]),
      );
    });
  });

  it('calls onClose when sheet is closed', () => {
    const {getByTestId} = render(
      <UserContext.Provider value={user}>
        <L10nContext.Provider value={l10n.en}>
          <ChatPalModelPickerSheet {...defaultProps} />
        </L10nContext.Provider>
      </UserContext.Provider>,
    );

    // The BottomSheet component should have onClose prop set
    // Since we're mocking BottomSheet, we can test that onClose is passed correctly
    // by checking that the component renders without errors and the onClose prop exists
    expect(getByTestId('bottom-sheet')).toBeTruthy();

    // In a real scenario, the onClose would be called by the BottomSheet component
    // when the user swipes down or taps the backdrop
    // For testing purposes, we can verify the component structure is correct
  });
});



================================================
FILE: src/components/ChatView/ChatView.tsx
================================================
import * as React from 'react';
import {
  FlatList,
  FlatListProps,
  InteractionManager,
  LayoutAnimation,
  StatusBar,
  StatusBarProps,
  View,
  TouchableOpacity,
  Animated,
  Platform,
} from 'react-native';

import dayjs from 'dayjs';
import {observer} from 'mobx-react';
import calendar from 'dayjs/plugin/calendar';
import {useHeaderHeight} from '@react-navigation/elements';
import {useSafeAreaInsets} from 'react-native-safe-area-context';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import {
  KeyboardAvoidingView,
  useKeyboardAnimation,
} from 'react-native-keyboard-controller';

import {
  useComponentSize,
  useKeyboardDimensions,
} from '../KeyboardAccessoryView/hooks';

import {usePrevious, useTheme, useMessageActions} from '../../hooks';

import ImageView from './ImageView';
import {createStyles} from './styles';

import {chatSessionStore, modelStore, palStore} from '../../store';

import {MessageType, User} from '../../utils/types';
import {calculateChatMessages, unwrap, UserContext} from '../../utils';
import {L10nContext} from '../../utils';
import {PalType} from '../PalsSheets/types';

import {
  Message,
  MessageTopLevelProps,
  CircularActivityIndicator,
  ChatInput,
  ChatInputAdditionalProps,
  ChatInputTopLevelProps,
  Menu,
  LoadingBubble,
  ChatPalModelPickerSheet,
  ChatHeader,
  ChatEmptyPlaceholder,
  VideoPalEmptyPlaceholder,
  ContentReportSheet,
} from '..';
import {
  AlertIcon,
  CopyIcon,
  GridIcon,
  PencilLineIcon,
  RefreshIcon,
} from '../../assets/icons';

type MenuItem = {
  label: string;
  onPress?: () => void;
  icon?: () => React.ReactNode;
  disabled: boolean;
  submenu?: SubMenuItem[];
};

type SubMenuItem = {
  label: string;
  onPress: () => void;
  disabled?: boolean;
  width?: number;
};

// Untestable
/* istanbul ignore next */
const animate = () => {
  LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);
};

dayjs.extend(calendar);

export type ChatTopLevelProps = ChatInputTopLevelProps & MessageTopLevelProps;

export interface ChatProps extends ChatTopLevelProps {
  /** If {@link ChatProps.dateFormat} and/or {@link ChatProps.timeFormat} is not enough to
   * customize date headers in your case, use this to return an arbitrary
   * string based on a `dateTime` of a particular message. Can be helpful to
   * return "Today" if `dateTime` is today. IMPORTANT: this will replace
   * all default date headers, so you must handle all cases yourself, like
   * for example today, yesterday and before. Or you can just return the same
   * date header for any message. */
  customDateHeaderText?: (dateTime: number) => string;
  /** Custom content to display between the header and chat list */
  customContent?: React.ReactNode;
  /** Allows you to customize the date format. IMPORTANT: only for the date,
   * do not return time here. @see {@link ChatProps.timeFormat} to customize the time format.
   * @see {@link ChatProps.customDateHeaderText} for more customization. */
  dateFormat?: string;
  /** Disable automatic image preview on tap. */
  disableImageGallery?: boolean;
  /** Allows you to change what the user sees when there are no messages.
   * `emptyChatPlaceholder` and `emptyChatPlaceholderTextStyle` are ignored
   * in this case. */
  emptyState?: () => React.ReactNode;
  /** Use this to enable `LayoutAnimation`. Experimental on Android (same as React Native). */
  enableAnimation?: boolean;
  flatListProps?: Partial<FlatListProps<MessageType.DerivedAny[]>>;
  inputProps?: ChatInputAdditionalProps;
  /** Used for pagination (infinite scroll) together with {@link ChatProps.onEndReached}.
   * When true, indicates that there are no more pages to load and
   * pagination will not be triggered. */
  isLastPage?: boolean;
  /** Indicates if the AI is currently streaming tokens */
  isStreaming?: boolean;
  /** Indicates if the AI is currently thinking (processing but not yet streaming) */
  isThinking?: boolean;
  messages: MessageType.Any[];
  /** Used for pagination (infinite scroll). Called when user scrolls
   * to the very end of the list (minus `onEndReachedThreshold`).
   * See {@link ChatProps.flatListProps} to set it up. */
  onEndReached?: () => Promise<void>;
  /** Show user names for received messages. Useful for a group chat. Will be
   * shown only on text messages. */
  showUserNames?: boolean;
  /** Whether to show the image upload button in the chat input */
  showImageUpload?: boolean;
  /** Whether to enable vision mode for the chat input */
  isVisionEnabled?: boolean;
  /**
   * Allows you to customize the time format. IMPORTANT: only for the time,
   * do not return date here. @see {@link ChatProps.dateFormat} to customize the date format.
   * @see {@link ChatProps.customDateHeaderText} for more customization.
   */
  timeFormat?: string;
  user: User;
}

/** Entry component, represents the complete chat */
export const ChatView = observer(
  ({
    customContent,
    customDateHeaderText,
    dateFormat,
    disableImageGallery,
    enableAnimation,
    flatListProps,
    inputProps,
    isLastPage,
    isStopVisible,
    isStreaming = false,
    isThinking = false,
    messages,
    onEndReached,
    onMessageLongPress: externalOnMessageLongPress,
    onMessagePress,
    onPreviewDataFetched,
    onSendPress,
    onStopPress,
    renderBubble,
    renderCustomMessage,
    renderFileMessage,
    renderImageMessage,
    renderTextMessage,
    sendButtonVisibilityMode = 'editing',
    showUserAvatars = false,
    showUserNames = false,
    showImageUpload = false,
    isVisionEnabled = false,
    textInputProps,
    timeFormat,
    usePreviewData = true,
    user,
  }: ChatProps) => {
    const l10n = React.useContext(L10nContext);
    const theme = useTheme();
    const styles = createStyles({theme});

    const [inputText, setInputText] = React.useState('');
    const [inputImages, setInputImages] = React.useState<string[]>([]);
    const [isPickerVisible, setIsPickerVisible] = React.useState(false);

    const animationRef = React.useRef(false);
    const list = React.useRef<FlatList<MessageType.DerivedAny>>(null);
    const insets = useSafeAreaInsets();
    const {progress} = useKeyboardAnimation();
    const headerHeight = useHeaderHeight();
    const activePalId = chatSessionStore.activePalId;
    const activePal = palStore.pals.find(pal => pal.id === activePalId);

    const {onLayout, size} = useComponentSize();
    const {onLayout: onLayoutChatInput, size: chatInputHeight} =
      useComponentSize();

    const bottomComponentHeight = React.useMemo(() => {
      const height = chatInputHeight.height;
      return height;
    }, [chatInputHeight.height]);

    const listPaddingBottom = progress.interpolate({
      inputRange: [0, 1],
      outputRange: [
        bottomComponentHeight,
        bottomComponentHeight - insets.bottom,
      ],
    });

    const {keyboardHeight: keyboardHeight} = useKeyboardDimensions(true);
    const translateY = progress.interpolate({
      inputRange: [0, 1],
      outputRange: [
        0,
        Math.max(0, Math.min(insets.bottom, keyboardHeight - insets.bottom)),
      ],
    });

    const [isImageViewVisible, setIsImageViewVisible] = React.useState(false);
    const [isNextPageLoading, setNextPageLoading] = React.useState(false);
    const [imageViewIndex, setImageViewIndex] = React.useState(0);
    const [stackEntry, setStackEntry] = React.useState<StatusBarProps>({});

    const [showScrollButton, setShowScrollButton] = React.useState(false);

    React.useEffect(() => {
      if (activePal) {
        if (!modelStore.activeModel && activePal.defaultModel) {
          const palDefaultModel = modelStore.availableModels.find(
            m => m.id === activePal.defaultModel?.id,
          );

          if (palDefaultModel) {
            // Initialize the model context
            modelStore.initContext(palDefaultModel);
          }
        }
      }
    }, [activePal]);

    const handleScroll = React.useCallback(event => {
      const {contentOffset} = event.nativeEvent;
      const isAtTop = contentOffset.y <= 80;
      setShowScrollButton(!isAtTop);
    }, []);

    const scrollToBottom = React.useCallback(() => {
      list.current?.scrollToOffset({
        animated: true,
        offset: 0,
      });
    }, []);

    const wrappedOnSendPress = React.useCallback(
      async (message: MessageType.PartialText) => {
        if (chatSessionStore.isEditMode) {
          await chatSessionStore.commitEdit();
        }
        onSendPress(message);
        setInputText('');
      },
      [onSendPress],
    );

    const handleCancelEdit = React.useCallback(() => {
      setInputText('');
      setInputImages([]);
      chatSessionStore.exitEditMode();
    }, []);

    const {handleCopy, handleEdit, handleTryAgain, handleTryAgainWith} =
      useMessageActions({
        user,
        messages,
        handleSendPress: wrappedOnSendPress,
        setInputText,
        setInputImages,
      });

    const {chatMessages, gallery} = calculateChatMessages(messages, user, {
      customDateHeaderText,
      dateFormat,
      showUserNames,
      timeFormat,
    });

    const previousChatMessages = usePrevious(chatMessages);

    React.useEffect(() => {
      if (
        chatMessages[0]?.type !== 'dateHeader' &&
        chatMessages[0]?.id !== previousChatMessages?.[0]?.id &&
        chatMessages[0]?.author?.id === user.id
      ) {
        list.current?.scrollToOffset({
          animated: true,
          offset: 0,
        });
      }
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [chatMessages]);

    // Untestable
    /* istanbul ignore next */
    if (animationRef.current && enableAnimation) {
      InteractionManager.runAfterInteractions(animate);
    }

    React.useEffect(() => {
      // Untestable
      /* istanbul ignore next */
      if (animationRef.current && enableAnimation) {
        InteractionManager.runAfterInteractions(animate);
      } else {
        animationRef.current = true;
      }
    }, [enableAnimation, messages]);

    const handleEndReached = React.useCallback(
      // Ignoring because `scroll` event for some reason doesn't trigger even basic
      // `onEndReached`, impossible to test.
      // TODO: Verify again later
      /* istanbul ignore next */
      async ({distanceFromEnd}: {distanceFromEnd: number}) => {
        if (
          !onEndReached ||
          isLastPage ||
          distanceFromEnd <= 0 ||
          messages.length === 0 ||
          isNextPageLoading
        ) {
          return;
        }

        setNextPageLoading(true);
        await onEndReached?.();
        setNextPageLoading(false);
      },
      [isLastPage, isNextPageLoading, messages.length, onEndReached],
    );

    const handleImagePress = React.useCallback(
      (message: MessageType.Image) => {
        setImageViewIndex(
          gallery.findIndex(
            image => image.id === message.id && image.uri === message.uri,
          ),
        );
        setIsImageViewVisible(true);
        setStackEntry(
          StatusBar.pushStackEntry({
            barStyle: 'light-content',
            animated: true,
          }),
        );
      },
      [gallery],
    );

    const handleMessagePress = React.useCallback(
      (message: MessageType.Any) => {
        if (message.type === 'image' && !disableImageGallery) {
          handleImagePress(message);
        }
        onMessagePress?.(message);
      },
      [disableImageGallery, handleImagePress, onMessagePress],
    );

    // TODO: Tapping on a close button results in the next warning:
    // `An update to ImageViewing inside a test was not wrapped in act(...).`
    /* istanbul ignore next */
    const handleRequestClose = () => {
      setIsImageViewVisible(false);
      StatusBar.popStackEntry(stackEntry);
    };

    const keyExtractor = React.useCallback(
      ({id}: MessageType.DerivedAny) => id,
      [],
    );

    const [menuVisible, setMenuVisible] = React.useState(false);
    const [menuPosition, setMenuPosition] = React.useState({x: 0, y: 0});
    const [selectedMessage, setSelectedMessage] =
      React.useState<MessageType.Any | null>(null);
    const [isReportSheetVisible, setIsReportSheetVisible] =
      React.useState(false);

    const handleMessageLongPress = React.useCallback(
      (message: MessageType.Any, event: any) => {
        if (message.type !== 'text') {
          externalOnMessageLongPress?.(message);
          return;
        }

        const {pageX, pageY} = event.nativeEvent;
        setMenuPosition({x: pageX, y: pageY});
        setSelectedMessage(message);
        setMenuVisible(true);
        externalOnMessageLongPress?.(message);
      },
      [externalOnMessageLongPress],
    );

    const handleMenuDismiss = React.useCallback(() => {
      setMenuVisible(false);
      setSelectedMessage(null);
    }, []);

    const {
      copy: copyLabel,
      regenerate: regenerateLabel,
      regenerateWith: regenerateWithLabel,
      edit: editLabel,
      reportContent: reportContentLabel,
    } = l10n.components.chatView.menuItems;

    const menuItems = React.useMemo((): MenuItem[] => {
      if (!selectedMessage || selectedMessage.type !== 'text') {
        return [];
      }

      const isAuthor = selectedMessage.author.id === user.id;
      const hasActiveModel = modelStore.activeModelId !== undefined;
      const models = modelStore.availableModels || [];

      const baseItems: MenuItem[] = [
        {
          label: copyLabel,
          onPress: () => {
            handleCopy(selectedMessage);
            handleMenuDismiss();
          },
          icon: () => <CopyIcon stroke={theme.colors.primary} />,
          disabled: false,
        },
      ];

      if (!isAuthor) {
        baseItems.push({
          label: regenerateLabel,
          onPress: () => {
            handleTryAgain(selectedMessage);
            handleMenuDismiss();
          },
          icon: () => <RefreshIcon stroke={theme.colors.primary} />,
          disabled: !hasActiveModel,
        });

        baseItems.push({
          label: regenerateWithLabel,
          icon: () => <GridIcon stroke={theme.colors.primary} />,
          disabled: false,
          submenu: models.map(model => ({
            label: model.name,
            width: Math.min(300, size.width),
            onPress: () => {
              handleTryAgainWith(model.id, selectedMessage);
              handleMenuDismiss();
            },
          })),
        });
      }

      if (isAuthor) {
        baseItems.push({
          label: editLabel,
          onPress: () => {
            handleEdit(selectedMessage);
            handleMenuDismiss();
          },
          icon: () => <PencilLineIcon stroke={theme.colors.primary} />,
          disabled: !hasActiveModel,
        });
      }

      baseItems.push({
        label: reportContentLabel,
        onPress: () => {
          setIsReportSheetVisible(true);
          handleMenuDismiss();
        },
        icon: () => <AlertIcon stroke={theme.colors.primary} />,
        disabled: false,
      });

      return baseItems;
    }, [
      selectedMessage,
      user.id,
      handleCopy,
      handleTryAgain,
      handleTryAgainWith,
      handleEdit,
      handleMenuDismiss,
      size.width,
      theme.colors.primary,
      copyLabel,
      regenerateLabel,
      regenerateWithLabel,
      editLabel,
      reportContentLabel,
    ]);

    const renderMenuItem = React.useCallback(
      (item: MenuItem, index: number) => {
        if (item.submenu) {
          return (
            <React.Fragment key={index}>
              <Menu.Item
                label={item.label}
                leadingIcon={item.icon}
                disabled={item.disabled}
                submenu={item.submenu.map(
                  (subItem: SubMenuItem, subIndex: number) => (
                    <React.Fragment key={subIndex}>
                      <Menu.Item
                        key={subIndex}
                        label={subItem.label}
                        onPress={subItem.onPress}
                        disabled={subItem.disabled}
                      />
                    </React.Fragment>
                  ),
                )}
              />
            </React.Fragment>
          );
        }

        return (
          <React.Fragment key={index}>
            <Menu.Item
              label={item.label}
              onPress={item.onPress}
              leadingIcon={item.icon}
              disabled={item.disabled}
            />
          </React.Fragment>
        );
      },
      [],
    );

    const renderMessage = React.useCallback(
      ({item: message}: {item: MessageType.DerivedAny; index: number}) => {
        const messageWidth =
          showUserAvatars &&
          message.type !== 'dateHeader' &&
          message.author?.id !== user.id
            ? Math.floor(Math.min(size.width * 0.9, 900))
            : Math.floor(Math.min(size.width * 0.92, 900));

        const roundBorder =
          message.type !== 'dateHeader' && message.nextMessageInGroup;
        const showAvatar =
          message.type !== 'dateHeader' && !message.nextMessageInGroup;
        const showName = message.type !== 'dateHeader' && message.showName;
        const showStatus = message.type !== 'dateHeader' && message.showStatus;

        return (
          <View>
            <Message
              {...{
                enableAnimation,
                message,
                messageWidth,
                onMessageLongPress: handleMessageLongPress,
                onMessagePress: handleMessagePress,
                onPreviewDataFetched,
                renderBubble,
                renderCustomMessage,
                renderFileMessage,
                renderImageMessage,
                renderTextMessage,
                roundBorder,
                showAvatar,
                showName,
                showStatus,
                showUserAvatars,
                usePreviewData,
              }}
            />
          </View>
        );
      },
      [
        enableAnimation,
        handleMessageLongPress,
        handleMessagePress,
        onPreviewDataFetched,
        renderBubble,
        renderCustomMessage,
        renderFileMessage,
        renderImageMessage,
        renderTextMessage,
        showUserAvatars,
        size.width,
        usePreviewData,
        user.id,
      ],
    );

    const renderListEmptyComponent = React.useCallback(() => {
      // Show VideoPalEmptyPlaceholder for video pal, otherwise show regular ChatEmptyPlaceholder
      if (inputProps?.palType === PalType.VIDEO) {
        return (
          <VideoPalEmptyPlaceholder
            bottomComponentHeight={bottomComponentHeight}
          />
        );
      }

      return (
        <ChatEmptyPlaceholder
          bottomComponentHeight={bottomComponentHeight}
          onSelectModel={() => setIsPickerVisible(true)}
        />
      );
    }, [bottomComponentHeight, setIsPickerVisible, inputProps?.palType]);

    const renderListFooterComponent = React.useCallback(
      () =>
        // Impossible to test, see `handleEndReached` function
        /* istanbul ignore next */
        isNextPageLoading ? (
          <View style={styles.footerLoadingPage}>
            <CircularActivityIndicator color={theme.colors.primary} size={16} />
          </View>
        ) : (
          <View style={styles.footer} />
        ),
      [
        isNextPageLoading,
        styles.footerLoadingPage,
        styles.footer,
        theme.colors.primary,
      ],
    );

    const renderListHeaderComponent = React.useCallback(
      () => (isThinking ? <LoadingBubble /> : null),
      [isThinking],
    );

    const renderChatList = React.useCallback(
      () => (
        <>
          <Animated.FlatList
            automaticallyAdjustContentInsets={false}
            contentContainerStyle={[
              styles.flatListContentContainer,
              // eslint-disable-next-line react-native/no-inline-styles
              {
                justifyContent:
                  chatMessages.length !== 0 ? undefined : 'center',
                paddingTop: listPaddingBottom, // Use animated padding
              },
            ]}
            initialNumToRender={10}
            ListEmptyComponent={renderListEmptyComponent}
            ListFooterComponent={renderListFooterComponent}
            ListHeaderComponent={renderListHeaderComponent}
            maxToRenderPerBatch={6}
            onEndReachedThreshold={0.75}
            style={styles.flatList}
            showsVerticalScrollIndicator={false}
            onScroll={handleScroll}
            {...unwrap(flatListProps)}
            data={chatMessages}
            inverted={chatMessages.length > 0}
            keyboardDismissMode="interactive"
            keyExtractor={keyExtractor}
            onEndReached={handleEndReached}
            ref={list}
            renderItem={renderMessage}
            maintainVisibleContentPosition={{
              autoscrollToTopThreshold: 20,
              minIndexForVisible: isStreaming ? 1 : 0,
            }}
          />
          {showScrollButton && (
            <Animated.View style={{transform: [{translateY}]}}>
              <TouchableOpacity
                style={[
                  styles.scrollToBottomButton,
                  {bottom: bottomComponentHeight + 20},
                ]}
                onPress={scrollToBottom}>
                <Icon
                  name="chevron-down"
                  size={24}
                  color={theme.colors.onPrimary}
                />
              </TouchableOpacity>
            </Animated.View>
          )}
        </>
      ),
      [
        styles.flatListContentContainer,
        styles.flatList,
        styles.scrollToBottomButton,
        chatMessages,
        listPaddingBottom,
        renderListEmptyComponent,
        renderListFooterComponent,
        renderListHeaderComponent,
        handleScroll,
        flatListProps,
        keyExtractor,
        handleEndReached,
        renderMessage,
        isStreaming,
        showScrollButton,
        translateY,
        bottomComponentHeight,
        scrollToBottom,
        theme.colors.onPrimary,
      ],
    );

    const [_selectedModel, setSelectedModel] = React.useState<string | null>(
      null,
    );
    const [_selectedPal, setSelectedPal] = React.useState<string | undefined>();

    const handleModelSelect = React.useCallback((model: string) => {
      setSelectedModel(model);
      setIsPickerVisible(false);
    }, []);

    const handlePalSelect = React.useCallback((pal: string | undefined) => {
      setSelectedPal(pal);
      setIsPickerVisible(false);
    }, []);

    const inputBackgroundColor = activePal?.color?.[1]
      ? activePal.color?.[1]
      : Platform.OS === 'ios'
      ? theme.colors.surface
      : theme.colors.secondaryContainer; // Since on Android, we don't have shadow enabled, use secondaryContainer for better contrast
    // Use surface for Android when new architecture is enabled

    return (
      <UserContext.Provider value={user}>
        <View style={styles.container} onLayout={onLayout}>
          <KeyboardAvoidingView
            behavior="padding"
            keyboardVerticalOffset={headerHeight}
            style={styles.container}>
            <View style={styles.chatContainer}>
              <ChatHeader />
              {customContent}
              {renderChatList()}
              <Animated.View
                onLayout={onLayoutChatInput}
                style={[
                  styles.inputContainer,
                  // eslint-disable-next-line react-native/no-inline-styles
                  {
                    paddingBottom: insets.bottom,
                    transform: [{translateY}],
                    zIndex: 10,
                  },
                  {backgroundColor: inputBackgroundColor},
                ]}>
                <ChatInput
                  {...{
                    ...unwrap(inputProps),
                    isStreaming,
                    onSendPress: wrappedOnSendPress,
                    onStopPress,
                    chatInputHeight,
                    inputBackgroundColor,
                    onCancelEdit: handleCancelEdit,
                    onPalBtnPress: () => setIsPickerVisible(!isPickerVisible),
                    isStopVisible,
                    isPickerVisible,
                    sendButtonVisibilityMode,
                    showImageUpload,
                    isVisionEnabled,
                    defaultImages: inputImages,
                    onDefaultImagesChange: setInputImages,
                    textInputProps: {
                      ...textInputProps,
                      // Only override value and onChangeText if not using promptText
                      ...(!(inputProps?.palType === PalType.VIDEO) && {
                        value: inputText,
                        onChangeText: setInputText,
                      }),
                    },
                  }}
                />
              </Animated.View>
              <ChatPalModelPickerSheet
                isVisible={isPickerVisible}
                onClose={() => setIsPickerVisible(false)}
                onModelSelect={handleModelSelect}
                onPalSelect={handlePalSelect}
                chatInputHeight={chatInputHeight.height}
                keyboardHeight={keyboardHeight}
              />
            </View>
          </KeyboardAvoidingView>
          <ImageView
            imageIndex={imageViewIndex}
            images={gallery}
            onRequestClose={handleRequestClose}
            visible={isImageViewVisible}
          />
          <Menu
            visible={menuVisible}
            onDismiss={handleMenuDismiss}
            selectable={false}
            anchor={menuPosition}>
            {menuItems.map(renderMenuItem)}
          </Menu>
          <ContentReportSheet
            isVisible={isReportSheetVisible}
            onClose={() => setIsReportSheetVisible(false)}
          />
        </View>
      </UserContext.Provider>
    );
  },
);



================================================
FILE: src/components/ChatView/ImageView.android.ts
================================================
import ImageView from 'react-native-image-viewing';

export default ImageView;



================================================
FILE: src/components/ChatView/ImageView.ios.ts
================================================
import ImageView from 'react-native-image-viewing';

export default ImageView;



================================================
FILE: src/components/ChatView/ImageView.tsx
================================================
import * as React from 'react';
import {ImageRequireSource, ImageURISource, View} from 'react-native';

interface Props {
  imageIndex: number;
  images: Array<ImageURISource | ImageRequireSource>;
  onRequestClose: () => void;
  visible: boolean;
}

const ImageView = (_: Props) => {
  return <View />;
};

export default ImageView;



================================================
FILE: src/components/ChatView/index.ts
================================================
export * from './ChatView';



================================================
FILE: src/components/ChatView/styles.ts
================================================
import {Platform, StyleSheet} from 'react-native';
import {Theme} from '../../utils/types';

export const createStyles = ({theme}: {theme: Theme}) =>
  StyleSheet.create({
    container: {
      //backgroundColor: theme.colors.primary,
      flex: 1,
    },
    flatList: {
      backgroundColor: theme.colors.background,
      height: '100%',
    },
    flatListContentContainer: {
      flexGrow: 1,
    },
    footer: {
      height: 16,
    },
    footerLoadingPage: {
      alignItems: 'center',
      justifyContent: 'center',
      marginTop: 16,
      height: 32,
    },
    header: {
      height: 4,
    },
    menu: {
      width: 170,
    },
    scrollToBottomButton: {
      position: 'absolute',
      right: 16,
      backgroundColor: theme.colors.primary,
      width: 40,
      height: 40,
      borderRadius: 20,
      justifyContent: 'center',
      alignItems: 'center',
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.25,
      shadowRadius: 3.84,
      elevation: 5,
    },
    inputContainer: {
      backgroundColor: theme.colors.primary,
      borderTopLeftRadius: theme.borders.inputBorderRadius,
      borderTopRightRadius: theme.borders.inputBorderRadius,
      position: 'absolute',
      left: 0,
      right: 0,
      bottom: 0,
      ...(!theme.dark
        ? Platform.select({
            ios: {
              shadowColor: theme.colors.shadow,
              shadowOffset: {width: 0, height: -2},
              shadowOpacity: 0.1,
              shadowRadius: 8,
            },
            android: {
              // Add boxShadow/dropShadow if new architecture is enabled
            },
          })
        : {}),
    },
    chatContainer: {
      flex: 1,
      position: 'relative',
      backgroundColor: theme.colors.background,
    },
    customBottomComponent: {
      position: 'absolute',
      bottom: 0,
      left: 0,
      right: 0,
    },
  });



================================================
FILE: src/components/ChatView/__tests__/ChatView.test.tsx
================================================
//import {fireEvent, render} from '@testing-library/react-native';
import * as React from 'react';

import {
  fileMessage,
  imageMessage,
  textMessage,
  user,
} from '../../../../jest/fixtures';
import {l10n} from '../../../utils/l10n';
import {MessageType} from '../../../utils/types';
import {ChatView} from '../ChatView';
import {fireEvent, render} from '../../../../jest/test-utils';
import {ChatEmptyPlaceholder} from '../../ChatEmptyPlaceholder';

jest.useFakeTimers();

// Mock ChatEmptyPlaceholder component
jest.mock('../../ChatEmptyPlaceholder', () => ({
  ChatEmptyPlaceholder: jest.fn(() => null),
}));

describe('chat', () => {
  it('renders image preview', async () => {
    const messages = [
      textMessage,
      imageMessage,
      fileMessage,
      {
        ...textMessage,
        createdAt: 1,
        id: 'new-uuidv4',
        status: 'delivered' as const,
      },
    ];
    const onSendPress = jest.fn();
    const {getByTestId, getByText} = render(
      <ChatView messages={messages} onSendPress={onSendPress} user={user} />,
      {withSafeArea: true, withNavigation: true},
    );

    const button = getByTestId('message-image').parent;
    expect(button).toBeDefined();
    if (button) {
      fireEvent.press(button);
    }
    const closeButton = getByText('‚úï');
    expect(closeButton).toBeDefined();
  });

  it('sends a text message', () => {
    expect.assertions(1);
    const messages = [
      textMessage,
      fileMessage,
      {
        ...imageMessage,
        createdAt: 1,
      },
      {
        ...textMessage,
        createdAt: 2,
        id: 'new-uuidv4',
        status: 'sending' as const,
      },
    ];
    const onSendPress = jest.fn();
    const {getByLabelText, getByPlaceholderText} = render(
      <ChatView
        messages={messages}
        onSendPress={onSendPress}
        textInputProps={{defaultValue: 'text'}}
        user={user}
      />,
      {withNavigation: true},
    );
    const textInput = getByPlaceholderText(
      l10n.en.components.chatInput.inputPlaceholder,
    );
    fireEvent.changeText(textInput, 'text');

    const button = getByLabelText(
      l10n.en.components.sendButton.accessibilityLabel,
    );
    fireEvent.press(button);
    expect(onSendPress).toHaveBeenCalledWith({text: 'text', type: 'text'});
  });

  it('opens file on a file message tap', () => {
    expect.assertions(1);
    const messages = [fileMessage, textMessage, imageMessage];
    const onSendPress = jest.fn();
    const onFilePress = jest.fn();
    const onMessagePress = (message: MessageType.Any) => {
      if (message.type === 'file') {
        onFilePress(message);
      }
    };
    const {getByLabelText} = render(
      <ChatView
        onMessagePress={onMessagePress}
        messages={messages}
        onSendPress={onSendPress}
        showUserAvatars
        user={user}
      />,
      {withNavigation: true},
    );

    const button = getByLabelText(
      l10n.en.components.fileMessage.fileButtonAccessibilityLabel,
    );
    fireEvent.press(button);
    expect(onFilePress).toHaveBeenCalledWith(fileMessage);
  });

  it('opens image on image message press', () => {
    expect.assertions(1);
    const messages = [imageMessage];
    const onSendPress = jest.fn();
    const onImagePress = jest.fn();
    const onMessagePress = (message: MessageType.Any) => {
      if (message.type === 'image') {
        onImagePress(message);
      }
    };

    const onMessageLongPress = jest.fn();

    const {getByTestId} = render(
      <ChatView
        onMessagePress={onMessagePress}
        onMessageLongPress={onMessageLongPress}
        messages={messages}
        onSendPress={onSendPress}
        showUserAvatars
        user={user}
      />,
      {withNavigation: true},
    );

    const button = getByTestId('ContentContainer');
    fireEvent.press(button);
    expect(onImagePress).toHaveBeenCalledWith(imageMessage);
  });

  it('fires image on image message long press', () => {
    expect.assertions(1);
    const messages = [imageMessage];
    const onSendPress = jest.fn();
    const onImagePress = jest.fn();
    const onMessagePress = (message: MessageType.Any) => {
      if (message.type === 'image') {
        onImagePress(message);
      }
    };

    const onMessageLongPress = jest.fn();

    const {getByTestId} = render(
      <ChatView
        onMessagePress={onMessagePress}
        onMessageLongPress={onMessageLongPress}
        messages={messages}
        onSendPress={onSendPress}
        showUserAvatars
        user={user}
      />,
      {withNavigation: true},
    );

    const button = getByTestId('ContentContainer');
    fireEvent(button, 'onLongPress');
    expect(onMessageLongPress).toHaveBeenCalledWith(imageMessage);
  });

  it('renders ChatEmptyPlaceholder when no messages', () => {
    expect.assertions(1);
    const messages = [];
    const onSendPress = jest.fn();
    const onMessagePress = jest.fn();
    render(
      <ChatView
        messages={messages}
        onMessagePress={onMessagePress}
        onSendPress={onSendPress}
        user={user}
      />,
      {withNavigation: true},
    );

    expect(ChatEmptyPlaceholder).toHaveBeenCalled();
  });
});



================================================
FILE: src/components/Checkbox/Checkbox.tsx
================================================
import React from 'react';
import {View, TouchableOpacity} from 'react-native';

import {Icon} from 'react-native-paper';

import {useTheme} from '../../hooks';

import {createStyles} from './styles';

type Props = {
  testID?: string;
  checked: boolean;
  onPress: () => void;
  size?: number;
  disabled?: boolean;
  children?: React.ReactNode;
};

export const Checkbox: React.FC<Props> = ({
  testID,
  checked,
  onPress,
  size = 20,
  disabled = false,
  children,
}) => {
  const theme = useTheme();
  const styles = createStyles(theme);

  return (
    <TouchableOpacity
      onPress={onPress}
      disabled={disabled}
      style={styles.container}
      testID={testID ?? 'checkbox'}>
      <View
        style={[
          styles.checkbox,
          {width: size, height: size},
          checked ? styles.checkedBox : styles.uncheckedBox,
        ]}>
        {checked && (
          <Icon
            source="check"
            size={size * 0.7}
            color={theme.colors.surface}
            testID="check-icon"
          />
        )}
      </View>
      {children}
    </TouchableOpacity>
  );
};



================================================
FILE: src/components/Checkbox/index.ts
================================================
export * from './Checkbox';



================================================
FILE: src/components/Checkbox/styles.ts
================================================
import {StyleSheet} from 'react-native';

import type {Theme} from '../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    container: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
    },
    checkbox: {
      borderWidth: 2,
      borderRadius: 4,
      justifyContent: 'center',
      alignItems: 'center',
    },
    checkedBox: {
      borderColor: theme.colors.primary,
      backgroundColor: theme.colors.primary,
    },
    uncheckedBox: {
      borderColor: theme.colors.outline,
      backgroundColor: 'transparent',
    },
  });



================================================
FILE: src/components/Checkbox/__tests__/Checkbox.test.tsx
================================================
import React from 'react';
import {Checkbox} from '../Checkbox';
import {fireEvent, render} from '../../../../jest/test-utils';

describe('Checkbox', () => {
  it('renders correctly in unchecked state', () => {
    const onPress = jest.fn();
    const {queryByTestId} = render(
      <Checkbox checked={false} onPress={onPress} />,
    );

    expect(queryByTestId('check-icon')).toBeNull();
  });

  it('renders correctly in checked state', async () => {
    const onPress = jest.fn();
    const {findByTestId} = render(
      <Checkbox checked={true} onPress={onPress} />,
    );

    const checkIcon = await findByTestId('check-icon', {
      includeHiddenElements: true,
    });
    expect(checkIcon).toBeDefined();
  });

  it('calls onPress when clicked and not disabled', () => {
    const onPress = jest.fn();
    const {getByTestId} = render(
      <Checkbox checked={false} onPress={onPress} />,
    );

    fireEvent.press(getByTestId('checkbox'));
    expect(onPress).toHaveBeenCalledTimes(1);
  });

  it('does not call onPress when disabled', () => {
    const onPress = jest.fn();
    const {getByTestId} = render(
      <Checkbox checked={false} onPress={onPress} disabled={true} />,
    );

    fireEvent.press(getByTestId('checkbox'));
    expect(onPress).not.toHaveBeenCalled();
  });
});



================================================
FILE: src/components/CircularActivityIndicator/CircularActivityIndicator.tsx
================================================
import * as React from 'react';
import {Animated, ColorValue, Easing, StyleProp, ViewStyle} from 'react-native';

import styles from './styles';

export interface CircularActivityIndicatorProps {
  color: ColorValue;
  size?: number;
  style?: StyleProp<ViewStyle>;
}

export const CircularActivityIndicator = ({
  color,
  size = 24,
  style,
}: CircularActivityIndicatorProps) => {
  const spinValue = React.useRef(new Animated.Value(0)).current;
  const {circle} = styles({color, size});

  React.useEffect(() => {
    Animated.loop(
      Animated.timing(spinValue, {
        toValue: 1,
        duration: 600,
        easing: Easing.linear,
        useNativeDriver: true,
      }),
    ).start();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <Animated.View
      style={[
        {
          transform: [
            {
              rotate: spinValue.interpolate({
                inputRange: [0, 1],
                outputRange: ['0deg', '360deg'],
              }),
            },
          ],
        },
        circle,
        style,
      ]}
      testID="CircularActivityIndicator"
    />
  );
};



================================================
FILE: src/components/CircularActivityIndicator/index.ts
================================================
export * from './CircularActivityIndicator';



================================================
FILE: src/components/CircularActivityIndicator/styles.ts
================================================
import {ColorValue, StyleSheet} from 'react-native';

const styles = ({color, size}: {color: ColorValue; size: number}) =>
  StyleSheet.create({
    circle: {
      backgroundColor: 'transparent',
      borderBottomColor: 'transparent',
      borderLeftColor: color,
      borderRadius: size / 2,
      borderRightColor: color,
      borderTopColor: color,
      borderWidth: 1.5,
      height: size,
      width: size,
    },
  });

export default styles;



================================================
FILE: src/components/CodeBlockHeader/CodeBlockHeader.tsx
================================================
import React from 'react';
import {View, Text, TouchableOpacity} from 'react-native';

import Clipboard from '@react-native-clipboard/clipboard';
import ReactNativeHapticFeedback from 'react-native-haptic-feedback';

import {CopyIcon} from '../../assets/icons';

import {useTheme} from '../../hooks';

import {createStyles} from './styles';

interface CodeBlockHeaderProps {
  language: string;
  content: string;
}

const hapticOptions = {
  enableVibrateFallback: true,
  ignoreAndroidSystemSettings: false,
};

export const CodeBlockHeader: React.FC<CodeBlockHeaderProps> = ({
  language,
  content,
}) => {
  const theme = useTheme();
  const styles = createStyles(theme);

  const handleCopy = () => {
    ReactNativeHapticFeedback.trigger('impactLight', hapticOptions);
    Clipboard.setString(content.trim());
  };

  return (
    <View style={styles.codeHeader}>
      <Text style={styles.codeLanguage} numberOfLines={1} ellipsizeMode="tail">
        {language}
      </Text>
      <TouchableOpacity onPress={handleCopy} style={styles.iconTouchable}>
        <CopyIcon
          width={16}
          height={16}
          stroke={theme.colors.onSurfaceVariant}
        />
      </TouchableOpacity>
    </View>
  );
};



================================================
FILE: src/components/CodeBlockHeader/index.ts
================================================
export * from './CodeBlockHeader';



================================================
FILE: src/components/CodeBlockHeader/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {Theme} from '../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    codeHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    codeLanguage: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 12,
    },
    iconTouchable: {
      padding: 12, // 16 (icon) + 10*2 = 40 for accessibility
      justifyContent: 'center',
      alignItems: 'center',
    },
  });



================================================
FILE: src/components/CompletionSettings/CompletionSettings.tsx
================================================
import {View} from 'react-native';
import React, {useState, useEffect} from 'react';

import Slider from '@react-native-community/slider';
import {Text, Switch, SegmentedButtons} from 'react-native-paper';

import {TextInput} from '..';

import {useTheme} from '../../hooks';

import {createStyles} from './styles';

import {L10nContext} from '../../utils';
import {
  COMPLETION_PARAMS_METADATA,
  validateNumericField,
} from '../../utils/modelSettings';
import {CompletionParams} from '../../utils/completionTypes';

interface Props {
  settings: CompletionParams;
  onChange: (name: string, value: any) => void;
}

export const CompletionSettings: React.FC<Props> = ({settings, onChange}) => {
  const [localSliderValues, setLocalSliderValues] = useState({});
  const theme = useTheme();
  const styles = createStyles(theme);
  const l10n = React.useContext(L10nContext);

  // Reset local values when settings change
  useEffect(() => {
    setLocalSliderValues({});
  }, [settings]);

  const handleOnChange = (name: string, value: any) => {
    onChange(name, value);
  };

  const renderSlider = ({name, step = 0.01}: {name: string; step?: number}) => (
    <View style={styles.settingItem}>
      <Text variant="labelSmall" style={styles.settingLabel}>
        {name.toUpperCase().replace('_', ' ')}
      </Text>
      <Text style={styles.description}>{l10n.completionParams[name]}</Text>
      <Slider
        style={styles.slider}
        minimumValue={COMPLETION_PARAMS_METADATA[name]?.validation.min}
        maximumValue={COMPLETION_PARAMS_METADATA[name]?.validation.max}
        step={step}
        value={localSliderValues[name] ?? settings[name]}
        onValueChange={value => {
          setLocalSliderValues(prev => ({...prev, [name]: value}));
        }}
        onSlidingComplete={value => {
          handleOnChange(name, value);
        }}
        thumbTintColor={theme.colors.primary}
        minimumTrackTintColor={theme.colors.primary}
        //onValueChange={value => onChange(name, value)}
        testID={`${name}-slider`}
      />
      <Text style={styles.settingValue}>
        {Number.isInteger(step)
          ? Math.round(localSliderValues[name] ?? settings[name]).toString()
          : (localSliderValues[name] ?? settings[name]).toFixed(2)}
      </Text>
    </View>
  );

  const renderIntegerInput = ({name}: {name: keyof CompletionParams}) => {
    const metadata = COMPLETION_PARAMS_METADATA[name];
    if (!metadata) {
      return null;
    }

    const value = settings[name]?.toString() ?? '';
    const validation = validateNumericField(value, metadata.validation);

    return (
      <View style={styles.settingItem}>
        <Text variant="labelSmall" style={styles.settingLabel}>
          {String(name).toUpperCase().replace('_', ' ')}
        </Text>
        <Text style={styles.description}>
          {l10n.completionParams[String(name)]}
        </Text>
        <TextInput
          value={value}
          onChangeText={_value => onChange(String(name), _value)}
          keyboardType="numeric"
          error={!validation.isValid}
          helperText={validation.errorMessage}
          testID={`${String(name)}-input`}
        />
      </View>
    );
  };

  const renderSwitch = (name: string) => {
    // Convert snake_case to UPPER CASE with spaces for display
    const displayName = name.toUpperCase().replace(/_/g, ' ');

    return (
      <View style={styles.settingItem}>
        <View style={styles.switchHeader}>
          <Text variant="labelSmall" style={styles.settingLabel}>
            {displayName}
          </Text>
          <Switch
            value={settings[name]}
            onValueChange={value => onChange(name, value)}
            testID={`${name}-switch`}
          />
        </View>
        <Text style={styles.description}>{l10n.completionParams[name]}</Text>
      </View>
    );
  };

  const renderMirostatSelector = () => {
    const description = l10n.completionParams.mirostat;

    return (
      <View style={styles.settingItem}>
        <Text style={styles.settingLabel}>Mirostat</Text>
        {description && <Text style={styles.description}>{description}</Text>}
        <SegmentedButtons
          value={(settings.mirostat ?? 0).toString()}
          onValueChange={value => onChange('mirostat', parseInt(value, 10))}
          density="high"
          buttons={[
            {
              value: '0',
              label: 'Off',
            },
            {
              value: '1',
              label: 'v1',
            },
            {
              value: '2',
              label: 'v2',
            },
          ]}
          style={styles.segmentedButtons}
        />
      </View>
    );
  };

  return (
    <View style={styles.container}>
      {renderIntegerInput({name: 'n_predict'})}
      {renderSwitch('include_thinking_in_context')}
      {renderSlider({name: 'temperature'})}
      {renderSlider({name: 'top_k', step: 1})}
      {renderSlider({name: 'top_p'})}
      {renderSlider({name: 'min_p'})}
      {renderSlider({name: 'xtc_threshold'})}
      {renderSlider({name: 'xtc_probability'})}
      {renderSlider({name: 'typical_p'})}
      {renderSlider({name: 'penalty_last_n', step: 1})}
      {renderSlider({name: 'penalty_repeat'})}
      {renderSlider({name: 'penalty_freq'})}
      {renderSlider({name: 'penalty_present'})}
      {renderMirostatSelector()}
      {(settings.mirostat ?? 0) > 0 && (
        <>
          {renderSlider({name: 'mirostat_tau', step: 1})}
          {renderSlider({name: 'mirostat_eta'})}
        </>
      )}
      {renderIntegerInput({name: 'seed'})}
      {renderSwitch('jinja')}
    </View>
  );
};



================================================
FILE: src/components/CompletionSettings/index.ts
================================================
export * from './CompletionSettings';



================================================
FILE: src/components/CompletionSettings/styles.ts
================================================
import {Platform, StyleSheet} from 'react-native';

import {Theme} from '../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    container: {
      padding: 16,
      backgroundColor: theme.colors.surface,
      borderRadius: theme.borders.default,
    },
    row: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
    },
    switchHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginBottom: 4,
    },
    stopLabel: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    settingItem: {
      marginBottom: 24,
      paddingHorizontal: 4,
    },
    settingLabel: {
      marginBottom: 2,
    },
    settingValue: {
      textAlign: 'right',
    },
    slider: {
      ...Platform.select({
        android: {
          marginLeft: -12,
          marginRight: -10,
        },
      }),
    },
    divider: {
      marginVertical: 16,
    },
    segmentedButtons: {
      marginTop: 8,
    },
    inputLabel: {
      flex: 1,
      fontSize: 16,
      marginRight: 8,
    },
    stopWordsContainer: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: 8,
      marginBottom: 8,
    },
    stopChip: {
      marginRight: 4,
      marginVertical: 4,
    },
    stopChipText: {
      fontSize: 12,
    },
    description: {
      fontSize: 12,
      color: theme.colors.textSecondary,
      marginTop: 2,
      marginBottom: 8,
    },
  });



================================================
FILE: src/components/CompletionSettings/__tests__/CompletionSettings.test.tsx
================================================
import React from 'react';
import {render, fireEvent} from '@testing-library/react-native';
import {CompletionSettings} from '../CompletionSettings';
import {mockCompletionParams} from '../../../../jest/fixtures/models';

jest.useFakeTimers();

describe('CompletionSettings', () => {
  it('renders all settings correctly', async () => {
    const {getByDisplayValue, getByTestId} = render(
      <CompletionSettings
        settings={{...mockCompletionParams, mirostat: 1}}
        onChange={jest.fn()}
      />,
    );

    expect(getByTestId('n_predict-input')).toBeTruthy();
    expect(getByDisplayValue('500')).toBeTruthy();

    expect(getByTestId('temperature-slider')).toBeTruthy();
    const temperatureSlider = getByTestId('temperature-slider');
    expect(temperatureSlider.props.value).toBe(0.01);

    expect(getByTestId('top_k-slider')).toBeTruthy();
    const topKSlider = getByTestId('top_k-slider');
    expect(topKSlider.props.value).toBe(40);

    expect(getByTestId('top_p-slider')).toBeTruthy();
    const topPSlider = getByTestId('top_p-slider');
    expect(topPSlider.props.value).toBe(0.95);

    expect(getByTestId('min_p-slider')).toBeTruthy();
    const minPSlider = getByTestId('min_p-slider');
    expect(minPSlider.props.value).toBe(0.05);

    expect(getByTestId('xtc_threshold-slider')).toBeTruthy();
    const xtcThresholdSlider = getByTestId('xtc_threshold-slider');
    expect(xtcThresholdSlider.props.value).toBe(0.1);

    expect(getByTestId('xtc_probability-slider')).toBeTruthy();
    const xtcProbabilitySlider = getByTestId('xtc_probability-slider');
    expect(xtcProbabilitySlider.props.value).toBe(0.01);

    expect(getByTestId('typical_p-slider')).toBeTruthy();
    const typicalPSlider = getByTestId('typical_p-slider');
    expect(typicalPSlider.props.value).toBe(1);

    expect(getByTestId('penalty_last_n-slider')).toBeTruthy();
    const penaltyLastNSlider = getByTestId('penalty_last_n-slider');
    expect(penaltyLastNSlider.props.value).toBe(64);

    expect(getByTestId('penalty_repeat-slider')).toBeTruthy();
    const penaltyRepeatSlider = getByTestId('penalty_repeat-slider');
    expect(penaltyRepeatSlider.props.value).toBe(1.0);

    expect(getByTestId('penalty_freq-slider')).toBeTruthy();
    const penaltyFreqSlider = getByTestId('penalty_freq-slider');
    expect(penaltyFreqSlider.props.value).toBe(0.5);

    expect(getByTestId('penalty_present-slider')).toBeTruthy();
    const penaltyPresentSlider = getByTestId('penalty_present-slider');
    expect(penaltyPresentSlider.props.value).toBe(0.4);

    expect(getByTestId('mirostat_tau-slider')).toBeTruthy();
    const mirostatTauSlider = getByTestId('mirostat_tau-slider');
    expect(mirostatTauSlider.props.value).toBe(5);

    expect(getByTestId('mirostat_eta-slider')).toBeTruthy();
    const mirostatEtaSlider = getByTestId('mirostat_eta-slider');
    expect(mirostatEtaSlider.props.value).toBe(0.1);

    expect(getByTestId('seed-input')).toBeTruthy();
    const seedInput = getByTestId('seed-input');
    expect(seedInput.props.value).toBe('0');
  });

  it('handles slider changes', () => {
    const mockOnChange = jest.fn();
    const {getByTestId} = render(
      <CompletionSettings
        settings={mockCompletionParams}
        onChange={mockOnChange}
      />,
    );

    const temperatureSlider = getByTestId('temperature-slider');

    fireEvent(temperatureSlider, 'valueChange', 0.8);
    fireEvent(temperatureSlider, 'slidingComplete', 0.8);

    expect(mockOnChange).toHaveBeenCalledWith('temperature', 0.8);
  });

  it('handles text input changes', () => {
    const mockOnChange = jest.fn();
    const {getByTestId} = render(
      <CompletionSettings
        settings={mockCompletionParams}
        onChange={mockOnChange}
      />,
    );

    const nPredictInput = getByTestId('n_predict-input');
    fireEvent.changeText(nPredictInput, '1024');
    expect(mockOnChange).toHaveBeenCalledWith('n_predict', '1024');
  });

  it('handles chip selection', () => {
    const mockOnChange = jest.fn();
    const {getByText} = render(
      <CompletionSettings
        settings={mockCompletionParams}
        onChange={mockOnChange}
      />,
    );

    const mirostatV2Button = getByText('v2');
    fireEvent.press(mirostatV2Button);
    expect(mockOnChange).toHaveBeenCalledWith('mirostat', 2);
  });
});



================================================
FILE: src/components/ContentReportSheet/ContentReportSheet.tsx
================================================
import {View, Alert} from 'react-native';
import React, {useContext, useState} from 'react';

import {Text, Button, Switch, ActivityIndicator} from 'react-native-paper';

import {Sheet} from '../Sheet/Sheet';

import {submitContentReport} from '../../api/feedback';

import {ChevronDownIcon} from '../../assets/icons';

import {useTheme} from '../../hooks';

import {Menu} from '../Menu';
import {createStyles} from './styles';

import {modelStore} from '../../store';

import {L10nContext} from '../../utils';

import {TextInput} from '..';

interface ContentReportSheetProps {
  isVisible: boolean;
  onClose: () => void;
}

const REPORT_CATEGORIES = [
  'hate',
  'sexual',
  'selfHarm',
  'violence',
  'other',
] as const;

type ReportCategory = (typeof REPORT_CATEGORIES)[number];

const ChevronDownButtonIcon = ({color}: {color: string}) => (
  <ChevronDownIcon width={16} height={16} stroke={color} />
);

export const ContentReportSheet: React.FC<ContentReportSheetProps> = ({
  isVisible,
  onClose,
}) => {
  const l10n = useContext(L10nContext);
  const theme = useTheme();
  const styles = createStyles(theme);

  const [selectedCategory, setSelectedCategory] =
    useState<ReportCategory | null>(null);
  const [description, setDescription] = useState('');
  const [includeModelInfo, setIncludeModelInfo] = useState(false);

  const hasActiveModel = modelStore.activeModelId !== undefined;
  const activeModel = modelStore.models.find(
    m => m.id === modelStore.activeModelId,
  );
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [categoryMenuVisible, setCategoryMenuVisible] = useState(false);

  const handleClose = () => {
    setSelectedCategory(null);
    setDescription('');
    setIncludeModelInfo(false);
    setIsSubmitting(false);
    setCategoryMenuVisible(false);
    onClose();
  };

  const handleSubmit = async () => {
    if (!selectedCategory || !description.trim()) {
      Alert.alert(
        l10n.components.contentReportSheet.validation.title,
        l10n.components.contentReportSheet.validation.message,
        [{text: l10n.common.ok}],
      );
      return;
    }

    setIsSubmitting(true);

    try {
      await submitContentReport({
        category: selectedCategory,
        description: description.trim(),
        includeModelInfo,
        modelId: includeModelInfo ? activeModel?.id : undefined,
        modelOid: includeModelInfo ? activeModel?.hfModelFile?.oid : undefined,
        isContentReport: true,
      });

      Alert.alert(
        l10n.components.contentReportSheet.success.title,
        l10n.components.contentReportSheet.success.message,
        [{text: l10n.common.ok, onPress: handleClose}],
      );
    } catch (error) {
      console.error('Content report submission error:', error);
      Alert.alert(
        l10n.components.contentReportSheet.error.title,
        l10n.components.contentReportSheet.error.message,
        [{text: l10n.common.ok}],
      );
    } finally {
      setIsSubmitting(false);
    }
  };

  const getCategoryLabel = (category: ReportCategory) => {
    return l10n.components.contentReportSheet.categories[category];
  };

  return (
    <Sheet
      title={l10n.components.contentReportSheet.title}
      isVisible={isVisible}
      onClose={handleClose}
      snapPoints={['70%']}>
      <Sheet.ScrollView
        // bottomOffset={80}
        contentContainerStyle={styles.container}>
        <View style={styles.section}>
          <Text variant="bodyMedium" style={styles.infoNote}>
            {l10n.components.contentReportSheet.privacyNote}
          </Text>
        </View>

        <View style={styles.section}>
          <Text variant="labelMedium" style={styles.label}>
            {l10n.components.contentReportSheet.categoryLabel}
          </Text>
          <Menu
            visible={categoryMenuVisible}
            onDismiss={() => setCategoryMenuVisible(false)}
            anchor={
              <Button
                mode="outlined"
                onPress={() => setCategoryMenuVisible(true)}
                style={styles.categoryButton}
                contentStyle={styles.categoryButtonContent}
                icon={ChevronDownButtonIcon}>
                {selectedCategory
                  ? getCategoryLabel(selectedCategory)
                  : l10n.components.contentReportSheet.selectCategory}
              </Button>
            }>
            {REPORT_CATEGORIES.map(category => (
              <Menu.Item
                key={category}
                onPress={() => {
                  setSelectedCategory(category);
                  setCategoryMenuVisible(false);
                }}
                label={getCategoryLabel(category)}
              />
            ))}
          </Menu>
        </View>

        <View style={styles.section}>
          <Text variant="labelMedium" style={styles.label}>
            {l10n.components.contentReportSheet.descriptionLabel}
          </Text>
          <TextInput
            multiline
            numberOfLines={4}
            defaultValue={description}
            onChangeText={setDescription}
            placeholder={
              l10n.components.contentReportSheet.descriptionPlaceholder
            }
            style={styles.textInput}
          />
        </View>

        <View style={styles.switchSection}>
          <View style={styles.switchContent}>
            <Text
              variant="bodyMedium"
              style={[
                styles.switchLabel,
                !hasActiveModel && styles.disabledText,
              ]}>
              {l10n.components.contentReportSheet.includeModelInfo}
            </Text>
            <Switch
              value={includeModelInfo && hasActiveModel}
              onValueChange={hasActiveModel ? setIncludeModelInfo : undefined}
              disabled={!hasActiveModel}
            />
          </View>
          <Text
            variant="bodySmall"
            style={[
              styles.switchDescription,
              !hasActiveModel && styles.disabledText,
            ]}>
            {hasActiveModel
              ? l10n.components.contentReportSheet.includeModelInfoDescription
              : l10n.components.contentReportSheet.noActiveModelNote}
          </Text>
        </View>
      </Sheet.ScrollView>

      <Sheet.Actions>
        <View style={styles.actionsContainer}>
          <Button
            mode="outlined"
            onPress={handleClose}
            disabled={isSubmitting}
            style={styles.button}>
            {l10n.common.cancel}
          </Button>
          <Button
            mode="contained"
            onPress={handleSubmit}
            disabled={isSubmitting}
            style={styles.button}>
            {isSubmitting ? (
              <ActivityIndicator size="small" />
            ) : (
              l10n.components.contentReportSheet.submit
            )}
          </Button>
        </View>
      </Sheet.Actions>
    </Sheet>
  );
};



================================================
FILE: src/components/ContentReportSheet/index.ts
================================================
export {ContentReportSheet} from './ContentReportSheet';



================================================
FILE: src/components/ContentReportSheet/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {Theme} from '../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    container: {
      paddingHorizontal: 16,
      paddingTop: 8,
    },
    section: {
      marginBottom: 24,
    },
    label: {
      marginBottom: 8,
      color: theme.colors.onSurface,
    },
    infoNote: {
      color: theme.colors.onSurfaceVariant,
      lineHeight: 20,
      backgroundColor: theme.colors.surfaceVariant,
      padding: 12,
      borderRadius: 8,
    },
    categoryButton: {
      justifyContent: 'flex-start',
    },
    categoryButtonContent: {
      justifyContent: 'space-between',
      flexDirection: 'row-reverse',
    },
    textInput: {
      backgroundColor: theme.colors.surface,
    },
    switchSection: {
      marginBottom: 24,
      paddingVertical: 8,
    },
    switchContent: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 4,
    },
    switchLabel: {
      color: theme.colors.onSurface,
    },
    switchDescription: {
      color: theme.colors.onSurfaceVariant,
      lineHeight: 16,
    },
    disabledText: {
      opacity: 0.5,
    },
    button: {},
    actionsContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      width: '100%',
      paddingHorizontal: 16,
    },
  });



================================================
FILE: src/components/DatabaseMigration/AppWithMigration.tsx
================================================
import React, {useEffect} from 'react';
import {View, StyleSheet} from 'react-native';
import {DatabaseMigration} from './DatabaseMigration';
import {chatSessionRepository} from '../../repositories/ChatSessionRepository';

/**
 * Wraps the main app component and displays the migration UI when needed.
 */
export const AppWithMigration: React.FC<{children: React.ReactNode}> = ({
  children,
}) => {
  useEffect(() => {
    const migrateSettings = async () => {
      try {
        // Wait a bit to avoid blocking the UI during startup
        await new Promise(resolve => setTimeout(resolve, 2000));

        // Migrate all settings to the latest version
        await chatSessionRepository.migrateAllSettings();
      } catch (error) {
        console.error('Failed to migrate settings:', error);
      }
    };

    migrateSettings();
  }, []);

  return (
    <View style={styles.container}>
      {children}
      <DatabaseMigration />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});



================================================
FILE: src/components/DatabaseMigration/DatabaseMigration.tsx
================================================
import React from 'react';
import {View, ActivityIndicator, Text, StyleSheet} from 'react-native';
import {observer} from 'mobx-react-lite';
import {chatSessionStore} from '../../store/ChatSessionStore';
import {useTheme} from '../../hooks';

export const DatabaseMigration = observer(() => {
  const theme = useTheme();

  if (!chatSessionStore.isMigrating) {
    return null;
  }

  return (
    <View
      style={[styles.container, {backgroundColor: theme.colors.background}]}>
      <ActivityIndicator size="large" color={theme.colors.primary} />
      <Text style={[styles.text, {color: theme.colors.text}]}>
        Upgrading database...
      </Text>
      <Text style={[styles.subText, {color: theme.colors.textSecondary}]}>
        Please don't close the app. This may take a moment.
      </Text>
    </View>
  );
});

const styles = StyleSheet.create({
  container: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 9999,
  },
  text: {
    fontSize: 18,
    fontWeight: 'bold',
    marginTop: 16,
  },
  subText: {
    fontSize: 14,
    marginTop: 8,
    textAlign: 'center',
    paddingHorizontal: 32,
  },
});



================================================
FILE: src/components/DatabaseMigration/index.ts
================================================
export {DatabaseMigration} from './DatabaseMigration';
export {AppWithMigration} from './AppWithMigration';



================================================
FILE: src/components/Dialog/Dialog.tsx
================================================
import React, {ReactNode} from 'react';
import {
  ViewStyle,
  Keyboard,
  TouchableWithoutFeedback,
  View,
} from 'react-native';

import {ScrollView} from 'react-native-gesture-handler';
import {Button, Portal, Dialog as PaperDialog} from 'react-native-paper';
import {KeyboardAwareScrollView} from 'react-native-keyboard-controller';

import {useTheme} from '../../hooks';

import {createStyles} from './styles';

export interface DialogAction {
  label: string;
  onPress: () => void;
  mode?: 'text' | 'contained' | 'outlined';
  loading?: boolean;
  disabled?: boolean;
  testID?: string;
}

interface CustomDialogProps {
  testID?: string;
  visible: boolean;
  onDismiss: () => void;
  title: string;
  children: ReactNode;
  actions?: DialogAction[];
  style?: ViewStyle;
  contentStyle?: ViewStyle;
  scrollAreaStyle?: ViewStyle;
  scrollable?: boolean;
  scrollableBorderShown?: boolean;
  dismissableBackButton?: boolean;
  dismissable?: boolean;
  avoidKeyboard?: boolean;
}

export const Dialog: React.FC<CustomDialogProps> = ({
  testID,
  visible,
  onDismiss,
  title,
  children,
  actions = [],
  style,
  contentStyle,
  scrollAreaStyle,
  scrollable = false,
  scrollableBorderShown = false,
  dismissableBackButton = true,
  dismissable = true,
  avoidKeyboard = false,
}) => {
  const theme = useTheme();
  const styles = createStyles(theme, scrollableBorderShown);

  const content = scrollable ? (
    <PaperDialog.ScrollArea style={[styles.dialogContent, contentStyle]}>
      {avoidKeyboard ? (
        <KeyboardAwareScrollView
          bottomOffset={10}
          style={[scrollAreaStyle]}
          //keyboardDismissMode="on-drag"
          keyboardShouldPersistTaps="handled"
          //bounces={false}
        >
          {children}
        </KeyboardAwareScrollView>
      ) : (
        <ScrollView
          style={scrollAreaStyle}
          keyboardDismissMode="on-drag"
          keyboardShouldPersistTaps="handled"
          //bounces={false}
        >
          {children}
        </ScrollView>
      )}
    </PaperDialog.ScrollArea>
  ) : (
    <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
      <PaperDialog.Content style={[styles.dialogContent, contentStyle]}>
        {avoidKeyboard ? (
          <KeyboardAwareScrollView>{children}</KeyboardAwareScrollView>
        ) : (
          children
        )}
      </PaperDialog.Content>
    </TouchableWithoutFeedback>
  );

  return (
    <Portal>
      <PaperDialog
        testID={testID}
        dismissableBackButton={dismissableBackButton}
        dismissable={dismissable}
        visible={visible}
        onDismiss={onDismiss}
        style={[styles.dialog, style]}>
        <PaperDialog.Title style={styles.dialogTitle}>
          {title}
        </PaperDialog.Title>
        <View>
          {content}
          {actions.length > 0 && (
            <PaperDialog.Actions style={styles.actionsContainer}>
              {actions.map(action => (
                <Button
                  key={action.label}
                  testID={action.testID}
                  mode={action.mode || 'text'}
                  onPress={action.onPress}
                  loading={action.loading}
                  disabled={action.disabled}
                  style={styles.dialogActionButton}>
                  {action.label}
                </Button>
              ))}
            </PaperDialog.Actions>
          )}
        </View>
      </PaperDialog>
    </Portal>
  );
};



================================================
FILE: src/components/Dialog/index.ts
================================================
export * from './Dialog';



================================================
FILE: src/components/Dialog/styles.ts
================================================
import {Dimensions, StyleSheet} from 'react-native';

import {Theme} from '../../utils/types';

const dialogHeight = Dimensions.get('window').height * 0.65;

export const createStyles = (theme: Theme, scrollableBorderShown?: boolean) =>
  StyleSheet.create({
    dialog: {
      //maxHeight: '90%',
      backgroundColor: theme.colors.background,
      borderRadius: 15,
      margin: 0,
      padding: 0,
      width: '92%',
      alignSelf: 'center',
    },
    dialogTitle: {
      fontSize: 16,
      fontWeight: 'bold',
    },
    dialogContent: {
      maxHeight: dialogHeight,
      paddingHorizontal: 24,
      borderTopWidth: scrollableBorderShown ? 1 : 0,
      borderBottomWidth: scrollableBorderShown ? 1 : 0,
      backgroundColor: theme.colors.background,
    },
    dialogActionButton: {
      minWidth: 70,
    },
    actionsContainer: {
      flexDirection: 'row',
      justifyContent: 'space-around',
      paddingHorizontal: 16,
      paddingBottom: 16,
    },
  });



================================================
FILE: src/components/Dialog/__tests__/Dialog.test.tsx
================================================
import React from 'react';
import {fireEvent, render} from '../../../../jest/test-utils';
import {Dialog} from '../Dialog';
import {Text} from 'react-native';

describe('Dialog', () => {
  const defaultProps = {
    visible: true,
    onDismiss: jest.fn(),
    title: 'Test Dialog',
    actions: [
      {
        label: 'Cancel',
        onPress: jest.fn(),
      },
      {
        label: 'OK',
        onPress: jest.fn(),
      },
    ],
    children: <Text>Dialog content</Text>,
  };

  it('renders dialog with title and content', () => {
    const {getByText} = render(<Dialog {...defaultProps} />);

    expect(getByText('Test Dialog')).toBeDefined();
    expect(getByText('Dialog content')).toBeDefined();
  });

  it('renders action buttons and handles presses', () => {
    const {getByText} = render(<Dialog {...defaultProps} />);

    const cancelButton = getByText('Cancel');
    const okButton = getByText('OK');

    fireEvent.press(cancelButton);
    expect(defaultProps.actions[0].onPress).toHaveBeenCalled();

    fireEvent.press(okButton);
    expect(defaultProps.actions[1].onPress).toHaveBeenCalled();
  });

  it('does not render when visible is false', () => {
    const {queryByText} = render(<Dialog {...defaultProps} visible={false} />);

    expect(queryByText('Test Dialog')).toBeNull();
  });
});



================================================
FILE: src/components/Divider/Divider.tsx
================================================
import React from 'react';

import {Divider as PaperDivider, DividerProps} from 'react-native-paper';

import {useTheme} from '../../hooks';

import {createStyles} from './styles';

export const Divider: React.FC<DividerProps> = props => {
  const theme = useTheme();
  const styles = createStyles(theme);

  return <PaperDivider {...props} style={[styles.separator, props.style]} />;
};



================================================
FILE: src/components/Divider/index.ts
================================================
export * from './Divider';



================================================
FILE: src/components/Divider/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {Theme} from '../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    separator: {
      height: 1,
      backgroundColor: theme.colors.outline,
    },
  });



================================================
FILE: src/components/DownloadErrorDialog/DownloadErrorDialog.tsx
================================================
import React from 'react';
import {View, Linking} from 'react-native';
import {Text, Portal} from 'react-native-paper';

import {Dialog, DialogAction} from '../Dialog';
import {Model} from '../../utils/types';
import {useTheme} from '../../hooks';
import {L10nContext} from '../../utils';
import {ErrorState} from '../../utils/errors';
import {createStyles} from './styles';
import {CheckCircleIcon} from '../../assets/icons';
import {hfStore} from '../../store';

const CheckIcon = ({color}: {color: string}) => (
  <CheckCircleIcon width={16} height={16} stroke={color} />
);

interface DownloadErrorDialogProps {
  visible: boolean;
  onDismiss: () => void;
  error: ErrorState | null;
  model?: Model;
  onGoToSettings?: () => void;
  onTryAgain?: () => void;
}

export const DownloadErrorDialog: React.FC<DownloadErrorDialogProps> = ({
  visible,
  onDismiss,
  error,
  model,
  onGoToSettings,
  onTryAgain,
}) => {
  const theme = useTheme();
  const l10n = React.useContext(L10nContext);
  const alerts = l10n.components.downloadErrorDialog;

  // Check if this is the case where token exists but is disabled
  const isTokenDisabledWhenAuthError =
    error?.code === 'authentication' &&
    hfStore.isTokenPresent &&
    !hfStore.useHfToken;

  const isTokenPresentWhenAuthError =
    error?.code === 'authentication' &&
    hfStore.isTokenPresent &&
    hfStore.useHfToken;

  const notEnoughSpace = error?.code === 'storage';

  const getErrorType = ():
    | 'unauthorized'
    | 'forbidden'
    | 'noToken'
    | 'other' => {
    if (!error) {
      return 'other';
    }

    if (error.code === 'authentication') {
      if (error.message?.includes('Token is missing')) {
        return 'noToken';
      }
      return 'unauthorized';
    } else if (error.code === 'authorization') {
      return 'forbidden';
    } else if (error.code === 'server') {
      return 'forbidden';
    }
    return 'other';
  };

  const errorType = getErrorType();

  const getDialogTitle = () => {
    if (isTokenDisabledWhenAuthError) {
      return alerts.tokenDisabledTitle;
    }

    if (isTokenPresentWhenAuthError) {
      return alerts.unauthorizedTitle;
    }

    switch (errorType) {
      case 'unauthorized':
        return alerts.unauthorizedTitle;
      case 'forbidden':
        return alerts.forbiddenTitle;
      case 'noToken':
        return alerts.getTokenTitle;
      default:
        return alerts.downloadFailedTitle;
    }
  };

  const getDialogMessage = () => {
    if (isTokenDisabledWhenAuthError) {
      return alerts.tokenDisabledMessage;
    }

    if (isTokenPresentWhenAuthError) {
      return alerts.unauthorizedMessage;
    }

    switch (errorType) {
      case 'unauthorized':
        return alerts.unauthorizedMessage;
      case 'forbidden':
        return alerts.forbiddenMessage;
      case 'noToken':
        return alerts.getTokenMessage;
      default:
        return !error?.message
          ? alerts.downloadFailedMessage.replace('{message}', '')
          : undefined;
    }
  };

  const getSteps = () => {
    if (isTokenDisabledWhenAuthError) {
      return [];
    }

    if (isTokenPresentWhenAuthError) {
      return [];
    }

    switch (errorType) {
      case 'forbidden':
        return alerts.forbiddenSteps;
      case 'noToken':
        return alerts.getTokenSteps;
      default:
        return [];
    }
  };

  const handleEnableToken = () => {
    hfStore.setUseHfToken(true);
    if (onTryAgain) {
      onTryAgain();
    }
  };

  const getActions = () => {
    const actions: DialogAction[] = [];

    if (model?.hfUrl && !isTokenDisabledWhenAuthError && !notEnoughSpace) {
      actions.push({
        label: alerts.viewOnHuggingFace,
        onPress: () => {
          Linking.openURL(model.hfUrl);
        },
        mode: 'text' as const,
      });
    }

    if (
      isTokenDisabledWhenAuthError ||
      isTokenPresentWhenAuthError ||
      notEnoughSpace
    ) {
      actions.push({
        label: l10n.common.dismiss,
        onPress: () => {
          onDismiss();
        },
        mode: 'text' as const,
      });
    }

    if (isTokenDisabledWhenAuthError) {
      actions.push({
        label: alerts.enableAndRetry,
        onPress: handleEnableToken,
        mode: 'contained' as const,
      });
    } else if (
      ['unauthorized', 'forbidden', 'noToken'].includes(errorType) &&
      onGoToSettings
    ) {
      actions.push({
        label: alerts.goToSettings,
        onPress: onGoToSettings,
        mode: 'text' as const,
      });
    }

    if (!isTokenDisabledWhenAuthError && onTryAgain) {
      actions.push({
        label: alerts.tryAgain,
        onPress: onTryAgain,
        mode: 'contained' as const,
      });
    }

    return actions;
  };

  const steps = getSteps();
  const message = getDialogMessage();
  const styles = createStyles(theme);

  return (
    <Portal>
      <Dialog
        testID="download-error-dialog"
        visible={visible}
        onDismiss={onDismiss}
        title={getDialogTitle()}
        actions={getActions()}
        scrollable={true}>
        <View>
          {message && <Text variant="bodyMedium">{message}</Text>}

          {steps.length > 0 && (
            <View style={styles.stepsContainer}>
              {steps.map((step, index) => (
                <View key={index} style={styles.stepItem}>
                  <View style={styles.stepRow}>
                    <CheckIcon color={theme.colors.primary} />
                    <View style={styles.textContainer}>
                      <Text style={styles.stepText}>{step}</Text>
                    </View>
                  </View>
                </View>
              ))}
            </View>
          )}

          {errorType === 'other' && error?.message && (
            <View style={styles.errorDetails}>
              <Text style={styles.errorText}>{error.message}</Text>
            </View>
          )}
        </View>
      </Dialog>
    </Portal>
  );
};



================================================
FILE: src/components/DownloadErrorDialog/index.ts
================================================
export * from './DownloadErrorDialog';



================================================
FILE: src/components/DownloadErrorDialog/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {Theme} from '../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    stepItem: {
      paddingVertical: 8,
      marginVertical: 2,
    },
    stepRow: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: 8,
    },
    textContainer: {
      flex: 1,
      marginLeft: 12,
    },
    stepText: {
      fontSize: 14,
    },
    errorDetails: {
      marginTop: 10,
      padding: 8,
      backgroundColor: theme.colors.errorContainer,
      borderRadius: 4,
    },
    errorText: {
      color: theme.colors.error,
      fontSize: 13,
    },
    stepsContainer: {
      marginTop: 16,
    },
  });



================================================
FILE: src/components/DownloadErrorDialog/__tests__/DownloadErrorDialog.test.tsx
================================================
import React from 'react';
import {fireEvent} from '@testing-library/react-native';
import {render} from '../../../../jest/test-utils';
import {DownloadErrorDialog} from '../DownloadErrorDialog';
import {Linking} from 'react-native';
import {hfStore} from '../../../store';
import {createModel} from '../../../../jest/fixtures/models';
import {l10n} from '../../../utils/l10n';
import {createErrorState, ErrorState} from '../../../utils/errors';

// Mock Linking for testing URL navigation
jest.mock('react-native/Libraries/Linking/Linking', () => ({
  openURL: jest.fn(() => Promise.resolve()),
}));

// Mock the CheckCircleIcon component
jest.mock('../../../assets/icons', () => ({
  CheckCircleIcon: props => (
    <div
      data-testid="check-circle-icon"
      style={{
        width: props.width,
        height: props.height,
        stroke: props.stroke,
      }}
    />
  ),
}));

describe('DownloadErrorDialog', () => {
  const mockDismiss = jest.fn();
  const mockGoToSettings = jest.fn();
  const mockTryAgain = jest.fn();
  const mockModel = createModel({
    id: 'test-model',
    name: 'Test Model',
    hfUrl: 'https://huggingface.co/test/test-model',
  });

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('does not render when not visible', () => {
    const {queryByText} = render(
      <DownloadErrorDialog
        visible={false}
        onDismiss={mockDismiss}
        error={null}
      />,
    );

    expect(queryByText('Download Failed')).toBeNull();
  });

  it('renders authentication error correctly when no token is present', () => {
    const error: ErrorState = createErrorState(
      new Error('Client error: 401'),
      'download',
      'huggingface',
      {
        modelId: 'test-model',
      },
    );

    const {getByText} = render(
      <DownloadErrorDialog
        visible={true}
        onDismiss={mockDismiss}
        error={error as ErrorState}
        model={mockModel}
        onGoToSettings={mockGoToSettings}
        onTryAgain={mockTryAgain}
      />,
    );

    // Check that the correct title and message are displayed
    expect(
      getByText(l10n.en.components.downloadErrorDialog.getTokenTitle),
    ).toBeTruthy();
    expect(
      getByText(l10n.en.components.downloadErrorDialog.getTokenMessage),
    ).toBeTruthy();

    const steps = l10n.en.components.downloadErrorDialog.getTokenSteps;
    for (let i = 0; i < steps.length; i++) {
      expect(getByText(steps[i])).toBeTruthy();
    }

    // Check that the HF button exists
    const hfButton = getByText(
      l10n.en.components.downloadErrorDialog.viewOnHuggingFace,
    );
    fireEvent.press(hfButton);
    expect(Linking.openURL).toHaveBeenCalledWith(
      'https://huggingface.co/test/test-model',
    );

    // Check retry button works
    const retryButton = getByText(
      l10n.en.components.downloadErrorDialog.tryAgain,
    );
    fireEvent.press(retryButton);
    expect(mockTryAgain).toHaveBeenCalled();
  });

  it('renders forbidden error correctly', () => {
    const error: ErrorState = createErrorState(
      new Error('Client error: 403'),
      'download',
      'huggingface',
      {
        modelId: 'test-model',
      },
    );
    console.log(error);

    const {getByText} = render(
      <DownloadErrorDialog
        visible={true}
        onDismiss={mockDismiss}
        error={error}
        model={mockModel}
        onGoToSettings={mockGoToSettings}
        onTryAgain={mockTryAgain}
      />,
    );

    // Check that the correct title and message are displayed
    expect(
      getByText(l10n.en.components.downloadErrorDialog.forbiddenTitle),
    ).toBeTruthy();
    expect(
      getByText(l10n.en.components.downloadErrorDialog.forbiddenMessage),
    ).toBeTruthy();

    // Check that the steps for forbidden models are displayed
    const steps = l10n.en.components.downloadErrorDialog.forbiddenSteps;
    for (let i = 0; i < steps.length; i++) {
      expect(getByText(steps[i])).toBeTruthy();
    }
  });

  it('renders token disabled case correctly', () => {
    // Update the mock to simulate having a token that's disabled
    hfStore.hfToken = 'test-token';
    hfStore.useHfToken = false;

    const error: ErrorState = createErrorState(
      new Error('Client error: 401'),
      'download',
      'huggingface',
      {
        modelId: 'test-model',
      },
    );

    const {getByText} = render(
      <DownloadErrorDialog
        visible={true}
        onDismiss={mockDismiss}
        error={error}
        model={mockModel}
        onGoToSettings={mockGoToSettings}
        onTryAgain={mockTryAgain}
      />,
    );

    // Check that the correct title and message for disabled token
    expect(
      getByText(l10n.en.components.downloadErrorDialog.tokenDisabledTitle),
    ).toBeTruthy();
    expect(
      getByText(l10n.en.components.downloadErrorDialog.tokenDisabledMessage),
    ).toBeTruthy();

    // Check the enable button works
    const enableButton = getByText(
      l10n.en.components.downloadErrorDialog.enableAndRetry,
    );
    fireEvent.press(enableButton);
    expect(hfStore.setUseHfToken).toHaveBeenCalledWith(true);
    expect(mockTryAgain).toHaveBeenCalled();
  });

  it('renders generic download error when error type is unknown', () => {
    // Reset token state
    hfStore.hfToken = '';
    hfStore.useHfToken = false;

    const error: ErrorState = createErrorState(
      new Error('Something unexpected happened'),
      'download',
      'huggingface',
      {
        modelId: 'test-model',
      },
    );

    const {getByText, getAllByText} = render(
      <DownloadErrorDialog
        visible={true}
        onDismiss={mockDismiss}
        error={error}
        model={mockModel}
        onTryAgain={mockTryAgain}
      />,
    );

    // Check that the generic error title is displayed
    expect(
      getByText(l10n.en.components.downloadErrorDialog.downloadFailedTitle),
    ).toBeTruthy();

    // Check that the error message is displayed
    expect(getAllByText('Something unexpected happened')[0]).toBeTruthy();
  });
});



================================================
FILE: src/components/EmbeddedVideoView/EmbeddedVideoView.tsx
================================================
import React, {useCallback, useEffect, useRef, useState} from 'react';
import {
  View,
  TouchableOpacity,
  Text,
  ActivityIndicator,
  Platform,
  Alert,
} from 'react-native';

import {observer} from 'mobx-react';
import 'react-native-get-random-values';
import * as RNFS from '@dr.pogodin/react-native-fs';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import {
  Camera,
  useCameraDevice,
  useCameraPermission,
  CameraPosition,
} from 'react-native-vision-camera';

import {useTheme} from '../../hooks';

import {createStyles} from './styles';
import {ResponseBubble} from '../ResponseBubble';

import {L10nContext} from '../../utils';

interface EmbeddedVideoViewProps {
  onCapture: (imageBase64: string) => void;
  onClose: () => void;
  captureInterval: number;
  onCaptureIntervalChange: (interval: number) => void;
  responseText?: string;
}

export const EmbeddedVideoView = observer(
  ({
    onCapture,
    onClose,
    captureInterval,
    onCaptureIntervalChange,
    responseText,
  }: EmbeddedVideoViewProps) => {
    const theme = useTheme();
    const styles = createStyles({theme});
    const l10n = React.useContext(L10nContext);
    const {hasPermission, requestPermission} = useCameraPermission();
    const [cameraPosition, setCameraPosition] =
      useState<CameraPosition>('back');
    const [isCapturing, setIsCapturing] = useState(false);
    const camera = useRef<Camera>(null);
    const device = useCameraDevice(cameraPosition);
    const captureTimerRef = useRef<NodeJS.Timeout | null>(null);

    // Check if running in simulator - simplified check for iOS simulator
    const isSimulator = Platform.OS === 'ios' && !device;

    // Request camera permission if not granted
    useEffect(() => {
      if (!hasPermission) {
        const requestCameraPermission = async () => {
          try {
            console.log('Requesting camera permission...');
            const result = await requestPermission();
            console.log('Camera permission result:', result);
            if (!result) {
              // Permission was denied
              Alert.alert(
                l10n.video.permissionTitle,
                l10n.video.permissionMessage,
                [
                  {
                    text: l10n.common.ok,
                    onPress: onClose,
                  },
                ],
              );
            }
          } catch (error) {
            console.error('Error requesting camera permission:', error);
            Alert.alert(
              l10n.video.permissionTitle,
              l10n.video.permissionMessage,
              [
                {
                  text: l10n.common.ok,
                  onPress: onClose,
                },
              ],
            );
          }
        };

        requestCameraPermission();
      }
    }, [hasPermission, requestPermission, onClose, l10n]);

    const stopCapturing = useCallback(() => {
      if (captureTimerRef.current) {
        clearInterval(captureTimerRef.current);
        captureTimerRef.current = null;
      }
    }, []);

    const startCapturing = useCallback(() => {
      stopCapturing();

      captureTimerRef.current = setInterval(async () => {
        if (camera.current && !isCapturing) {
          setIsCapturing(true);
          try {
            const photo = await camera.current.takePhoto({
              flash: 'off',
              enableShutterSound: false,
            });

            // Convert photo to base64
            const filePath = Platform.OS === 'ios' ? photo.path : photo.path;
            const base64Data = await RNFS.readFile(filePath, 'base64');

            // Clean up the temporary file immediately after reading
            try {
              await RNFS.unlink(filePath);
            } catch (deleteError) {
              console.warn(
                'Failed to delete temporary image file:',
                deleteError,
              );
              // Don't throw - continue with the base64 data even if cleanup fails
            }

            // Create data URL format expected by llama.rn
            const imageBase64 = `data:image/jpeg;base64,${base64Data}`;

            onCapture(imageBase64);
          } catch (error) {
            // Only log error if camera is still supposed to be active
            console.error('Error taking photo or converting to base64:', error);
          } finally {
            setIsCapturing(false);
          }
        }
      }, captureInterval);
    }, [stopCapturing, captureInterval, isCapturing, onCapture]);

    // Start capturing frames at the specified interval
    useEffect(() => {
      if (hasPermission && device) {
        startCapturing();
      }

      return () => {
        stopCapturing();
      };
    }, [hasPermission, device, captureInterval, startCapturing, stopCapturing]);

    const toggleCameraPosition = useCallback(() => {
      setCameraPosition(current => (current === 'back' ? 'front' : 'back'));
    }, []);

    const decreaseInterval = useCallback(() => {
      const newInterval = Math.max(500, captureInterval - 500);
      onCaptureIntervalChange(newInterval);
    }, [captureInterval, onCaptureIntervalChange]);

    const increaseInterval = useCallback(() => {
      const newInterval = Math.min(5000, captureInterval + 500);
      onCaptureIntervalChange(newInterval);
    }, [captureInterval, onCaptureIntervalChange]);

    if (!hasPermission) {
      return (
        <View style={styles.permissionContainer}>
          <Text style={styles.permissionText}>
            {l10n.video.requestingPermission}
          </Text>
          <ActivityIndicator size="large" color={theme.colors.primary} />
        </View>
      );
    }

    if (!device) {
      return (
        <View style={styles.permissionContainer}>
          <Text style={styles.permissionText}>
            {isSimulator
              ? l10n.simulator.cameraNotAvailable
              : l10n.video.noDevice}
          </Text>
          {isSimulator && (
            <TouchableOpacity style={styles.closeButton} onPress={onClose}>
              <Icon name="close" style={styles.closeButtonIcon} />
            </TouchableOpacity>
          )}
        </View>
      );
    }

    return (
      <View style={styles.container}>
        <Camera
          ref={camera}
          style={styles.camera}
          device={device}
          isActive={true}
          photo={true}
        />

        {/* Response overlay */}
        {responseText ? (
          <View style={styles.responseOverlayContainer}>
            <ResponseBubble>
              <Text style={styles.responseText}>{responseText}</Text>
            </ResponseBubble>
          </View>
        ) : null}

        {/* Interval controls */}
        <View style={styles.intervalControlsContainer}>
          <TouchableOpacity
            style={styles.intervalButton}
            onPress={decreaseInterval}
            testID="decrease-interval-button">
            <Text style={styles.intervalButtonText}>-</Text>
          </TouchableOpacity>
          <View>
            <Text style={styles.intervalValue}>
              {captureInterval}
              {l10n.video.captureIntervalUnit}
            </Text>
          </View>
          <TouchableOpacity
            style={styles.intervalButton}
            onPress={increaseInterval}
            testID="increase-interval-button">
            <Text style={styles.intervalButtonText}>+</Text>
          </TouchableOpacity>
        </View>

        {/* Camera controls */}
        <View style={styles.controlsContainer}>
          <TouchableOpacity
            style={styles.closeButton}
            onPress={onClose}
            testID="close-button">
            <Icon name="close" style={styles.closeButtonIcon} />
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.flipButton}
            onPress={toggleCameraPosition}
            testID="flip-camera-button">
            <Icon name="camera-flip" style={styles.flipButtonIcon} />
          </TouchableOpacity>
        </View>
      </View>
    );
  },
);

export default EmbeddedVideoView;



================================================
FILE: src/components/EmbeddedVideoView/index.ts
================================================
export {default as EmbeddedVideoView} from './EmbeddedVideoView';



================================================
FILE: src/components/EmbeddedVideoView/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {Theme} from '../../utils/types';

export const createStyles = ({theme}: {theme: Theme}) =>
  StyleSheet.create({
    container: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: '#000',
      overflow: 'hidden',
      zIndex: 1,
    },
    camera: {
      flex: 1,
    },
    controlsContainer: {
      position: 'absolute',
      bottom: '5%', // Lower position, below the interval controls
      alignSelf: 'center', // Center horizontally
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      gap: 20, // Space between close and flip buttons
    },
    closeButton: {
      width: 40,
      height: 40,
      borderRadius: 20,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
      borderWidth: 1,
      borderColor: 'rgba(255, 255, 255, 0.2)',
      justifyContent: 'center',
      alignItems: 'center',
    },
    closeButtonIcon: {
      color: '#fff',
      fontSize: 20,
    },
    flipButton: {
      width: 40,
      height: 40,
      borderRadius: 20,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
      borderWidth: 1,
      borderColor: 'rgba(255, 255, 255, 0.2)',
      justifyContent: 'center',
      alignItems: 'center',
    },
    flipButtonIcon: {
      color: '#fff',
      fontSize: 20,
    },
    permissionContainer: {
      height: 250,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: theme.colors.background,
      borderRadius: 12,
      marginHorizontal: 16,
      marginVertical: 8,
      zIndex: 1,
    },
    permissionText: {
      color: theme.colors.onBackground,
      fontSize: 16,
      marginBottom: 20,
      textAlign: 'center',
      paddingHorizontal: 20,
    },
    intervalControlsContainer: {
      position: 'absolute',
      bottom: '11%', // Position above the camera controls
      alignSelf: 'center', // Center horizontally
      width: '50%', // Take up 50% of screen width
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      paddingHorizontal: 16,
      paddingVertical: 8,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
      borderRadius: 25, // Make it oval-shaped
      borderWidth: 1,
      borderColor: 'rgba(255, 255, 255, 0.2)',
    },
    intervalLabel: {
      color: '#fff',
      fontSize: 11,
      marginRight: 4,
      fontWeight: '500',
      textShadowColor: 'rgba(0, 0, 0, 0.5)',
      textShadowOffset: {width: 0, height: 1},
      textShadowRadius: 1,
    },
    intervalValue: {
      color: '#fff',
      fontSize: 12,
      marginHorizontal: 8,
      minWidth: 40,
      textAlign: 'center',
      fontWeight: '600',
      textShadowColor: 'rgba(0, 0, 0, 0.5)',
      textShadowOffset: {width: 0, height: 1},
      textShadowRadius: 1,
    },
    intervalButton: {
      width: 26,
      height: 26,
      borderRadius: 13,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
      justifyContent: 'center',
      alignItems: 'center',
      borderWidth: 1,
      borderColor: 'rgba(255, 255, 255, 0.2)',
    },
    intervalButtonText: {
      color: '#fff',
      fontSize: 14,
      fontWeight: 'bold',
    },
    responseOverlayContainer: {
      position: 'absolute',
      bottom: 180,
      left: 16,
      right: 16,
      maxHeight: '40%',
    },
    responseText: {
      color: '#fff',
      fontSize: 16,
      lineHeight: 22,
      fontWeight: '400',
    },
  });



================================================
FILE: src/components/EmbeddedVideoView/__tests__/EmbeddedVideoView.test.tsx
================================================
import React from 'react';
import {render, fireEvent, waitFor} from '@testing-library/react-native';
import {Alert, Platform} from 'react-native';

import {EmbeddedVideoView} from '../EmbeddedVideoView';
import {L10nContext} from '../../../utils';
import {l10n} from '../../../utils/l10n';

// Mock react-native-vision-camera
jest.mock('react-native-vision-camera', () => {
  const mockReact = require('react');
  return {
    Camera: mockReact.forwardRef(({children, ...props}: any, ref: any) =>
      mockReact.createElement(
        'View',
        {ref, testID: 'camera', ...props},
        children,
      ),
    ),
    useCameraDevice: jest.fn(() => ({id: 'mock-device'})),
    useCameraPermission: jest.fn(() => ({
      hasPermission: true,
      requestPermission: jest.fn(() => Promise.resolve(true)),
    })),
  };
});

// Mock react-native-vector-icons
jest.mock('react-native-vector-icons/MaterialCommunityIcons', () => 'Icon');

// Mock useTheme hook
jest.mock('../../../hooks', () => ({
  useTheme: () => ({
    colors: {
      primary: '#007AFF',
      surface: '#FFFFFF',
      onSurface: '#000000',
    },
  }),
}));

// Mock Alert
jest.spyOn(Alert, 'alert');

// Mock Platform
Object.defineProperty(Platform, 'OS', {
  get: jest.fn(() => 'ios'),
});

const defaultProps = {
  onCapture: jest.fn(),
  onClose: jest.fn(),
  captureInterval: 2000,
  onCaptureIntervalChange: jest.fn(),
  responseText: undefined,
};

describe('EmbeddedVideoView', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  it('renders correctly with camera permission', () => {
    const {getByTestId} = render(
      <L10nContext.Provider value={l10n.en}>
        <EmbeddedVideoView {...defaultProps} />
      </L10nContext.Provider>,
    );

    expect(getByTestId('camera')).toBeTruthy();
  });

  it('renders response text when provided', () => {
    const {getByText} = render(
      <L10nContext.Provider value={l10n.en}>
        <EmbeddedVideoView {...defaultProps} responseText="Test response" />
      </L10nContext.Provider>,
    );

    expect(getByText('Test response')).toBeTruthy();
  });

  it('does not render response overlay when no response text', () => {
    const {queryByText} = render(
      <L10nContext.Provider value={l10n.en}>
        <EmbeddedVideoView {...defaultProps} />
      </L10nContext.Provider>,
    );

    // Should not have response text specifically
    expect(queryByText('Test response')).toBeNull();
  });

  it('handles camera permission request', async () => {
    const mockRequestPermission = jest.fn(() => Promise.resolve(true));
    const {useCameraPermission} = require('react-native-vision-camera');
    useCameraPermission.mockReturnValue({
      hasPermission: false,
      requestPermission: mockRequestPermission,
    });

    render(
      <L10nContext.Provider value={l10n.en}>
        <EmbeddedVideoView {...defaultProps} />
      </L10nContext.Provider>,
    );

    // Wait for the component to request permission
    await waitFor(
      () => {
        expect(mockRequestPermission).toHaveBeenCalled();
      },
      {timeout: 3000},
    );
  });

  it('shows permission alert when permission denied', async () => {
    const mockRequestPermission = jest.fn(() => Promise.resolve(false));
    const {useCameraPermission} = require('react-native-vision-camera');
    useCameraPermission.mockReturnValue({
      hasPermission: false,
      requestPermission: mockRequestPermission,
    });

    render(
      <L10nContext.Provider value={l10n.en}>
        <EmbeddedVideoView {...defaultProps} />
      </L10nContext.Provider>,
    );

    await waitFor(() => {
      expect(Alert.alert).toHaveBeenCalledWith(
        l10n.en.video.permissionTitle,
        l10n.en.video.permissionMessage,
        expect.arrayContaining([
          expect.objectContaining({
            text: l10n.en.common.ok,
            onPress: defaultProps.onClose,
          }),
        ]),
      );
    });
  });

  it('handles permission request error', async () => {
    const mockRequestPermission = jest.fn(() =>
      Promise.reject(new Error('Permission error')),
    );
    const {useCameraPermission} = require('react-native-vision-camera');
    useCameraPermission.mockReturnValue({
      hasPermission: false,
      requestPermission: mockRequestPermission,
    });

    render(
      <L10nContext.Provider value={l10n.en}>
        <EmbeddedVideoView {...defaultProps} />
      </L10nContext.Provider>,
    );

    await waitFor(
      () => {
        expect(Alert.alert).toHaveBeenCalledWith(
          l10n.en.video.permissionTitle,
          l10n.en.video.permissionMessage,
          expect.arrayContaining([
            expect.objectContaining({
              text: l10n.en.common.ok,
              onPress: defaultProps.onClose,
            }),
          ]),
        );
      },
      {timeout: 3000},
    );
  });

  it('toggles camera position when flip button is pressed', () => {
    // Mock camera permission as granted
    const {useCameraPermission} = require('react-native-vision-camera');
    useCameraPermission.mockReturnValue({
      hasPermission: true,
      requestPermission: jest.fn(),
    });

    const {getByTestId} = render(
      <L10nContext.Provider value={l10n.en}>
        <EmbeddedVideoView {...defaultProps} />
      </L10nContext.Provider>,
    );

    const flipButton = getByTestId('flip-camera-button');

    // Just verify the button exists and can be pressed
    expect(flipButton).toBeTruthy();
    fireEvent.press(flipButton);

    // The camera position toggle is internal state, so we just verify the button works
    expect(flipButton).toBeTruthy();
  });

  it('increases capture interval when increase button is pressed', () => {
    // Mock camera permission as granted
    const {useCameraPermission} = require('react-native-vision-camera');
    useCameraPermission.mockReturnValue({
      hasPermission: true,
      requestPermission: jest.fn(),
    });

    const {getByTestId} = render(
      <L10nContext.Provider value={l10n.en}>
        <EmbeddedVideoView {...defaultProps} captureInterval={2000} />
      </L10nContext.Provider>,
    );

    const increaseButton = getByTestId('increase-interval-button');
    fireEvent.press(increaseButton);

    expect(defaultProps.onCaptureIntervalChange).toHaveBeenCalledWith(2500);
  });

  it('decreases capture interval when decrease button is pressed', () => {
    // Mock camera permission as granted
    const {useCameraPermission} = require('react-native-vision-camera');
    useCameraPermission.mockReturnValue({
      hasPermission: true,
      requestPermission: jest.fn(),
    });

    const {getByTestId} = render(
      <L10nContext.Provider value={l10n.en}>
        <EmbeddedVideoView {...defaultProps} captureInterval={2000} />
      </L10nContext.Provider>,
    );

    const decreaseButton = getByTestId('decrease-interval-button');
    fireEvent.press(decreaseButton);

    expect(defaultProps.onCaptureIntervalChange).toHaveBeenCalledWith(1500);
  });

  it('does not decrease interval below minimum', () => {
    // Mock camera permission as granted
    const {useCameraPermission} = require('react-native-vision-camera');
    useCameraPermission.mockReturnValue({
      hasPermission: true,
      requestPermission: jest.fn(),
    });

    const {getByTestId} = render(
      <L10nContext.Provider value={l10n.en}>
        <EmbeddedVideoView {...defaultProps} captureInterval={500} />
      </L10nContext.Provider>,
    );

    const decreaseButton = getByTestId('decrease-interval-button');
    fireEvent.press(decreaseButton);

    expect(defaultProps.onCaptureIntervalChange).toHaveBeenCalledWith(500); // Should stay at minimum
  });

  it('does not increase interval above maximum', () => {
    // Mock camera permission as granted
    const {useCameraPermission} = require('react-native-vision-camera');
    useCameraPermission.mockReturnValue({
      hasPermission: true,
      requestPermission: jest.fn(),
    });

    const {getByTestId} = render(
      <L10nContext.Provider value={l10n.en}>
        <EmbeddedVideoView {...defaultProps} captureInterval={5000} />
      </L10nContext.Provider>,
    );

    const increaseButton = getByTestId('increase-interval-button');
    fireEvent.press(increaseButton);

    expect(defaultProps.onCaptureIntervalChange).toHaveBeenCalledWith(5000); // Should stay at maximum
  });

  it('calls onClose when close button is pressed', () => {
    // Mock camera permission as granted
    const {useCameraPermission} = require('react-native-vision-camera');
    useCameraPermission.mockReturnValue({
      hasPermission: true,
      requestPermission: jest.fn(),
    });

    const {getByTestId} = render(
      <L10nContext.Provider value={l10n.en}>
        <EmbeddedVideoView {...defaultProps} />
      </L10nContext.Provider>,
    );

    const closeButton = getByTestId('close-button');
    fireEvent.press(closeButton);

    expect(defaultProps.onClose).toHaveBeenCalled();
  });

  it('detects iOS simulator correctly', () => {
    // Mock camera permission as granted
    const {
      useCameraPermission,
      useCameraDevice,
    } = require('react-native-vision-camera');
    useCameraPermission.mockReturnValue({
      hasPermission: true,
      requestPermission: jest.fn(),
    });
    useCameraDevice.mockReturnValue(null); // Simulate no device (simulator)

    const {getByText} = render(
      <L10nContext.Provider value={l10n.en}>
        <EmbeddedVideoView {...defaultProps} />
      </L10nContext.Provider>,
    );

    // Should show simulator message when no camera device is available
    expect(
      getByText(
        'Camera not available in simulator. Please use a physical device.',
      ),
    ).toBeTruthy();
  });
});



================================================
FILE: src/components/ErrorSnackbar/ErrorSnackbar.tsx
================================================
import React from 'react';
import {View} from 'react-native';
import {Portal, Snackbar, Text} from 'react-native-paper';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';

import {useTheme} from '../../hooks';
import {ErrorState} from '../../utils/errors';
import {createStyles} from './styles';

interface ErrorSnackbarProps {
  error: ErrorState | null;
  onDismiss: () => void;
  onRetry?: () => void;
  onSettings?: () => void;
}

export const ErrorSnackbar: React.FC<ErrorSnackbarProps> = ({
  error,
  onDismiss,
  onRetry,
  onSettings,
}) => {
  const theme = useTheme();

  if (!error) {
    return null;
  }

  const styles = createStyles(theme);

  // Get the appropriate icon based on error code and service
  const getIcon = () => {
    // Service-specific icons for auth errors
    if (error.code === 'authentication' || error.code === 'authorization') {
      switch (error.service) {
        case 'huggingface':
          return 'key-alert'; // Specific icon for HF auth issues
        case 'firebase':
          return 'firebase'; // Firebase-specific icon
        default:
          return 'shield-alert-outline'; // Generic auth icon
      }
    }

    // For other error types
    switch (error.code) {
      case 'network':
        return 'wifi-off';
      case 'storage':
        return 'harddisk-remove';
      case 'server':
        return 'server-off';
      case 'multimodal':
        return 'image-off-outline';
      default:
        return 'alert-circle-outline';
    }
  };

  // Determine the appropriate action based on error type, context, and service
  const getAction = () => {
    // For auth errors, customize based on service
    if (
      (error.code === 'authentication' || error.code === 'authorization') &&
      onSettings
    ) {
      const label = error.service === 'huggingface' ? 'Add Token' : 'Settings';

      return {
        label,
        onPress: onSettings,
        labelStyle: {color: theme.colors.secondary},
      };
    }

    // For recoverable errors, show retry button
    if (error.recoverable && onRetry) {
      return {
        label: 'Retry',
        onPress: onRetry,
        labelStyle: {color: theme.colors.secondary},
      };
    }

    // Default action is just to dismiss
    return {
      label: 'Dismiss',
      onPress: onDismiss,
      labelStyle: {color: theme.colors.secondary},
    };
  };

  // Calculate duration based on error type and severity
  const getDuration = () => {
    if (error.severity === 'warning') {
      return 8000; // 8 seconds for warnings
    }
    if (
      error.code === 'authentication' ||
      error.code === 'authorization' ||
      error.code === 'storage'
    ) {
      return 20000; // 20 seconds for critical errors
    }
    return 10000; // 10 seconds for regular errors
  };

  // Get the appropriate icon color based on severity
  const getIconColor = () => {
    if (error.severity === 'warning') {
      return theme.colors.onSurfaceVariant; // More subtle color for warnings
    }
    return theme.colors.error; // Standard error color
  };

  return (
    <Portal>
      <Snackbar
        testID="error-snackbar"
        visible={true}
        onDismiss={onDismiss}
        duration={getDuration()}
        style={styles.snackbar}
        wrapperStyle={styles.wrapper} // Ensure it's above everything
        action={getAction()}>
        <View style={styles.content}>
          <Icon
            testID={`icon-${getIcon()}`}
            name={getIcon()}
            size={20}
            color={getIconColor()}
            style={styles.icon}
          />
          <Text style={styles.message}>{error.message}</Text>
        </View>
      </Snackbar>
    </Portal>
  );
};



================================================
FILE: src/components/ErrorSnackbar/index.ts
================================================
export * from './ErrorSnackbar';



================================================
FILE: src/components/ErrorSnackbar/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {Theme} from '../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    snackbar: {
      backgroundColor: theme.colors.errorContainer,
    },
    content: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    icon: {
      marginRight: 8,
    },
    message: {
      color: theme.colors.onErrorContainer,
      flex: 1,
    },
    action: {
      marginRight: -8, // Offset Paper's internal padding
    },
    actionLabel: {
      color: theme.colors.primary,
    },
    wrapper: {
      zIndex: 9999,
    },
  });



================================================
FILE: src/components/ErrorSnackbar/__tests__/ErrorSnackbar.test.tsx
================================================
import React from 'react';
import {render as renderNative} from '@testing-library/react-native';
import {render, fireEvent} from '../../../../jest/test-utils';
import {ErrorSnackbar} from '../ErrorSnackbar';
import {ErrorState, NetworkError, ServerError} from '../../../utils/errors';
import {createErrorState} from '../../../utils/errors';
import {l10n} from '../../../utils/l10n';

describe('ErrorSnackbar', () => {
  const mockDismiss = jest.fn();
  const mockRetry = jest.fn();
  const mockSettings = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders null when there is no error', () => {
    const {toJSON} = renderNative(
      <ErrorSnackbar
        error={null}
        onDismiss={mockDismiss}
        onRetry={mockRetry}
        onSettings={mockSettings}
      />,
    );
    expect(toJSON()).toBeNull();
  });

  it('renders authentication error for HuggingFace with correct icon and actions', () => {
    const error: ErrorState = createErrorState(
      new Error('Client error: 401'),
      'download',
      'huggingface',
      {
        context: 'download',
      },
    );

    const {getByText, getByTestId} = render(
      <ErrorSnackbar
        error={error}
        onDismiss={mockDismiss}
        onRetry={mockRetry}
        onSettings={mockSettings}
      />,
    );

    // Check that the correct icon is displayed for HF auth error
    expect(getByTestId('icon-key-alert')).toBeTruthy();

    // Check that the error message is displayed
    expect(getByText(l10n.en.errors.hfAuthenticationError)).toBeTruthy();

    // Check that the "Add Token" action is available for HF auth errors
    const addTokenButton = getByText('Add Token');
    fireEvent.press(addTokenButton);
    expect(mockSettings).toHaveBeenCalled();
  });

  it('renders network error with correct icon and retry action', () => {
    const error: ErrorState = createErrorState(
      new NetworkError('Network connection error'),
      'search',
      'huggingface',
      {
        context: 'download',
      },
    );
    const {getByText, getByTestId} = render(
      <ErrorSnackbar
        error={error}
        onDismiss={mockDismiss}
        onRetry={mockRetry}
      />,
    );

    // Check that the correct icon is displayed for network error
    expect(getByTestId('icon-wifi-off')).toBeTruthy();

    // Check that the error message is displayed
    expect(getByText('Network connection error')).toBeTruthy();

    // For recoverable errors, check that "Retry" action is available
    const retryButton = getByText('Retry');
    fireEvent.press(retryButton);
    expect(mockRetry).toHaveBeenCalled();
  });

  it('renders server error with correct icon and dismiss action', () => {
    const error: ErrorState = createErrorState(
      new ServerError('Server unavailable'),
      'search',
      'firebase',
      {
        context: 'search',
      },
    );
    const {getByText, getByTestId} = render(
      <ErrorSnackbar error={error} onDismiss={mockDismiss} />,
    );

    // Check that the correct icon is displayed for server error
    expect(getByTestId('icon-server-off')).toBeTruthy();

    // Check that the error message is displayed
    expect(getByText('Server unavailable')).toBeTruthy();

    // For non-recoverable errors without retry, check "Dismiss" action
    const dismissButton = getByText('Dismiss');
    fireEvent.press(dismissButton);
    expect(mockDismiss).toHaveBeenCalled();
  });

  it('renders storage error with correct icon', () => {
    const error: ErrorState = createErrorState(
      new Error('Not enough storage space'),
      'download',
      'localapi',
      {
        context: 'download',
      },
    );

    const {getByText, getByTestId} = render(
      <ErrorSnackbar error={error} onDismiss={mockDismiss} />,
    );

    // Check that the correct icon is displayed for storage error
    expect(getByTestId('icon-harddisk-remove')).toBeTruthy();

    // Check that the error message is displayed
    expect(getByText('Not enough storage space')).toBeTruthy();
  });

  it('renders unknown error with default icon', () => {
    const error: ErrorState = createErrorState(
      new Error('Something went wrong'),
      'search',
      'localapi',
      {
        context: 'search',
      },
    );
    const {getByText, getByTestId} = render(
      <ErrorSnackbar
        error={error}
        onDismiss={mockDismiss}
        onRetry={mockRetry}
      />,
    );

    // Check that the default icon is displayed for unknown error
    expect(getByTestId('icon-alert-circle-outline')).toBeTruthy();

    // Check that the error message is displayed
    expect(getByText('Something went wrong')).toBeTruthy();
  });
});



================================================
FILE: src/components/FileMessage/FileMessage.tsx
================================================
import * as React from 'react';
import {Image, Text, View} from 'react-native';

import {useTheme} from '../../hooks';

import {styles} from './styles';

import {MessageType} from '../../utils/types';
import {formatBytes, L10nContext, UserContext} from '../../utils';

export interface FileMessageProps {
  message: MessageType.DerivedFile;
}

export const FileMessage = ({message}: FileMessageProps) => {
  const l10n = React.useContext(L10nContext);
  const user = React.useContext(UserContext);
  const theme = useTheme();
  const {container, icon, iconContainer, name, size, textContainer} = styles({
    message,
    theme,
    user,
  });

  return (
    <View
      accessibilityLabel={
        l10n.components.fileMessage.fileButtonAccessibilityLabel
      }
      style={container}>
      <View style={iconContainer}>
        {theme.icons?.documentIcon?.() ?? (
          <Image
            source={require('../../assets/icon-document.png')}
            style={icon}
          />
        )}
      </View>
      <View style={textContainer}>
        <Text style={name}>{message.name}</Text>
        <Text style={size}>{formatBytes(message.size)}</Text>
      </View>
    </View>
  );
};



================================================
FILE: src/components/FileMessage/index.ts
================================================
export * from './FileMessage';



================================================
FILE: src/components/FileMessage/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {MessageType, Theme, User} from '../../utils/types';

export const styles = ({
  message,
  theme,
  user,
}: {
  message: MessageType.DerivedFile;
  theme: Theme;
  user?: User;
}) =>
  StyleSheet.create({
    container: {
      alignItems: 'center',
      flexDirection: 'row',
      padding: theme.insets.messageInsetsVertical,
      paddingRight: theme.insets.messageInsetsHorizontal,
    },
    icon: {
      tintColor:
        user?.id === message.author.id
          ? theme.colors.sentMessageDocumentIcon
          : theme.colors.receivedMessageDocumentIcon,
    },
    iconContainer: {
      alignItems: 'center',
      backgroundColor:
        user?.id === message.author.id
          ? `${String(theme.colors.sentMessageDocumentIcon)}33`
          : `${String(theme.colors.receivedMessageDocumentIcon)}33`,
      borderRadius: 21,
      height: 42,
      justifyContent: 'center',
      width: 42,
    },
    name: {
      ...(user?.id === message.author.id
        ? theme.fonts.sentMessageBodyTextStyle
        : theme.fonts.receivedMessageBodyTextStyle),
    },
    size: {
      ...(user?.id === message.author.id
        ? theme.fonts.sentMessageCaptionTextStyle
        : theme.fonts.receivedMessageCaptionTextStyle),
      marginTop: 4,
    },
    textContainer: {
      flexShrink: 1,
      marginLeft: 16,
    },
  });



================================================
FILE: src/components/HeaderLeft/HeaderLeft.tsx
================================================
import React from 'react';
import {TouchableOpacity} from 'react-native';
import {DrawerNavigationProp} from '@react-navigation/drawer';
import {useNavigation} from '@react-navigation/native';

import {styles} from './styles';
import {MenuIcon} from '../../assets/icons';
import {useTheme} from '../../hooks';

export const HeaderLeft: React.FC = () => {
  const theme = useTheme();
  const navigation = useNavigation<DrawerNavigationProp<any>>();

  return (
    <TouchableOpacity
      style={[styles.menuIcon]}
      onPress={() => navigation.openDrawer()}>
      <MenuIcon stroke={theme.colors.primary} />
    </TouchableOpacity>
  );
};



================================================
FILE: src/components/HeaderLeft/index.ts
================================================
export {HeaderLeft} from './HeaderLeft';



================================================
FILE: src/components/HeaderLeft/styles.ts
================================================
import {StyleSheet} from 'react-native';

export const styles = StyleSheet.create({
  menuIcon: {
    // Minimum 44pt touch target for iOS accessibility guidelines
    height: 44,
    width: 44,
    marginHorizontal: 11,
    justifyContent: 'center',
    alignItems: 'center',
  },
});



================================================
FILE: src/components/HeaderRight/HeaderRight.tsx
================================================
import React, {useContext} from 'react';
import {Alert, Keyboard, View} from 'react-native';

import {observer} from 'mobx-react';
import {IconButton, useTheme} from 'react-native-paper';

import {
  // ClockFastForwardIcon,
  DotsVerticalIcon,
  DuplicateIcon,
  EditBoxIcon,
  EditIcon,
  GridIcon,
  SettingsIcon,
  ShareIcon,
  TrashIcon,
} from '../../assets/icons';

import {Menu} from '../Menu';
import {styles} from './styles';

import {chatSessionStore, modelStore, uiStore} from '../../store';

import {L10nContext} from '../../utils';
import {Model} from '../../utils/types';
import {importChatSessions} from '../../utils/importUtils';
import {
  exportChatSession,
  exportAllChatSessions,
} from '../../utils/exportUtils';

import {RenameModal, UsageStats} from '..';
import {ChatGenerationSettingsSheet} from '..';

export const HeaderRight: React.FC = observer(() => {
  const theme = useTheme();
  const [menuVisible, setMenuVisible] = React.useState(false);
  const [renameModalVisible, setRenameModalVisible] = React.useState(false);
  const [chatGenerationSettingsVisible, setChatGenerationSettingsVisible] =
    React.useState(false);

  const openMenu = () => {
    if (Keyboard.isVisible()) {
      Keyboard.dismiss();
    }
    setMenuVisible(true);
  };
  const closeMenu = () => setMenuVisible(false);
  const l10n = useContext(L10nContext);

  const models = modelStore.availableModels;
  const activeModelId = modelStore.activeModelId;
  const session = chatSessionStore.sessions.find(
    s => s.id === chatSessionStore.activeSessionId,
  );

  const onSelectModel = (model: Model) => {
    modelStore.initContext(model);
    closeMenu();
  };

  const onPressGenerationSettings = () => {
    setChatGenerationSettingsVisible(true);
    closeMenu();
  };

  const onPressDelete = () => {
    if (session?.id) {
      Alert.alert(
        l10n.components.headerRight.deleteChatTitle,
        l10n.components.headerRight.deleteChatMessage,
        [
          {
            text: l10n.common.cancel,
            style: 'cancel',
          },
          {
            text: l10n.common.delete,
            style: 'destructive',
            onPress: async () => {
              chatSessionStore.resetActiveSession();
              await chatSessionStore.deleteSession(session.id);
              closeMenu();
            },
          },
        ],
      );
    }
    closeMenu();
  };

  const onPressDuplicate = async () => {
    if (session?.id) {
      await chatSessionStore.duplicateSession(session.id);
      closeMenu();
    }
  };

  const onPressRename = () => {
    setRenameModalVisible(true);
    closeMenu();
  };

  const onPressExportCurrentSession = async () => {
    if (session?.id) {
      try {
        await exportChatSession(session.id);
      } catch (error) {
        console.error('Error exporting current session:', error);
        Alert.alert('Export Error', 'Failed to export the current session.');
      }
    }
    closeMenu();
  };

  const onPressExportAllSessions = async () => {
    try {
      await exportAllChatSessions();
    } catch (error) {
      console.error('Error exporting all sessions:', error);
      Alert.alert('Export Error', 'Failed to export all sessions.');
    }
    closeMenu();
  };

  const onPressImportSessions = async () => {
    try {
      const count = await importChatSessions();
      if (count > 0) {
        Alert.alert(
          'Import Success',
          l10n.settings.importSuccess.replace('{{count}}', count.toString()),
        );
        // Refresh the chat sessions
        await chatSessionStore.loadSessionList();
      }
    } catch (error) {
      console.error('Error importing sessions:', error);
      Alert.alert('Import Error', l10n.settings.importError);
    }
    closeMenu();
  };

  return (
    <View style={styles.headerRightContainer}>
      {uiStore.displayMemUsage && <UsageStats width={40} height={20} />}
      <IconButton
        icon={() => <EditBoxIcon stroke={theme.colors.primary} />}
        testID="reset-button"
        style={styles.chatBtn}
        onPress={() => {
          chatSessionStore.resetActiveSession();
        }}
      />
      <Menu
        visible={menuVisible}
        onDismiss={closeMenu}
        anchorPosition="bottom"
        anchor={
          <IconButton
            icon={() => <DotsVerticalIcon fill={theme.colors.primary} />}
            style={styles.menuBtn}
            onPress={openMenu}
            testID="menu-button"
          />
        }>
        <Menu.Item
          onPress={onPressGenerationSettings}
          label={l10n.components.headerRight.generationSettings}
          leadingIcon={() => <SettingsIcon stroke={theme.colors.primary} />}
        />
        <Menu.Item
          disabled={models.length === 0}
          submenu={models.map(model => (
            <Menu.Item
              label={model.name}
              onPress={() => onSelectModel(model)}
              key={model.id}
              selectable
              selected={model.id === activeModelId}
            />
          ))}
          label={l10n.components.headerRight.model}
          leadingIcon={() => <GridIcon stroke={theme.colors.primary} />}
        />
        {session?.id && (
          <>
            <Menu.Separator />
            <Menu.Item
              onPress={onPressDuplicate}
              label={l10n.components.headerRight.duplicateChatHistory}
              leadingIcon={() => (
                <DuplicateIcon stroke={theme.colors.primary} />
              )}
            />
            <Menu.Item
              onPress={onPressRename}
              label={l10n.common.rename}
              leadingIcon={() => <EditIcon stroke={theme.colors.primary} />}
            />
            <Menu.Item
              onPress={onPressDelete}
              label={l10n.common.delete}
              labelStyle={{color: theme.colors.error}}
              leadingIcon={() => <TrashIcon stroke={theme.colors.error} />}
            />
            {/* <Menu.Separator />
            <Menu.Item
              onPress={() => {}}
              label={l10n.components.headerRight.makeChatTemporary}
              leadingIcon={() => (
                <ClockFastForwardIcon stroke={theme.colors.primary} />
              )}
            /> */}
          </>
        )}
        <Menu.Item
          submenu={[
            <Menu.Item
              disabled={!session?.id}
              key="export-current"
              onPress={onPressExportCurrentSession}
              label={l10n.components.headerRight.exportCurrentSession}
            />,
            <Menu.Item
              key="export-all"
              onPress={onPressExportAllSessions}
              label={l10n.components.headerRight.exportAllSessions}
            />,
            <Menu.Item
              key="import"
              onPress={onPressImportSessions}
              label={l10n.components.headerRight.importSessions}
            />,
          ]}
          label={l10n.components.headerRight.export}
          leadingIcon={() => <ShareIcon stroke={theme.colors.primary} />}
        />
      </Menu>
      <ChatGenerationSettingsSheet
        isVisible={chatGenerationSettingsVisible}
        onClose={() => setChatGenerationSettingsVisible(false)}
      />
      {session && (
        <RenameModal
          visible={renameModalVisible}
          onClose={() => setRenameModalVisible(false)}
          session={session}
        />
      )}
    </View>
  );
});



================================================
FILE: src/components/HeaderRight/index.ts
================================================
export * from './HeaderRight';



================================================
FILE: src/components/HeaderRight/styles.ts
================================================
import {StyleSheet} from 'react-native';

export const styles = StyleSheet.create({
  headerRightContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  menuBtn: {
    marginLeft: 0,
  },
  chatBtn: {
    marginRight: 0,
  },
});



================================================
FILE: src/components/HeaderRight/__tests__/HeaderRight.test.tsx
================================================
import React from 'react';
import {Alert} from 'react-native';

import {render, fireEvent} from '../../../../jest/test-utils';

import {HeaderRight} from '../HeaderRight';

import {chatSessionStore, modelStore, uiStore} from '../../../store';
import {defaultCompletionSettings} from '../../../store/ChatSessionStore';
import {L10nContext} from '../../../utils';
import {modelsList} from '../../../../jest/fixtures/models';
import {l10n} from '../../../utils/l10n';

jest.mock('../../UsageStats', () => ({
  UsageStats: jest.fn(() => {
    const {View} = require('react-native');
    return <View testID="usage-stats" />;
  }),
}));

jest.mock(
  '../../ChatGenerationSettingsSheet/ChatGenerationSettingsSheet',
  () => ({
    ChatGenerationSettingsSheet: jest.fn(({isVisible}) => {
      const {View} = require('react-native');
      if (!isVisible) {
        return null;
      }
      return <View testID="chat-generation-settings-sheet" />;
    }),
  }),
);

const renderWithI18n = (ui: React.ReactElement) => {
  return render(
    <L10nContext.Provider value={l10n.en as any}>{ui}</L10nContext.Provider>,
  );
};

describe('HeaderRight', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    chatSessionStore.sessions = [];
    chatSessionStore.activeSessionId = null;
  });

  it('renders without UsageStats when displayMemUsage is false', () => {
    uiStore.displayMemUsage = false;
    const {queryByTestId} = renderWithI18n(<HeaderRight />);
    expect(queryByTestId('usage-stats')).toBeNull();
    expect(queryByTestId('reset-button')).toBeTruthy();
    expect(queryByTestId('menu-button')).toBeTruthy();
  });

  it('renders UsageStats when displayMemUsage is true', () => {
    uiStore.displayMemUsage = true;
    const {queryByTestId} = renderWithI18n(<HeaderRight />);
    expect(queryByTestId('usage-stats')).toBeTruthy();
    expect(queryByTestId('reset-button')).toBeTruthy();
    expect(queryByTestId('menu-button')).toBeTruthy();
  });

  it('calls resetActiveSession when reset button is pressed', () => {
    const {queryByTestId} = renderWithI18n(<HeaderRight />);
    const resetButton = queryByTestId('reset-button');
    expect(resetButton).toBeTruthy();
    if (resetButton) {
      fireEvent.press(resetButton);
    }
    expect(chatSessionStore.resetActiveSession).toHaveBeenCalled();
  });

  describe('Menu functionality', () => {
    it('opens menu when menu button is pressed', () => {
      const {getByTestId} = renderWithI18n(<HeaderRight />);
      const menuButton = getByTestId('menu-button');
      fireEvent.press(menuButton);
      // Menu should be visible now
      expect(getByTestId('menu-view')).toBeTruthy();
    });

    describe('with active session', () => {
      beforeEach(() => {
        chatSessionStore.sessions = [
          {
            id: 'test-session',
            title: 'Test Session',
            date: new Date().toISOString(),
            messages: [],
            completionSettings: defaultCompletionSettings,
          },
        ];
        chatSessionStore.activeSessionId = 'test-session';
        // Set up the mock model store
        modelStore.models = [modelsList[0]];
        modelStore.activeModelId = modelsList[0].id;
        jest.spyOn(Alert, 'alert').mockImplementation(jest.fn());
      });

      afterEach(() => {
        jest.restoreAllMocks();
      });

      it('shows session-specific menu items', async () => {
        const {getByTestId, findByText} = renderWithI18n(<HeaderRight />);
        const menuButton = getByTestId('menu-button');
        fireEvent.press(menuButton);

        expect(
          await findByText(l10n.en.components.headerRight.generationSettings),
        ).toBeTruthy();
        expect(
          await findByText(l10n.en.components.headerRight.model),
        ).toBeTruthy();
        expect(
          await findByText(l10n.en.components.headerRight.duplicateChatHistory),
        ).toBeTruthy();
        expect(await findByText(l10n.en.common.rename)).toBeTruthy();
        expect(await findByText(l10n.en.common.delete)).toBeTruthy();
      });

      it('handles generation settings press', async () => {
        const {getByTestId, findByText} = renderWithI18n(<HeaderRight />);
        const menuButton = getByTestId('menu-button');
        fireEvent.press(menuButton);

        const settingsButton = await findByText(
          l10n.en.components.headerRight.generationSettings,
        );
        fireEvent.press(settingsButton);

        expect(getByTestId('chat-generation-settings-sheet')).toBeTruthy();
      });

      it('handles delete action with confirmation', async () => {
        const {getByTestId, findByText} = renderWithI18n(<HeaderRight />);
        const menuButton = getByTestId('menu-button');
        fireEvent.press(menuButton);

        const deleteButton = await findByText('Delete');
        fireEvent.press(deleteButton);

        // Verify Alert was shown with correct options
        expect(Alert.alert).toHaveBeenCalledWith(
          'Delete Chat',
          'Are you sure you want to delete this chat?',
          expect.arrayContaining([
            expect.objectContaining({text: 'Cancel'}),
            expect.objectContaining({
              text: 'Delete',
              style: 'destructive',
              onPress: expect.any(Function),
            }),
          ]),
        );

        // Get the delete callback and call it
        const alertCall = (Alert.alert as jest.Mock).mock.calls[0];
        const deleteCallback = alertCall[2].find(
          (button: any) => button.text === 'Delete',
        ).onPress;
        deleteCallback();

        // Verify the delete actions were called
        expect(chatSessionStore.resetActiveSession).toHaveBeenCalled();
        expect(chatSessionStore.deleteSession).toHaveBeenCalledWith(
          'test-session',
        );
      });

      it('handles duplicate action', async () => {
        const {getByTestId, findByText} = renderWithI18n(<HeaderRight />);
        const menuButton = getByTestId('menu-button');
        fireEvent.press(menuButton);

        const duplicateButton = await findByText('Duplicate chat history');
        fireEvent.press(duplicateButton);

        expect(chatSessionStore.duplicateSession).toHaveBeenCalledWith(
          'test-session',
        );
      });
    });
  });
});



================================================
FILE: src/components/HFTokenSheet/HFTokenSheet.tsx
================================================
import React, {useState, useContext, useEffect} from 'react';
import {View, Linking} from 'react-native';
import {
  Text,
  Button,
  Snackbar,
  TextInput as PaperTextInput,
} from 'react-native-paper';
import {observer} from 'mobx-react';

import {Sheet, TextInput} from '..';
import {useTheme} from '../../hooks';
import {hfStore} from '../../store';
import {L10nContext} from '../../utils';

import {createStyles} from './styles';
import {EyeIcon, EyeOffIcon} from '../../assets/icons';

interface HFTokenSheetProps {
  isVisible: boolean;
  onDismiss: () => void;
  onSave?: () => void;
}

export const HFTokenSheet: React.FC<HFTokenSheetProps> = observer(
  ({isVisible, onDismiss, onSave}) => {
    const theme = useTheme();
    const l10n = useContext(L10nContext);
    const styles = createStyles(theme);

    const [token, setToken] = useState(hfStore.hfToken || '');
    const [isSubmitting, setIsSubmitting] = useState(false);
    const [isResetting, setIsResetting] = useState(false);
    const [showSuccess, setShowSuccess] = useState(false);
    const [showError, setShowError] = useState(false);
    const [successMessage, setSuccessMessage] = useState('');
    const [secureTextEntry, setSecureTextEntry] = useState(true);

    // Update token state when hfToken changes in store
    useEffect(() => {
      if (hfStore.hfToken) {
        setToken(hfStore.hfToken);
      }
    }, []);

    const handleSaveToken = async () => {
      if (!token.trim()) {
        return;
      }

      setIsSubmitting(true);

      try {
        const success = await hfStore.setToken(token.trim());

        if (success) {
          setSuccessMessage(l10n.components.hfTokenSheet.saved);
          setShowSuccess(true);

          // Call onSave callback if provided
          if (onSave) {
            onSave();
          }
        } else {
          setShowError(true);
        }
      } catch (error) {
        console.error('Error saving token:', error);
        setShowError(true);
      } finally {
        setIsSubmitting(false);
      }
    };

    const handleResetToken = async () => {
      setIsResetting(true);

      try {
        const success = await hfStore.clearToken();

        if (success) {
          setToken('');
          setSuccessMessage(l10n.components.hfTokenSheet.resetSuccess);
          setShowSuccess(true);

          // Call onSave callback if provided
          if (onSave) {
            onSave();
          }
        } else {
          setShowError(true);
        }
      } catch (error) {
        console.error('Error resetting token:', error);
        setShowError(true);
      } finally {
        setIsResetting(false);
      }
    };

    const handleTokenWebsite = () => {
      Linking.openURL('https://huggingface.co/settings/tokens');
    };

    const toggleSecureEntry = () => {
      setSecureTextEntry(!secureTextEntry);
    };

    return (
      <>
        <Sheet
          isVisible={isVisible}
          onClose={onDismiss}
          title={l10n.components.hfTokenSheet.title}
          snapPoints={['60%']}>
          <Sheet.ScrollView contentContainerStyle={styles.container}>
            <Text style={styles.description}>
              {l10n.components.hfTokenSheet.description}
            </Text>

            <View style={styles.instructionsContainer}>
              <Text style={styles.instructionsTitle}>
                {l10n.components.hfTokenSheet.instructions}
              </Text>
              {l10n.components.hfTokenSheet.instructionsSteps.map(
                (step, index) => (
                  <Text key={index} style={styles.instructionItem}>
                    {index + 1}. {step}
                  </Text>
                ),
              )}
              <Text
                testID="hf-token-get-token-link"
                onPress={handleTokenWebsite}
                style={styles.linkButton}>
                {l10n.components.hfTokenSheet.getTokenLink}
              </Text>
            </View>

            <TextInput
              testID="hf-token-input"
              label={l10n.components.hfTokenSheet.inputLabel}
              defaultValue={token}
              onChangeText={setToken}
              //multiline // secureTextEntry is not working with multiline
              //numberOfLines={3}
              placeholder={l10n.components.hfTokenSheet.inputPlaceholder}
              autoCapitalize="none"
              autoCorrect={false}
              spellCheck={false}
              secureTextEntry={secureTextEntry}
              right={
                <PaperTextInput.Icon
                  testID="hf-token-input-icon"
                  icon={({color}) =>
                    secureTextEntry ? (
                      <EyeIcon width={24} height={24} stroke={color} />
                    ) : (
                      <EyeOffIcon width={24} height={24} stroke={color} />
                    )
                  }
                  onPress={toggleSecureEntry}
                />
              }
            />
          </Sheet.ScrollView>
          <Sheet.Actions>
            <View style={styles.buttonsContainer}>
              {hfStore.isTokenPresent && (
                <Button
                  testID="hf-token-reset-button"
                  mode="text"
                  onPress={handleResetToken}
                  loading={isResetting}
                  disabled={isSubmitting || isResetting}
                  style={styles.resetButton}>
                  {l10n.components.hfTokenSheet.reset}
                </Button>
              )}
              <Button
                testID="hf-token-save-button"
                mode="contained"
                onPress={handleSaveToken}
                loading={isSubmitting}
                disabled={isSubmitting || isResetting || !token.trim()}
                style={styles.saveButton}>
                {l10n.components.hfTokenSheet.save}
              </Button>
            </View>
          </Sheet.Actions>
        </Sheet>

        <Snackbar
          visible={showSuccess}
          onDismiss={() => setShowSuccess(false)}
          duration={3000}>
          {successMessage}
        </Snackbar>

        <Snackbar
          visible={showError}
          onDismiss={() => setShowError(false)}
          duration={3000}
          style={styles.errorSnackbar}
          action={{
            label: l10n.common.dismiss,
            onPress: () => setShowError(false),
          }}>
          {l10n.components.hfTokenSheet.error.saving}
        </Snackbar>
      </>
    );
  },
);



================================================
FILE: src/components/HFTokenSheet/index.ts
================================================
export * from './HFTokenSheet';



================================================
FILE: src/components/HFTokenSheet/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {Theme} from '../../utils/types';

export const createStyles = (theme: Theme) => {
  return StyleSheet.create({
    container: {
      padding: 16,
      paddingBottom: 32,
    },
    description: {
      marginBottom: 16,
      color: theme.colors.onSurface,
    },
    instructionsContainer: {
      marginBottom: 24,
      backgroundColor: theme.colors.surfaceContainerLow,
      padding: 16,
      borderRadius: 8,
    },
    instructionsTitle: {
      fontWeight: 'bold',
      marginBottom: 8,
      color: theme.colors.onSurface,
    },
    instructionItem: {
      marginBottom: 6,
      color: theme.colors.onSurface,
    },
    linkButton: {
      marginTop: 8,
      alignSelf: 'flex-start',
      textDecorationLine: 'underline',
    },
    input: {
      marginBottom: 8,
    },
    buttonsContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      width: '100%',
    },
    saveButton: {
      flex: 1,
      marginRight: 8,
    },
    resetButton: {
      flex: 1,
      marginLeft: 8,
    },
    errorSnackbar: {
      backgroundColor: theme.colors.errorContainer,
    },
  });
};



================================================
FILE: src/components/HFTokenSheet/__tests__/HFTokenSheet.test.tsx
================================================
import React from 'react';
import {render, fireEvent, waitFor} from '../../../../jest/test-utils';
import {HFTokenSheet} from '../HFTokenSheet';
import {hfStore} from '../../../store';

jest.mock('react-native/Libraries/Linking/Linking', () => ({
  openURL: jest.fn(() => Promise.resolve()),
}));

jest.mock('../../Sheet', () => {
  const {View, Button} = require('react-native');
  const MockSheet = ({children, isVisible, onClose, title}) => {
    if (!isVisible) {
      return null;
    }
    return (
      <View testID="sheet">
        <View testID="sheet-title">{title}</View>
        <Button title="Close" onPress={onClose} testID="sheet-close-button" />
        {children}
      </View>
    );
  };
  MockSheet.ScrollView = ({children}) => (
    <View testID="sheet-scroll-view">{children}</View>
  );
  MockSheet.Actions = ({children}) => (
    <View testID="sheet-actions">{children}</View>
  );
  return {Sheet: MockSheet};
});

describe('HFTokenSheet', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders correctly with an existing token', () => {
    hfStore.hfToken = 'existing-token';
    const {queryByTestId, getByTestId} = render(
      <HFTokenSheet isVisible={true} onDismiss={jest.fn()} />,
    );

    // Check that the title is displayed
    expect(queryByTestId('sheet-title')).toBeTruthy();

    // Check that the input field is pre-filled with the existing token
    const tokenInput = getByTestId('hf-token-input');
    expect(tokenInput.props.defaultValue).toBe('existing-token');
  });

  it('handles saving a token', async () => {
    const mockOnSave = jest.fn();
    const {getByTestId} = render(
      <HFTokenSheet
        isVisible={true}
        onDismiss={jest.fn()}
        onSave={mockOnSave}
      />,
    );

    // Change token value
    const tokenInput = getByTestId('hf-token-input');
    fireEvent.changeText(tokenInput, 'new-token');

    // Submit the form
    const saveButton = getByTestId('hf-token-save-button');
    fireEvent.press(saveButton);

    // Verify token is saved
    await waitFor(() => {
      expect(hfStore.setToken).toHaveBeenCalledWith('new-token');
      expect(mockOnSave).toHaveBeenCalled();
    });
  });

  it('handles resetting a token', async () => {
    const mockOnSave = jest.fn();
    const {getByTestId} = render(
      <HFTokenSheet
        isVisible={true}
        onDismiss={jest.fn()}
        onSave={mockOnSave}
      />,
    );

    // Click reset button
    const resetButton = getByTestId('hf-token-reset-button');
    fireEvent.press(resetButton);

    // Verify token is cleared
    await waitFor(() => {
      expect(hfStore.clearToken).toHaveBeenCalled();
      expect(mockOnSave).toHaveBeenCalled();
    });
  });

  it('opens the Hugging Face token page when link is clicked', () => {
    const {getByTestId} = render(
      <HFTokenSheet isVisible={true} onDismiss={jest.fn()} />,
    );

    const getTokenLink = getByTestId('hf-token-get-token-link');
    fireEvent.press(getTokenLink);

    // Verify the Linking API was called with the correct URL
    expect(
      require('react-native/Libraries/Linking/Linking').openURL,
    ).toHaveBeenCalledWith('https://huggingface.co/settings/tokens');
  });

  it('toggles password visibility when eye icon is pressed', () => {
    const {getByTestId} = render(
      <HFTokenSheet isVisible={true} onDismiss={jest.fn()} />,
    );

    const tokenInput = getByTestId('hf-token-input');
    expect(tokenInput.props.secureTextEntry).toBe(true);

    // Find the icon button by its props
    const rightIconButton = getByTestId('hf-token-input-icon');
    fireEvent.press(rightIconButton);

    // Now password should be visible (secure entry off)
    expect(tokenInput.props.secureTextEntry).toBe(false);
  });
});



================================================
FILE: src/components/ImageMessage/ImageMessage.tsx
================================================
import * as React from 'react';
import {Image, ImageBackground, Text, View} from 'react-native';

import {useTheme} from '../../hooks';

import styles from './styles';

import {MessageType, Size} from '../../utils/types';
import {formatBytes, UserContext} from '../../utils';

export interface ImageMessageProps {
  message: MessageType.DerivedImage;
  /** Maximum message width */
  messageWidth: number;
}

/** Image message component. Supports different
 * aspect ratios, renders blurred image as a background which is visible
 * if the image is narrow, renders image in form of a file if aspect
 * ratio is very small or very big. */
export const ImageMessage = ({message, messageWidth}: ImageMessageProps) => {
  const theme = useTheme();
  const user = React.useContext(UserContext);
  const defaultHeight = message.height ?? 0;
  const defaultWidth = message.width ?? 0;
  const [size, setSize] = React.useState<Size>({
    height: defaultHeight,
    width: defaultWidth,
  });
  const aspectRatio = size.width / (size.height || 1);
  const isMinimized = aspectRatio < 0.1 || aspectRatio > 10;
  const {
    horizontalImage,
    minimizedImage,
    minimizedImageContainer,
    nameText,
    sizeText,
    textContainer,
    verticalImage,
  } = styles({
    aspectRatio,
    message,
    messageWidth,
    theme,
    user,
  });

  React.useEffect(() => {
    if (defaultHeight <= 0 || defaultWidth <= 0) {
      Image.getSize(
        message.uri,
        (width, height) => setSize({height, width}),
        () => setSize({height: 0, width: 0}),
      );
    }
  }, [defaultHeight, defaultWidth, message.uri]);

  const renderImage = () => {
    return (
      <Image
        accessibilityRole="image"
        testID="message-image"
        resizeMode={isMinimized ? 'cover' : 'contain'}
        source={{uri: message.uri}}
        style={
          isMinimized
            ? minimizedImage
            : aspectRatio < 1
            ? verticalImage
            : horizontalImage
        }
      />
    );
  };

  return isMinimized ? (
    <View style={minimizedImageContainer}>
      {renderImage()}
      <View style={textContainer}>
        <Text style={nameText}>{message.name}</Text>
        <Text style={sizeText}>{formatBytes(message.size)}</Text>
      </View>
    </View>
  ) : (
    <ImageBackground blurRadius={26} source={{uri: message.uri}} style={{}}>
      {renderImage()}
    </ImageBackground>
  );
};



================================================
FILE: src/components/ImageMessage/index.ts
================================================
export * from './ImageMessage';



================================================
FILE: src/components/ImageMessage/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {MessageType, Theme, User} from '../../utils/types';

const styles = ({
  aspectRatio,
  message,
  messageWidth,
  theme,
  user,
}: {
  aspectRatio: number;
  message: MessageType.Image;
  messageWidth: number;
  theme: Theme;
  user?: User;
}) =>
  StyleSheet.create({
    horizontalImage: {
      height: messageWidth / aspectRatio,
      maxHeight: messageWidth,
      width: messageWidth,
    },
    minimizedImage: {
      borderRadius: 15,
      height: 64,
      marginLeft: theme.insets.messageInsetsVertical,
      marginRight: 16,
      marginVertical: theme.insets.messageInsetsVertical,
      width: 64,
    },
    minimizedImageContainer: {
      alignItems: 'center',
      backgroundColor:
        user?.id === message.author.id
          ? theme.colors.primary
          : theme.colors.secondary,
      flexDirection: 'row',
    },
    nameText: {
      ...(user?.id === message.author.id
        ? theme.fonts.sentMessageBodyTextStyle
        : theme.fonts.receivedMessageBodyTextStyle),
    },
    sizeText: {
      ...(user?.id === message.author.id
        ? theme.fonts.sentMessageCaptionTextStyle
        : theme.fonts.receivedMessageCaptionTextStyle),
      marginTop: 4,
    },
    textContainer: {
      flexShrink: 1,
      marginRight: theme.insets.messageInsetsHorizontal,
      marginVertical: theme.insets.messageInsetsVertical,
    },
    verticalImage: {
      height: messageWidth,
      minWidth: 170,
      width: messageWidth * aspectRatio,
    },
  });

export default styles;



================================================
FILE: src/components/ImageMessage/__tests__/ImageMessage.test.tsx
================================================
import {act, render} from '@testing-library/react-native';
import * as React from 'react';
import {Image} from 'react-native';

import {derivedImageMessage, size} from '../../../../jest/fixtures';
import {ImageMessage} from '../ImageMessage';

describe('image message', () => {
  it('gets image size and renders', () => {
    expect.assertions(5);
    const getSizeMock = jest.spyOn(Image, 'getSize');
    getSizeMock.mockImplementation(() => {});
    const message = {
      ...derivedImageMessage,
      height: undefined,
      width: undefined,
    };
    const {getByTestId} = render(
      <ImageMessage message={message} messageWidth={440} />,
    );
    expect(getSizeMock).toHaveBeenCalledTimes(1);
    const getSizeArgs = getSizeMock.mock.calls[0];
    expect(getSizeArgs[0]).toBe(derivedImageMessage.uri);
    const success = getSizeArgs[1];
    const error = getSizeArgs[2];
    act(() => {
      success(size.width, size.height);
    });
    const successImageComponent = getByTestId('message-image');
    expect(successImageComponent.props).toHaveProperty('style.height', 440);
    act(() => {
      success(size.width, size.width * 10 + 1);
    });
    const successMinimizedImageComponent = getByTestId('message-image');
    expect(successMinimizedImageComponent.props).toHaveProperty(
      'style.width',
      64,
    );
    act(() => {
      if (error) {
        error(new Error());
      }
    });
    const errorImageComponent = getByTestId('message-image');
    expect(errorImageComponent.props).toHaveProperty('style.width', 64);
    getSizeMock.mockRestore();
  });
});



================================================
FILE: src/components/KeyboardAccessoryView/index.tsx
================================================
import * as React from 'react';
import {
  Animated,
  GestureResponderHandlers,
  StyleProp,
  StyleSheet,
  View,
  ViewStyle,
} from 'react-native';
import {useSafeAreaInsets} from 'react-native-safe-area-context';

import {
  useComponentSize,
  useKeyboardDimensions,
  usePanResponder,
} from './hooks';

interface Props {
  children?: React.ReactNode;
  contentContainerStyle?: StyleProp<ViewStyle>;
  contentOffsetKeyboardClosed?: number;
  contentOffsetKeyboardOpened?: number;
  renderBackground?: () => React.ReactNode;
  renderScrollable: (panHandlers: GestureResponderHandlers) => React.ReactNode;
  scrollableContainerStyle?: StyleProp<ViewStyle>;
  spaceBetweenKeyboardAndAccessoryView?: number;
  style?: StyleProp<ViewStyle>;
  useListenersOnAndroid?: boolean;
}

export const KeyboardAccessoryView = React.memo(
  ({
    children,
    contentContainerStyle,
    contentOffsetKeyboardClosed,
    contentOffsetKeyboardOpened,
    renderBackground,
    renderScrollable,
    scrollableContainerStyle,
    spaceBetweenKeyboardAndAccessoryView,
    style,
    useListenersOnAndroid,
  }: Props) => {
    const {onLayout, size} = useComponentSize();
    const {keyboardEndPositionY, keyboardHeight} = useKeyboardDimensions(
      useListenersOnAndroid,
    );
    const {panHandlers, positionY} = usePanResponder();
    const {bottom, left, right} = useSafeAreaInsets();

    const deltaY = Animated.subtract(
      positionY,
      keyboardEndPositionY,
    ).interpolate({
      inputRange: [0, Number.MAX_SAFE_INTEGER],
      outputRange: [0, Number.MAX_SAFE_INTEGER],
      extrapolate: 'clamp',
    });

    const offset =
      size.height +
      keyboardHeight +
      (keyboardHeight > 0
        ? (contentOffsetKeyboardOpened ?? 0) - bottom
        : contentOffsetKeyboardClosed ?? 0);

    return (
      <>
        <Animated.View
          style={[
            // eslint-disable-next-line react-native/no-inline-styles
            {
              flex: 1,
              paddingBottom: Animated.subtract(offset, deltaY),
            },
            scrollableContainerStyle,
          ]}>
          {renderScrollable(panHandlers)}
        </Animated.View>
        <Animated.View
          style={[
            {
              bottom: Animated.subtract(
                keyboardHeight > 0
                  ? keyboardHeight + (spaceBetweenKeyboardAndAccessoryView ?? 0)
                  : 0,
                deltaY,
              ),
            },
            styles.container,
            style,
          ]}
          testID="container">
          {renderBackground?.()}
          <View
            onLayout={onLayout}
            style={[
              styles.contentContainer,
              // eslint-disable-next-line react-native/no-inline-styles
              {
                marginBottom: keyboardHeight > 0 ? 0 : bottom,
                marginLeft: left,
                marginRight: right,
              },
              contentContainerStyle,
            ]}>
            {children}
          </View>
        </Animated.View>
      </>
    );
  },
);

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    left: 0,
    right: 0,
  },
  contentContainer: {
    flex: 1,
  },
});



================================================
FILE: src/components/KeyboardAccessoryView/hooks/index.ts
================================================
export * from './useComponentSize';
export * from './useKeyboardDimensions';
export * from './usePanResponder';



================================================
FILE: src/components/KeyboardAccessoryView/hooks/useComponentSize.tsx
================================================
import * as React from 'react';
import {LayoutChangeEvent} from 'react-native';

/**
 * Calculates view's width & height based on the `onLayout` event.
 * @example
 * const [onLayout, size] = useComponentSize()
 * ...
 * <View onLayout={onLayout} /> // `size` will contain the size of this view
 */
export const useComponentSize = () => {
  const [size, setSize] = React.useState({height: 0, width: 0});

  const onLayout = React.useCallback((event: LayoutChangeEvent) => {
    const {height, width} = event.nativeEvent.layout;
    setSize({height, width});
  }, []);

  return {onLayout, size};
};



================================================
FILE: src/components/KeyboardAccessoryView/hooks/useKeyboardDimensions.tsx
================================================
import * as React from 'react';
import {
  Dimensions,
  EventSubscription,
  Keyboard,
  KeyboardEvent,
  LayoutAnimation,
  Platform,
  ScaledSize,
} from 'react-native';
import {useSafeAreaFrame} from 'react-native-safe-area-context';

/**
 * Utility hook used to calculate keyboard dimensions.
 *
 * @param `useListenersOnAndroid` Will register keyboard listeners for Android
 *
 * ‚ö†Ô∏è You shouldn't use this hook on the same screen with `KeyboardAccessoryView` component, unexpected behavior might occur
 * @returns `keyboardEndPositionY` Keyboard's top line Y position
 * @returns `keyboardHeight` Keyboard's height
 */
export const useKeyboardDimensions = (useListenersOnAndroid?: boolean) => {
  const {height, y} = useSafeAreaFrame();
  const [state, setState] = React.useState({
    keyboardEndPositionY: height,
    keyboardHeight: 0,
  });

  React.useEffect(() => {
    const handleDimensionsChange = ({window}: {window: ScaledSize}) =>
      setState(current => ({
        ...current,
        keyboardEndPositionY: window.height,
      }));

    const resetKeyboardDimensions = () =>
      setState({
        keyboardEndPositionY: height,
        keyboardHeight: 0,
      });

    const updateKeyboardDimensions = (event: KeyboardEvent) =>
      setState(current => {
        const {screenY: keyboardEndPositionY} = event.endCoordinates;
        const keyboardHeight = height - keyboardEndPositionY + y;

        if (keyboardHeight === current.keyboardHeight) {
          return current;
        }

        const {duration, easing} = event;

        if (duration && easing) {
          // We have to pass the duration equal to minimal
          // accepted duration defined here: RCTLayoutAnimation.m
          const animationDuration = Math.max(duration, 10);

          LayoutAnimation.configureNext({
            duration: animationDuration,
            update: {
              duration: animationDuration,
              type: LayoutAnimation.Types[easing],
            },
          });
        }

        return {
          keyboardEndPositionY,
          keyboardHeight,
        };
      });

    const dimensionsListener = Dimensions.addEventListener(
      'change',
      handleDimensionsChange,
    );

    const keyboardListeners: EventSubscription[] = [];

    if (Platform.OS === 'android' && useListenersOnAndroid) {
      keyboardListeners.push(
        Keyboard.addListener('keyboardDidHide', resetKeyboardDimensions),
        Keyboard.addListener('keyboardDidShow', updateKeyboardDimensions),
      );
    } else {
      keyboardListeners.push(
        Keyboard.addListener(
          'keyboardWillChangeFrame',
          updateKeyboardDimensions,
        ),
      );
    }

    return () => {
      keyboardListeners.forEach(listener => listener.remove());
      dimensionsListener.remove();
    };
  }, [height, useListenersOnAndroid, y]);

  return state;
};



================================================
FILE: src/components/KeyboardAccessoryView/hooks/usePanResponder.tsx
================================================
import * as React from 'react';
import {Animated, PanResponder, Platform} from 'react-native';

/**
 * Returns `panHandlers` used to calculate Y finger position.
 *
 * Used to support interactive dismiss on iOS, on Android `panHandlers` is an empty object.
 *
 * ‚ö†Ô∏è You shouldn't use this hook if you don't use interactive dismiss on iOS.
 * @example
 * // `positionY` will be passed to the `KeyboardAccessoryView` component
 * const [panHandlers, positionY] = usePanResponder()
 * ...
 * <ScrollView {...panHandlers} />
 */
export const usePanResponder = () => {
  const positionY = React.useRef(new Animated.Value(0)).current;

  // Ignore PanResponder callbacks from the coverage since it is hard to simulate touches in a unit test
  /* istanbul ignore next */
  const panResponder = React.useRef(
    PanResponder.create({
      onPanResponderMove: Animated.event([null, {moveY: positionY}], {
        useNativeDriver: false,
      }),
      onPanResponderEnd: () => {
        setTimeout(() => {
          positionY.setValue(0);
        }, 10);
      },
    }),
  ).current;

  return {
    panHandlers: Platform.OS === 'android' ? {} : panResponder.panHandlers,
    positionY,
  };
};



================================================
FILE: src/components/KeyboardAccessoryView/hooks/__tests__/useComponentSize.test.tsx
================================================
import {LayoutChangeEvent} from 'react-native';

import {renderHook, act} from '@testing-library/react-native';

import {useComponentSize} from '../useComponentSize';

describe('useComponentSize', () => {
  it('should return initial size of {height: 0, width: 0}', () => {
    const {result} = renderHook(() => useComponentSize());

    expect(result.current.size).toEqual({height: 0, width: 0});
  });

  it('should update size when onLayout is triggered', () => {
    const {result} = renderHook(() => useComponentSize());

    const mockEvent: LayoutChangeEvent = {
      nativeEvent: {
        layout: {
          height: 100,
          width: 200,
          x: 0,
          y: 0,
        },
      },
      currentTarget: {} as any,
      target: {} as any,
      bubbles: false,
      cancelable: false,
      defaultPrevented: false,
      eventPhase: 0,
      isTrusted: true,
      preventDefault: jest.fn(),
      stopPropagation: jest.fn(),
      timeStamp: Date.now(),
      type: 'layout',
      isDefaultPrevented: jest.fn(),
      isPropagationStopped: jest.fn(),
      persist: jest.fn(),
    };

    // Trigger the onLayout callback with the event
    act(() => {
      result.current.onLayout(mockEvent);
    });

    expect(result.current.size).toEqual({height: 100, width: 200});
  });
});



================================================
FILE: src/components/KeyboardAccessoryView/hooks/__tests__/useKeyboardDimensions.test.tsx
================================================
import {Dimensions, Keyboard, LayoutAnimation, Platform} from 'react-native';

import {renderHook, act} from '@testing-library/react-native';
import {useSafeAreaFrame} from 'react-native-safe-area-context';

import {useKeyboardDimensions} from '../useKeyboardDimensions';

jest.mock('react-native-safe-area-context', () => ({
  useSafeAreaFrame: jest.fn(),
}));

jest.mock('react-native', () => ({
  Dimensions: {
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
    get: jest.fn().mockReturnValue({height: 800}),
  },
  Keyboard: {
    addListener: jest.fn(),
    removeListener: jest.fn(),
  },
  LayoutAnimation: {
    configureNext: jest.fn(),
    Types: {
      easeInEaseOut: 'easeInEaseOut',
    },
  },
  Platform: {
    OS: 'ios', // android?
  },
}));

describe('useKeyboardDimensions', () => {
  beforeEach(() => {
    jest.resetAllMocks();
    (useSafeAreaFrame as jest.Mock).mockReturnValue({height: 800, y: 0});
  });

  it('should initialize with the screen height and no keyboard', () => {
    const {result} = renderHook(() => useKeyboardDimensions());

    expect(result.current).toEqual({
      keyboardEndPositionY: 800,
      keyboardHeight: 0,
    });
  });

  it('should update keyboard dimensions on keyboardWillChangeFrame', () => {
    const mockEvent = {
      endCoordinates: {screenY: 600}, // Keyboard's end position
      duration: 250,
      easing: 'easeInEaseOut',
    };

    const {result} = renderHook(() => useKeyboardDimensions());

    act(() => {
      // Trigger the keyboard event to simulate the keyboard appearance
      (Keyboard.addListener as jest.Mock).mock.calls[0][1](mockEvent); // Simulating 'keyboardWillChangeFrame'
    });

    expect(LayoutAnimation.configureNext).toHaveBeenCalledWith({
      duration: 250,
      update: {
        duration: 250,
        type: 'easeInEaseOut',
      },
    });

    expect(result.current).toEqual({
      keyboardEndPositionY: 600,
      keyboardHeight: 200, // 800 - 600
    });
  });

  it('should reset keyboard dimensions on keyboardDidHide (Android)', () => {
    Platform.OS = 'android';
    const {result} = renderHook(() => useKeyboardDimensions(true));

    act(() => {
      // Simulate keyboardDidHide event
      (Keyboard.addListener as jest.Mock).mock.calls[0][1](); // Resetting dimensions
    });

    expect(result.current).toEqual({
      keyboardEndPositionY: 800, // Back to the full screen height
      keyboardHeight: 0,
    });
  });

  it('should add keyboard listeners for Android when `useListenersOnAndroid` is true', () => {
    Platform.OS = 'android';
    renderHook(() => useKeyboardDimensions(true));

    expect(Keyboard.addListener).toHaveBeenCalledWith(
      'keyboardDidHide',
      expect.any(Function),
    );
    expect(Keyboard.addListener).toHaveBeenCalledWith(
      'keyboardDidShow',
      expect.any(Function),
    );
  });

  it('should update keyboardEndPositionY when dimensions change', () => {
    const {result} = renderHook(() => useKeyboardDimensions());
    act(() => {
      const dimensionsChangeHandler = (Dimensions.addEventListener as jest.Mock)
        .mock.calls[0][1];
      dimensionsChangeHandler({window: {height: 1000}});
    });
    expect(result.current.keyboardEndPositionY).toBe(1000);
  });

  it('should remove all listeners on unmount', () => {
    const dimensionsListener = {remove: jest.fn()};
    const keyboardListener = {remove: jest.fn()};

    (Dimensions.addEventListener as jest.Mock).mockReturnValue(
      dimensionsListener,
    );
    (Keyboard.addListener as jest.Mock).mockReturnValue(keyboardListener);

    const {unmount} = renderHook(() => useKeyboardDimensions());

    // Unmount the hook and ensure listeners are removed
    unmount();

    expect(keyboardListener.remove).toHaveBeenCalled();
    expect(dimensionsListener.remove).toHaveBeenCalled();
  });
});



================================================
FILE: src/components/KeyboardAccessoryView/hooks/__tests__/usePanResponder.test.tsx
================================================
import React from 'react';
import {render} from '@testing-library/react-native';
import {View, Platform, Animated} from 'react-native';

import {usePanResponder} from '../usePanResponder';

// Mock Platform
const mockPlatform = Platform as any;

// Test component that uses the hook
const TestComponent = () => {
  const {panHandlers, positionY} = usePanResponder();

  return (
    <View testID="test-component" {...panHandlers}>
      <Animated.View
        testID="animated-view"
        style={{transform: [{translateY: positionY}]}}
      />
    </View>
  );
};

describe('usePanResponder', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('returns pan handlers and position Y on iOS', () => {
    mockPlatform.OS = 'ios';

    const {getByTestId} = render(<TestComponent />);

    const testComponent = getByTestId('test-component');
    const animatedView = getByTestId('animated-view');

    expect(testComponent).toBeTruthy();
    expect(animatedView).toBeTruthy();
  });

  it('returns empty pan handlers on Android', () => {
    mockPlatform.OS = 'android';

    const {getByTestId} = render(<TestComponent />);

    const testComponent = getByTestId('test-component');
    const animatedView = getByTestId('animated-view');

    expect(testComponent).toBeTruthy();
    expect(animatedView).toBeTruthy();
  });

  it('provides consistent positionY reference across renders', () => {
    mockPlatform.OS = 'ios';

    const TestComponentWithState = () => {
      const [count, setCount] = React.useState(0);
      const {panHandlers, positionY} = usePanResponder();

      React.useEffect(() => {
        if (count < 2) {
          setCount(count + 1);
        }
      }, [count]);

      return (
        <View testID="test-component" {...panHandlers}>
          <Animated.View
            testID="animated-view"
            style={{transform: [{translateY: positionY}]}}
          />
        </View>
      );
    };

    const {getByTestId} = render(<TestComponentWithState />);

    const testComponent = getByTestId('test-component');
    const animatedView = getByTestId('animated-view');

    expect(testComponent).toBeTruthy();
    expect(animatedView).toBeTruthy();
  });

  it('handles pan responder creation correctly on iOS', () => {
    mockPlatform.OS = 'ios';

    const TestComponentWithHandlers = () => {
      const {panHandlers, positionY} = usePanResponder();

      // Test that pan handlers have the expected properties for iOS
      const hasOnMoveShouldSetPanResponder =
        'onMoveShouldSetPanResponder' in panHandlers;
      const hasOnPanResponderMove = 'onPanResponderMove' in panHandlers;

      return (
        <View testID="test-component" {...panHandlers}>
          <View
            testID="has-move-should-set"
            data-value={hasOnMoveShouldSetPanResponder}
          />
          <View
            testID="has-pan-responder-move"
            data-value={hasOnPanResponderMove}
          />
          <Animated.View
            testID="animated-view"
            style={{transform: [{translateY: positionY}]}}
          />
        </View>
      );
    };

    const {getByTestId} = render(<TestComponentWithHandlers />);

    const testComponent = getByTestId('test-component');
    const animatedView = getByTestId('animated-view');

    expect(testComponent).toBeTruthy();
    expect(animatedView).toBeTruthy();
  });

  it('returns empty object for pan handlers on Android', () => {
    mockPlatform.OS = 'android';

    const TestComponentWithHandlers = () => {
      const {panHandlers, positionY} = usePanResponder();

      // Test that pan handlers is empty object for Android
      const handlerKeys = Object.keys(panHandlers);

      return (
        <View testID="test-component" {...panHandlers}>
          <View testID="handler-keys-count" data-value={handlerKeys.length} />
          <Animated.View
            testID="animated-view"
            style={{transform: [{translateY: positionY}]}}
          />
        </View>
      );
    };

    const {getByTestId} = render(<TestComponentWithHandlers />);

    const testComponent = getByTestId('test-component');
    const animatedView = getByTestId('animated-view');
    const handlerKeysCount = getByTestId('handler-keys-count');

    expect(testComponent).toBeTruthy();
    expect(animatedView).toBeTruthy();
    expect(handlerKeysCount.props['data-value']).toBe(0);
  });

  it('initializes positionY with zero value', () => {
    mockPlatform.OS = 'ios';

    const TestComponentWithValue = () => {
      const {panHandlers, positionY} = usePanResponder();

      // Access the initial value of the Animated.Value
      const initialValue = (positionY as any)._value;

      return (
        <View testID="test-component" {...panHandlers}>
          <View testID="initial-value" data-value={initialValue} />
          <Animated.View
            testID="animated-view"
            style={{transform: [{translateY: positionY}]}}
          />
        </View>
      );
    };

    const {getByTestId} = render(<TestComponentWithValue />);

    const testComponent = getByTestId('test-component');
    const animatedView = getByTestId('animated-view');
    const initialValue = getByTestId('initial-value');

    expect(testComponent).toBeTruthy();
    expect(animatedView).toBeTruthy();
    expect(initialValue.props['data-value']).toBe(0);
  });

  it('maintains same Animated.Value instance across re-renders', () => {
    mockPlatform.OS = 'ios';

    const TestComponentWithRerender = () => {
      const [renderCount, setRenderCount] = React.useState(0);
      const {panHandlers, positionY} = usePanResponder();

      // Store the first positionY reference
      const positionYRef = React.useRef(positionY);
      const isSameReference = positionYRef.current === positionY;

      React.useEffect(() => {
        if (renderCount === 0) {
          setRenderCount(1);
        }
      }, [renderCount]);

      return (
        <View testID="test-component" {...panHandlers}>
          <View testID="same-reference" data-value={isSameReference} />
          <Animated.View
            testID="animated-view"
            style={{transform: [{translateY: positionY}]}}
          />
        </View>
      );
    };

    const {getByTestId} = render(<TestComponentWithRerender />);

    const testComponent = getByTestId('test-component');
    const animatedView = getByTestId('animated-view');
    const sameReference = getByTestId('same-reference');

    expect(testComponent).toBeTruthy();
    expect(animatedView).toBeTruthy();
    expect(sameReference.props['data-value']).toBe(true);
  });
});



================================================
FILE: src/components/LoadingBubble/index.ts
================================================
export {LoadingBubble} from './LoadingBubble';



================================================
FILE: src/components/LoadingBubble/LoadingBubble.tsx
================================================
import {View, Animated} from 'react-native';
import React, {useEffect, useRef} from 'react';

import {useTheme} from '../../hooks';

import {styles} from './styles';

import {Theme} from '../../utils/types';

interface LoadingDotProps {
  delay: number;
  theme: Theme;
}

const LoadingDot: React.FC<LoadingDotProps> = ({delay, theme}) => {
  const opacity = useRef(new Animated.Value(0.3)).current;

  useEffect(() => {
    const animation = Animated.sequence([
      Animated.timing(opacity, {
        toValue: 1,
        duration: 500,
        delay,
        useNativeDriver: true,
      }),
      Animated.timing(opacity, {
        toValue: 0.3,
        duration: 500,
        useNativeDriver: true,
      }),
    ]);

    Animated.loop(animation).start();
  }, [opacity, delay]);

  return (
    <Animated.View
      style={[
        styles.dot,
        {
          backgroundColor: theme.colors.outline,
          opacity,
        },
      ]}
    />
  );
};

export const LoadingBubble: React.FC = () => {
  const theme = useTheme();

  return (
    <View
      style={[
        styles.container,
        {backgroundColor: theme.colors.surfaceVariant},
      ]}>
      <LoadingDot delay={0} theme={theme} />
      <LoadingDot delay={200} theme={theme} />
      <LoadingDot delay={400} theme={theme} />
    </View>
  );
};



================================================
FILE: src/components/LoadingBubble/styles.ts
================================================
import {StyleSheet} from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    padding: 8,
    borderRadius: 16,
    alignSelf: 'flex-start',
    marginVertical: 8,
    marginHorizontal: 12,
    gap: 4,
  },
  dot: {
    width: 6,
    height: 6,
    borderRadius: 3,
  },
});



================================================
FILE: src/components/MarkdownView/index.ts
================================================
export * from './MarkdownView';



================================================
FILE: src/components/MarkdownView/MarkdownView.tsx
================================================
import {View} from 'react-native';
import React, {useMemo} from 'react';

import {marked} from 'marked';
import RenderHtml, {
  defaultSystemFonts,
  HTMLContentModel,
  HTMLElementModel,
} from 'react-native-render-html';

import {useTheme} from '../../hooks';
import {ThinkingBubble} from '../ThinkingBubble';
import {CodeBlockHeader} from '../CodeBlockHeader';

import {createTagsStyles} from './styles';

marked.use({
  langPrefix: 'language-',
  mangle: false,
  headerIds: false,
});

interface MarkdownViewProps {
  markdownText: string;
  maxMessageWidth: number;
  //isComplete: boolean; // indicating if message is complete
  selectable?: boolean;
}

// Helper function to check if content is empty
const isEmptyContent = (content: string): boolean => {
  return !content || content.trim() === '';
};

const ThinkingRenderer = ({TDefaultRenderer, ...props}: any) => {
  // Check if the content is empty
  const content = props.tnode?.domNode?.children?.[0]?.data || '';
  // If content is empty, don't render the ThinkingBubble
  if (isEmptyContent(content)) {
    return null;
  }

  return (
    <ThinkingBubble>
      <TDefaultRenderer {...props} />
    </ThinkingBubble>
  );
};

const CodeRenderer = ({TDefaultRenderer, ...props}: any) => {
  const isCodeBlock = props?.tnode?.parent?.tagName === 'pre';

  // if not code block, use the default renderer
  if (!isCodeBlock) {
    return <TDefaultRenderer {...props} />;
  }

  const language =
    props.tnode?.domNode?.attribs?.class?.replace('language-', '') || 'code';
  const content = props.tnode?.domNode?.children?.[0]?.data || '';

  return (
    <View>
      <CodeBlockHeader language={language} content={content} />
      <TDefaultRenderer {...props} />
    </View>
  );
};

export const MarkdownView: React.FC<MarkdownViewProps> = React.memo(
  ({markdownText, maxMessageWidth, selectable = false}) => {
    const _maxWidth = maxMessageWidth;

    const theme = useTheme();
    const tagsStyles = useMemo(() => createTagsStyles(theme), [theme]);

    const customHTMLElementModels = useMemo(
      () => ({
        think: HTMLElementModel.fromCustomModel({
          tagName: 'think',
          contentModel: HTMLContentModel.block,
        }),
        thought: HTMLElementModel.fromCustomModel({
          tagName: 'thought',
          contentModel: HTMLContentModel.block,
        }),
        thinking: HTMLElementModel.fromCustomModel({
          tagName: 'thinking',
          contentModel: HTMLContentModel.block,
        }),
      }),
      [],
    );

    const renderers = useMemo(
      () => ({
        think: (props: any) => ThinkingRenderer(props),
        thought: (props: any) => ThinkingRenderer(props),
        thinking: (props: any) => ThinkingRenderer(props),
        code: (props: any) => CodeRenderer(props),
      }),
      [],
    );

    const defaultTextProps = useMemo(
      () => ({
        selectable,
        userSelect: selectable ? 'text' : 'none',
      }),
      [selectable],
    );
    const systemFonts = useMemo(() => defaultSystemFonts, []);

    const contentWidth = useMemo(() => _maxWidth, [_maxWidth]);

    const htmlContent = useMemo(() => marked(markdownText), [markdownText]);
    const source = useMemo(() => ({html: htmlContent}), [htmlContent]);

    return (
      <View testID="chatMarkdownScrollView" style={{maxWidth: _maxWidth}}>
        <RenderHtml
          contentWidth={contentWidth}
          source={source}
          tagsStyles={tagsStyles}
          defaultTextProps={defaultTextProps}
          systemFonts={systemFonts}
          customHTMLElementModels={customHTMLElementModels}
          renderers={renderers}
        />
      </View>
    );
  },
  (prevProps, nextProps) =>
    prevProps.markdownText === nextProps.markdownText &&
    //prevProps.isComplete === nextProps.isComplete &&
    prevProps.maxMessageWidth === nextProps.maxMessageWidth &&
    prevProps.selectable === nextProps.selectable,
);



================================================
FILE: src/components/MarkdownView/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {Theme} from '../../utils/types';

export const createTagsStyles = (theme: Theme) => ({
  body: {
    color: theme.colors.text,
    fontSize: 16,
    fontFamily:
      '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
    padding: 0,
    paddingTop: 0,
    margin: 0,
    backgroundColor: 'transparent',
    // display: 'inline-block',
  },
  code: {
    fontFamily: 'Courier', // Change the font for code snippets
    backgroundColor: theme.colors.surface, // Custom background for code blocks
    padding: 4,
    borderRadius: 4,
    color: theme.colors.onSurface, // Color for code text
    fontSize: 12,
  },
  pre: {
    backgroundColor: theme.colors.surface, // Background for pre blocks
    padding: 8,
    borderRadius: 6,
    color: theme.colors.onPrimaryContainer,
    fontFamily: 'Courier',
    fontSize: 14,
    // overflow: 'scroll', // Ensure scrolling for long code blocks
  },
  // Styles for thinking tags
  thinking: {
    color: theme.colors.thinkingBubbleText,
    fontSize: 14,
    lineHeight: 20,
    fontFamily:
      '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  think: {
    color: theme.colors.thinkingBubbleText,
    fontSize: 14,
    lineHeight: 20,
    fontFamily:
      '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
  thought: {
    color: theme.colors.thinkingBubbleText,
    fontSize: 14,
    lineHeight: 20,
    fontFamily:
      '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
  },
});

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    container: {
      flex: 1,
    },
    thinkContainer: {
      backgroundColor: theme.colors.surfaceContainerHigh,
      borderRadius: 8,
      padding: 12,
      marginVertical: 8,
      borderLeftWidth: 4,
      borderLeftColor: theme.colors.primary,
      opacity: 0.8,
    },
    thinkText: {
      color: theme.colors.primary,
      fontWeight: 'bold',
      marginRight: 8,
    },
    thinkTextContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: 4,
    },
  });



================================================
FILE: src/components/MarkdownView/__tests__/MarkdownView.test.tsx
================================================
import React from 'react';

import {render, fireEvent} from '@testing-library/react-native';

import {MarkdownView} from '../MarkdownView';

describe('MarkdownView Component', () => {
  it('renders markdown content correctly', () => {
    const markdownText = 'Hello **World**';
    const {getByText} = render(
      <MarkdownView markdownText={markdownText} maxMessageWidth={300} />,
    );

    expect(getByText('Hello World')).toBeTruthy();
  });

  it('handles different content widths properly', () => {
    const markdownText = '# Test Markdown';
    const {getByTestId, rerender} = render(
      <MarkdownView markdownText={markdownText} maxMessageWidth={300} />,
    );

    // Simulate a layout change
    fireEvent(getByTestId('chatMarkdownScrollView'), 'layout', {
      nativeEvent: {
        layout: {width: 200, height: 100},
      },
    });

    rerender(
      <MarkdownView markdownText={markdownText} maxMessageWidth={200} />,
    );

    expect(getByTestId('chatMarkdownScrollView').props.style.maxWidth).toBe(
      200,
    );
  });
});



================================================
FILE: src/components/Menu/index.ts
================================================
export * from './Menu';
export * from './MenuItem';



================================================
FILE: src/components/Menu/Menu.tsx
================================================
import React, {useState} from 'react';

import {
  Divider,
  Menu as PaperMenu,
  MenuProps as PaperMenuProps,
} from 'react-native-paper';

import {useTheme} from '../../hooks';

import {createStyles} from './styles';
import {MenuItem, MenuItemProps} from './MenuItem';
import {useSafeAreaInsets} from 'react-native-safe-area-context';

const Separator = () => {
  const theme = useTheme();
  const styles = createStyles(theme);
  return <Divider style={styles.separator} />;
};

const GroupSeparator = () => {
  const theme = useTheme();
  const styles = createStyles(theme);
  return (
    <PaperMenu.Item
      title=""
      style={[
        styles.groupSeparator,
        {backgroundColor: theme.colors.menuGroupSeparator},
      ]}
      disabled
    />
  );
};

export interface MenuProps extends Omit<PaperMenuProps, 'theme'> {
  selectable?: boolean;
}

export const Menu: React.FC<MenuProps> & {
  Item: typeof MenuItem;
  GroupSeparator: typeof GroupSeparator;
  Separator: typeof Separator;
} = ({children, selectable = false, ...menuProps}) => {
  const theme = useTheme();
  const styles = createStyles(theme);
  const [hasActiveSubmenu, setHasActiveSubmenu] = useState(false);
  const statusBarHeight = useSafeAreaInsets().top;

  const handleSubmenuOpen = () => setHasActiveSubmenu(true);
  const handleSubmenuClose = () => setHasActiveSubmenu(false);

  return (
    <PaperMenu
      {...menuProps}
      style={[
        styles.menu,
        hasActiveSubmenu && styles.menuWithSubmenu,
        menuProps.style,
      ]}
      statusBarHeight={statusBarHeight}
      contentStyle={[
        styles.content,
        hasActiveSubmenu && styles.contentWithSubmenu,
      ]}>
      {React.Children.map(children, child =>
        React.isValidElement<MenuItemProps>(child)
          ? React.cloneElement(child, {
              onSubmenuOpen: handleSubmenuOpen,
              onSubmenuClose: handleSubmenuClose,
              selectable,
            })
          : child,
      )}
    </PaperMenu>
  );
};

Menu.Item = MenuItem;
Menu.GroupSeparator = GroupSeparator;
Menu.Separator = Separator;



================================================
FILE: src/components/Menu/MenuContext.tsx
================================================
import React from 'react';

export const MenuContext = React.createContext<{selectable: boolean}>({
  selectable: false,
});



================================================
FILE: src/components/Menu/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {Theme} from '../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    menu: {
      shadowColor: 'rgba(0, 0, 0, 0.05)',
      shadowRadius: 70,
      shadowOffset: {width: 0, height: 0},
      elevation: 5,
      borderRadius: 12,
      maxWidth: '90%',
    },
    menuWithSubmenu: {
      elevation: 0,
      shadowOpacity: 0,
    },
    content: {
      paddingVertical: 0,
      backgroundColor: theme.colors.menuBackground,
      borderRadius: 12,
      // overflow: 'hidden', This removes shadow
      marginRight: 10,
    },
    contentWithSubmenu: {
      backgroundColor: theme.colors.menuBackground,
    },
    groupSeparator: {
      height: 6,
      flexShrink: 0,
      backgroundColor: 'transparent',
    },
    separator: {
      backgroundColor: theme.colors.menuSeparator,
    },
  });



================================================
FILE: src/components/Menu/__tests__/Menu.test.tsx
================================================
import React from 'react';
import {render} from '../../../../jest/test-utils';
import {Menu} from '../Menu';

describe('Menu', () => {
  it('renders menu items correctly', () => {
    const {getByText} = render(
      <Menu visible={true} onDismiss={() => {}} anchor={undefined}>
        <Menu.Item label="Item 1" onPress={() => {}} />
        <Menu.Item label="Item 2" onPress={() => {}} />
      </Menu>,
    );

    expect(getByText('Item 1')).toBeTruthy();
    expect(getByText('Item 2')).toBeTruthy();
  });

  it('renders separators correctly', () => {
    const {UNSAFE_getAllByType} = render(
      <Menu visible={true} onDismiss={() => {}} anchor={undefined}>
        <Menu.Item label="Item 1" onPress={() => {}} />
        <Menu.Separator />
        <Menu.Item label="Item 2" onPress={() => {}} />
        <Menu.GroupSeparator />
        <Menu.Item label="Item 3" onPress={() => {}} />
      </Menu>,
    );

    const separators = UNSAFE_getAllByType(Menu.Separator);
    const groupSeparators = UNSAFE_getAllByType(Menu.GroupSeparator);

    expect(separators).toHaveLength(1);
    expect(groupSeparators).toHaveLength(1);
  });
});



================================================
FILE: src/components/Menu/MenuItem/index.ts
================================================
export * from './MenuItem';



================================================
FILE: src/components/Menu/MenuItem/MenuItem.tsx
================================================
import {View, Animated} from 'react-native';
import React, {useRef, useState, useEffect} from 'react';
import {StyleProp, TextStyle, ViewStyle} from 'react-native';

import {Menu as PaperMenu, Icon} from 'react-native-paper';
import {
  MenuItemProps as PaperMenuItemProps,
  MenuProps as PaperMenuProps,
} from 'react-native-paper';
import {IconSource} from 'react-native-paper/lib/typescript/components/Icon';

import {SubMenu} from '../SubMenu/SubMenu';

import {useTheme} from '../../../hooks';

import {createStyles} from './styles';

export interface MenuItemProps
  extends Omit<PaperMenuItemProps, 'title' | 'titleStyle'> {
  label: string;
  labelStyle?: StyleProp<TextStyle>;
  danger?: boolean;
  style?: StyleProp<ViewStyle>;
  isGroupLabel?: boolean;
  icon?: IconSource;
  selected?: boolean;
  submenu?: React.ReactNode[];
  onSubmenuOpen?: () => void;
  onSubmenuClose?: () => void;
  selectable?: boolean;
  submenuProps?: Omit<PaperMenuProps, 'theme'>;
}

export const MenuItem: React.FC<MenuItemProps> = ({
  label,
  danger,
  style,
  labelStyle,
  isGroupLabel,
  icon,
  selected,
  leadingIcon,
  trailingIcon,
  submenu,
  onSubmenuOpen,
  onSubmenuClose,
  selectable = false,
  submenuProps,
  ...menuItemProps
}) => {
  const [isSubmenuOpen, setIsSubmenuOpen] = useState(false);
  const [submenuPosition, setSubmenuPosition] = useState({x: 0, y: 0});
  const itemRef = useRef<View>(null);
  const fadeAnim = useRef(new Animated.Value(1)).current;

  const theme = useTheme();

  useEffect(() => {
    Animated.timing(fadeAnim, {
      toValue: isSubmenuOpen ? 0.6 : 1,
      duration: 200,
      useNativeDriver: true,
    }).start();
  }, [fadeAnim, isSubmenuOpen]);

  const styles = createStyles(theme);

  const renderLeadingIcon = props => {
    return (
      <View
        style={[
          styles.leadingContainer,
          menuItemProps.disabled && styles.itemDisabled,
        ]}>
        {selected && <Icon testID="selected-icon" source="check" size={18} />}
        {leadingIcon &&
          (typeof leadingIcon === 'function' ? (
            leadingIcon({...props, size: 18})
          ) : (
            <Icon source={leadingIcon} size={18} />
          ))}
      </View>
    );
  };

  const renderTrailingIcon = props => (
    <View
      style={[
        styles.trailingContainer,
        menuItemProps.disabled && styles.itemDisabled,
      ]}>
      {trailingIcon ? (
        typeof trailingIcon === 'function' ? (
          trailingIcon({...props, size: 18})
        ) : (
          <Icon source={trailingIcon} size={18} />
        )
      ) : icon ? (
        <Icon source={icon} size={18} />
      ) : null}
    </View>
  );

  const renderSubmenuIcon = () => (
    <View style={styles.trailingContainer}>
      <Icon
        source={isSubmenuOpen ? 'chevron-down' : 'chevron-right'}
        size={18}
        color={
          menuItemProps.disabled
            ? theme.colors.onSurfaceDisabled
            : theme.colors.primary
        }
      />
    </View>
  );

  const getTrailingIcon = () => {
    if (submenu) {
      return renderSubmenuIcon;
    }
    if (trailingIcon || icon) {
      return renderTrailingIcon;
    }
    return undefined;
  };

  const getLeadingIcon = () => {
    if (!selectable && !leadingIcon) {
      return undefined;
    }
    return renderLeadingIcon;
  };

  const handlePress = (e: any) => {
    if (submenu) {
      itemRef.current?.measure((x, y, width, height, pageX, pageY) => {
        const willOpen = !isSubmenuOpen;
        setSubmenuPosition({x: pageX + width, y: pageY + height});
        setIsSubmenuOpen(willOpen);
        if (willOpen) {
          onSubmenuOpen?.();
        } else {
          onSubmenuClose?.();
        }
      });
    } else {
      menuItemProps.onPress?.(e);
    }
  };

  return (
    <Animated.View ref={itemRef} style={{opacity: fadeAnim}}>
      <PaperMenu.Item
        {...menuItemProps}
        onPress={handlePress}
        disabled={isGroupLabel || menuItemProps.disabled}
        title={label}
        style={[
          styles.container,
          isSubmenuOpen && styles.activeParent,
          isGroupLabel && styles.groupLabel,
          style,
        ]}
        dense
        contentStyle={[
          styles.contentContainer,
          !getLeadingIcon() && styles.noLeadingIcon,
          !getTrailingIcon() && styles.noTrailingIcon,
        ]}
        titleStyle={[
          styles.label,
          {
            color: danger ? theme.colors.menuDangerText : theme.colors.menuText,
          },
          menuItemProps.disabled && styles.labelDisabled,
          labelStyle,
        ]}
        leadingIcon={getLeadingIcon()}
        trailingIcon={getTrailingIcon()}
      />
      {submenu && (
        <SubMenu
          visible={isSubmenuOpen}
          onDismiss={() => {
            setIsSubmenuOpen(false);
            onSubmenuClose?.();
          }}
          anchor={submenuPosition}
          {...submenuProps}>
          {submenu}
        </SubMenu>
      )}
    </Animated.View>
  );
};



================================================
FILE: src/components/Menu/MenuItem/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {Theme} from '../../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    container: {
      height: 46,
      backgroundColor: 'transparent',
      paddingRight: 16,
      paddingLeft: 16,
      maxWidth: 'auto',
    },
    leadingContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-start',
    },
    contentContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'flex-start',
      marginLeft: 10,
      marginRight: 10,
      maxWidth: 'auto',
      flexGrow: 1,
    },
    noLeadingIcon: {
      marginLeft: 0,
    },
    noTrailingIcon: {
      marginRight: 0,
    },
    label: {
      ...theme.fonts.titleSmall,
      textAlign: 'left',
      paddingLeft: 0,
    },
    labelDisabled: {
      opacity: 0.5,
    },
    itemDisabled: {
      opacity: 0.5,
    },
    trailingContainer: {
      alignItems: 'flex-end',
    },
    groupLabel: {
      paddingTop: 12,
      opacity: 0.5,
    },
    activeParent: {
      backgroundColor: theme.colors.menuBackgroundActive,
    },
  });



================================================
FILE: src/components/Menu/MenuItem/__tests__/MenuItem.test.tsx
================================================
import React from 'react';
import {MenuItem} from '../MenuItem';
import {useTheme} from '../../../../hooks';
import {fireEvent, render} from '../../../../../jest/test-utils';

describe('MenuItem', () => {
  beforeEach(() => {
    (useTheme as jest.Mock).mockReturnValue({
      colors: {
        menuText: '#000000',
        menuDangerText: '#FF0000',
        menuBackgroundActive: '#E0E0E0',
      },
      fonts: {
        bodySmall: {},
      },
    });
  });

  it('renders basic menu item correctly', () => {
    const onPress = jest.fn();
    const {getByText} = render(
      <MenuItem label="Test Item" onPress={onPress} />,
    );

    expect(getByText('Test Item')).toBeTruthy();
  });

  it('handles press events', () => {
    const onPress = jest.fn();
    const {getByText} = render(
      <MenuItem label="Test Item" onPress={onPress} />,
    );

    fireEvent.press(getByText('Test Item'));
    expect(onPress).toHaveBeenCalled();
  });

  it('renders leading icon when provided', () => {
    const {UNSAFE_getByProps} = render(
      <MenuItem label="Test Item" leadingIcon="check" onPress={() => {}} />,
    );

    expect(UNSAFE_getByProps({source: 'check'})).toBeTruthy();
  });

  it('renders trailing icon when provided', () => {
    const {UNSAFE_getByProps} = render(
      <MenuItem label="Test Item" trailingIcon="close" onPress={() => {}} />,
    );

    expect(UNSAFE_getByProps({source: 'close'})).toBeTruthy();
  });

  it('handles disabled state correctly', () => {
    const onPress = jest.fn();
    const {getByText} = render(
      <MenuItem label="Test Item" onPress={onPress} disabled={true} />,
    );

    fireEvent.press(getByText('Test Item'));
    expect(onPress).not.toHaveBeenCalled();
  });
});



================================================
FILE: src/components/Menu/SubMenu/index.ts
================================================
export * from './SubMenu';



================================================
FILE: src/components/Menu/SubMenu/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {Theme} from '../../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    menu: {
      maxWidth: '90%',
      marginTop: 0,
      marginLeft: 0,
    },
    content: {
      paddingVertical: 0,
      backgroundColor: theme.colors.menuBackground,
      borderRadius: 12,
      //overflow: 'hidden', This removes shadow
    },
  });



================================================
FILE: src/components/Menu/SubMenu/SubMenu.tsx
================================================
import React from 'react';

import {
  Menu as PaperMenu,
  MenuProps as PaperMenuProps,
} from 'react-native-paper';

import {useTheme} from '../../../hooks';

import {createStyles} from './styles';

interface SubMenuProps extends Omit<PaperMenuProps, 'theme'> {}

export const SubMenu: React.FC<SubMenuProps> = ({
  visible,
  onDismiss,
  children,
  style,
  ...menuProps
}) => {
  const theme = useTheme();
  const styles = createStyles(theme);

  return (
    <PaperMenu
      visible={visible}
      onDismiss={onDismiss}
      style={[styles.menu, style]}
      contentStyle={styles.content}
      {...menuProps}>
      {children}
    </PaperMenu>
  );
};

/**
 * SubMenu component for nested menu items.
 *
 * Usage example:
 * ```tsx
 * <Menu.Item
 *   label="Advanced"
 *   submenu={[
 *     <Menu.Item
 *       key="1"
 *       label="Option 1"
 *     />,
 *     // Nested submenu
 *     <Menu.Item
 *       label="More Options"
 *       submenu={[
 *         <Menu.Item key="2.1" label="Sub Option 1" />,
 *         <Menu.Item key="2.2" label="Sub Option 2" />,
 *       ]}
 *     />,
 *     <Menu.Item
 *       key="3"
 *       label="Option 3"
 *     />,
 *   ]}
 * />
 * ```
 *
 * Features:
 * - Supports infinite nesting of submenus
 * - Parent menu dims when submenu is open
 * - Maintains consistent styling with parent menu
 */



================================================
FILE: src/components/Menu/SubMenu/__tests__/SubMenu.test.tsx
================================================
import React from 'react';
import {render} from '../../../../../jest/test-utils';
import {SubMenu} from '../SubMenu';
import {MenuItem} from '../../MenuItem';

describe('SubMenu', () => {
  it('renders when visible', () => {
    const {getByText} = render(
      <SubMenu visible={true} onDismiss={() => {}} anchor={{x: 100, y: 100}}>
        <MenuItem label="SubMenu Item" onPress={() => {}} />
      </SubMenu>,
    );

    expect(getByText('SubMenu Item')).toBeTruthy();
  });

  it('does not render when not visible', () => {
    const {queryByText} = render(
      <SubMenu visible={false} onDismiss={() => {}} anchor={{x: 100, y: 100}}>
        <MenuItem label="SubMenu Item" onPress={() => {}} />
      </SubMenu>,
    );

    expect(queryByText('SubMenu Item')).toBeNull();
  });

  it('handles multiple menu items', () => {
    const {getByText} = render(
      <SubMenu visible={true} onDismiss={() => {}} anchor={{x: 100, y: 100}}>
        <MenuItem label="Item 1" onPress={() => {}} />
        <MenuItem label="Item 2" onPress={() => {}} />
        <MenuItem label="Item 3" onPress={() => {}} />
      </SubMenu>,
    );

    expect(getByText('Item 1')).toBeTruthy();
    expect(getByText('Item 2')).toBeTruthy();
    expect(getByText('Item 3')).toBeTruthy();
  });
});



================================================
FILE: src/components/Message/index.ts
================================================
export * from './Message';



================================================
FILE: src/components/Message/Message.tsx
================================================
import * as React from 'react';
import {Pressable, Text, View, Animated} from 'react-native';

import {oneOf} from '@flyerhq/react-native-link-preview';
import ReactNativeHapticFeedback from 'react-native-haptic-feedback';

import {useTheme} from '../../hooks';

import styles from './styles';
import {
  Avatar,
  StatusIcon,
  FileMessage,
  ImageMessage,
  TextMessage,
  TextMessageTopLevelProps,
} from '..';

import {MessageType} from '../../utils/types';
import {excludeDerivedMessageProps, UserContext} from '../../utils';

const hapticOptions = {
  enableVibrateFallback: true,
  ignoreAndroidSystemSettings: false,
};

export interface MessageTopLevelProps extends TextMessageTopLevelProps {
  /** Called when user makes a long press on any message */
  onMessageLongPress?: (message: MessageType.Any, event?: any) => void;
  /** Called when user taps on any message */
  onMessagePress?: (message: MessageType.Any, event?: any) => void;
  /** Customize the default bubble using this function. `child` is a content
   * you should render inside your bubble, `message` is a current message
   * (contains `author` inside) and `nextMessageInGroup` allows you to see
   * if the message is a part of a group (messages are grouped when written
   * in quick succession by the same author) */
  renderBubble?: (payload: {
    child: React.ReactNode;
    message: MessageType.Any;
    nextMessageInGroup: boolean;
    scale?: Animated.Value;
  }) => React.ReactNode;
  /** Render a custom message inside predefined bubble */
  renderCustomMessage?: (
    message: MessageType.Custom,
    messageWidth: number,
  ) => React.ReactNode;
  /** Render a file message inside predefined bubble */
  renderFileMessage?: (
    message: MessageType.File,
    messageWidth: number,
  ) => React.ReactNode;
  /** Render an image message inside predefined bubble */
  renderImageMessage?: (
    message: MessageType.Image,
    messageWidth: number,
  ) => React.ReactNode;
  /** Render a text message inside predefined bubble */
  renderTextMessage?: (
    message: MessageType.Text,
    messageWidth: number,
    showName: boolean,
  ) => React.ReactNode;
  /** Show user avatars for received messages. Useful for a group chat. */
  showUserAvatars?: boolean;
}

export interface MessageProps extends MessageTopLevelProps {
  enableAnimation?: boolean;
  message: MessageType.DerivedAny;
  messageWidth: number;
  roundBorder: boolean;
  showAvatar: boolean;
  showName: boolean;
  showStatus: boolean;
}

/** Base component for all message types in the chat. Renders bubbles around
 * messages and status. Sets maximum width for a message for
 * a nice look on larger screens. */
export const Message = React.memo(
  ({
    enableAnimation,
    message,
    messageWidth,
    onMessagePress,
    onMessageLongPress,
    onPreviewDataFetched,
    renderBubble,
    renderCustomMessage,
    renderFileMessage,
    renderImageMessage,
    renderTextMessage,
    roundBorder,
    showAvatar,
    showName,
    showStatus,
    showUserAvatars,
    usePreviewData,
  }: MessageProps) => {
    const user = React.useContext(UserContext);
    const theme = useTheme();
    const scaleAnim = React.useRef(new Animated.Value(1)).current;

    const currentUserIsAuthor =
      message.type !== 'dateHeader' && user?.id === message.author.id;

    const {container, contentContainer, dateHeader, pressable} = styles({
      currentUserIsAuthor,
      message,
      messageWidth,
      roundBorder,
      theme,
    });

    const handlePressIn = () => {
      Animated.spring(scaleAnim, {
        toValue: 1.03,
        friction: 8,
        tension: 100,
        useNativeDriver: true,
      }).start();
    };

    const handlePressOut = () => {
      Animated.spring(scaleAnim, {
        toValue: 1,
        friction: 8,
        tension: 100,
        useNativeDriver: true,
      }).start();
    };

    if (message.type === 'dateHeader') {
      return (
        <View style={dateHeader}>
          <Text
            style={[
              theme.fonts.dateDividerTextStyle,
              {color: theme.colors.onSurface},
            ]}>
            {message.text}
          </Text>
        </View>
      );
    }

    const renderBubbleContainer = () => {
      const child = renderMessage();

      return oneOf(
        renderBubble,
        <View style={contentContainer} testID="ContentContainer">
          {child}
        </View>,
      )({
        child,
        message: excludeDerivedMessageProps(message),
        nextMessageInGroup: roundBorder,
        scale: scaleAnim,
      });
    };

    const renderMessage = () => {
      switch (message.type) {
        case 'custom':
          return (
            renderCustomMessage?.(
              // It's okay to cast here since we checked message type above
              // type-coverage:ignore-next-line
              excludeDerivedMessageProps(message) as MessageType.Custom,
              messageWidth,
            ) ?? null
          );
        case 'file':
          return oneOf(renderFileMessage, <FileMessage message={message} />)(
            // type-coverage:ignore-next-line
            excludeDerivedMessageProps(message) as MessageType.File,
            messageWidth,
          );
        case 'image':
          return oneOf(
            renderImageMessage,
            <ImageMessage
              {...{
                message,
                messageWidth,
              }}
            />,
          )(
            // type-coverage:ignore-next-line
            excludeDerivedMessageProps(message) as MessageType.Image,
            messageWidth,
          );
        case 'text':
          return oneOf(
            renderTextMessage,
            <TextMessage
              {...{
                enableAnimation,
                message,
                messageWidth,
                onPreviewDataFetched,
                showName,
                usePreviewData,
              }}
            />,
          )(
            // type-coverage:ignore-next-line
            excludeDerivedMessageProps(message) as MessageType.Text,
            messageWidth,
            showName,
          );
        default:
          return null;
      }
    };

    return (
      <View style={container}>
        <Avatar
          {...{
            author: message.author,
            currentUserIsAuthor,
            showAvatar,
            showUserAvatars,
            theme,
          }}
        />
        <Pressable
          onLongPress={event => {
            ReactNativeHapticFeedback.trigger('impactLight', hapticOptions);
            onMessageLongPress?.(excludeDerivedMessageProps(message), event);
          }}
          onPress={event => {
            onMessagePress?.(excludeDerivedMessageProps(message), event);
          }}
          onPressIn={handlePressIn}
          onPressOut={handlePressOut}
          style={pressable}>
          {renderBubbleContainer()}
        </Pressable>
        <StatusIcon
          {...{
            currentUserIsAuthor,
            showStatus,
            status: message.status,
            theme,
          }}
        />
      </View>
    );
  },
);



================================================
FILE: src/components/Message/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {MessageType, Theme} from '../../utils/types';

const styles = ({
  currentUserIsAuthor,
  message,
  messageWidth,
  roundBorder,
  theme,
}: {
  currentUserIsAuthor: boolean;
  message: MessageType.DerivedAny;
  messageWidth: number;
  roundBorder: boolean;
  theme: Theme;
}) =>
  StyleSheet.create({
    container: {
      alignItems: 'flex-end',
      alignSelf: currentUserIsAuthor ? 'flex-end' : 'flex-start',
      justifyContent: !currentUserIsAuthor ? 'flex-end' : 'flex-start',
      flex: 1,
      flexDirection: 'row',
      marginBottom: message.type === 'dateHeader' ? 0 : 4 + message.offset,
      marginLeft: 20,
    },
    contentContainer: {
      backgroundColor:
        !currentUserIsAuthor || message.type === 'image'
          ? theme.colors.secondary
          : theme.colors.primary,
      borderBottomLeftRadius:
        currentUserIsAuthor || roundBorder
          ? theme.borders.messageBorderRadius
          : 0,
      borderBottomRightRadius: currentUserIsAuthor
        ? roundBorder
          ? theme.borders.messageBorderRadius
          : 0
        : theme.borders.messageBorderRadius,
      borderColor: 'transparent',
      borderRadius: theme.borders.messageBorderRadius,
      overflow: 'hidden',
    },
    dateHeader: {
      alignItems: 'center',
      justifyContent: 'center',
      marginBottom: 32,
      marginTop: 16,
    },
    pressable: {
      maxWidth: messageWidth,
    },
  });

export default styles;



================================================
FILE: src/components/Message/__tests__/Message.test.tsx
================================================
import {render} from '@testing-library/react-native';
import * as React from 'react';

import {derivedTextMessage} from '../../../../jest/fixtures';
import {Message} from '../Message';

describe('message', () => {
  it('renders undefined in ContentContainer', () => {
    expect.assertions(2);
    const {getByTestId} = render(
      <Message
        message={{...derivedTextMessage, type: 'custom'}}
        messageWidth={440}
        onMessagePress={jest.fn}
        roundBorder
        showAvatar
        showName
        showStatus
      />,
    );
    const ContentContainer = getByTestId('ContentContainer');
    expect(ContentContainer).toBeDefined();
    expect(ContentContainer.props.children).toBeNull();
  });

  it('renders undefined in ContentContainer with wrong message type', () => {
    expect.assertions(2);
    const {getByTestId} = render(
      <Message
        message={{...derivedTextMessage, type: 'unsupported'}}
        messageWidth={440}
        onMessagePress={jest.fn}
        roundBorder
        showAvatar
        showName
        showStatus
      />,
    );
    const ContentContainer = getByTestId('ContentContainer');
    expect(ContentContainer).toBeDefined();
    expect(ContentContainer.props.children).toBeNull();
  });
});



================================================
FILE: src/components/ModelSettingsSheet/index.ts
================================================
export * from './ModelSettingsSheet';



================================================
FILE: src/components/ModelSettingsSheet/ModelSettingsSheet.tsx
================================================
import React, {useState, useEffect, memo, useContext} from 'react';
import {Button, Text, Divider} from 'react-native-paper';

import {ModelSettings} from '../../screens/ModelsScreen/ModelSettings';
import {Sheet} from '../Sheet';
import {ProjectionModelSelector} from '../ProjectionModelSelector';
import {Model} from '../../utils/types';
import {modelStore} from '../../store';
import {chatTemplates} from '../../utils/chat';

import {styles} from './styles';
import {View} from 'react-native';
import {L10nContext} from '../../utils';

interface ModelSettingsSheetProps {
  isVisible: boolean;
  onClose: () => void;
  model?: Model;
}

export const ModelSettingsSheet: React.FC<ModelSettingsSheetProps> = memo(
  ({isVisible, onClose, model}) => {
    const [tempChatTemplate, setTempChatTemplate] = useState(
      model?.chatTemplate || chatTemplates.default,
    );
    const [tempStopWords, setTempStopWords] = useState<string[]>(
      model?.stopWords || [],
    );
    const l10n = useContext(L10nContext);

    // Reset temp settings when model changes
    useEffect(() => {
      if (model) {
        setTempChatTemplate(model.chatTemplate);
        setTempStopWords(model.stopWords || []);
      }
    }, [model]);

    const handleSettingsUpdate = (name: string, value: any) => {
      setTempChatTemplate(prev => {
        const newTemplate =
          name === 'name' ? chatTemplates[value] : {...prev, [name]: value};
        return newTemplate;
      });
    };

    const handleSaveSettings = () => {
      if (model) {
        modelStore.updateModelChatTemplate(model.id, tempChatTemplate);
        modelStore.updateModelStopWords(model.id, tempStopWords);
        onClose();
      }
    };

    const handleCancelSettings = () => {
      if (model) {
        // Reset to store values
        setTempChatTemplate(model.chatTemplate);
        setTempStopWords(model.stopWords || []);
      }
      onClose();
    };

    const handleReset = () => {
      if (model) {
        // Reset to model default values
        modelStore.resetModelChatTemplate(model.id);
        modelStore.resetModelStopWords(model.id);
        setTempChatTemplate(model.chatTemplate);
        setTempStopWords(model.stopWords || []);
      }
    };

    if (!model) {
      return null;
    }

    return (
      <Sheet
        isVisible={isVisible}
        onClose={handleCancelSettings}
        title={l10n.components.modelSettingsSheet.modelSettings}
        displayFullHeight>
        <Sheet.ScrollView
          bottomOffset={16}
          contentContainerStyle={styles.sheetScrollViewContainer}>
          <ModelSettings
            chatTemplate={tempChatTemplate}
            stopWords={tempStopWords}
            onChange={handleSettingsUpdate}
            onStopWordsChange={value => setTempStopWords(value || [])}
          />

          {/* Multimodal Settings Section */}
          {model.supportsMultimodal && (
            <>
              <Divider style={styles.multimodalDivider} />
              <Text style={styles.multimodalSectionTitle}>
                {l10n.models.multimodal.settings}
              </Text>
              <ProjectionModelSelector
                model={model}
                onProjectionModelSelect={projectionModelId => {
                  modelStore.setDefaultProjectionModel(
                    model.id,
                    projectionModelId,
                  );
                }}
              />
            </>
          )}
        </Sheet.ScrollView>
        <Sheet.Actions>
          <View style={styles.secondaryButtons}>
            <Button mode="text" onPress={handleReset}>
              {l10n.common.reset}
            </Button>
            <Button mode="text" onPress={handleCancelSettings}>
              {l10n.common.cancel}
            </Button>
          </View>
          <Button mode="contained" onPress={handleSaveSettings}>
            {l10n.components.modelSettingsSheet.saveChanges}
          </Button>
        </Sheet.Actions>
      </Sheet>
    );
  },
);



================================================
FILE: src/components/ModelSettingsSheet/styles.ts
================================================
import {StyleSheet} from 'react-native';

export const styles = StyleSheet.create({
  sheetScrollViewContainer: {
    padding: 16,
  },
  secondaryButtons: {
    flexDirection: 'row',
    gap: 10,
  },
  multimodalDivider: {
    marginVertical: 16,
  },
  multimodalSectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 12,
  },
});



================================================
FILE: src/components/ModelSettingsSheet/__tests__/ModelSettingsSheet.test.tsx
================================================
import React from 'react';
import {fireEvent, render, act} from '../../../../jest/test-utils';
import {ModelSettingsSheet} from '../ModelSettingsSheet';
import {modelStore} from '../../../store';
import {Model, ModelOrigin} from '../../../utils/types';
import {defaultCompletionParams} from '../../../utils/completionSettingsVersions';

// Mock the ModelSettings component
jest.mock('../../../screens/ModelsScreen/ModelSettings', () => {
  const {View} = require('react-native');
  return {
    ModelSettings: ({onChange, onStopWordsChange}) => (
      <View testID="model-settings">
        <View
          testID="mock-settings-update"
          onPress={() => onChange('chatTemplate', 'new template')}
        />
        <View
          testID="mock-stop-words-update"
          onPress={() => onStopWordsChange(['stop1', 'stop2'])}
        />
      </View>
    ),
  };
});

// Mock Sheet component
jest.mock('../../../components/Sheet', () => {
  const {View, Button} = require('react-native');
  const MockSheet = ({children, isVisible, onClose, title}) => {
    if (!isVisible) {
      return null;
    }
    return (
      <View testID="sheet">
        <View testID="sheet-title">{title}</View>
        <Button title="Close" onPress={onClose} testID="sheet-close-button" />
        {children}
      </View>
    );
  };
  MockSheet.ScrollView = ({children}) => (
    <View testID="sheet-scroll-view">{children}</View>
  );
  MockSheet.Actions = ({children}) => (
    <View testID="sheet-actions">{children}</View>
  );
  return {Sheet: MockSheet};
});

// Mock the stores
jest.mock('../../../store', () => ({
  modelStore: {
    updateModelChatTemplate: jest.fn(),
    updateModelStopWords: jest.fn(),
    resetModelChatTemplate: jest.fn(),
    resetModelStopWords: jest.fn(),
  },
}));

describe('ModelSettingsSheet', () => {
  const defaultTemplate = {
    name: 'custom',
    addGenerationPrompt: true,
    bosToken: '<|START|>',
    eosToken: '<|END|>',
    chatTemplate: 'User: {{prompt}}\nAssistant:',
    systemPrompt: 'You are a helpful assistant',
    addBosToken: true,
    addEosToken: true,
  };

  const mockModel: Model = {
    id: 'test-model',
    author: 'test-author',
    name: 'Test Model',
    size: 1000,
    params: 1000000,
    isDownloaded: true,
    downloadUrl: 'https://example.com/model',
    hfUrl: 'https://huggingface.co/test-model',
    progress: 100,
    filename: 'test-model.bin',
    isLocal: false,
    origin: ModelOrigin.PRESET,
    defaultChatTemplate: defaultTemplate,
    chatTemplate: defaultTemplate,
    defaultStopWords: ['test'],
    stopWords: ['test'],
    defaultCompletionSettings: defaultCompletionParams,
    completionSettings: defaultCompletionParams,
  };

  const defaultProps = {
    isVisible: true,
    onClose: jest.fn(),
    model: mockModel,
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders correctly when visible', () => {
    const {getByTestId} = render(<ModelSettingsSheet {...defaultProps} />);

    expect(getByTestId('sheet')).toBeTruthy();
    expect(getByTestId('model-settings')).toBeTruthy();
    expect(getByTestId('sheet-title')).toBeTruthy();
  });

  it('does not render when not visible', () => {
    const {queryByTestId} = render(
      <ModelSettingsSheet {...defaultProps} isVisible={false} />,
    );

    expect(queryByTestId('sheet')).toBeNull();
  });

  it('returns null when no model is provided', () => {
    const {queryByTestId} = render(
      <ModelSettingsSheet {...defaultProps} model={undefined} />,
    );

    expect(queryByTestId('sheet')).toBeNull();
  });

  it('handles save settings correctly', async () => {
    const {getByText} = render(<ModelSettingsSheet {...defaultProps} />);

    await act(async () => {
      fireEvent.press(getByText('Save Changes'));
    });

    expect(modelStore.updateModelChatTemplate).toHaveBeenCalledWith(
      mockModel.id,
      mockModel.chatTemplate,
    );
    expect(modelStore.updateModelStopWords).toHaveBeenCalledWith(
      mockModel.id,
      mockModel.stopWords,
    );
    expect(defaultProps.onClose).toHaveBeenCalled();
  });

  it('handles cancel correctly', async () => {
    const {getByText} = render(<ModelSettingsSheet {...defaultProps} />);

    await act(async () => {
      fireEvent.press(getByText('Cancel'));
    });

    expect(defaultProps.onClose).toHaveBeenCalled();
  });

  it('handles reset correctly', async () => {
    const {getByText} = render(<ModelSettingsSheet {...defaultProps} />);

    await act(async () => {
      fireEvent.press(getByText('Reset'));
    });

    expect(modelStore.resetModelChatTemplate).toHaveBeenCalledWith(
      mockModel.id,
    );
    expect(modelStore.resetModelStopWords).toHaveBeenCalledWith(mockModel.id);
  });

  it('updates settings when model changes', () => {
    const {rerender} = render(<ModelSettingsSheet {...defaultProps} />);

    const newModel = {
      ...mockModel,
      chatTemplate: {
        ...defaultTemplate,
        systemPrompt: 'New system prompt',
      },
      stopWords: ['new-stop-word'],
    };

    rerender(<ModelSettingsSheet {...defaultProps} model={newModel} />);

    // The state updates are handled by useEffect, which is tested implicitly
    // through the save/cancel/reset tests
  });
});



================================================
FILE: src/components/ModelsHeaderRight/index.ts
================================================
export * from './ModelsHeaderRight';



================================================
FILE: src/components/ModelsHeaderRight/ModelsHeaderRight.tsx
================================================
import {Image, View} from 'react-native';
import React, {useContext, useState} from 'react';

import {observer} from 'mobx-react';
import {IconButton} from 'react-native-paper';

import iconHF from '../../assets/icon-hf.png';
import iconHFLight from '../../assets/icon-hf-light.png';

import {createStyles} from './styles';
import {ModelsResetDialog} from '../ModelsResetDialog';

import {modelStore, uiStore} from '../../store';

import {L10nContext} from '../../utils';

import {Menu} from '..';

export const ModelsHeaderRight = observer(() => {
  const [menuVisible, setMenuVisible] = useState(false);
  const [resetDialogVisible, setResetDialogVisible] = useState(false);
  const [_, setTrigger] = useState<boolean>(false);

  const l10n = useContext(L10nContext);

  const styles = createStyles();

  const filters = uiStore.pageStates.modelsScreen.filters;
  const setFilters = (value: string[]) => {
    uiStore.setValue('modelsScreen', 'filters', value);
  };

  const showResetDialog = () => setResetDialogVisible(true);
  const hideResetDialog = () => setResetDialogVisible(false);

  const handleReset = async () => {
    try {
      modelStore.resetModels();
      setTrigger(prev => !prev); // Trigger UI refresh
    } catch (error) {
      console.error('Error resetting models:', error);
    } finally {
      hideResetDialog();
    }
  };

  const toggleFilter = (filterName: string) => {
    const newFilters = filters.includes(filterName)
      ? filters.filter(f => f !== filterName)
      : [...filters, filterName];
    setFilters(newFilters);
  };

  return (
    <View style={styles.container}>
      <ModelsResetDialog
        visible={resetDialogVisible}
        onDismiss={hideResetDialog}
        onReset={handleReset}
        testID="reset-dialog"
      />
      <Menu
        visible={menuVisible}
        onDismiss={() => setMenuVisible(false)}
        selectable
        anchor={
          <IconButton
            icon="tune-vertical"
            size={24}
            style={styles.iconButton}
            onPress={() => setMenuVisible(true)}
            testID="models-menu-button"
          />
        }
        anchorPosition="bottom">
        {/* Filter section */}
        <Menu.Item label="Filters" isGroupLabel />
        <Menu.Item
          icon={({size}) => (
            <Image
              source={filters.includes('hf') ? iconHF : iconHFLight}
              style={{width: size, height: size}}
            />
          )}
          onPress={() => toggleFilter('hf')}
          label={l10n.components.modelsHeaderRight.menuTitleHf}
          selected={filters.includes('hf')}
        />
        <Menu.Item
          icon={filters.includes('downloaded') ? 'download-circle' : 'download'}
          onPress={() => toggleFilter('downloaded')}
          label={l10n.components.modelsHeaderRight.menuTitleDownloaded}
          selected={filters.includes('downloaded')}
        />

        {/* View section */}
        <Menu.Item label="View" isGroupLabel />
        <Menu.Item
          icon={filters.includes('grouped') ? 'layers' : 'layers-outline'}
          onPress={() => toggleFilter('grouped')}
          label={l10n.components.modelsHeaderRight.menuTitleGrouped}
          selected={filters.includes('grouped')}
        />

        {/* Actions section */}
        <Menu.Separator />
        <Menu.Item
          leadingIcon="refresh"
          onPress={() => {
            setMenuVisible(false);
            showResetDialog();
          }}
          label={l10n.components.modelsHeaderRight.menuTitleReset}
        />
      </Menu>
    </View>
  );
});



================================================
FILE: src/components/ModelsHeaderRight/styles.ts
================================================
import {StyleSheet} from 'react-native';

export const createStyles = () =>
  StyleSheet.create({
    container: {
      flexDirection: 'row',
      alignItems: 'center',
      marginRight: 8,
    },
    iconButton: {
      margin: 0,
      marginHorizontal: 4,
    },
  });



================================================
FILE: src/components/ModelsHeaderRight/__tests__/ModelsHeaderRight.test.tsx
================================================
import React from 'react';

import {fireEvent, render, waitFor} from '../../../../jest/test-utils';

import {ModelsHeaderRight} from '../ModelsHeaderRight';

import {uiStore} from '../../../store';

import {l10n} from '../../../utils/l10n';

describe('ModelsHeaderRight', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders correctly', () => {
    const {getByTestId} = render(<ModelsHeaderRight />);
    expect(getByTestId('models-menu-button')).toBeTruthy();
  });

  it('toggles HF filter when pressed', async () => {
    const {getByTestId, getByText} = render(<ModelsHeaderRight />);

    // Open menu
    fireEvent.press(getByTestId('models-menu-button'));

    // Press HF filter option
    const hfOption = getByText(
      l10n.en.components.modelsHeaderRight.menuTitleHf,
    );
    fireEvent.press(hfOption);

    expect(uiStore.setValue).toHaveBeenCalledWith(
      'modelsScreen',
      'filters',
      expect.arrayContaining(['hf']),
    );
  });

  it('toggles downloaded filter when pressed', async () => {
    const {getByTestId, getByText} = render(<ModelsHeaderRight />);

    // Open menu
    fireEvent.press(getByTestId('models-menu-button'));

    // Press downloaded filter option
    const downloadedOption = getByText(
      l10n.en.components.modelsHeaderRight.menuTitleDownloaded,
    );
    fireEvent.press(downloadedOption);

    expect(uiStore.setValue).toHaveBeenCalledWith(
      'modelsScreen',
      'filters',
      expect.arrayContaining(['downloaded']),
    );
  });

  it('toggles grouped view when pressed', async () => {
    const {getByTestId, getByText} = render(<ModelsHeaderRight />);

    // Open menu
    fireEvent.press(getByTestId('models-menu-button'));

    // Press group option
    const groupOption = getByText(
      l10n.en.components.modelsHeaderRight.menuTitleGrouped,
    );
    fireEvent.press(groupOption);

    expect(uiStore.setValue).toHaveBeenCalledWith(
      'modelsScreen',
      'filters',
      expect.arrayContaining(['grouped']),
    );
  });

  it('shows reset dialog when reset option is pressed', async () => {
    const {getByTestId, getByText, queryByTestId} = render(
      <ModelsHeaderRight />,
    );

    // Open menu
    fireEvent.press(getByTestId('models-menu-button'));

    // Press reset option
    const resetOption = getByText(
      l10n.en.components.modelsHeaderRight.menuTitleReset,
    );
    fireEvent.press(resetOption);

    await waitFor(() => {
      expect(queryByTestId('reset-dialog')).toBeTruthy();
    });
  });
});



================================================
FILE: src/components/ModelsResetDialog/index.ts
================================================
export * from './ModelsResetDialog';



================================================
FILE: src/components/ModelsResetDialog/ModelsResetDialog.tsx
================================================
import React, {useContext} from 'react';

import {observer} from 'mobx-react';
import {Portal, Dialog, Button, Text, Paragraph} from 'react-native-paper';

import {styles} from './styles';

import {L10nContext} from '../../utils';

type ModelsResetDialogProps = {
  testID?: string;
  visible: boolean;
  onDismiss: () => void;
  onReset: () => void;
};

export const ModelsResetDialog: React.FC<ModelsResetDialogProps> = observer(
  ({testID, visible, onDismiss, onReset}) => {
    const l10n = useContext(L10nContext);
    return (
      <Portal>
        <Dialog testID={testID} visible={visible} onDismiss={onDismiss}>
          <Dialog.Title>
            {l10n.components.modelsResetDialog.confirmReset}
          </Dialog.Title>
          <Dialog.Content>
            <Paragraph style={styles.paragraph}>
              This will reset model settings (
              <Text variant="labelMedium">
                'system prompt', 'chat template', 'temperature',
              </Text>
              etc.) to their default configuration.
            </Paragraph>

            <Paragraph style={styles.paragraph}>
              - Your downloaded models will <Text style={styles.bold}>not</Text>{' '}
              be removed.
            </Paragraph>

            <Paragraph style={styles.paragraph}>
              - Your 'Local Models' will remain intact.
            </Paragraph>

            {/*<Paragraph style={styles.paragraph}>
            - This action is <Text style={styles.bold}>irreversible.</Text>
          </Paragraph>*/}
          </Dialog.Content>
          <Dialog.Actions>
            <Button testID="cancel-reset-button" onPress={onDismiss}>
              {l10n.common.cancel}
            </Button>
            <Button testID="proceed-reset-button" onPress={onReset}>
              {l10n.components.modelsResetDialog.proceedWithReset}
            </Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    );
  },
);



================================================
FILE: src/components/ModelsResetDialog/styles.ts
================================================
import {StyleSheet} from 'react-native';

export const styles = StyleSheet.create({
  paragraph: {
    marginBottom: 8,
  },
  bold: {
    fontWeight: 'bold',
  },
});



================================================
FILE: src/components/ModelsResetDialog/__tests__/ModelsResetDialog.test.tsx
================================================
import React from 'react';

import {fireEvent, render} from '../../../../jest/test-utils';

import {ModelsResetDialog} from '../ModelsResetDialog';

import {l10n} from '../../../utils/l10n';

describe('ModelsResetDialog', () => {
  const mockOnDismiss = jest.fn();
  const mockOnReset = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders correctly when visible', () => {
    const {getByTestId, getByText} = render(
      <ModelsResetDialog
        testID="reset-dialog"
        visible={true}
        onDismiss={mockOnDismiss}
        onReset={mockOnReset}
      />,
    );

    // Check if dialog is rendered
    expect(getByTestId('reset-dialog')).toBeTruthy();

    // Check if title is rendered
    expect(
      getByText(l10n.en.components.modelsResetDialog.confirmReset),
    ).toBeTruthy();

    // Check if buttons are rendered
    expect(getByTestId('cancel-reset-button')).toBeTruthy();
    expect(getByTestId('proceed-reset-button')).toBeTruthy();
  });

  it('is not visible when visible prop is false', () => {
    const {queryByTestId} = render(
      <ModelsResetDialog
        testID="reset-dialog"
        visible={false}
        onDismiss={mockOnDismiss}
        onReset={mockOnReset}
      />,
    );

    expect(queryByTestId('reset-dialog')).toBeNull();
  });

  it('calls onDismiss when cancel button is pressed', () => {
    const {getByTestId} = render(
      <ModelsResetDialog
        testID="reset-dialog"
        visible={true}
        onDismiss={mockOnDismiss}
        onReset={mockOnReset}
      />,
    );

    const cancelButton = getByTestId('cancel-reset-button');
    fireEvent.press(cancelButton);

    expect(mockOnDismiss).toHaveBeenCalledTimes(1);
    expect(mockOnReset).not.toHaveBeenCalled();
  });

  it('calls onReset when proceed button is pressed', () => {
    const {getByTestId} = render(
      <ModelsResetDialog
        testID="reset-dialog"
        visible={true}
        onDismiss={mockOnDismiss}
        onReset={mockOnReset}
      />,
    );

    const proceedButton = getByTestId('proceed-reset-button');
    fireEvent.press(proceedButton);

    expect(mockOnReset).toHaveBeenCalledTimes(1);
    expect(mockOnDismiss).not.toHaveBeenCalled();
  });

  it('calls onDismiss when dialog backdrop is pressed', () => {
    const {getByTestId} = render(
      <ModelsResetDialog
        testID="reset-dialog"
        visible={true}
        onDismiss={mockOnDismiss}
        onReset={mockOnReset}
      />,
    );

    // Simulate pressing the dialog backdrop
    fireEvent(getByTestId('reset-dialog'), 'onDismiss');

    expect(mockOnDismiss).toHaveBeenCalledTimes(1);
    expect(mockOnReset).not.toHaveBeenCalled();
  });
});



================================================
FILE: src/components/ModelTypeTag/index.ts
================================================
export * from './ModelTypeTag';



================================================
FILE: src/components/ModelTypeTag/ModelTypeTag.tsx
================================================
import React from 'react';
import {View} from 'react-native';

import {Text} from 'react-native-paper';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';

import {useTheme} from '../../hooks';

import {createStyles} from './styles';

export type ModelType = 'vision' | 'mmproj' | 'llm';

interface ModelTypeTagProps {
  type: ModelType;
  label?: string;
  size?: 'small' | 'medium';
}

export const ModelTypeTag: React.FC<ModelTypeTagProps> = ({
  type,
  label,
  size = 'small',
}) => {
  const theme = useTheme();
  const styles = createStyles(theme, type, size);

  const getIconName = () => {
    switch (type) {
      case 'vision':
        return 'eye';
      case 'mmproj':
        return 'image-outline';
      case 'llm':
        return 'brain';
      default:
        return 'cube-outline';
    }
  };

  const getColor = () => {
    switch (type) {
      case 'vision':
        return theme.colors.tertiary;
      case 'mmproj':
        return theme.colors.tertiary;
      case 'llm':
        return theme.colors.secondary;
      default:
        return theme.colors.onSurfaceVariant;
    }
  };

  const iconSize = size === 'small' ? 12 : 16;
  const iconColor = getColor();

  return (
    <View style={styles.container} testID="model-type-tag-container">
      <Icon name={getIconName()} size={iconSize} color={iconColor} />
      {label && <Text style={styles.text}>{label}</Text>}
    </View>
  );
};



================================================
FILE: src/components/ModelTypeTag/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {ModelType} from './ModelTypeTag';

import {Theme} from '../../utils';

export const createStyles = (
  theme: Theme,
  type: ModelType,
  size: 'small' | 'medium',
) =>
  StyleSheet.create({
    container: {
      flexDirection: 'row',
      alignItems: 'center',
      borderRadius: 10,
      borderWidth: 1,
      paddingHorizontal: size === 'small' ? 4 : 6,
      marginRight: 4,
      height: size === 'small' ? 20 : 24,
      backgroundColor: (() => {
        switch (type) {
          case 'vision':
            return 'transparent';
          case 'mmproj':
            return theme.colors.tertiaryContainer;
          case 'llm':
            return theme.colors.secondaryContainer;
          default:
            return theme.colors.surfaceVariant;
        }
      })(),
      borderColor: (() => {
        const color = (() => {
          switch (type) {
            case 'vision':
              return theme.colors.tertiary;
            case 'mmproj':
              return theme.colors.tertiary;
            case 'llm':
              return theme.colors.secondary;
            default:
              return theme.colors.onSurfaceVariant;
          }
        })();
        return color + '30'; // 30% opacity
      })(),
    },
    text: {
      fontWeight: '600',
      fontSize: size === 'small' ? 10 : 12,
      marginLeft: 2,
      color: (() => {
        switch (type) {
          case 'vision':
            return theme.colors.tertiary;
          case 'mmproj':
            return theme.colors.tertiary;
          case 'llm':
            return theme.colors.secondary;
          default:
            return theme.colors.onSurfaceVariant;
        }
      })(),
    },
  });



================================================
FILE: src/components/ModelTypeTag/__tests__/ModelTypeTag.test.tsx
================================================
import React from 'react';
import {render} from '@testing-library/react-native';

import {ModelTypeTag, ModelType} from '../ModelTypeTag';

// Mock react-native-vector-icons
jest.mock('react-native-vector-icons/MaterialCommunityIcons', () => {
  return (props: any) => {
    const {View} = require('react-native');
    return <View testID="mock-icon" {...props} />;
  };
});

// Mock useTheme hook
jest.mock('../../../hooks', () => ({
  useTheme: () => ({
    colors: {
      tertiary: '#FF6B35',
      secondary: '#4ECDC4',
      onSurfaceVariant: '#666666',
    },
  }),
}));

describe('ModelTypeTag', () => {
  it('renders vision type correctly', () => {
    const {getByTestId} = render(<ModelTypeTag type="vision" />);

    const container = getByTestId('model-type-tag-container');
    expect(container).toBeTruthy();
  });

  it('renders mmproj type correctly', () => {
    const {getByTestId} = render(<ModelTypeTag type="mmproj" />);

    const container = getByTestId('model-type-tag-container');
    expect(container).toBeTruthy();
  });

  it('renders llm type correctly', () => {
    const {getByTestId} = render(<ModelTypeTag type="llm" />);

    const container = getByTestId('model-type-tag-container');
    expect(container).toBeTruthy();
  });

  it('renders with label when provided', () => {
    const {getByText} = render(
      <ModelTypeTag type="vision" label="Vision Model" />,
    );

    expect(getByText('Vision Model')).toBeTruthy();
  });

  it('renders without label when not provided', () => {
    const {queryByText} = render(<ModelTypeTag type="vision" />);

    // Should not have any text when no label is provided
    expect(queryByText(/./)).toBeNull();
  });

  it('renders small size by default', () => {
    const {getByTestId} = render(<ModelTypeTag type="vision" />);

    const container = getByTestId('model-type-tag-container');
    expect(container).toBeTruthy();
  });

  it('renders medium size when specified', () => {
    const {getByTestId} = render(<ModelTypeTag type="vision" size="medium" />);

    const container = getByTestId('model-type-tag-container');
    expect(container).toBeTruthy();
  });

  it('uses correct icon for vision type', () => {
    const {getByTestId} = render(<ModelTypeTag type="vision" />);

    const icon = getByTestId('mock-icon');
    expect(icon.props.name).toBe('eye');
  });

  it('uses correct icon for mmproj type', () => {
    const {getByTestId} = render(<ModelTypeTag type="mmproj" />);

    const icon = getByTestId('mock-icon');
    expect(icon.props.name).toBe('image-outline');
  });

  it('uses correct icon for llm type', () => {
    const {getByTestId} = render(<ModelTypeTag type="llm" />);

    const icon = getByTestId('mock-icon');
    expect(icon.props.name).toBe('brain');
  });

  it('uses correct icon size for small size', () => {
    const {getByTestId} = render(<ModelTypeTag type="vision" size="small" />);

    const icon = getByTestId('mock-icon');
    expect(icon.props.size).toBe(12);
  });

  it('uses correct icon size for medium size', () => {
    const {getByTestId} = render(<ModelTypeTag type="vision" size="medium" />);

    const icon = getByTestId('mock-icon');
    expect(icon.props.size).toBe(16);
  });

  it('uses correct color for vision type', () => {
    const {getByTestId} = render(<ModelTypeTag type="vision" />);

    const icon = getByTestId('mock-icon');
    expect(icon.props.color).toBe('#FF6B35'); // tertiary color
  });

  it('uses correct color for mmproj type', () => {
    const {getByTestId} = render(<ModelTypeTag type="mmproj" />);

    const icon = getByTestId('mock-icon');
    expect(icon.props.color).toBe('#FF6B35'); // tertiary color
  });

  it('uses correct color for llm type', () => {
    const {getByTestId} = render(<ModelTypeTag type="llm" />);

    const icon = getByTestId('mock-icon');
    expect(icon.props.color).toBe('#4ECDC4'); // secondary color
  });

  it('handles unknown type gracefully', () => {
    const {getByTestId} = render(
      <ModelTypeTag type={'unknown' as ModelType} />,
    );

    const icon = getByTestId('mock-icon');
    expect(icon.props.name).toBe('cube-outline');
    expect(icon.props.color).toBe('#666666'); // onSurfaceVariant color
  });

  it('renders both icon and label when both are provided', () => {
    const {getByTestId, getByText} = render(
      <ModelTypeTag type="vision" label="Vision Model" />,
    );

    const icon = getByTestId('mock-icon');
    const label = getByText('Vision Model');

    expect(icon).toBeTruthy();
    expect(label).toBeTruthy();
  });
});



================================================
FILE: src/components/PalHeaderRight/index.ts
================================================
export * from './PalHeaderRight';



================================================
FILE: src/components/PalHeaderRight/PalHeaderRight.tsx
================================================
import {View, Keyboard, Alert} from 'react-native';

import React, {useContext, useState} from 'react';

import {observer} from 'mobx-react';
import {IconButton, useTheme} from 'react-native-paper';

import {createStyles} from './styles';
import {L10nContext} from '../../utils';

import {Menu} from '..';
import {DotsVerticalIcon, ShareIcon} from '../../assets/icons';

import {exportAllPals} from '../../utils/exportUtils';
import {importPals} from '../../utils/importUtils';

export const PalHeaderRight = observer(() => {
  const theme = useTheme();
  const [menuVisible, setMenuVisible] = useState(false);

  const l10n = useContext(L10nContext);

  const styles = createStyles();

  const openMenu = () => {
    if (Keyboard.isVisible()) {
      Keyboard.dismiss();
    }
    setMenuVisible(true);
  };
  const closeMenu = () => setMenuVisible(false);

  const onPressExportAllPals = async () => {
    try {
      await exportAllPals();
    } catch (error) {
      console.error('Error exporting all pals:', error);
      Alert.alert('Export Error', 'Failed to export all pals.');
    }
    closeMenu();
  };

  const onPressImportPals = async () => {
    try {
      const count = await importPals();
      if (count > 0) {
        Alert.alert(
          'Import Success',
          l10n.components.palHeaderRight.importSuccess.replace(
            '{{count}}',
            count.toString(),
          ),
        );
      }
    } catch (error) {
      console.error('Error importing pals:', error);
      Alert.alert('Import Error', l10n.components.palHeaderRight.importError);
    }
    closeMenu();
  };

  return (
    <View style={styles.container}>
      <Menu
        visible={menuVisible}
        onDismiss={closeMenu}
        anchorPosition="bottom"
        anchor={
          <IconButton
            icon={() => <DotsVerticalIcon fill={theme.colors.primary} />}
            style={styles.menuBtn}
            onPress={openMenu}
            testID="menu-button"
          />
        }>
        <Menu.Item
          submenu={[
            <Menu.Item
              key="export-all"
              onPress={onPressExportAllPals}
              label={l10n.components.palHeaderRight.exportAllPals}
            />,
            <Menu.Item
              key="import"
              onPress={onPressImportPals}
              label={l10n.components.palHeaderRight.importPals}
            />,
          ]}
          label={l10n.components.headerRight.export}
          leadingIcon={() => <ShareIcon stroke={theme.colors.primary} />}
        />
      </Menu>
    </View>
  );
});



================================================
FILE: src/components/PalHeaderRight/styles.ts
================================================
import {StyleSheet} from 'react-native';

export const createStyles = () =>
  StyleSheet.create({
    container: {
      flexDirection: 'row',
      alignItems: 'center',
      marginRight: 8,
    },
    menuBtn: {
      marginLeft: 0,
    },
  });



================================================
FILE: src/components/PalsSheets/AssistantPalSheet.tsx
================================================
import React, {
  useContext,
  useRef,
  useEffect,
  useCallback,
  useMemo,
} from 'react';
import {View, TextInput as RNTextInput} from 'react-native';
import {Button} from 'react-native-paper';
import {observer} from 'mobx-react-lite';
import {useForm, FormProvider, Controller} from 'react-hook-form';
import {zodResolver} from '@hookform/resolvers/zod';

import {Sheet} from '..';
import {useTheme} from '../../hooks';
import {createStyles} from './styles';
import {L10nContext} from '../../utils';
import {palStore} from '../../store';
import {FormField} from './FormField';
import {SystemPromptSection} from './SystemPromptSection';
import {ColorSection} from './ColorSection';
import {ModelSelector} from './ModelSelector';
import {createSchemaWithL10n, PalType, type AssistantFormData} from './types';
import {ModelNotAvailable} from './ModelNotAvailable';

interface AssistantPalSheetProps {
  isVisible: boolean;
  onClose: () => void;
  editPal?: AssistantFormData & {id: string};
}

const INITIAL_STATE: Omit<AssistantFormData, 'palType'> = {
  name: '',
  defaultModel: undefined,
  useAIPrompt: false,
  systemPrompt: '',
  originalSystemPrompt: '',
  isSystemPromptChanged: false,
  color: undefined,
  promptGenerationModel: undefined,
  generatingPrompt: '',
};

export const AssistantPalSheet: React.FC<AssistantPalSheetProps> = observer(
  ({isVisible, onClose, editPal}) => {
    const theme = useTheme();
    const styles = createStyles(theme);
    const l10n = useContext(L10nContext);

    // Create localized schema using current l10n context
    const schemas = useMemo(() => createSchemaWithL10n(l10n), [l10n]);
    const assistantFormSchema = schemas.assistantSchema;

    const inputRefs = useRef<{[key: string]: RNTextInput | null}>({});

    const methods = useForm<AssistantFormData>({
      resolver: zodResolver(assistantFormSchema),
      defaultValues: {...INITIAL_STATE, palType: PalType.ASSISTANT},
    });

    useEffect(() => {
      if (editPal) {
        methods.reset(editPal);
      }
    }, [editPal, methods]);

    const validateAssistantFields = async () => {
      const formState = methods.getValues();
      if (formState.useAIPrompt) {
        if (!formState.generatingPrompt) {
          methods.setError('generatingPrompt', {
            message:
              l10n.components.assistantPalSheet.validation
                .generatingPromptRequired,
          });
        }
        if (!formState.promptGenerationModel) {
          methods.setError('promptGenerationModel', {
            message:
              l10n.components.assistantPalSheet.validation.promptModelRequired,
          });
        }
        return Boolean(
          formState.generatingPrompt && formState.promptGenerationModel,
        );
      }
      return true;
    };

    const resetForm = useCallback(() => {
      if (editPal) {
        methods.reset(editPal);
      } else {
        methods.reset({...INITIAL_STATE, palType: PalType.ASSISTANT});
      }
    }, [editPal, methods]);

    useEffect(() => {
      resetForm();
    }, [resetForm]);

    const handleClose = () => {
      resetForm();
      onClose();
    };

    const onSubmit = (data: AssistantFormData) => {
      if (editPal) {
        palStore.updatePal(editPal.id, data);
      } else {
        palStore.addPal(data);
      }
      handleClose();
    };

    return (
      <Sheet
        title={
          editPal
            ? l10n.components.assistantPalSheet.title.edit
            : l10n.components.assistantPalSheet.title.create
        }
        isVisible={isVisible}
        displayFullHeight
        onClose={handleClose}>
        <FormProvider {...methods}>
          <Sheet.ScrollView
            bottomOffset={16}
            contentContainerStyle={styles.scrollviewContainer}>
            <View style={styles.form}>
              <FormField
                ref={ref => (inputRefs.current.name = ref)}
                name="name"
                label={l10n.components.assistantPalSheet.palName}
                placeholder={
                  l10n.components.assistantPalSheet.palNamePlaceholder
                }
                required
                onSubmitEditing={() => inputRefs.current.defaultModel?.focus()}
              />

              <Controller
                name="defaultModel"
                control={methods.control}
                render={({field: {onChange, value}, fieldState: {error}}) => (
                  <ModelSelector
                    value={value}
                    onChange={onChange}
                    label={l10n.components.assistantPalSheet.defaultModel}
                    placeholder={
                      l10n.components.assistantPalSheet.defaultModelPlaceholder
                    }
                    error={!!error}
                    helperText={error?.message}
                    inputRef={ref => (inputRefs.current.defaultModel = ref)}
                    onSubmitEditing={() =>
                      inputRefs.current.description?.focus()
                    }
                  />
                )}
              />

              <ModelNotAvailable
                model={editPal?.defaultModel}
                closeSheet={handleClose}
              />

              <SystemPromptSection
                validateFields={validateAssistantFields}
                closeSheet={handleClose}
              />
              <ColorSection />
            </View>
          </Sheet.ScrollView>

          <Sheet.Actions>
            <View style={styles.actions}>
              <Button
                style={styles.actionBtn}
                mode="text"
                onPress={handleClose}>
                {l10n.common.cancel}
              </Button>
              <Button
                style={styles.actionBtn}
                mode="contained"
                onPress={methods.handleSubmit(onSubmit)}>
                {editPal
                  ? l10n.common.save
                  : l10n.components.assistantPalSheet.create}
              </Button>
            </View>
          </Sheet.Actions>
        </FormProvider>
      </Sheet>
    );
  },
);



================================================
FILE: src/components/PalsSheets/FormField.tsx
================================================
import React, {forwardRef} from 'react';
import {View, TextInput as RNTextInput} from 'react-native';
import {Text} from 'react-native-paper';
import {Controller, useFormContext} from 'react-hook-form';

import {useTheme} from '../../hooks';
import {createStyles} from './styles';
import {TextInput} from '../TextInput';
import type {AssistantFormData, RoleplayFormData} from './types';

type FormData = AssistantFormData | RoleplayFormData;

// Extract only string fields
type StringFields =
  | 'name'
  | 'systemPrompt'
  | 'generatingPrompt'
  | 'world'
  | 'location'
  | 'aiRole'
  | 'userRole'
  | 'situation'
  | 'toneStyle';

interface FormFieldProps {
  name: StringFields;
  label: string;
  placeholder?: string;
  multiline?: boolean;
  required?: boolean;
  sublabel?: string;
  disabled?: boolean;
  onSubmitEditing?: () => void;
}

const FormField = forwardRef<RNTextInput, FormFieldProps>(
  (
    {
      name,
      label,
      placeholder,
      multiline,
      required,
      sublabel,
      disabled,
      onSubmitEditing,
    },
    ref,
  ) => {
    const theme = useTheme();
    const styles = createStyles(theme);
    const {
      control,
      formState: {errors},
    } = useFormContext<FormData>();

    return (
      <View style={styles.field}>
        <Text style={theme.fonts.titleMediumLight}>
          {label}
          {required && '*'}
        </Text>
        {sublabel && <Text style={styles.sublabel}>{sublabel}</Text>}
        <Controller
          control={control}
          name={name}
          render={({field: {onChange, value}}) => (
            <TextInput
              testID={`form-field-${name}`}
              ref={ref}
              value={value || ''}
              onChangeText={onChange}
              error={!!errors[name]}
              placeholder={placeholder}
              helperText={errors[name]?.message?.toString()}
              multiline={multiline}
              numberOfLines={multiline ? 5 : 1}
              editable={!disabled}
              onSubmitEditing={!multiline ? onSubmitEditing : undefined}
              returnKeyType={'default'}
            />
          )}
        />
      </View>
    );
  },
);

FormField.displayName = 'FormField';

export {FormField};



================================================
FILE: src/components/PalsSheets/index.ts
================================================
export * from './AssistantPalSheet';
export * from './RoleplayPalSheet';
export * from './VideoPalSheet';
export * from './types';



================================================
FILE: src/components/PalsSheets/ModelNotAvailable.tsx
================================================
import React, {useContext} from 'react';
import {Button, Paragraph, ProgressBar, Text} from 'react-native-paper';
import {modelStore} from '../../store';
import {Model} from '../../utils/types';
import {useTheme} from '../../hooks';
import {View} from 'react-native';
import {createStyles} from './styles';
import {useNavigation} from '@react-navigation/native';
import {observer} from 'mobx-react';
import {L10nContext} from '../../utils';

export const ModelNotAvailable = observer(
  ({model, closeSheet}: {model?: Model; closeSheet: () => void}) => {
    const theme = useTheme();
    const navigation = useNavigation<any>();
    const styles = createStyles(theme);
    const l10n = useContext(L10nContext);

    const isPalModelDownloaded = modelStore.isModelAvailable(model?.id);
    const defaultModel = modelStore.models.find(m => m.id === model?.id);

    const isDownloading = defaultModel
      ? modelStore.isDownloading(defaultModel.id)
      : false;
    const downloadProgress = (defaultModel?.progress || 0) / 100;
    const downloadSpeed = defaultModel?.downloadSpeed;

    const hasAnyDownloadedModel = modelStore.availableModels.length > 0;

    const handleDownloadModel = async (modelToDownload: Model) => {
      if (modelToDownload.hfModel) {
        // For HF models, use default vision preference (enabled) for backward compatibility
        await modelStore.downloadHFModel(
          modelToDownload.hfModel!,
          modelToDownload.hfModelFile!,
          {enableVision: true},
        );
      } else {
        await modelStore.checkSpaceAndDownload(modelToDownload.id);
      }
    };

    const handleNavigateToModels = () => {
      closeSheet();
      navigation.navigate('Models');
    };

    if (!hasAnyDownloadedModel && !model) {
      return (
        <View style={styles.modelNotDownloaded}>
          <Text style={{color: theme.colors.error}}>
            {l10n.components.modelNotAvailable.noModelsDownloaded}
          </Text>
          <Button onPress={handleNavigateToModels} mode="contained-tonal">
            {l10n.components.modelNotAvailable.downloadAModel}
          </Button>
        </View>
      );
    }
    if (model && !isPalModelDownloaded) {
      return (
        <View style={styles.modelNotDownloaded}>
          {isDownloading ? (
            <>
              <ProgressBar
                testID="download-progress-bar"
                progress={downloadProgress}
                color={theme.colors.tertiary}
                style={styles.progressBar}
              />
              {downloadSpeed && <Paragraph>{downloadSpeed}</Paragraph>}
            </>
          ) : (
            <Text style={{color: theme.colors.error}}>
              {l10n.components.modelNotAvailable.defaultModelNotDownloaded}
            </Text>
          )}

          <Button
            onPress={() =>
              isDownloading
                ? modelStore.cancelDownload(model.id)
                : handleDownloadModel(model)
            }
            mode="contained-tonal">
            {isDownloading
              ? l10n.components.modelNotAvailable.cancelDownload
              : l10n.components.modelNotAvailable.download}
          </Button>
        </View>
      );
    }
    return null;
  },
);



================================================
FILE: src/components/PalsSheets/ModelSelector.tsx
================================================
import React from 'react';
import {observer} from 'mobx-react-lite';
import {View, TextInput as RNTextInput} from 'react-native';
import {Text, TextInput as PaperTextInput} from 'react-native-paper';
import {Menu} from '../Menu';
import {TextInput} from '../TextInput';
import {modelStore} from '../../store';
import {useTheme} from '../../hooks';
import {createStyles} from './styles';
import {ChevronRightIcon} from '../../assets/icons';
import {Model} from '../../utils/types';

interface ModelSelectorProps {
  value?: Model;
  onChange: (value: Model) => void;
  label: string;
  sublabel?: string;
  placeholder?: string;
  error?: boolean;
  helperText?: string;
  required?: boolean;
  inputRef?: (ref: RNTextInput | null) => void;
  onSubmitEditing?: () => void;
  disabled?: boolean;
  filter?: (model: Model) => boolean;
}

export const ModelSelector = observer(
  ({
    value,
    onChange,
    label,
    sublabel,
    placeholder = 'Select model',
    error,
    helperText,
    required,
    inputRef,
    onSubmitEditing,
    disabled,
    filter,
  }: ModelSelectorProps) => {
    const [menuVisible, setMenuVisible] = React.useState(false);
    const theme = useTheme();
    const styles = createStyles(theme);

    return (
      <View style={styles.field}>
        <Text style={theme.fonts.titleMediumLight}>
          {label}
          {required && '*'}
        </Text>
        {sublabel && <Text style={styles.sublabel}>{sublabel}</Text>}
        <Menu
          visible={menuVisible}
          selectable
          onDismiss={() => setMenuVisible(false)}
          anchor={
            <TextInput
              ref={inputRef}
              value={value?.name || ''}
              placeholder={placeholder}
              onPressIn={() => setMenuVisible(true)}
              disabled={disabled}
              editable={false}
              error={error}
              helperText={helperText}
              onSubmitEditing={onSubmitEditing}
              returnKeyType="next"
              right={
                <PaperTextInput.Icon
                  onPress={() => setMenuVisible(true)}
                  icon={() => (
                    <ChevronRightIcon stroke={theme.colors.primary} />
                  )}
                />
              }
            />
          }>
          {modelStore.availableModels
            .filter(model => (filter ? filter(model) : true))
            .map(model => (
              <Menu.Item
                key={model.id}
                label={model.name}
                onPress={() => {
                  onChange(model);
                  setMenuVisible(false);
                  onSubmitEditing?.();
                }}
                selectable
                selected={model.id === value?.id}
              />
            ))}
        </Menu>
      </View>
    );
  },
);



================================================
FILE: src/components/PalsSheets/RoleplayPalSheet.tsx
================================================
import React, {
  useContext,
  useRef,
  useEffect,
  useCallback,
  useMemo,
} from 'react';
import {View, TextInput as RNTextInput} from 'react-native';
import {Button} from 'react-native-paper';
import {observer} from 'mobx-react-lite';
import {useForm, FormProvider, Controller} from 'react-hook-form';
import {zodResolver} from '@hookform/resolvers/zod';

import {Sheet} from '..';
import {useTheme} from '../../hooks';
import {createStyles} from './styles';
import {L10nContext} from '../../utils';
import {palStore} from '../../store';
import {FormField} from './FormField';
import {SystemPromptSection} from './SystemPromptSection';
import {ColorSection} from './ColorSection';
import {ModelSelector} from './ModelSelector';
import {SectionDivider} from './SectionDivider';
import {createSchemaWithL10n, PalType, type RoleplayFormData} from './types';
import {generateRoleplayPrompt} from './utils';

interface RoleplayPalSheetProps {
  isVisible: boolean;
  onClose: () => void;
  editPal?: RoleplayFormData & {id: string};
}

const INITIAL_STATE: Omit<RoleplayFormData, 'palType'> = {
  name: '',
  defaultModel: undefined,
  world: '',
  location: '',
  aiRole: '',
  userRole: '',
  situation: '',
  toneStyle: '',
  useAIPrompt: false,
  systemPrompt: '',
  isSystemPromptChanged: false,
  color: undefined,
  promptGenerationModel: undefined,
  generatingPrompt: '',
};

export const RoleplayPalSheet: React.FC<RoleplayPalSheetProps> = observer(
  ({isVisible, onClose, editPal}) => {
    const theme = useTheme();
    const styles = createStyles(theme);
    const l10n = useContext(L10nContext);

    // Create localized schema using current l10n context
    const schemas = useMemo(() => createSchemaWithL10n(l10n), [l10n]);
    const roleplayFormSchema = schemas.roleplaySchema;

    const inputRefs = useRef<{[key: string]: RNTextInput | null}>({});

    const methods = useForm<RoleplayFormData>({
      resolver: zodResolver(roleplayFormSchema),
      defaultValues: {...INITIAL_STATE, palType: PalType.ROLEPLAY},
    });

    const resetForm = useCallback(() => {
      if (editPal) {
        methods.reset(editPal);
      } else {
        methods.reset({...INITIAL_STATE, palType: PalType.ROLEPLAY});
      }
    }, [editPal, methods]);

    useEffect(() => {
      resetForm();
    }, [resetForm]);

    const handleClose = () => {
      resetForm();
      onClose();
    };

    const validateRoleplayFields = async () => {
      let result = await methods.trigger([
        'world',
        'location',
        'aiRole',
        'userRole',
        'situation',
        'toneStyle',
      ]);

      const formState = methods.getValues();
      if (formState.useAIPrompt) {
        if (!formState.promptGenerationModel) {
          methods.setError('promptGenerationModel', {
            message:
              l10n.components.roleplayPalSheet.validation.promptModelRequired,
          });
          result = false;
        }
      }
      return result;
    };

    const onSubmit = (data: RoleplayFormData) => {
      if (editPal) {
        palStore.updatePal(editPal.id, data);
      } else {
        palStore.addPal(data);
      }
      handleClose();
    };

    const updateSystemPromptOnFormChange = () => {
      // Use this custom template if use AI to generate checkbox is off
      if (!methods.getValues().useAIPrompt) {
        const systemPrompt = generateRoleplayPrompt(methods.getValues());
        methods.setValue('systemPrompt', systemPrompt);
        methods.setValue('originalSystemPrompt', systemPrompt);
      }
    };

    return (
      <Sheet
        title={
          editPal
            ? l10n.components.roleplayPalSheet.title.edit
            : l10n.components.roleplayPalSheet.title.create
        }
        isVisible={isVisible}
        displayFullHeight
        onClose={handleClose}>
        <FormProvider {...methods}>
          <Sheet.ScrollView
            bottomOffset={16}
            contentContainerStyle={styles.scrollviewContainer}>
            <View style={styles.form}>
              <View
                testID="inner-form"
                style={styles.innerForm}
                // @ts-ignore
                onBlur={updateSystemPromptOnFormChange}>
                <FormField
                  ref={ref => (inputRefs.current.name = ref)}
                  name="name"
                  label={l10n.components.roleplayPalSheet.palName}
                  placeholder={
                    l10n.components.roleplayPalSheet.palNamePlaceholder
                  }
                  required
                  onSubmitEditing={() =>
                    inputRefs.current.defaultModel?.focus()
                  }
                />

                <Controller
                  name="defaultModel"
                  control={methods.control}
                  render={({field: {onChange, value}, fieldState: {error}}) => (
                    <ModelSelector
                      value={value}
                      onChange={onChange}
                      label={l10n.components.roleplayPalSheet.defaultModel}
                      placeholder={
                        l10n.components.roleplayPalSheet.defaultModelPlaceholder
                      }
                      error={!!error}
                      helperText={error?.message}
                      inputRef={ref => (inputRefs.current.defaultModel = ref)}
                      onSubmitEditing={() => inputRefs.current.world?.focus()}
                    />
                  )}
                />

                <SectionDivider
                  label={l10n.components.roleplayPalSheet.descriptionSection}
                />

                <FormField
                  ref={ref => (inputRefs.current.world = ref)}
                  name="world"
                  label={l10n.components.roleplayPalSheet.world}
                  placeholder={
                    l10n.components.roleplayPalSheet.worldPlaceholder
                  }
                  required
                  onSubmitEditing={() => inputRefs.current.location?.focus()}
                />

                <FormField
                  ref={ref => (inputRefs.current.location = ref)}
                  name="location"
                  label={l10n.components.roleplayPalSheet.location}
                  placeholder={
                    l10n.components.roleplayPalSheet.locationPlaceholder
                  }
                  sublabel={l10n.components.roleplayPalSheet.locationSublabel}
                  required
                  onSubmitEditing={() => inputRefs.current.aiRole?.focus()}
                />

                <FormField
                  ref={ref => (inputRefs.current.aiRole = ref)}
                  name="aiRole"
                  label={l10n.components.roleplayPalSheet.aiRole}
                  placeholder={
                    l10n.components.roleplayPalSheet.aiRolePlaceholder
                  }
                  sublabel={l10n.components.roleplayPalSheet.aiRoleSublabel}
                  required
                  onSubmitEditing={() => inputRefs.current.userRole?.focus()}
                />

                <FormField
                  ref={ref => (inputRefs.current.userRole = ref)}
                  name="userRole"
                  label={l10n.components.roleplayPalSheet.userRole}
                  placeholder={
                    l10n.components.roleplayPalSheet.userRolePlaceholder
                  }
                  sublabel={l10n.components.roleplayPalSheet.userRoleSublabel}
                  required
                  onSubmitEditing={() => inputRefs.current.situation?.focus()}
                />

                <FormField
                  ref={ref => (inputRefs.current.situation = ref)}
                  name="situation"
                  label={l10n.components.roleplayPalSheet.situation}
                  placeholder={
                    l10n.components.roleplayPalSheet.situationPlaceholder
                  }
                  required
                  onSubmitEditing={() => inputRefs.current.toneStyle?.focus()}
                />

                <FormField
                  ref={ref => (inputRefs.current.toneStyle = ref)}
                  name="toneStyle"
                  label={l10n.components.roleplayPalSheet.toneStyle}
                  placeholder={
                    l10n.components.roleplayPalSheet.toneStylePlaceholder
                  }
                  required
                />
              </View>

              <SystemPromptSection
                hideGeneratingPrompt
                validateFields={validateRoleplayFields}
                closeSheet={handleClose}
              />
              <ColorSection />
            </View>
          </Sheet.ScrollView>

          <Sheet.Actions>
            <View style={styles.actions}>
              <Button
                style={styles.actionBtn}
                mode="text"
                onPress={handleClose}>
                {l10n.common.cancel}
              </Button>
              <Button
                style={styles.actionBtn}
                mode="contained"
                onPress={methods.handleSubmit(onSubmit)}>
                {editPal
                  ? l10n.common.save
                  : l10n.components.roleplayPalSheet.create}
              </Button>
            </View>
          </Sheet.Actions>
        </FormProvider>
      </Sheet>
    );
  },
);



================================================
FILE: src/components/PalsSheets/SectionDivider.tsx
================================================
import React from 'react';
import {View} from 'react-native';

import {Text} from 'react-native-paper';

import {useTheme} from '../../hooks';

import {createStyles} from './styles';

import {Divider} from '..';

interface SectionDividerProps {
  label: string;
}

export const SectionDivider: React.FC<SectionDividerProps> = ({label}) => {
  const theme = useTheme();
  const styles = createStyles(theme);

  return (
    <View testID="section-divider-container" style={styles.dividerContainer}>
      <View testID="section-divider-content" style={styles.dividerContent}>
        <Text variant="labelSmall" style={styles.dividerLabel}>
          {label}
        </Text>
        <View testID="section-divider-line" style={styles.dividerLine}>
          <Divider />
        </View>
      </View>
    </View>
  );
};



================================================
FILE: src/components/PalsSheets/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {Theme} from '../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    sliderContainer: {
      marginBottom: 16,
      paddingHorizontal: 8,
    },
    sliderLabel: {
      ...theme.fonts.bodyMedium,
      marginBottom: 8,
    },
    slider: {
      width: '100%',
      height: 40,
    },
    sliderLabels: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      width: '100%',
      marginTop: -8,
    },
    sliderMinLabel: {
      ...theme.fonts.bodySmall,
      color: theme.colors.onSurfaceVariant,
    },
    sliderMaxLabel: {
      ...theme.fonts.bodySmall,
      color: theme.colors.onSurfaceVariant,
    },
    scrollviewContainer: {
      padding: theme.spacing.default,
    },
    form: {
      gap: theme.spacing.default,
      padding: theme.spacing.default,
      backgroundColor: theme.colors.surface,
      borderRadius: theme.borders.default,
    },
    innerForm: {
      gap: theme.spacing.default,
    },
    modelNotDownloaded: {
      gap: 10,
    },
    progressBar: {
      height: 8,
      borderRadius: 5,
    },
    field: {
      gap: 4,
    },
    dividerContainer: {
      marginVertical: theme.spacing.default,
    },
    dividerContent: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.default,
    },
    dividerLabel: {
      color: theme.colors.onSurfaceVariant,
    },
    dividerLine: {
      flex: 1,
    },
    label: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
    },
    sublabel: {
      ...theme.fonts.bodySmall,
      color: theme.colors.onSurfaceVariant,
    },
    input: {
      backgroundColor: theme.colors.surface,
    },
    checkboxContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
    },
    actions: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      gap: 8,
      width: '100%',
    },
    actionBtn: {
      flex: 1,
    },
    warningContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginTop: 8,
    },
    warningText: {
      color: theme.colors.error,
      flex: 1,
    },
    resetButton: {
      marginLeft: 8,
    },
    // New styles for LookieSheet
    modelDownloadSection: {
      gap: 16,
      marginTop: 8,
      marginBottom: 16,
    },
    modelSectionTitle: {
      ...theme.fonts.bodyMedium,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 8,
    },
    modelItem: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      padding: 12,
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: theme.borders.default,
    },
    modelInfo: {
      flex: 1,
      marginRight: 12,
    },
    modelName: {
      ...theme.fonts.titleSmall,
      color: theme.colors.onSurface,
    },
    modelDescription: {
      ...theme.fonts.bodySmall,
      color: theme.colors.onSurfaceVariant,
    },
  });



================================================
FILE: src/components/PalsSheets/SystemPromptSection.tsx
================================================
import React, {useContext} from 'react';
import {View} from 'react-native';
import {Button, Text} from 'react-native-paper';
import {observer} from 'mobx-react-lite';
import {Controller, useFormContext} from 'react-hook-form';

import {useTheme} from '../../hooks';
import {createStyles} from './styles';
import {FormField} from './FormField';
import {SectionDivider} from './SectionDivider';
import {PalType, RoleplayFormData, type PalFormData} from './types';
import {Checkbox} from '../Checkbox';
import {ModelSelector} from './ModelSelector';
import {useStructuredOutput} from '../../hooks/useStructuredOutput';
import {modelStore} from '../../store';
import {getPromptForModelGeneration} from './utils';
import {ModelNotAvailable} from './ModelNotAvailable';
import {L10nContext} from '../../utils';

interface SystemPromptSectionProps {
  hideGeneratingPrompt?: boolean;
  validateFields?: () => Promise<boolean>;
  closeSheet: () => void;
}

export const SystemPromptSection = observer(
  ({
    hideGeneratingPrompt,
    validateFields,
    closeSheet,
  }: SystemPromptSectionProps) => {
    const theme = useTheme();
    const styles = createStyles(theme);
    const l10n = useContext(L10nContext);

    const {watch, control, getValues, setValue, clearErrors} =
      useFormContext<PalFormData>();
    const useAIPrompt = watch('useAIPrompt');
    const promptGenerationModel = watch('promptGenerationModel');
    const isLoadingModel = modelStore.isContextLoading;

    const {generate, isGenerating, stop} = useStructuredOutput();

    const handleGeneratePrompt = async () => {
      // Validate form fields if validateFields is provided
      if (validateFields) {
        const isValid = await validateFields();
        if (!isValid) {
          return;
        }
      }

      clearErrors('systemPrompt');

      try {
        const selectedModel = getValues().promptGenerationModel;
        if (!selectedModel) {
          console.error('Active model not found');
          return;
        }

        if (modelStore.activeModelId !== selectedModel.id) {
          const context = await modelStore.initContext(selectedModel);
          if (!context) {
            console.error('Failed to initialize context');
            return;
          }
        }

        if (getValues().palType === PalType.ROLEPLAY) {
          const pal = getValues();
          const prompt = getPromptForModelGeneration(pal as RoleplayFormData);

          const schema = {
            type: 'object',
            properties: {
              prompt: {
                type: 'string',
                description: 'The system prompt for the roleplay scenario',
              },
            },
            required: ['prompt'],
          };

          const result = await generate(prompt, schema);

          setValue('systemPrompt', result?.prompt);
          setValue('originalSystemPrompt', result?.prompt);
          setValue('isSystemPromptChanged', false);
        } else if (getValues().palType === PalType.ASSISTANT) {
          const schema = {
            type: 'object',
            properties: {
              prompt: {
                type: 'string',
                description: 'The system prompt for the assistant scenario',
              },
            },
            required: ['prompt'],
          };

          const generatingPrompt = [
            'Generate a concise and professional system prompt for an AI assistant with the following role:',
            `Topic: "${getValues().generatingPrompt}"\n`,
            'The system prompt should:',
            "- Be clear and direct but concise about the assistant's primary function",
            '- Be written in second person ("You are...")',
            'Output the system prompt in JSON format with the key "prompt".',
          ].join('\n');
          const result = await generate(generatingPrompt, schema);
          setValue('systemPrompt', result?.prompt);
          setValue('originalSystemPrompt', result?.prompt);
          setValue('isSystemPromptChanged', false);
        }
      } catch (err) {
        console.error('Generation error:', err);
      } finally {
      }
    };

    const handleStopGeneration = () => {
      stop();
    };

    const handleReset = () => {
      const originalPrompt = getValues('originalSystemPrompt');
      if (originalPrompt) {
        setValue('systemPrompt', originalPrompt);
        setValue('isSystemPromptChanged', false);
      }
    };

    const isSystemPromptEdited = watch('isSystemPromptChanged');

    return (
      <>
        <SectionDivider
          label={l10n.components.systemPromptSection.sectionTitle}
        />
        <View style={styles.field}>
          <Controller
            control={control}
            name="useAIPrompt"
            render={({field: {onChange, value}}) => (
              <View style={styles.checkboxContainer}>
                <Checkbox
                  checked={value}
                  onPress={() => {
                    onChange(!value);
                    clearErrors('systemPrompt');
                  }}
                  disabled={isSystemPromptEdited}>
                  <Text>{l10n.components.systemPromptSection.useAIPrompt}</Text>
                </Checkbox>
              </View>
            )}
          />
        </View>

        {useAIPrompt && (
          <>
            <Controller
              name="promptGenerationModel"
              control={control}
              render={({field: {onChange, value}, fieldState: {error}}) => (
                <ModelSelector
                  value={value}
                  onChange={selected => {
                    onChange(selected);
                    clearErrors('promptGenerationModel');
                  }}
                  label={
                    l10n.components.systemPromptSection.modelSelector.label
                  }
                  sublabel={
                    l10n.components.systemPromptSection.modelSelector.sublabel
                  }
                  placeholder={
                    l10n.components.systemPromptSection.modelSelector
                      .placeholder
                  }
                  error={!!error}
                  helperText={error?.message}
                  disabled={isSystemPromptEdited}
                />
              )}
            />
            <ModelNotAvailable
              model={promptGenerationModel}
              closeSheet={closeSheet}
            />
            {!hideGeneratingPrompt && (
              <FormField
                name="generatingPrompt"
                label={
                  l10n.components.systemPromptSection.generatingPrompt.label
                }
                placeholder={
                  l10n.components.systemPromptSection.generatingPrompt
                    .placeholder
                }
                multiline
                required
                disabled={isSystemPromptEdited}
              />
            )}
            <Button
              mode="contained"
              onPress={
                isGenerating ? handleStopGeneration : handleGeneratePrompt
              }
              loading={isGenerating || isLoadingModel}
              disabled={isLoadingModel || isSystemPromptEdited}
              testID="generate-button">
              {isLoadingModel
                ? l10n.components.systemPromptSection.buttons.loadingModel
                : isGenerating
                ? l10n.components.systemPromptSection.buttons.stopGenerating
                : l10n.components.systemPromptSection.buttons.generatePrompt}
            </Button>
          </>
        )}

        <>
          <FormField
            name="systemPrompt"
            label={l10n.components.systemPromptSection.systemPrompt.label}
            sublabel={l10n.components.systemPromptSection.systemPrompt.sublabel}
            placeholder={
              l10n.components.systemPromptSection.systemPrompt.placeholder
            }
            multiline
            required
            disabled={useAIPrompt && isGenerating}
            onSubmitEditing={() => {
              setValue('isSystemPromptChanged', true);
            }}
          />
          {isSystemPromptEdited && (
            <View style={styles.warningContainer}>
              <Text style={[theme.fonts.bodyMedium, styles.warningText]}>
                {l10n.components.systemPromptSection.warnings.promptChanged}
              </Text>
              <Button
                mode="text"
                onPress={handleReset}
                style={styles.resetButton}>
                {l10n.common.reset}
              </Button>
            </View>
          )}
        </>
      </>
    );
  },
);



================================================
FILE: src/components/PalsSheets/types.ts
================================================
import {z} from 'zod';
import {Model} from '../../utils/types';

export enum PalType {
  ROLEPLAY = 'roleplay',
  ASSISTANT = 'assistant',
  VIDEO = 'video',
}

// We'll use this factory function to create schemas with the current localization
export function createSchemaWithL10n(l10n: any) {
  // Base schema with common fields
  const baseFormSchema = {
    name: z.string().min(1, l10n.validation.nameRequired),
    defaultModel: z.any().optional(),
    useAIPrompt: z.boolean(),
    systemPrompt: z.string().min(1, l10n.validation.systemPromptRequired),
    originalSystemPrompt: z.string().optional(),
    isSystemPromptChanged: z.boolean().default(false),
    color: z.tuple([z.string(), z.string()]).optional(),
    promptGenerationModel: z.any().optional(),
    generatingPrompt: z.string().optional(),
  };

  // Assistant-specific schema
  const assistantSchema = z.object({
    ...baseFormSchema,
    palType: z.literal(PalType.ASSISTANT),
  });

  // Roleplay-specific schema
  const roleplaySchema = z.object({
    ...baseFormSchema,
    palType: z.literal(PalType.ROLEPLAY),
    world: z.string().min(1, l10n.validation.worldRequired),
    location: z.string().min(1, l10n.validation.locationRequired),
    aiRole: z.string().min(1, l10n.validation.aiRoleRequired),
    userRole: z.string().min(1, l10n.validation.userRoleRequired),
    situation: z.string().min(1, l10n.validation.situationRequired),
    toneStyle: z.string().min(1, l10n.validation.toneStyleRequired),
  });

  // Video-specific schema
  const videoSchema = z.object({
    ...baseFormSchema,
    palType: z.literal(PalType.VIDEO),
    captureInterval: z.number().min(500).default(1000),
  });

  return {
    assistantSchema,
    roleplaySchema,
    videoSchema,
  };
}

// Default schemas with fallback English messages
export const assistantFormSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  defaultModel: z.any().optional(),
  useAIPrompt: z.boolean(),
  systemPrompt: z.string().min(1, 'System prompt is required'),
  originalSystemPrompt: z.string().optional(),
  isSystemPromptChanged: z.boolean().default(false),
  color: z.tuple([z.string(), z.string()]).optional(),
  promptGenerationModel: z.any().optional(),
  generatingPrompt: z.string().optional(),
  palType: z.literal(PalType.ASSISTANT),
});

export const roleplayFormSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  defaultModel: z.any().optional(),
  useAIPrompt: z.boolean(),
  systemPrompt: z.string().min(1, 'System prompt is required'),
  originalSystemPrompt: z.string().optional(),
  isSystemPromptChanged: z.boolean().default(false),
  color: z.tuple([z.string(), z.string()]).optional(),
  promptGenerationModel: z.any().optional(),
  generatingPrompt: z.string().optional(),
  palType: z.literal(PalType.ROLEPLAY),
  world: z.string().min(1, 'World is required'),
  location: z.string().min(1, 'Location is required'),
  aiRole: z.string().min(1, "AI's role is required"),
  userRole: z.string().min(1, 'User role is required'),
  situation: z.string().min(1, 'Situation is required'),
  toneStyle: z.string().min(1, 'Tone/Style is required'),
});

export const videoPalFormSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  defaultModel: z.any().optional(),
  useAIPrompt: z.boolean(),
  systemPrompt: z.string().min(1, 'System prompt is required'),
  originalSystemPrompt: z.string().optional(),
  isSystemPromptChanged: z.boolean().default(false),
  color: z.tuple([z.string(), z.string()]).optional(),
  promptGenerationModel: z.any().optional(),
  generatingPrompt: z.string().optional(),
  palType: z.literal(PalType.VIDEO),
  captureInterval: z.number().min(500).default(1000),
});

// Base type for common fields
interface BaseFormData {
  id?: string;
  name: string;
  defaultModel?: Model;
  useAIPrompt: boolean;
  systemPrompt: string;
  originalSystemPrompt?: string;
  isSystemPromptChanged: boolean;
  color?: [string, string];
  promptGenerationModel?: Model;
  generatingPrompt?: string;
}

// Assistant-specific type
export interface AssistantFormData extends BaseFormData {
  palType: PalType.ASSISTANT;
}

// Roleplay-specific type
export interface RoleplayFormData extends BaseFormData {
  palType: PalType.ROLEPLAY;
  world: string;
  location: string;
  aiRole: string;
  userRole: string;
  situation: string;
  toneStyle: string;
}

// Video-specific type
export interface VideoPalFormData extends BaseFormData {
  palType: PalType.VIDEO;
  captureInterval: number; // Interval in milliseconds between frame captures
}

// Union type for form data
export type PalFormData =
  | AssistantFormData
  | RoleplayFormData
  | VideoPalFormData;



================================================
FILE: src/components/PalsSheets/utils.ts
================================================
import {RoleplayFormData} from './types';

export function generateRoleplayPrompt(pal: RoleplayFormData): string {
  const {aiRole, world, location, userRole, situation, toneStyle} = pal;

  return `
You are a creative and intelligent AI assistant engaged in an uncensored iterative storytelling experience using a roleplay chat format. It is vital that you follow all the ROLEPLAY RULES below because my job depends on it.

${world ? `**World:** ${world}` : ''}
${location ? `**Location:** ${location}` : ''}
**AI Role:** ${aiRole}
${userRole ? `**User Role:** ${userRole}` : ''}
${situation ? `**Situation:** ${situation}` : ''}
${toneStyle ? `**Tone/Style:** ${toneStyle}` : ''}

**ROLEPLAY RULES:**
- Chat exclusively as ${aiRole}. Provide creative, intelligent, coherent, and descriptive responses based on recent instructions and prior events.
- Avoid overly elaborate introductions; respond as if the scene is already in motion.
- Stay responsive to the user's cues, allowing them to drive the events of the roleplay.
- Keep responses fluid and avoid pre-determining major events before the user prompts them.
- Subtly build intrigue rather than explaining everything outright.
- Use subtle physical cues and occasional internal thoughts (enclosed in asterisks, e.g., *I never expected to see a knight here‚Ä¶*).
- Maintain a crisp and minimalist style, making responses engaging yet succinct.
- Pay careful attention to all past events in the chat to ensure accuracy and coherence to the plot.
`.trim();
}

export const getPromptForModelGeneration = (pal: RoleplayFormData): string => {
  const {world, location, userRole, aiRole, situation, toneStyle} = pal;
  return `
Generate a system prompt for a roleplay scenario using the following structured details:

${world ? `- World: ${world}` : ''}
${location ? `- Location: ${location}` : ''}
${userRole ? `- User‚Äôs Role: ${userRole}` : ''}
${aiRole ? `- AI‚Äôs Role: ${aiRole}` : ''}
${situation ? `- Situation: ${situation}` : ''}
${toneStyle ? `- Tone/Style: ${toneStyle}` : ''}
The system prompt must:
1. Start with "You are ${aiRole}" followed by a description of the AI‚Äôs personality, behavior, and role in the scenario.
2. Describe the user‚Äôs role and mission, including their character and objective.
3. Clearly define the relationship between the user and the AI, explaining how the AI should interact with the user (e.g., as an ally, a rival, or a guide).
4. End with instructions for the AI to stay in character, engage creatively, and enhance the user‚Äôs immersive experience through storytelling, vivid descriptions, and engaging dialogue.

Output the system prompt in JSON format with the key "prompt" containing the full system prompt as a string.
  `.trim();
};



================================================
FILE: src/components/PalsSheets/VideoPalSheet.tsx
================================================
import React, {
  useContext,
  useRef,
  useEffect,
  useCallback,
  useMemo,
} from 'react';
import {View, TextInput as RNTextInput} from 'react-native';

import {observer} from 'mobx-react-lite';
import {Button, Text} from 'react-native-paper';
import {zodResolver} from '@hookform/resolvers/zod';
import Slider from '@react-native-community/slider';
import {useForm, FormProvider, Controller, useWatch} from 'react-hook-form';

import {useTheme} from '../../hooks';

import {createStyles} from './styles';
import {FormField} from './FormField';
import {ColorSection} from './ColorSection';
import {ModelSelector} from './ModelSelector';
import {SectionDivider} from './SectionDivider';
import {ModelNotAvailable} from './ModelNotAvailable';
import {SystemPromptSection} from './SystemPromptSection';
import {createSchemaWithL10n, PalType, type VideoPalFormData} from './types';

import {palStore} from '../../store';
import {modelStore} from '../../store/ModelStore';

import {L10nContext} from '../../utils';

import {Sheet} from '..';

interface VideoPalSheetProps {
  isVisible: boolean;
  onClose: () => void;
  editPal?: VideoPalFormData & {id: string};
}

// Default model for video pals
const DEFAULT_VIDEO_MODEL_ID =
  'ggml-org/SmolVLM-500M-Instruct-GGUF/SmolVLM-500M-Instruct-Q8_0.gguf';

// Initial state for the form
const INITIAL_STATE: Omit<VideoPalFormData, 'palType'> = {
  name: 'Lookie',
  defaultModel: undefined, // Will be set to SmolVLM if available
  useAIPrompt: false,
  systemPrompt:
    'You are Lookie, an AI assistant giving real-time, concise descriptions of a video feed. Use few words. If unsure, say so clearly.',
  originalSystemPrompt: '',
  isSystemPromptChanged: false,
  color: ['#9E204F', '#F6E1EA'],
  captureInterval: 3000, // Default to 3 second
};

export const VideoPalSheet: React.FC<VideoPalSheetProps> = observer(
  ({isVisible, onClose, editPal}) => {
    const theme = useTheme();
    const styles = createStyles(theme);
    const l10n = useContext(L10nContext);

    // Create localized schema using current l10n context
    const schemas = useMemo(() => createSchemaWithL10n(l10n), [l10n]);
    const videoFormSchema = schemas.videoSchema;

    const inputRefs = useRef<{[key: string]: RNTextInput | null}>({});

    const methods = useForm<VideoPalFormData>({
      resolver: zodResolver(videoFormSchema),
      defaultValues: {...INITIAL_STATE, palType: PalType.VIDEO},
    });

    // Watch the defaultModel field to get reactive updates
    const watchedDefaultModel = useWatch({
      control: methods.control,
      name: 'defaultModel',
    });

    const resetForm = useCallback(() => {
      if (editPal) {
        methods.reset(editPal);
      } else {
        // Set default model to SmolVLM regardless of download status
        // This shows users which model they need to download
        const defaultModel = modelStore.models.find(
          model => model.id === DEFAULT_VIDEO_MODEL_ID,
        );
        methods.reset({
          ...INITIAL_STATE,
          palType: PalType.VIDEO,
          defaultModel: defaultModel || undefined,
        });
      }
    }, [editPal, methods]);

    useEffect(() => {
      resetForm();
    }, [resetForm]);

    const handleClose = () => {
      resetForm();
      onClose();
    };

    const validateVideoFields = async () => {
      const formState = methods.getValues();
      if (formState.useAIPrompt) {
        if (!formState.generatingPrompt) {
          methods.setError('generatingPrompt', {
            message:
              l10n.components.assistantPalSheet.validation
                .generatingPromptRequired,
          });
        }
        if (!formState.promptGenerationModel) {
          methods.setError('promptGenerationModel', {
            message:
              l10n.components.assistantPalSheet.validation.promptModelRequired,
          });
        }
        return Boolean(
          formState.generatingPrompt && formState.promptGenerationModel,
        );
      }
      return true;
    };

    const onSubmit = (data: VideoPalFormData) => {
      if (editPal) {
        palStore.updatePal(editPal.id, data);
      } else {
        palStore.addPal(data);
      }
      handleClose();
    };

    return (
      <Sheet
        title={
          editPal
            ? l10n.components.lookiePalSheet.title.edit
            : l10n.components.lookiePalSheet.title.create
        }
        isVisible={isVisible}
        displayFullHeight
        onClose={handleClose}>
        <FormProvider {...methods}>
          <Sheet.ScrollView
            bottomOffset={16}
            contentContainerStyle={styles.scrollviewContainer}>
            <View style={styles.form}>
              <FormField
                ref={ref => (inputRefs.current.name = ref)}
                name="name"
                label={l10n.components.lookiePalSheet.palName}
                placeholder={l10n.components.lookiePalSheet.palNamePlaceholder}
                required
              />

              <SectionDivider
                label={l10n.components.lookiePalSheet.requiredModelsSection}
              />

              <Controller
                name="defaultModel"
                control={methods.control}
                render={({field: {onChange, value}, fieldState: {error}}) => (
                  <ModelSelector
                    value={value}
                    onChange={onChange}
                    label={l10n.components.lookiePalSheet.visionModel}
                    placeholder={
                      l10n.components.lookiePalSheet.visionModelPlaceholder
                    }
                    error={!!error}
                    helperText={error?.message}
                    inputRef={ref => (inputRefs.current.defaultModel = ref)}
                    filter={model => Boolean(model.supportsMultimodal)}
                  />
                )}
              />

              <ModelNotAvailable
                model={editPal?.defaultModel || watchedDefaultModel}
                closeSheet={handleClose}
              />

              <SectionDivider
                label={l10n.components.lookiePalSheet.captureInterval}
              />

              <Controller
                name="captureInterval"
                control={methods.control}
                render={({field: {onChange, value}}) => (
                  <View style={styles.sliderContainer}>
                    <Text style={styles.sliderLabel}>
                      {l10n.components.lookiePalSheet.captureInterval}: {value}{' '}
                      {l10n.video.captureIntervalUnit}
                    </Text>
                    <Slider
                      style={styles.slider}
                      minimumValue={500}
                      maximumValue={5000}
                      step={500}
                      value={value}
                      onValueChange={onChange}
                      minimumTrackTintColor={theme.colors.primary}
                      maximumTrackTintColor={theme.colors.surfaceVariant}
                      thumbTintColor={theme.colors.primary}
                    />
                    <View style={styles.sliderLabels}>
                      <Text style={styles.sliderMinLabel}>500ms</Text>
                      <Text style={styles.sliderMaxLabel}>5000ms</Text>
                    </View>
                  </View>
                )}
              />

              <SystemPromptSection
                validateFields={validateVideoFields}
                closeSheet={handleClose}
              />
              <ColorSection />
            </View>
          </Sheet.ScrollView>

          <Sheet.Actions>
            <View style={styles.actions}>
              <Button
                style={styles.actionBtn}
                mode="text"
                onPress={handleClose}>
                {l10n.common.cancel}
              </Button>
              <Button
                style={styles.actionBtn}
                mode="contained"
                onPress={methods.handleSubmit(onSubmit)}>
                {editPal
                  ? l10n.common.save
                  : l10n.components.lookiePalSheet.create}
              </Button>
            </View>
          </Sheet.Actions>
        </FormProvider>
      </Sheet>
    );
  },
);



================================================
FILE: src/components/PalsSheets/__tests__/AssistantPalSheet.test.tsx
================================================
import React, {act} from 'react';
import {render, fireEvent, waitFor} from '../../../../jest/test-utils';
import {AssistantPalSheet} from '../AssistantPalSheet';
import {palStore} from '../../../store';
import {PalType} from '../types';
import {mockBasicModel} from '../../../../jest/fixtures/models';

jest.mock('../../Sheet', () => {
  const {View, Button} = require('react-native');
  const MockSheet = ({children, isVisible, onClose, title}) => {
    if (!isVisible) {
      return null;
    }
    return (
      <View testID="sheet">
        <View testID="sheet-title">{title}</View>
        <Button title="Close" onPress={onClose} testID="sheet-close-button" />
        {children}
      </View>
    );
  };
  MockSheet.ScrollView = ({children}) => (
    <View testID="sheet-scroll-view">{children}</View>
  );
  MockSheet.Actions = ({children}) => (
    <View testID="sheet-actions">{children}</View>
  );
  return {Sheet: MockSheet};
});

describe('AssistantPalSheet', () => {
  const mockOnClose = jest.fn();
  const defaultProps = {
    isVisible: true,
    onClose: mockOnClose,
  };

  beforeEach(() => {
    jest.clearAllMocks();
    palStore.pals = [];
  });

  it('renders correctly when visible', () => {
    const {getByTestId, queryByText} = render(
      <AssistantPalSheet {...defaultProps} isVisible={true} />,
      {withNavigation: true},
    );
    expect(getByTestId('sheet')).toBeTruthy();
    expect(getByTestId('sheet-title')).toBeTruthy();
    expect(queryByText('Create')).toBeTruthy(); // Should show create button in create mode
  });

  it('does not render when not visible', () => {
    const {queryByTestId} = render(
      <AssistantPalSheet {...defaultProps} isVisible={false} />,
    );

    expect(queryByTestId('sheet')).toBeNull();
  });

  it('shows edit title and save button in edit mode', () => {
    const editPal = {
      id: 'test-id',
      name: 'Test Assistant',
      palType: PalType.ASSISTANT as const, // use the enum value
      defaultModel: mockBasicModel,
      systemPrompt: 'Test system prompt',
      useAIPrompt: false,
      isSystemPromptChanged: false,
      color: ['#123456', '#123456'] as [string, string],
    };

    const {getByTestId, queryByText} = render(
      <AssistantPalSheet {...defaultProps} editPal={editPal} />,
      {withNavigation: true},
    );

    expect(getByTestId('sheet')).toBeTruthy();
    expect(queryByText('Save')).toBeTruthy(); // Should show save in edit mode
  });

  it('closes sheet when cancel button is pressed', () => {
    const {getByText} = render(<AssistantPalSheet {...defaultProps} />, {
      withNavigation: true,
    });

    fireEvent.press(getByText('Cancel'));
    expect(mockOnClose).toHaveBeenCalled();
  });

  it('adds a new pal when form is submitted in create mode', async () => {
    const {getByText, getByTestId} = render(
      <AssistantPalSheet {...defaultProps} />,
      {withNavigation: true},
    );

    // Fill in required fields
    const nameInput = getByTestId('form-field-name');
    fireEvent.changeText(nameInput, 'New Assistant');

    const systemPromptInput = getByTestId('form-field-systemPrompt');
    fireEvent.changeText(systemPromptInput, 'You are a helpful assistant.');

    // Submit the form
    await act(async () => {
      fireEvent.press(getByText('Create'));
    });

    await waitFor(
      () => {
        // Check if a pal was added
        expect(palStore.getPals().length).toBeGreaterThan(0);
      },
      {timeout: 5000},
    );
  });

  it('updates an existing pal when form is submitted in edit mode', async () => {
    const editPal = {
      id: 'test-id',
      name: 'Test Assistant',
      palType: PalType.ASSISTANT as const,
      defaultModel: mockBasicModel,
      systemPrompt: 'Test system prompt',
      useAIPrompt: false,
      isSystemPromptChanged: false,
      color: ['#123456', '#123456'] as [string, string],
    };
    palStore.pals = [editPal];

    const {getByText, getByTestId, debug} = render(
      <AssistantPalSheet {...defaultProps} editPal={editPal} />,
      {withNavigation: true},
    );

    // Update a field
    const nameInput = getByTestId('form-field-name');
    fireEvent.changeText(nameInput, 'Updated Assistant');

    const systemPromptInput = getByTestId('form-field-systemPrompt');
    fireEvent.changeText(systemPromptInput, 'You are a helpful assistant.');
    debug();
    // Submit the form
    await act(async () => {
      fireEvent.press(getByText('Save'));
    });

    await waitFor(() => {
      // Check if a pal was added
      expect(palStore.getPals().length).toBeGreaterThan(0);
    });

    await waitFor(() => {
      expect(mockOnClose).toHaveBeenCalled();
    });

    const updatedPal = palStore.getPals().find(pal => pal.id === editPal.id);
    expect(updatedPal?.name).toBe('Updated Assistant');
    expect(updatedPal?.systemPrompt).toBe('You are a helpful assistant.');
  });
});



================================================
FILE: src/components/PalsSheets/__tests__/FormField.test.tsx
================================================
import React from 'react';
import type {TextInput as RNTextInput} from 'react-native';
import {fireEvent} from '@testing-library/react-native';
import {FormProvider, useForm} from 'react-hook-form';

import {render} from '../../../../jest/test-utils';
import {FormField} from '../FormField';
import type {AssistantFormData} from '../types';

const TestWrapper = ({
  children,
  defaultValues = {},
}: {
  children: React.ReactNode;
  defaultValues?: Partial<AssistantFormData>;
}) => {
  const methods = useForm<AssistantFormData>({
    defaultValues: {
      name: '',
      systemPrompt: '',
      useAIPrompt: false,
      isSystemPromptChanged: false,
      ...defaultValues,
    },
  });
  return <FormProvider {...methods}>{children}</FormProvider>;
};

describe('FormField', () => {
  it('renders with required props', () => {
    const {getByText, getByPlaceholderText} = render(
      <TestWrapper>
        <FormField name="name" label="Name" placeholder="Enter name" />
      </TestWrapper>,
    );

    expect(getByText('Name')).toBeDefined();
    expect(getByPlaceholderText('Enter name')).toBeDefined();
  });

  it('shows required asterisk when required prop is true', () => {
    const {getByText} = render(
      <TestWrapper>
        <FormField name="name" label="Name" required />
      </TestWrapper>,
    );

    expect(getByText('Name*')).toBeDefined();
  });

  it('shows sublabel when provided', () => {
    const {getByText} = render(
      <TestWrapper>
        <FormField
          name="name"
          label="Name"
          sublabel="This is a helpful description"
        />
      </TestWrapper>,
    );

    expect(getByText('This is a helpful description')).toBeDefined();
  });

  it('updates form value on text change', () => {
    const {getByPlaceholderText} = render(
      <TestWrapper>
        <FormField name="name" label="Name" placeholder="Enter name" />
      </TestWrapper>,
    );

    const input = getByPlaceholderText('Enter name');
    fireEvent.changeText(input, 'Test Name');

    expect(input.props.value).toBe('Test Name');
  });

  it('shows error message when form has errors', () => {
    const TestComponent = () => {
      const methods = useForm<AssistantFormData>({
        defaultValues: {
          name: '',
          systemPrompt: '',
          useAIPrompt: false,
          isSystemPromptChanged: false,
        },
      });

      React.useEffect(() => {
        methods.setError('name', {
          type: 'manual',
          message: 'Name is required',
        });
      }, [methods]);

      return (
        <FormProvider {...methods}>
          <FormField name="name" label="Name" />
        </FormProvider>
      );
    };

    const {getByText} = render(<TestComponent />);
    expect(getByText('Name is required')).toBeDefined();
  });

  it('renders multiline input when multiline prop is true', () => {
    const {getByPlaceholderText} = render(
      <TestWrapper>
        <FormField
          name="systemPrompt"
          label="System Prompt"
          placeholder="Enter prompt"
          multiline
        />
      </TestWrapper>,
    );

    const input = getByPlaceholderText('Enter prompt');
    expect(input.props.multiline).toBe(true);
    expect(input.props.numberOfLines).toBe(5);
  });

  it('calls onSubmitEditing when not multiline', () => {
    const onSubmitEditing = jest.fn();
    const {getByPlaceholderText} = render(
      <TestWrapper>
        <FormField
          name="name"
          label="Name"
          placeholder="Enter name"
          onSubmitEditing={onSubmitEditing}
        />
      </TestWrapper>,
    );

    const input = getByPlaceholderText('Enter name');
    fireEvent(input, 'onSubmitEditing');
    expect(onSubmitEditing).toHaveBeenCalled();
  });

  it('does not pass onSubmitEditing when multiline', () => {
    const onSubmitEditing = jest.fn();
    const {getByPlaceholderText} = render(
      <TestWrapper>
        <FormField
          name="systemPrompt"
          label="System Prompt"
          placeholder="Enter prompt"
          multiline
          onSubmitEditing={onSubmitEditing}
        />
      </TestWrapper>,
    );

    const input = getByPlaceholderText('Enter prompt');
    expect(input.props.onSubmitEditing).toBeUndefined();
  });

  it('disables input when disabled prop is true', () => {
    const {getByPlaceholderText} = render(
      <TestWrapper>
        <FormField name="name" label="Name" placeholder="Enter name" disabled />
      </TestWrapper>,
    );

    const input = getByPlaceholderText('Enter name');
    expect(input.props.editable).toBe(false);
  });

  it('handles empty or undefined values', () => {
    const {getByPlaceholderText} = render(
      <TestWrapper defaultValues={{name: undefined}}>
        <FormField name="name" label="Name" placeholder="Enter name" />
      </TestWrapper>,
    );

    const input = getByPlaceholderText('Enter name');
    expect(input.props.value).toBe('');
  });

  it('forwards ref to TextInput', () => {
    const ref = React.createRef<RNTextInput>();
    render(
      <TestWrapper>
        <FormField
          ref={ref}
          name="name"
          label="Name"
          placeholder="Enter name"
        />
      </TestWrapper>,
    );

    expect(ref.current).toBeTruthy();
  });
});



================================================
FILE: src/components/PalsSheets/__tests__/ModelNotAvailable.test.tsx
================================================
import React from 'react';
import {render, fireEvent} from '../../../../jest/test-utils';
import {ModelNotAvailable} from '../ModelNotAvailable';
import {
  modelsList,
  hfModel1,
  basicModel,
  downloadingModel,
} from '../../../../jest/fixtures/models';
import {modelStore} from '../../../store';

describe('ModelNotAvailable', () => {
  const mockCloseSheet = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
    modelStore.models = modelsList;
  });

  it('should show message when no models are downloaded', () => {
    modelStore.models = [];
    const {getByText} = render(
      <ModelNotAvailable model={undefined} closeSheet={mockCloseSheet} />,
      {withNavigation: true},
    );

    expect(
      getByText(
        'You do not have any models downloaded yet. Please download a model first.',
      ),
    ).toBeTruthy();
    expect(getByText('Download a model')).toBeTruthy();
  });

  it('should show download button when specific model is not downloaded', () => {
    const {getByText} = render(
      <ModelNotAvailable model={basicModel} closeSheet={mockCloseSheet} />,
      {withNavigation: true},
    );

    expect(
      getByText(
        'Default model is not downloaded yet. Please download it first.',
      ),
    ).toBeTruthy();
    expect(getByText('Download')).toBeTruthy();
  });

  it('should show progress bar when model is being downloaded', () => {
    const {getByTestId, getByText} = render(
      <ModelNotAvailable
        model={downloadingModel}
        closeSheet={mockCloseSheet}
      />,
      {withNavigation: true},
    );

    expect(getByTestId('download-progress-bar')).toBeTruthy();
    expect(getByText('Cancel download')).toBeTruthy();
  });

  it('should call cancelDownload when cancel button is pressed', () => {
    const {getByText} = render(
      <ModelNotAvailable
        model={downloadingModel}
        closeSheet={mockCloseSheet}
      />,
      {withNavigation: true},
    );

    fireEvent.press(getByText('Cancel download'));
    expect(modelStore.cancelDownload).toHaveBeenCalledWith(downloadingModel.id);
  });

  it('should call checkSpaceAndDownload when download button is pressed', () => {
    const {getByText} = render(
      <ModelNotAvailable model={basicModel} closeSheet={mockCloseSheet} />,
      {withNavigation: true},
    );

    fireEvent.press(getByText('Download'));
    expect(modelStore.checkSpaceAndDownload).toHaveBeenCalledWith(
      basicModel.id,
    );
  });

  it('should handle HF model download when model has hfModel property', () => {
    const {getByText} = render(
      <ModelNotAvailable model={hfModel1} closeSheet={mockCloseSheet} />,
      {withNavigation: true},
    );

    fireEvent.press(getByText('Download'));
    expect(modelStore.downloadHFModel).toHaveBeenCalledWith(
      hfModel1.hfModel,
      hfModel1.hfModelFile,
      {enableVision: true},
    );
  });
});



================================================
FILE: src/components/PalsSheets/__tests__/ModelSelector.test.tsx
================================================
import React from 'react';
import {render} from '../../../../jest/test-utils';
import {ModelSelector} from '../ModelSelector';
import {modelsList} from '../../../../jest/fixtures/models';

// Mock the modelStore
jest.mock('../../../store', () => ({
  modelStore: {
    availableModels: [
      {id: 'model1', name: 'Model 1'},
      {id: 'model2', name: 'Model 2'},
      {id: 'model3', name: 'Model 3'},
    ],
  },
}));

// Mock the Menu component
jest.mock('../../../components/Menu', () => {
  const {View} = require('react-native');
  return {
    Menu: ({visible, anchor, children}: any) => (
      <>
        {anchor}
        {visible && <View testID="menu-content">{children}</View>}
      </>
    ),
    'Menu.Item': ({label, onPress}: any) => (
      <View testID="menu-item" onPress={onPress}>
        {label}
      </View>
    ),
  };
});

describe('ModelSelector', () => {
  const defaultProps = {
    label: 'Select Model',
    onChange: jest.fn(),
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders with required props', () => {
    const {getByText, getByPlaceholderText} = render(
      <ModelSelector {...defaultProps} />,
    );

    expect(getByText('Select Model')).toBeDefined();
    expect(getByPlaceholderText('Select model')).toBeDefined();
  });

  it('shows required asterisk when required prop is true', () => {
    const {getByText} = render(<ModelSelector {...defaultProps} required />);

    expect(getByText('Select Model*')).toBeDefined();
  });

  it('displays selected model name when value is provided', () => {
    const {getByTestId} = render(
      <ModelSelector {...defaultProps} value={modelsList[0]} />,
    );

    const input = getByTestId('text-input-flat');
    expect(input.props.value).toBe(modelsList[0].name);
  });

  it('displays helper text when provided', () => {
    const {getByText} = render(
      <ModelSelector {...defaultProps} helperText="Helper message" />,
    );

    expect(getByText('Helper message')).toBeDefined();
  });

  it('uses custom placeholder when provided', () => {
    const {getByPlaceholderText} = render(
      <ModelSelector {...defaultProps} placeholder="Custom placeholder" />,
    );

    expect(getByPlaceholderText('Custom placeholder')).toBeDefined();
  });
});



================================================
FILE: src/components/PalsSheets/__tests__/RoleplayPalSheet.test.tsx
================================================
import React from 'react';
import {render, fireEvent, waitFor, act} from '../../../../jest/test-utils';
import {RoleplayPalSheet} from '../RoleplayPalSheet';
import {palStore} from '../../../store';
import {generateRoleplayPrompt} from '../utils';
import {PalType} from '../types';
import {mockBasicModel} from '../../../../jest/fixtures/models';

jest.mock('../utils', () => ({
  generateRoleplayPrompt: jest.fn().mockReturnValue('Generated prompt'),
}));

jest.mock('../../Sheet', () => {
  const {View, Button} = require('react-native');
  const MockSheet = ({children, isVisible, onClose, title}) => {
    if (!isVisible) {
      return null;
    }
    return (
      <View testID="sheet">
        <View testID="sheet-title">{title}</View>
        <Button title="Close" onPress={onClose} testID="sheet-close-button" />
        {children}
      </View>
    );
  };
  MockSheet.ScrollView = ({children}) => (
    <View testID="sheet-scroll-view">{children}</View>
  );
  MockSheet.Actions = ({children}) => (
    <View testID="sheet-actions">{children}</View>
  );
  return {Sheet: MockSheet};
});

describe('RoleplayPalSheet', () => {
  const mockOnClose = jest.fn();
  const defaultProps = {
    isVisible: true,
    onClose: mockOnClose,
  };

  beforeEach(() => {
    jest.clearAllMocks();
    palStore.pals = [];
  });

  it('renders correctly when visible', () => {
    const {getByTestId, queryByText} = render(
      <RoleplayPalSheet {...defaultProps} />,
      {withNavigation: true},
    );

    expect(getByTestId('sheet')).toBeTruthy();
    expect(getByTestId('sheet-title')).toBeTruthy();
    expect(queryByText('Create')).toBeTruthy(); // Should show create button in create mode
  });

  it('does not render when not visible', () => {
    const {queryByTestId} = render(
      <RoleplayPalSheet {...defaultProps} isVisible={false} />,
    );

    expect(queryByTestId('sheet')).toBeNull();
  });

  it('shows edit title and save button in edit mode', () => {
    const editPal = {
      id: 'test-id',
      name: 'Test Roleplay',
      palType: PalType.ROLEPLAY as const,
      defaultModel: mockBasicModel,
      world: 'Fantasy world',
      location: 'Castle',
      aiRole: 'Knight',
      userRole: 'Squire',
      situation: 'Preparing for battle',
      toneStyle: 'Medieval formal',
      systemPrompt: 'Test system prompt',
      useAIPrompt: false,
      isSystemPromptChanged: false,
      color: ['#123456', '#123456'] as [string, string],
    };

    const {getByTestId, queryByText} = render(
      <RoleplayPalSheet {...defaultProps} editPal={editPal} />,
    );

    expect(getByTestId('sheet')).toBeTruthy();
    expect(queryByText('Save')).toBeTruthy(); // Should show save in edit mode
  });

  it('closes sheet when cancel button is pressed', () => {
    const {getByText} = render(<RoleplayPalSheet {...defaultProps} />);

    fireEvent.press(getByText('Cancel'));
    expect(mockOnClose).toHaveBeenCalled();
  });

  it('adds a new pal when form is submitted in create mode', async () => {
    const {getByText, getByTestId} = render(
      <RoleplayPalSheet {...defaultProps} />,
    );

    // Check that the palStore is empty
    expect(palStore.getPals().length).toBe(0);

    const nameInput = getByTestId('form-field-name');
    fireEvent.changeText(nameInput, 'New Roleplay');

    const worldInput = getByTestId('form-field-world');
    fireEvent.changeText(worldInput, 'Fantasy world');

    const locationInput = getByTestId('form-field-location');
    fireEvent.changeText(locationInput, 'Castle');

    const aiRoleInput = getByTestId('form-field-aiRole');
    fireEvent.changeText(aiRoleInput, 'Knight');

    const userRoleInput = getByTestId('form-field-userRole');
    fireEvent.changeText(userRoleInput, 'Squire');

    const situationInput = getByTestId('form-field-situation');
    fireEvent.changeText(situationInput, 'Preparing for battle');

    const toneStyleInput = getByTestId('form-field-toneStyle');
    fireEvent.changeText(toneStyleInput, 'Medieval formal');

    const systemPromptInput = getByTestId('form-field-systemPrompt');
    fireEvent.changeText(systemPromptInput, 'Test system prompt');

    // Submit the form
    await act(async () => {
      fireEvent.press(getByText('Create'));
    });

    await waitFor(
      () => {
        // Check if a pal was added
        expect(palStore.getPals().length).toBe(1);
      },
      {timeout: 5000},
    );
  });

  it('updates an existing pal when form is submitted in edit mode', async () => {
    const editPal = {
      id: 'test-id',
      name: 'Test Roleplay',
      palType: PalType.ROLEPLAY as const,
      defaultModel: mockBasicModel,
      world: 'Fantasy world',
      location: 'Castle',
      aiRole: 'Knight',
      userRole: 'Squire',
      situation: 'Preparing for battle',
      toneStyle: 'Medieval formal',
      systemPrompt: 'Test system prompt',
      useAIPrompt: false,
      isSystemPromptChanged: false,
      color: ['#123456', '#123456'] as [string, string],
    };
    palStore.pals = [editPal];

    const {getByText, getByTestId} = render(
      <RoleplayPalSheet {...defaultProps} editPal={editPal} />,
      {withNavigation: true},
    );

    // Update a field
    const nameInput = getByTestId('form-field-name');
    fireEvent.changeText(nameInput, 'Updated Roleplay');

    // Submit the form
    await act(async () => {
      fireEvent.press(getByText('Save'));
    });

    await waitFor(() => {
      expect(mockOnClose).toHaveBeenCalled();
    });

    const updatedPal = palStore.getPals().find(pal => pal.id === editPal.id);
    expect(updatedPal?.name).toBe('Updated Roleplay');
  });

  it('generates a system prompt based on form fields', async () => {
    const {getByTestId, getAllByTestId} = render(
      <RoleplayPalSheet {...defaultProps} />,
    );

    // Fill in the roleplay form fields
    const formInputName = getByTestId('form-field-name');
    fireEvent.changeText(formInputName, 'Test Roleplay'); // name

    const worldInput = getByTestId('form-field-world');
    fireEvent.changeText(worldInput, 'Fantasy world');

    const locationInput = getByTestId('form-field-location');
    fireEvent.changeText(locationInput, 'Castle');

    const aiRoleInput = getByTestId('form-field-aiRole');
    fireEvent.changeText(aiRoleInput, 'Knight');

    const userRoleInput = getByTestId('form-field-userRole');
    fireEvent.changeText(userRoleInput, 'Squire');

    const situationInput = getByTestId('form-field-situation');
    fireEvent.changeText(situationInput, 'Preparing for battle');

    const toneStyleInput = getByTestId('form-field-toneStyle');
    fireEvent.changeText(toneStyleInput, 'Medieval formal');

    const colorInputs = getAllByTestId('color-button');
    fireEvent.press(colorInputs[0]);

    const formContainer = getByTestId('inner-form');
    await act(async () => {
      fireEvent(formContainer, 'blur');
    });

    const systemPromptInput = getByTestId('form-field-systemPrompt');
    await waitFor(() => {
      expect(systemPromptInput.props.value).toBe('Generated prompt');
    });
    expect(generateRoleplayPrompt).toHaveBeenCalledWith(
      expect.objectContaining({
        name: 'Test Roleplay',
        world: 'Fantasy world',
        location: 'Castle',
        aiRole: 'Knight',
        userRole: 'Squire',
        situation: 'Preparing for battle',
        toneStyle: 'Medieval formal',
        useAIPrompt: false,
        isSystemPromptChanged: false,
        color: ['#858585', '#333333'] as [string, string],
      }),
    );
  });

  it('handles form field focus navigation', () => {
    const {getByTestId} = render(<RoleplayPalSheet {...defaultProps} />);

    const nameInput = getByTestId('form-field-name');
    fireEvent(nameInput, 'submitEditing');

    // Should focus next field (defaultModel)
    expect(nameInput).toBeTruthy();
  });

  it('validates required fields', async () => {
    const {getByText} = render(<RoleplayPalSheet {...defaultProps} />);

    // Try to submit without filling required fields
    await act(async () => {
      fireEvent.press(getByText('Create'));
    });

    // Should not close the sheet due to validation errors
    expect(mockOnClose).not.toHaveBeenCalled();
  });

  it('handles model selection', () => {
    const {getByTestId} = render(<RoleplayPalSheet {...defaultProps} />);

    // Model selector should be present
    expect(getByTestId('sheet')).toBeTruthy();
  });

  it('handles color selection', () => {
    const {getAllByTestId} = render(<RoleplayPalSheet {...defaultProps} />);

    const colorButtons = getAllByTestId('color-button');
    expect(colorButtons.length).toBeGreaterThan(0);

    fireEvent.press(colorButtons[0]);
    // Color should be selected
  });

  it('handles system prompt manual editing', () => {
    const {getByTestId} = render(<RoleplayPalSheet {...defaultProps} />);

    const systemPromptInput = getByTestId('form-field-systemPrompt');
    fireEvent.changeText(systemPromptInput, 'Manual system prompt');

    expect(systemPromptInput.props.value).toBe('Manual system prompt');
  });

  it('resets form when switching between create and edit modes', () => {
    const editPal = {
      id: 'test-id',
      name: 'Test Roleplay',
      palType: PalType.ROLEPLAY as const,
      defaultModel: mockBasicModel,
      world: 'Fantasy world',
      location: 'Castle',
      aiRole: 'Knight',
      userRole: 'Squire',
      situation: 'Preparing for battle',
      toneStyle: 'Medieval formal',
      systemPrompt: 'Test system prompt',
      useAIPrompt: false,
      isSystemPromptChanged: false,
      color: ['#123456', '#123456'] as [string, string],
    };

    const {rerender, getByTestId} = render(
      <RoleplayPalSheet {...defaultProps} />,
    );

    // Switch to edit mode
    rerender(<RoleplayPalSheet {...defaultProps} editPal={editPal} />);

    const nameInput = getByTestId('form-field-name');
    expect(nameInput.props.value).toBe('Test Roleplay');

    // Switch back to create mode
    rerender(<RoleplayPalSheet {...defaultProps} />);

    // Form should be reset
    expect(nameInput.props.value).toBe('');
  });

  it('displays section dividers correctly', () => {
    const {getByTestId} = render(<RoleplayPalSheet {...defaultProps} />);

    // Should have section dividers for different form sections
    expect(getByTestId('sheet')).toBeTruthy();
  });

  it('handles AI prompt toggle', () => {
    const {getByTestId} = render(<RoleplayPalSheet {...defaultProps} />);

    // Should have system prompt section with AI toggle
    expect(getByTestId('sheet')).toBeTruthy();
  });
});



================================================
FILE: src/components/PalsSheets/__tests__/SectionDivider.test.tsx
================================================
import React from 'react';
import {render} from '../../../../jest/test-utils';
import {SectionDivider} from '../SectionDivider';

describe('SectionDivider', () => {
  it('renders with label', () => {
    const {getByText} = render(<SectionDivider label="Test Section" />);
    expect(getByText('Test Section')).toBeDefined();
  });

  it('renders divider line', () => {
    const {getByTestId} = render(<SectionDivider label="Test Section" />);
    expect(getByTestId('section-divider-line')).toBeDefined();
  });

  it('applies correct styles', () => {
    const {getByTestId} = render(<SectionDivider label="Test Section" />);
    const container = getByTestId('section-divider-container');
    const content = getByTestId('section-divider-content');

    expect(container.props.style).toMatchObject({
      marginVertical: expect.any(Number),
    });

    expect(content.props.style).toMatchObject({
      flexDirection: 'row',
      alignItems: 'center',
      gap: expect.any(Number),
    });
  });
});



================================================
FILE: src/components/PalsSheets/__tests__/SystemPromptSection.test.tsx
================================================
import React from 'react';
import {fireEvent, render, waitFor} from '../../../../jest/test-utils';
import {FormProvider, useForm} from 'react-hook-form';
import {SystemPromptSection} from '../SystemPromptSection';
import {modelStore} from '../../../store';
import {useStructuredOutput} from '../../../hooks/useStructuredOutput';
import {PalType} from '../types';
import {modelsList} from '../../../../jest/fixtures/models';

// Mock the modelStore
jest.mock('../../../store', () => {
  const {
    modelsList: mockedModelsList,
  } = require('../../../../jest/fixtures/models');
  return {
    modelStore: {
      availableModels: [mockedModelsList[0], mockedModelsList[1]],
      isContextLoading: false,
      activeModelId: mockedModelsList[0].id,
      isDownloading: () => false,
      initContext: jest.fn(),
      models: mockedModelsList,
      isModelAvailable: (modelId?: string) => {
        if (!modelId) {
          return false;
        }
        return [mockedModelsList[0].id, mockedModelsList[1].id].includes(
          modelId,
        );
      },
    },
  };
});

// Mock useStructuredOutput hook
jest.mock('../../../hooks/useStructuredOutput', () => ({
  useStructuredOutput: jest.fn(),
}));

const TestWrapper = ({
  children,
  defaultValues = {},
}: {
  children: React.ReactNode;
  defaultValues?: any;
}) => {
  const methods = useForm({
    defaultValues: {
      name: '',
      systemPrompt: '',
      useAIPrompt: false,
      isSystemPromptChanged: false,
      palType: PalType.ASSISTANT,
      ...defaultValues,
    },
  });
  return <FormProvider {...methods}>{children}</FormProvider>;
};

describe('SystemPromptSection', () => {
  const mockGenerate = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
    (useStructuredOutput as jest.Mock).mockReturnValue({
      generate: mockGenerate,
      isGenerating: false,
    });
  });

  it('renders basic fields correctly', () => {
    const {getByText, getByPlaceholderText} = render(
      <TestWrapper>
        <SystemPromptSection closeSheet={() => {}} />
      </TestWrapper>,
      {
        withNavigation: true,
      },
    );

    expect(getByText('System Prompt')).toBeDefined();
    expect(getByText('Use AI to generate system prompt')).toBeDefined();
    expect(getByPlaceholderText('You are a helpful assistant')).toBeDefined();
  });

  it('toggles AI prompt generation fields visibility', () => {
    const {getByText, queryByText} = render(
      <TestWrapper defaultValues={{useAIPrompt: false}}>
        <SystemPromptSection closeSheet={() => {}} />
      </TestWrapper>,
      {
        withNavigation: true,
      },
    );

    // Initially, generation fields should be hidden
    expect(queryByText('Select Model for Generation*')).toBeNull();

    // Toggle AI prompt generation
    fireEvent.press(getByText('Use AI to generate system prompt'));

    // Generation fields should be visible
    expect(getByText('Select Model for Generation*')).toBeDefined();
  });

  it('handles system prompt generation for assistant type', async () => {
    mockGenerate.mockResolvedValueOnce({prompt: 'Generated assistant prompt'});

    const {getByText, getByPlaceholderText} = render(
      <TestWrapper
        defaultValues={{
          useAIPrompt: true,
          promptGenerationModel: modelsList[0],
          palType: PalType.ASSISTANT,
          generatingPrompt: 'Test generating prompt',
        }}>
        <SystemPromptSection closeSheet={() => {}} />
      </TestWrapper>,
      {
        withNavigation: true,
      },
    );

    // Click generate button
    fireEvent.press(getByText('Generate System Prompt'));

    await waitFor(() => {
      expect(mockGenerate).toHaveBeenCalled();
      expect(
        getByPlaceholderText('You are a helpful assistant').props.value,
      ).toBe('Generated assistant prompt');
    });
  });

  it('handles system prompt generation for roleplay type', async () => {
    mockGenerate.mockResolvedValueOnce({prompt: 'Generated roleplay prompt'});

    const {getByText, getByPlaceholderText} = render(
      <TestWrapper
        defaultValues={{
          useAIPrompt: true,
          promptGenerationModel: modelsList[0],
          palType: PalType.ROLEPLAY,
          world: 'Fantasy',
          location: 'Castle',
          aiRole: 'Wizard',
          userRole: 'Knight',
          situation: 'Quest',
          toneStyle: 'Medieval',
        }}>
        <SystemPromptSection closeSheet={() => {}} />
      </TestWrapper>,
      {
        withNavigation: true,
      },
    );

    // Click generate button
    fireEvent.press(getByText('Generate System Prompt'));

    await waitFor(() => {
      expect(mockGenerate).toHaveBeenCalled();
      expect(
        getByPlaceholderText('You are a helpful assistant').props.value,
      ).toBe('Generated roleplay prompt');
    });
  });

  it('handles validation before generation', async () => {
    const validateFields = jest.fn().mockResolvedValue(false);

    const {getByText} = render(
      <TestWrapper
        defaultValues={{
          useAIPrompt: true,
          promptGenerationModel: 'model1',
        }}>
        <SystemPromptSection
          validateFields={validateFields}
          closeSheet={() => {}}
        />
      </TestWrapper>,
      {
        withNavigation: true,
      },
    );

    // Click generate button
    fireEvent.press(getByText('Generate System Prompt'));

    await waitFor(() => {
      expect(validateFields).toHaveBeenCalled();
      expect(mockGenerate).not.toHaveBeenCalled();
    });
  });

  it('handles model initialization for generation', async () => {
    mockGenerate.mockResolvedValueOnce({prompt: 'Generated prompt'});

    const {getByText} = render(
      <TestWrapper
        defaultValues={{
          useAIPrompt: true,
          promptGenerationModel: modelsList[1], // Different from activeModelId
          palType: PalType.ASSISTANT,
          generatingPrompt: 'Test prompt',
        }}>
        <SystemPromptSection closeSheet={() => {}} />
      </TestWrapper>,
      {
        withNavigation: true,
      },
    );

    // Click generate button
    fireEvent.press(getByText('Generate System Prompt'));

    await waitFor(() => {
      expect(modelStore.initContext).toHaveBeenCalledWith(modelsList[1]);
    });
  });

  it('shows system prompt changed warning and handles reset', () => {
    const {getByText, getByPlaceholderText} = render(
      <TestWrapper
        defaultValues={{
          systemPrompt: 'Changed prompt',
          originalSystemPrompt: 'Original prompt',
          isSystemPromptChanged: true,
        }}>
        <SystemPromptSection closeSheet={() => {}} />
      </TestWrapper>,
      {
        withNavigation: true,
      },
    );

    // Check if warning is shown
    expect(getByText('System prompt has been manually changed')).toBeDefined();

    // Click reset button
    fireEvent.press(getByText('Reset'));

    // Check if prompt is reset
    expect(
      getByPlaceholderText('You are a helpful assistant').props.value,
    ).toBe('Original prompt');
  });

  it('disables generation when system prompt is manually changed', () => {
    const {getByTestId} = render(
      <TestWrapper
        defaultValues={{
          useAIPrompt: true,
          isSystemPromptChanged: true,
          promptGenerationModel: modelsList[0],
        }}>
        <SystemPromptSection closeSheet={() => {}} />
      </TestWrapper>,
      {
        withNavigation: true,
      },
    );

    const generateButton = getByTestId('generate-button');
    expect(generateButton.props.accessibilityState.disabled).toBe(true);
  });
});



================================================
FILE: src/components/PalsSheets/__tests__/utils.test.ts
================================================
import {generateRoleplayPrompt} from '../utils';
import {PalType, RoleplayFormData} from '../types';

describe('PalsSheets utils', () => {
  const basePal: RoleplayFormData = {
    name: 'Test Roleplay',
    palType: PalType.ROLEPLAY,
    world: 'Fantasy World',
    location: 'Ancient Castle',
    aiRole: 'Wise Wizard',
    userRole: 'Brave Knight',
    situation: 'A dark curse has fallen upon the kingdom',
    toneStyle: 'Mysterious and dramatic',
    systemPrompt: '',
    defaultModel: undefined,
    useAIPrompt: false,
    isSystemPromptChanged: false,
    promptGenerationModel: undefined,
    generatingPrompt: '',
    color: undefined,
  };

  describe('generateRoleplayPrompt', () => {
    it('should generate prompt with all fields', () => {
      const prompt = generateRoleplayPrompt(basePal);

      expect(prompt).toContain('**World:** Fantasy World');
      expect(prompt).toContain('**Location:** Ancient Castle');
      expect(prompt).toContain('**AI Role:** Wise Wizard');
      expect(prompt).toContain('**User Role:** Brave Knight');
      expect(prompt).toContain(
        '**Situation:** A dark curse has fallen upon the kingdom',
      );
      expect(prompt).toContain('**Tone/Style:** Mysterious and dramatic');
      expect(prompt).toContain('Chat exclusively as Wise Wizard');
    });

    it('should handle missing optional fields', () => {
      const minimalPal: RoleplayFormData = {
        ...basePal,
        world: '',
        location: '',
        userRole: '',
        situation: '',
        toneStyle: '',
      };

      const prompt = generateRoleplayPrompt(minimalPal);

      expect(prompt).not.toContain('**World:**');
      expect(prompt).not.toContain('**Location:**');
      expect(prompt).not.toContain('**User Role:**');
      expect(prompt).not.toContain('**Situation:**');
      expect(prompt).not.toContain('**Tone/Style:**');
      expect(prompt).toContain('**AI Role:** Wise Wizard');
    });

    it('should include all roleplay rules', () => {
      const prompt = generateRoleplayPrompt(basePal);

      expect(prompt).toContain('ROLEPLAY RULES:');
      expect(prompt).toContain('Avoid overly elaborate introductions');
      expect(prompt).toContain("Stay responsive to the user's cues");
      expect(prompt).toContain('Keep responses fluid');
      expect(prompt).toContain('Subtly build intrigue');
      expect(prompt).toContain('Use subtle physical cues');
      expect(prompt).toContain('Maintain a crisp and minimalist style');
      expect(prompt).toContain('Pay careful attention to all past events');
    });
  });
});



================================================
FILE: src/components/PalsSheets/__tests__/VideoPalSheet.test.tsx
================================================
import React from 'react';
import {fireEvent, waitFor} from '@testing-library/react-native';

import {render} from '../../../../jest/test-utils';
import {VideoPalSheet} from '../VideoPalSheet';
import {PalType} from '../types';
import {createModel} from '../../../../jest/fixtures/models';
import {palStore} from '../../../store';
// Mock the Sheet component following the established pattern
jest.mock('../../Sheet', () => {
  const {View, Button} = require('react-native');
  const MockSheet = ({children, isVisible, onClose, title}: any) => {
    if (!isVisible) {
      return null;
    }
    return (
      <View testID="sheet">
        <View testID="sheet-title">{title}</View>
        <Button title="Close" onPress={onClose} testID="sheet-close-button" />
        {children}
      </View>
    );
  };
  MockSheet.ScrollView = ({children}: any) => (
    <View testID="sheet-scroll-view">{children}</View>
  );
  MockSheet.Actions = ({children}: any) => (
    <View testID="sheet-actions">{children}</View>
  );
  return {Sheet: MockSheet};
});

describe('VideoPalSheet', () => {
  const defaultProps = {
    isVisible: true,
    onClose: jest.fn(),
  };

  const mockMultimodalModel = createModel({
    id: 'ggml-org/SmolVLM-500M-Instruct-GGUF/SmolVLM-500M-Instruct-Q8_0.gguf',
    name: 'SmolVLM-500M-Instruct',
    supportsMultimodal: true,
    isDownloaded: true,
  });

  const mockEditPal = {
    id: 'test-pal-id',
    name: 'Test Video Pal',
    defaultModel: mockMultimodalModel,
    useAIPrompt: false,
    systemPrompt: 'Test system prompt',
    originalSystemPrompt: '',
    isSystemPromptChanged: false,
    color: ['#FF0000', '#00FF00'] as [string, string],
    captureInterval: 2000,
    palType: PalType.VIDEO as const,
  };

  beforeEach(() => {
    jest.clearAllMocks();
    // Reset the store state
    palStore.pals = [];
  });

  describe('Visibility and Basic Rendering', () => {
    it('does not render when not visible', () => {
      const {queryByTestId} = render(
        <VideoPalSheet {...defaultProps} isVisible={false} />,
      );

      expect(queryByTestId('sheet')).toBeNull();
    });

    it('renders correctly when visible in create mode', () => {
      const {getByTestId, getByText} = render(
        <VideoPalSheet {...defaultProps} />,
        {withNavigation: true},
      );

      expect(getByTestId('sheet')).toBeTruthy();
      expect(getByTestId('sheet-title')).toBeTruthy();
      expect(getByText('Create')).toBeTruthy(); // Should show create button
    });

    it('renders correctly when visible in edit mode', () => {
      const {getByTestId, getByText} = render(
        <VideoPalSheet {...defaultProps} editPal={mockEditPal} />,
        {withNavigation: true},
      );

      expect(getByTestId('sheet')).toBeTruthy();
      expect(getByTestId('sheet-title')).toBeTruthy();
      expect(getByText('Save')).toBeTruthy(); // Should show save button in edit mode
    });
  });

  describe('Form Interactions', () => {
    it('calls onClose when close button is pressed', () => {
      const {getByTestId} = render(<VideoPalSheet {...defaultProps} />, {
        withNavigation: true,
      });

      const closeButton = getByTestId('sheet-close-button');
      fireEvent.press(closeButton);

      expect(defaultProps.onClose).toHaveBeenCalledTimes(1);
    });

    it('calls onClose when cancel button is pressed', () => {
      const {getByText} = render(<VideoPalSheet {...defaultProps} />, {
        withNavigation: true,
      });

      const cancelButton = getByText('Cancel');
      fireEvent.press(cancelButton);

      expect(defaultProps.onClose).toHaveBeenCalledTimes(1);
    });
  });

  describe('Form Submission', () => {
    it('creates a new pal when form is submitted in create mode', async () => {
      const {getByText} = render(<VideoPalSheet {...defaultProps} />, {
        withNavigation: true,
      });

      const createButton = getByText('Create');
      fireEvent.press(createButton);

      await waitFor(() => {
        // Check if a pal was added by checking the store state
        expect(palStore.getPals().length).toBeGreaterThan(0);
      });

      // Verify the pal has the correct properties
      const addedPal = palStore.getPals()[0];
      expect(addedPal).toEqual(
        expect.objectContaining({
          palType: PalType.VIDEO,
          name: 'Lookie',
          captureInterval: 3000,
        }),
      );
    });

    it('updates an existing pal when form is submitted in edit mode', async () => {
      // Set up initial pal in store
      palStore.pals = [mockEditPal];

      const {getByText} = render(
        <VideoPalSheet {...defaultProps} editPal={mockEditPal} />,
        {withNavigation: true},
      );

      const saveButton = getByText('Save');
      fireEvent.press(saveButton);

      await waitFor(() => {
        // Check that the pal still exists (was updated, not deleted)
        expect(palStore.getPals().length).toBe(1);
      });

      // Verify the pal was updated
      const updatedPal = palStore
        .getPals()
        .find(pal => pal.id === mockEditPal.id);
      expect(updatedPal).toBeDefined();
      expect(updatedPal?.palType).toBe(PalType.VIDEO);
    });

    it('closes sheet after successful submission', async () => {
      const {getByText} = render(<VideoPalSheet {...defaultProps} />, {
        withNavigation: true,
      });

      const createButton = getByText('Create');
      fireEvent.press(createButton);

      await waitFor(() => {
        expect(defaultProps.onClose).toHaveBeenCalledTimes(1);
      });
    });
  });

  describe('Basic Form Elements', () => {
    it('renders sheet structure correctly', () => {
      const {getByTestId} = render(<VideoPalSheet {...defaultProps} />, {
        withNavigation: true,
      });

      expect(getByTestId('sheet')).toBeTruthy();
      expect(getByTestId('sheet-scroll-view')).toBeTruthy();
      expect(getByTestId('sheet-actions')).toBeTruthy();
    });
  });
});



================================================
FILE: src/components/PalsSheets/ColorSection/ColorSection.tsx
================================================
import React from 'react';
import {View, TouchableOpacity, ScrollView} from 'react-native';
import {observer} from 'mobx-react-lite';
import {useFormContext, Controller} from 'react-hook-form';

import {useTheme} from '../../../hooks';
import {createStyles} from './styles';
import {SectionDivider} from '../SectionDivider';
import type {PalFormData} from '../types';

type ColorPair = {
  id: string;
  colors: [string, string];
};
const colorPairs: ColorPair[] = [
  {
    id: 'light-mode',
    colors: ['#858585', '#333333'],
  },
  {
    id: 'dark-mode',
    colors: ['#333333', '#e5e5e6'],
  },
  {id: 'blue-light', colors: ['#70A6F5', '#D9F2FF']},
  {id: 'blue-mid', colors: ['#2444DA', '#70A6F5']},
  {id: 'green-light', colors: ['#A2D29E', '#CBFFDC']},
  {id: 'pink-light', colors: ['#FFBBFE', '#FAEFFE']},
  {id: 'orange-beige', colors: ['#FFAD50', '#F1EAD9']},
  {id: 'pink-rose', colors: ['#9E204F', '#F6E1EA']},
  {id: 'navy-purple', colors: ['#253375', '#8B94C1']},
];

const DualColorCircle = ({
  colors,
  isSelected,
}: {
  colors: [string, string];
  isSelected: boolean;
}) => {
  const theme = useTheme();
  const styles = createStyles(theme);

  return (
    <View
      testID="color-button"
      style={[
        styles.colorButtonContainer,
        isSelected && styles.selectedColorButtonContainer,
      ]}>
      <View style={styles.colorButton}>
        <View style={[styles.colorHalf, {backgroundColor: colors[0]}]} />
        <View
          style={[
            styles.colorHalf,
            styles.rightHalf,
            {backgroundColor: colors[1]},
          ]}
        />
      </View>
    </View>
  );
};

export const ColorSection = observer(() => {
  const {control} = useFormContext<PalFormData>();
  const theme = useTheme();
  const styles = createStyles(theme);

  return (
    <View>
      <SectionDivider label="Color" />
      <Controller
        control={control}
        name="color"
        render={({field: {onChange, value}}) => (
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={styles.pickerContainer}>
            {colorPairs.map(pair => (
              <TouchableOpacity
                key={pair.id}
                onPress={() => onChange(pair.colors)}
                hitSlop={5}
                activeOpacity={0.7}>
                <DualColorCircle
                  colors={pair.colors}
                  isSelected={
                    value?.[0] === pair.colors[0] &&
                    value?.[1] === pair.colors[1]
                  }
                />
              </TouchableOpacity>
            ))}
          </ScrollView>
        )}
      />
    </View>
  );
});



================================================
FILE: src/components/PalsSheets/ColorSection/index.ts
================================================
export * from './ColorSection';



================================================
FILE: src/components/PalsSheets/ColorSection/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {Theme} from '../../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    pickerContainer: {
      flexDirection: 'row',
      paddingVertical: 8,
      gap: 12,
    },
    colorButtonContainer: {
      width: 28,
      height: 28,
      borderRadius: 100,
      borderWidth: 1,
      borderColor: '#222222',
      padding: 1,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: 'white',
    },
    colorButton: {
      width: 24,
      height: 24,
      borderRadius: 12,
      overflow: 'hidden',
      flexDirection: 'row',
      transform: [{rotate: '45deg'}],
    },
    colorHalf: {
      width: '50%',
      height: '100%',
    },
    rightHalf: {
      borderLeftWidth: 0.5,
      borderLeftColor: '#E0E0E0',
    },
    selectedColorButtonContainer: {
      width: 30,
      height: 30,
      borderColor: theme.colors.onBackground,
      borderWidth: 2.5,
      shadowColor: theme.colors.onBackground,
      shadowOffset: {width: 0, height: 1},
      shadowOpacity: 0.3,
      shadowRadius: 2,
      elevation: 3,
    },
  });



================================================
FILE: src/components/PalsSheets/ColorSection/__tests__/ColorSection.test.tsx
================================================
import React from 'react';
import {fireEvent} from '@testing-library/react-native';
import {FormProvider, useForm, UseFormReturn} from 'react-hook-form';

import {render} from '../../../../../jest/test-utils';
import {ColorSection} from '../ColorSection';
import type {PalFormData} from '../../types';

const TestWrapper = ({
  children,
  onFormReady,
}: {
  children: React.ReactNode;
  onFormReady?: (methods: UseFormReturn<PalFormData>) => void;
}) => {
  const methods = useForm<PalFormData>({
    defaultValues: {
      color: ['#858585', '#333333'],
    },
  });

  React.useEffect(() => {
    onFormReady?.(methods);
  }, [onFormReady, methods]);

  return <FormProvider {...methods}>{children}</FormProvider>;
};

describe('ColorSection', () => {
  it('renders all color options', () => {
    const {getAllByTestId} = render(
      <TestWrapper>
        <ColorSection />
      </TestWrapper>,
    );

    const colorButtons = getAllByTestId('color-button');
    expect(colorButtons).toHaveLength(9); // Number of color pairs defined in component
  });

  it('shows selected state for default color', () => {
    const {getAllByTestId} = render(
      <TestWrapper>
        <ColorSection />
      </TestWrapper>,
    );

    const colorButtons = getAllByTestId('color-button');
    const selectedButton = colorButtons[0]; // First color pair should be selected by default
    const styles = selectedButton.props.style;
    expect(styles[1]).toBeTruthy(); // Selected style should be applied
  });

  it('changes selected color on press', () => {
    const {getAllByTestId} = render(
      <TestWrapper>
        <ColorSection />
      </TestWrapper>,
    );

    const colorButtons = getAllByTestId('color-button');
    const button = colorButtons[1].parent?.parent;
    if (button) {
      fireEvent.press(button); // Press second color option
    }

    // Check styles after re-render
    const updatedButtons = getAllByTestId('color-button');
    expect(updatedButtons[0].props.style[1]).toBeFalsy(); // First button should not have selected style
    expect(updatedButtons[1].props.style[1]).toBeTruthy(); // Second button should have selected style
  });

  it('updates form context on color selection', () => {
    let formMethods: UseFormReturn<PalFormData> | undefined;

    const {getAllByTestId} = render(
      <TestWrapper
        onFormReady={methods => {
          formMethods = methods;
        }}>
        <ColorSection />
      </TestWrapper>,
    );

    const colorButtons = getAllByTestId('color-button');
    const button = colorButtons[2].parent?.parent;
    if (button) {
      fireEvent.press(button); // Select third color option
    }

    // Check if form values were updated
    expect(formMethods?.getValues().color).toEqual(['#70A6F5', '#D9F2FF']); // Values for blue-light color pair
  });
});



================================================
FILE: src/components/ProjectionModelSelector/index.ts
================================================
export * from './ProjectionModelSelector';



================================================
FILE: src/components/ProjectionModelSelector/ProjectionModelSelector.tsx
================================================
import {View, TouchableOpacity, Alert} from 'react-native';
import React, {useContext, useEffect, useState} from 'react';

import {observer} from 'mobx-react';
import {Text, ActivityIndicator} from 'react-native-paper';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';

import {useTheme} from '../../hooks';

import {createStyles} from './styles';

import {modelStore} from '../../store';

import {Model} from '../../utils/types';
import {L10nContext, formatBytes} from '../../utils';

interface ProjectionModelSelectorProps {
  model: Model;
  onProjectionModelSelect?: (projectionModelId: string) => void;
  showDownloadActions?: boolean; // Controls whether to show download/delete buttons
  context?: 'search' | 'modelsList'; // Context for data source selection
  availableProjectionModels?: Model[]; // For search context - models from HF repository
}

/**
 * Component for displaying and managing projection models for a vision LLM
 */
export const ProjectionModelSelector = observer(
  ({
    model,
    onProjectionModelSelect,
    showDownloadActions = true,
    context = 'modelsList',
    availableProjectionModels,
  }: ProjectionModelSelectorProps) => {
    const theme = useTheme();
    const l10n = useContext(L10nContext);
    const styles = createStyles(theme);

    const [expanded, setExpanded] = useState(false);
    const [compatibleModels, setCompatibleModels] = useState<Model[]>([]);
    const [selectedModelId, setSelectedModelId] = useState<string | undefined>(
      model.defaultProjectionModel,
    );

    // Get compatible projection models based on context
    useEffect(() => {
      let projectionModels: Model[] = [];

      if (context === 'search' && availableProjectionModels) {
        // Use provided models from HF repository for search context
        projectionModels = availableProjectionModels;
      } else {
        // Use store-based lookup for downloaded models context
        projectionModels = modelStore.getCompatibleProjectionModels(model.id);
      }

      setCompatibleModels(projectionModels);

      // Auto-expand if there are models to show - better UX!
      if (projectionModels.length > 0) {
        setExpanded(true);
      }
    }, [model.id, context, availableProjectionModels]);

    const handleSelectModel = (projectionModelId: string) => {
      setSelectedModelId(projectionModelId);
      if (onProjectionModelSelect) {
        onProjectionModelSelect(projectionModelId);
      }

      // If this is the active model, we need to reload the context with the new projection model
      if (modelStore.activeModelId === model.id) {
        const projectionModel = modelStore.models.find(
          m => m.id === projectionModelId,
        );
        if (projectionModel && projectionModel.isDownloaded) {
          // Show notification that the model will be reloaded
          Alert.alert(
            l10n.models.multimodal.reloadModelTitle,
            l10n.models.multimodal.reloadModelMessage,
            [
              {
                text: l10n.common.cancel,
                style: 'cancel',
              },
              {
                text: l10n.models.multimodal.reload,
                onPress: async () => {
                  // Get the projection model path
                  const projModelPath = await modelStore.getModelFullPath(
                    projectionModel,
                  );
                  if (projModelPath) {
                    // Reload the model with the new projection model
                    modelStore.initContext(model, projModelPath);
                  }
                },
              },
            ],
          );
        }
      }
    };

    const handleDownloadModel = (projectionModel: Model) => {
      modelStore.checkSpaceAndDownload(projectionModel.id);
    };

    const handleDeleteModel = (projectionModel: Model) => {
      // Check if model is currently active - this is the only case we prevent deletion
      if (modelStore.activeModelId === projectionModel.id) {
        Alert.alert(
          l10n.models.multimodal.cannotDeleteTitle,
          l10n.models.multimodal.cannotDeleteActive,
          [{text: l10n.common.ok, style: 'default'}],
        );
        return;
      }

      // Get dependent models for warning message (manual deletion always allowed)
      const dependentModels = modelStore.getDownloadedLLMsUsingProjectionModel(
        projectionModel.id,
      );

      let message = l10n.models.multimodal.deleteProjectionMessage;
      if (dependentModels.length > 0) {
        const modelNames = dependentModels.map(m => m.name).join(', ');
        message = `${l10n.models.multimodal.deleteProjectionMessage}\n\n${l10n.models.multimodal.dependentModels} ${modelNames}\n\n${l10n.models.multimodal.visionWillBeDisabled}`;
      }

      // Show confirmation dialog (always allow deletion for manual action)
      Alert.alert(l10n.models.multimodal.deleteProjectionTitle, message, [
        {text: l10n.common.cancel, style: 'cancel'},
        {
          text: l10n.common.delete,
          style: 'destructive',
          onPress: async () => {
            try {
              // Disable vision for dependent models before deletion
              dependentModels.forEach(dependentModel => {
                modelStore.setModelVisionEnabled(dependentModel.id, false);
              });

              await modelStore.deleteModel(projectionModel);
            } catch (error) {
              console.error('Failed to delete projection model:', error);
              Alert.alert(
                l10n.models.multimodal.cannotDeleteTitle,
                error instanceof Error
                  ? error.message
                  : 'Unknown error occurred',
                [{text: l10n.common.ok, style: 'default'}],
              );
            }
          },
        },
      ]);
    };

    const toggleExpanded = () => {
      setExpanded(!expanded);
    };

    if (!model.supportsMultimodal) {
      return null;
    }

    return (
      <View testID="projection-model-selector" style={styles.container}>
        {/* Optional Header - only show if there are multiple models or user needs to collapse */}
        {compatibleModels.length > 1 && (
          <TouchableOpacity
            style={styles.header}
            onPress={toggleExpanded}
            activeOpacity={0.7}>
            <Text style={styles.headerTitle}>
              {l10n.models.multimodal.projectionModels}
            </Text>
            <Icon
              name={expanded ? 'chevron-up' : 'chevron-down'}
              size={16}
              color={theme.colors.onSurfaceVariant}
              style={styles.chevronIcon}
            />
          </TouchableOpacity>
        )}

        {/* Clean Content - auto-expanded for better UX */}
        {expanded && (
          <View style={styles.content}>
            {compatibleModels.length === 0 ? (
              <View style={styles.emptyState}>
                <Icon
                  name="image-off-outline"
                  size={24}
                  color={theme.colors.onSurfaceVariant}
                />
                <Text style={styles.emptyText}>
                  {l10n.models.multimodal.noCompatibleModels}
                </Text>
              </View>
            ) : (
              <View style={styles.modelsList}>
                {/* Show title for context when there's only one model */}
                {compatibleModels.length === 1 && (
                  <Text style={styles.singleModelTitle}>
                    {l10n.models.multimodal.projectionModels}
                  </Text>
                )}

                {compatibleModels.map(projModel => {
                  const isSelected = selectedModelId === projModel.id;

                  return (
                    <View
                      testID="projection-model-item"
                      key={projModel.id}
                      style={[
                        styles.modelItem,
                        isSelected && styles.selectedModelItem,
                      ]}>
                      <View style={styles.modelInfo}>
                        <View style={styles.modelHeader}>
                          <Icon
                            name="cube-outline"
                            size={12}
                            color={
                              isSelected
                                ? theme.colors.tertiary
                                : theme.colors.onSurfaceVariant
                            }
                            style={styles.modelIcon}
                          />
                          <Text
                            style={[
                              styles.modelName,
                              isSelected && styles.selectedModelName,
                            ]}
                            numberOfLines={1}>
                            {projModel.name}
                          </Text>
                        </View>
                        <Text style={styles.modelSize}>
                          {formatBytes(projModel.size)}
                        </Text>
                      </View>

                      <View style={styles.modelActions}>
                        {showDownloadActions ? (
                          // Full download/delete actions for ModelCard context
                          <>
                            {projModel.isDownloaded ? (
                              <View style={styles.downloadedActions}>
                                <TouchableOpacity
                                  testID="select-projection-model-button"
                                  onPress={() =>
                                    handleSelectModel(projModel.id)
                                  }
                                  style={[
                                    styles.selectArea,
                                    isSelected && styles.selectedArea,
                                  ]}
                                  activeOpacity={0.7}>
                                  <Icon
                                    name={
                                      isSelected
                                        ? 'check-circle'
                                        : 'circle-outline'
                                    }
                                    size={20}
                                    color={
                                      isSelected
                                        ? theme.colors.tertiary
                                        : theme.colors.onSurfaceVariant
                                    }
                                  />
                                </TouchableOpacity>
                                <TouchableOpacity
                                  onPress={() => handleDeleteModel(projModel)}
                                  style={styles.deleteArea}
                                  activeOpacity={0.7}>
                                  <Icon
                                    name="delete-outline"
                                    size={16}
                                    color={theme.colors.error}
                                  />
                                </TouchableOpacity>
                              </View>
                            ) : projModel.progress > 0 ? (
                              <View style={styles.downloadProgress}>
                                <ActivityIndicator
                                  size="small"
                                  color={theme.colors.primary}
                                />
                                <Text style={styles.progressText}>
                                  {Math.round(projModel.progress)}%
                                </Text>
                              </View>
                            ) : (
                              <TouchableOpacity
                                onPress={() => handleDownloadModel(projModel)}
                                style={styles.downloadArea}
                                activeOpacity={0.7}>
                                <Icon
                                  name="download"
                                  size={16}
                                  color={theme.colors.primary}
                                />
                                <Text style={styles.downloadText}>
                                  {l10n.models.multimodal.download}
                                </Text>
                              </TouchableOpacity>
                            )}
                          </>
                        ) : (
                          // Selection only for VisionDownloadSheet context
                          <TouchableOpacity
                            testID="select-projection-model-button"
                            onPress={() => handleSelectModel(projModel.id)}
                            style={[
                              styles.selectArea,
                              isSelected && styles.selectedArea,
                            ]}
                            activeOpacity={0.7}>
                            <Icon
                              name={
                                isSelected ? 'check-circle' : 'circle-outline'
                              }
                              size={20}
                              color={
                                isSelected
                                  ? theme.colors.tertiary
                                  : theme.colors.onSurfaceVariant
                              }
                            />
                          </TouchableOpacity>
                        )}
                      </View>
                    </View>
                  );
                })}
              </View>
            )}
          </View>
        )}
      </View>
    );
  },
);



================================================
FILE: src/components/ProjectionModelSelector/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {Theme} from '../../utils';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    container: {
      marginTop: 8,
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingVertical: 12,
      paddingHorizontal: 4,
    },
    headerTitle: {
      fontSize: 14,
      fontWeight: '600',
      color: theme.colors.primary,
    },
    chevronIcon: {
      marginLeft: 8,
    },
    content: {
      paddingTop: 8,
    },
    emptyState: {
      alignItems: 'center',
      paddingVertical: 16,
    },
    emptyText: {
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
      fontSize: 12,
      marginTop: 6,
      fontStyle: 'italic',
    },
    modelsList: {
      gap: 8,
    },
    singleModelTitle: {
      fontSize: 12,
      fontWeight: '600',
      color: theme.colors.primary,
      marginBottom: 8,
    },
    modelItem: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: 12,
      paddingHorizontal: 12,
      backgroundColor: theme.colors.surfaceVariant + '20', // Very subtle background
      borderRadius: 8,
      borderLeftWidth: 3,
      borderLeftColor: 'transparent',
    },
    selectedModelItem: {
      borderLeftColor: theme.colors.tertiary,
      backgroundColor: theme.colors.tertiaryContainer + '20',
    },
    modelInfo: {
      flex: 1,
      marginRight: 12,
    },
    modelHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: 4,
    },
    modelIcon: {
      marginRight: 8,
    },
    modelName: {
      fontSize: 14,
      fontWeight: '500',
      color: theme.colors.onSurface,
      flex: 1,
    },
    selectedModelName: {
      fontWeight: '600',
      color: theme.colors.tertiary,
    },
    modelSize: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
      marginLeft: 20, // Align with model name
    },
    modelActions: {
      minWidth: 80,
      alignItems: 'flex-end',
    },
    downloadedActions: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
    },
    selectArea: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: 6,
      paddingHorizontal: 8,
      borderRadius: 6,
      minWidth: 70,
      justifyContent: 'center',
    },
    selectedArea: {
      backgroundColor: theme.colors.tertiaryContainer + '30',
    },
    selectText: {
      fontSize: 12,
      fontWeight: '500',
      color: theme.colors.onSurfaceVariant,
      marginLeft: 4,
    },
    deleteArea: {
      padding: 6,
      borderRadius: 6,
      backgroundColor: theme.colors.errorContainer + '20',
      alignItems: 'center',
      justifyContent: 'center',
    },
    downloadArea: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: 6,
      paddingHorizontal: 8,
      borderRadius: 6,
      backgroundColor: theme.colors.primaryContainer + '20',
    },
    downloadText: {
      fontSize: 12,
      fontWeight: '500',
      color: theme.colors.primary,
      marginLeft: 4,
    },
    downloadProgress: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: 4,
      paddingHorizontal: 8,
      backgroundColor: theme.colors.primaryContainer + '30',
      borderRadius: 6,
    },
    progressText: {
      marginLeft: 6,
      fontSize: 11,
      fontWeight: '500',
      color: theme.colors.primary,
    },
  });



================================================
FILE: src/components/RenameModal/index.ts
================================================
export {RenameModal} from './RenameModal';



================================================
FILE: src/components/RenameModal/RenameModal.tsx
================================================
import React, {useContext, useEffect} from 'react';
import {Modal, TextInput, TouchableOpacity, View} from 'react-native';
import {Text, useTheme} from 'react-native-paper';

import {createStyles} from './styles';
import {L10nContext} from '../../utils';
import {chatSessionStore, SessionMetaData} from '../../store';

interface RenameModalProps {
  visible: boolean;
  onClose: () => void;
  session: SessionMetaData | null;
}

export const RenameModal: React.FC<RenameModalProps> = ({
  visible,
  onClose,
  session,
}) => {
  const [newTitle, setNewTitle] = React.useState(session?.title || '');
  const theme = useTheme();
  const styles = createStyles(theme);
  const l10n = useContext(L10nContext);

  useEffect(() => {
    setNewTitle(session?.title || '');
  }, [session, visible]);

  const handleRename = async () => {
    if (session?.id && newTitle.trim()) {
      await chatSessionStore.updateSessionTitleBySessionId(
        session?.id,
        newTitle,
      );
      onClose();
    }
  };

  const handleClose = () => {
    onClose();
  };

  return (
    <Modal
      transparent={true}
      visible={visible}
      onRequestClose={handleClose}
      animationType="fade">
      <View style={styles.modalOverlay}>
        <View style={styles.modalContent}>
          <Text style={styles.modalTitle}>{l10n.common.rename}</Text>
          <TextInput
            style={styles.textInput}
            placeholder="New Title"
            placeholderTextColor={theme.colors.onSurfaceVariant}
            value={newTitle}
            maxLength={40}
            onChangeText={setNewTitle}
            autoFocus={true}
            onSubmitEditing={handleRename}
            returnKeyType="done"
          />
          <View style={styles.buttonContainer}>
            <TouchableOpacity style={styles.cancelButton} onPress={handleClose}>
              <Text style={styles.cancelText}>{l10n.common.cancel}</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[
                styles.confirmButton,
                !newTitle.trim() && styles.disabledButton,
              ]}
              onPress={handleRename}
              disabled={!newTitle.trim()}>
              <Text style={styles.confirmText}>{l10n.common.save}</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );
};



================================================
FILE: src/components/RenameModal/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {MD3Theme} from 'react-native-paper';

export const createStyles = (theme: MD3Theme) =>
  StyleSheet.create({
    modalOverlay: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
    },
    modalContent: {
      width: '80%',
      backgroundColor: theme.colors.surface,
      borderRadius: 14,
      overflow: 'hidden',
      borderWidth: StyleSheet.hairlineWidth,
      borderColor: theme.dark
        ? theme.colors.outline + '50'
        : theme.colors.outline + '30',
    },
    modalTitle: {
      fontSize: 17,
      fontWeight: '600',
      color: theme.colors.onSurface,
      textAlign: 'center',
      paddingVertical: 16,
      borderBottomWidth: StyleSheet.hairlineWidth,
      borderBottomColor: theme.dark
        ? theme.colors.outline + '50'
        : theme.colors.outline + '30',
    },
    textInput: {
      margin: 16,
      padding: 12,
      backgroundColor: theme.dark
        ? theme.colors.surfaceVariant + '80'
        : theme.colors.surface + '90',
      color: theme.colors.onSurface,
      fontSize: 17,
      borderWidth: StyleSheet.hairlineWidth * 2,
      borderColor: theme.dark
        ? theme.colors.outline + '50'
        : theme.colors.outline + '30',
      borderRadius: 10,
    },
    buttonContainer: {
      flexDirection: 'row',
      borderTopWidth: StyleSheet.hairlineWidth,
      borderTopColor: theme.dark
        ? theme.colors.outline + '50'
        : theme.colors.outline + '30',
    },
    cancelButton: {
      flex: 1,
      paddingVertical: 12,
      borderRightWidth: StyleSheet.hairlineWidth,
      borderRightColor: theme.dark
        ? theme.colors.outline + '50'
        : theme.colors.outline + '30',
      alignItems: 'center',
      justifyContent: 'center',
    },
    cancelText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 17,
      fontWeight: '400',
    },
    confirmButton: {
      flex: 1,
      paddingVertical: 12,
      alignItems: 'center',
      justifyContent: 'center',
    },
    confirmText: {
      color: theme.colors.primary,
      fontSize: 17,
      fontWeight: '600',
    },
    disabledButton: {
      opacity: 0.4,
    },
  });



================================================
FILE: src/components/ResponseBubble/index.ts
================================================
export * from './ResponseBubble';



================================================
FILE: src/components/ResponseBubble/ResponseBubble.tsx
================================================
import React, {useState, useRef, useEffect} from 'react';
import {
  View,
  TouchableOpacity,
  Animated,
  Easing,
  ScrollView,
  LayoutAnimation,
  Platform,
  UIManager,
} from 'react-native';

import LinearGradient from 'react-native-linear-gradient';
import MaskedView from '@react-native-masked-view/masked-view';
import {createStyles} from './styles';

// Enable LayoutAnimation for Android
if (
  Platform.OS === 'android' &&
  UIManager.setLayoutAnimationEnabledExperimental
) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

enum BubbleState {
  PARTIAL = 'partial',
  EXPANDED = 'expanded',
}

interface ResponseBubbleProps {
  children?: React.ReactNode;
}

export const ResponseBubble: React.FC<ResponseBubbleProps> = ({children}) => {
  const styles = createStyles();

  const [bubbleState, setBubbleState] = useState<BubbleState>(
    BubbleState.EXPANDED,
  );

  // We don't need to track animation state anymore

  const chevronRotation = useRef(new Animated.Value(0)).current;

  // Reference to the ScrollView for auto-scrolling
  const scrollViewRef = useRef<ScrollView>(null);

  // Toggle between partial and expanded states
  const toggleState = () => {
    // Configure layout animation
    LayoutAnimation.configureNext({
      duration: 300,
      create: {
        type: LayoutAnimation.Types.easeInEaseOut,
        property: LayoutAnimation.Properties.opacity,
      },
      update: {
        type: LayoutAnimation.Types.spring,
        springDamping: 0.85,
      },
    });

    // Update state
    if (bubbleState === BubbleState.PARTIAL) {
      setBubbleState(BubbleState.EXPANDED);
      animateChevron(180);
    } else {
      setBubbleState(BubbleState.PARTIAL);
      animateChevron(0);
    }
  };

  // Animate chevron rotation
  const animateChevron = (toValue: number) => {
    Animated.timing(chevronRotation, {
      toValue,
      duration: 300,
      easing: Easing.bezier(0.2, 0, 0.2, 1),
      useNativeDriver: true,
    }).start();
  };

  // Chevron rotation interpolation
  const chevronRotationDeg = chevronRotation.interpolate({
    inputRange: [0, 180],
    outputRange: ['0deg', '180deg'],
  });

  const containerStyle = [
    styles.container,
    bubbleState === BubbleState.PARTIAL && styles.partialContainer,
    bubbleState === BubbleState.EXPANDED && styles.expandedContainer,
  ];

  const isScrollable = bubbleState === BubbleState.PARTIAL;

  // Auto-scroll to the bottom when content changes
  useEffect(() => {
    if (isScrollable && scrollViewRef.current) {
      // Use a longer timeout to ensure content is fully rendered
      setTimeout(() => {
        scrollViewRef.current?.scrollToEnd({animated: true});
      }, 100);
    }
  }, [children, isScrollable]);

  return (
    <TouchableOpacity
      style={styles.shadowContainer}
      activeOpacity={0.9}
      onPress={toggleState}>
      <View style={containerStyle}>
        {/* Content */}
        {isScrollable ? (
          // Use MaskedView for partial state
          <MaskedView
            testID="masked-view"
            style={styles.maskedContentContainer}
            maskElement={
              <View style={styles.maskElementContainer}>
                <LinearGradient
                  style={styles.maskGradient}
                  colors={['transparent', 'black']}
                  pointerEvents="none"
                />
                <View style={styles.maskSolid} />
              </View>
            }>
            {/* The actual content that will be masked */}
            <ScrollView
              ref={scrollViewRef}
              style={styles.contentContainer}
              contentContainerStyle={styles.contentContainerStyle}
              showsVerticalScrollIndicator={false}
              // scrollEventThrottle={16}
              onContentSizeChange={() =>
                scrollViewRef.current?.scrollToEnd({animated: true})
              }
              // onLayout={() => {
              //   // Scroll when layout changes
              //   scrollViewRef.current?.scrollToEnd({animated: false});
              // }}
              // onContentSizeChange={() => {
              //   // First scroll without animation to ensure we reach the end
              //   scrollViewRef.current?.scrollToEnd({animated: false});
              //   // Then add a slight delay and scroll with animation for a smoother experience
              //   setTimeout(() => {
              //     scrollViewRef.current?.scrollToEnd({animated: true});
              //   }, 50);
              // }}
            >
              {children}
            </ScrollView>
          </MaskedView>
        ) : (
          // Full content view for expanded state
          <ScrollView
            style={styles.contentContainer}
            contentContainerStyle={styles.contentContainerStyle}
            showsVerticalScrollIndicator={false}
            scrollEventThrottle={16}>
            {children}
          </ScrollView>
        )}

        {/* Expand/Collapse indicator */}
        <View style={styles.indicatorContainer}>
          <Animated.View
            style={[
              styles.chevronContainer,
              {
                transform: [{rotate: chevronRotationDeg}],
              },
            ]}>
            <View style={styles.chevronIndicator} />
          </Animated.View>
        </View>
      </View>
    </TouchableOpacity>
  );
};

export default ResponseBubble;



================================================
FILE: src/components/ResponseBubble/styles.ts
================================================
import {StyleSheet, Platform} from 'react-native';

export const createStyles = () => {
  // Colors
  const bubbleBackground = 'rgba(0, 0, 0, 0.7)';
  const bubbleBorderColor = 'rgba(255, 255, 255, 0.2)';
  const shadowColor = '#000';

  return StyleSheet.create({
    shadowContainer: {
      ...Platform.select({
        ios: {
          shadowColor: shadowColor,
          shadowOffset: {width: 0, height: 2},
          shadowOpacity: 0.4,
          shadowRadius: 12,
        },
        android: {
          // No need here, shadows come from elevation in the inner container
        },
      }),
    },
    container: {
      borderRadius: 16,
      overflow: 'hidden',
      backgroundColor: bubbleBackground,
      borderWidth: 1,
      borderColor: bubbleBorderColor,
      ...Platform.select({
        ios: {
          // No need here, shadows come from parent container
        },
        android: {
          elevation: 8,
        },
      }),
    },
    partialContainer: {
      maxHeight: 120, // Limited height for partial view
    },
    expandedContainer: {
      // Full height for expanded view
    },
    contentContainer: {
      padding: 16,
      paddingBottom: 40, // Extra padding at bottom for indicator and to ensure content is visible
    },
    contentContainerStyle: {
      flexGrow: 1, // Allow content to grow and enable proper scrolling
    },
    maskedContentContainer: {
      height: 120, // Match the partialContainer maxHeight
    },
    maskElementContainer: {
      flex: 1,
      backgroundColor: 'transparent',
    },
    maskGradient: {
      height: 40, // Height of the fade effect
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
    },
    maskSolid: {
      flex: 1,
      backgroundColor: 'black',
      marginTop: 40, // Match the maskGradient height
    },
    indicatorContainer: {
      position: 'absolute',
      bottom: 4,
      left: 0,
      right: 0,
      alignItems: 'center',
      justifyContent: 'center',
      height: 20,
    },
    chevronContainer: {
      width: 30,
      height: 20,
      alignItems: 'center',
      justifyContent: 'center',
    },
    chevronIndicator: {
      width: 36,
      height: 4,
      borderRadius: 2,
      backgroundColor: 'rgba(255, 255, 255, 0.5)',
    },
  });
};

export default createStyles;



================================================
FILE: src/components/Searchbar/index.ts
================================================
export * from './Searchbar';



================================================
FILE: src/components/Searchbar/Searchbar.tsx
================================================
import React from 'react';
import {StyleSheet} from 'react-native';

import {BlurView} from '@react-native-community/blur';
import LinearGradient from 'react-native-linear-gradient';
import MaskedView from '@react-native-masked-view/masked-view';
import {Searchbar as PaperSearchbar} from 'react-native-paper';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import {KeyboardStickyView} from 'react-native-keyboard-controller';

import {useTheme} from '../../hooks';

import {createStyles, iconStyles} from './styles';

interface SearchbarProps {
  value: string;
  onChangeText: (text: string) => void;
  placeholder?: string;
  containerStyle?: object;
  inputStyle?: object;
  blurIntensity?: number;
  gradientLocations?: number[];
  showBlur?: boolean;
}

const SearchIcon = ({color}: {color: string}) => (
  <Icon name="magnify" size={24} color={color} style={iconStyles.searchIcon} />
);

const ClearIcon = ({color}: {color: string}) => (
  <Icon name="close" size={24} color={color} />
);

export const Searchbar = ({
  value,
  onChangeText,
  placeholder = 'Search...',
  containerStyle,
  inputStyle,
  blurIntensity = 4,
  gradientLocations = [0, 0.1, 1],
  showBlur = true,
}: SearchbarProps) => {
  const theme = useTheme();
  const styles = createStyles(theme);

  const searchIconSource = () => (
    <SearchIcon color={theme.colors.onSurfaceVariant} />
  );

  const clearIconSource = () => (
    <ClearIcon color={theme.colors.onSurfaceVariant} />
  );

  return (
    <KeyboardStickyView style={[styles.container, containerStyle]}>
      {showBlur ? (
        <MaskedView
          style={StyleSheet.absoluteFill}
          maskElement={
            <LinearGradient
              style={StyleSheet.absoluteFill}
              colors={['transparent', 'black', 'black']}
              locations={gradientLocations}
              pointerEvents="none"
            />
          }>
          <BlurView
            style={StyleSheet.absoluteFill}
            blurType={theme.dark ? 'dark' : 'light'}
            blurAmount={blurIntensity}
            reducedTransparencyFallbackColor={
              theme.dark ? 'rgba(0, 0, 0, 0.7)' : 'rgba(255, 255, 255, 0.85)'
            }
          />
        </MaskedView>
      ) : null}
      <PaperSearchbar
        placeholder={placeholder}
        onChangeText={onChangeText}
        value={value}
        inputStyle={[styles.searchbarInput, inputStyle]}
        style={styles.searchbar}
        icon={searchIconSource}
        clearIcon={value.length > 0 ? clearIconSource : undefined}
      />
    </KeyboardStickyView>
  );
};



================================================
FILE: src/components/Searchbar/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {Theme} from '../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    container: {
      paddingHorizontal: 10,
      paddingTop: 4,
      paddingBottom: 8,
      height: 65,
    },
    searchbar: {
      height: 44,
      borderRadius: 16,
      backgroundColor: theme.dark
        ? theme.colors.surfaceVariant + '80'
        : theme.colors.surface + '90',
      borderWidth: StyleSheet.hairlineWidth,
      borderColor: theme.dark
        ? theme.colors.outline + '50'
        : theme.colors.outline + '30',
      shadowColor: theme.dark ? '#000' : 'rgba(0, 0, 0, 0.15)',
      shadowOffset: {
        width: 0,
        height: 1,
      },
      shadowOpacity: 0.2,
      shadowRadius: 3,
      elevation: 2,
      zIndex: 1,
    },
    searchbarInput: {
      fontSize: 16,
      maxHeight: 44,
      minHeight: 44,
      height: 44,
      padding: 0,
      marginLeft: 8,
      color: theme.colors.onSurface,
      fontWeight: '400',
      letterSpacing: 0.25,
    },
  });

export const iconStyles = StyleSheet.create({
  searchIcon: {
    marginLeft: 4,
  },
});



================================================
FILE: src/components/SendButton/index.ts
================================================
export * from './SendButton';



================================================
FILE: src/components/SendButton/SendButton.tsx
================================================
import * as React from 'react';
import {
  GestureResponderEvent,
  StyleSheet,
  TouchableOpacity,
  TouchableOpacityProps,
} from 'react-native';

import {useTheme} from '../../hooks';

import {L10nContext} from '../../utils';
import {SendIcon} from '../../assets/icons';

export interface SendButtonPropsAdditionalProps {
  touchableOpacityProps?: TouchableOpacityProps;
  color?: string;
}

export interface SendButtonProps extends SendButtonPropsAdditionalProps {
  /** Callback for send button tap event */
  onPress: () => void;
}

export const SendButton = ({
  onPress,
  color,
  touchableOpacityProps,
}: SendButtonProps) => {
  const l10n = React.useContext(L10nContext);
  const theme = useTheme();
  const handlePress = (event: GestureResponderEvent) => {
    onPress();
    touchableOpacityProps?.onPress?.(event);
  };

  return (
    <TouchableOpacity
      accessibilityLabel={l10n.components.sendButton.accessibilityLabel}
      accessibilityRole="button"
      testID="send-button"
      {...touchableOpacityProps}
      onPress={handlePress}
      style={styles.sendButton}>
      {theme.icons?.sendButtonIcon?.() ?? (
        <SendIcon
          stroke={color ?? theme.colors.inverseOnSurface}
          width={24}
          height={24}
        />
      )}
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  sendButton: {
    marginLeft: 16,
    // Minimum 40pt touch target for accessibility
    minHeight: 40,
    minWidth: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
});



================================================
FILE: src/components/Sheet/Actions.tsx
================================================
import React, {useMemo} from 'react';
import {useTheme} from '../../hooks';
import {useSafeAreaInsets} from 'react-native-safe-area-context';
import {StyleProp, View, ViewStyle} from 'react-native';

interface ActionsProps {
  children: React.ReactNode;
  style?: StyleProp<ViewStyle>;
}

export const Actions = ({children, style}: ActionsProps) => {
  const theme = useTheme();
  const insets = useSafeAreaInsets();

  const containerStyle: StyleProp<ViewStyle> = useMemo(() => {
    return {
      flexDirection: 'row',
      justifyContent: 'space-between',
      backgroundColor: theme.colors.background,
      paddingHorizontal: 16,
      paddingTop: 10,
      paddingBottom: 10 + insets.bottom,
      gap: 10,
    };
  }, [theme, insets]);

  return <View style={[containerStyle, style]}>{children}</View>;
};



================================================
FILE: src/components/Sheet/BottomSheetAwareScrollview.tsx
================================================
import React, {memo} from 'react';
import {
  KeyboardAwareScrollView,
  KeyboardAwareScrollViewProps,
} from 'react-native-keyboard-controller';
import {
  SCROLLABLE_TYPE,
  createBottomSheetScrollableComponent,
  type BottomSheetScrollViewMethods,
} from '@gorhom/bottom-sheet';
import type {BottomSheetScrollViewProps} from '@gorhom/bottom-sheet/src/components/bottomSheetScrollable/types';
import Reanimated from 'react-native-reanimated';

const AnimatedScrollView =
  Reanimated.createAnimatedComponent<KeyboardAwareScrollViewProps>(
    KeyboardAwareScrollView,
  );
const BottomSheetScrollViewComponent = createBottomSheetScrollableComponent<
  BottomSheetScrollViewMethods,
  BottomSheetScrollViewProps
>(SCROLLABLE_TYPE.SCROLLVIEW, AnimatedScrollView);

const BottomSheetKeyboardAwareScrollView = memo(
  (props: BottomSheetScrollViewProps & KeyboardAwareScrollViewProps) => {
    return <BottomSheetScrollViewComponent {...props} />;
  },
);

BottomSheetKeyboardAwareScrollView.displayName =
  'BottomSheetKeyboardAwareScrollView';

export default BottomSheetKeyboardAwareScrollView as (
  props: BottomSheetScrollViewProps & KeyboardAwareScrollViewProps,
) => ReturnType<typeof BottomSheetKeyboardAwareScrollView>;



================================================
FILE: src/components/Sheet/CustomBackdrop.tsx
================================================
import {
  BottomSheetBackdrop,
  BottomSheetBackdropProps,
} from '@gorhom/bottom-sheet';
import React, {useMemo} from 'react';
import {useTheme} from 'react-native-paper';
import {Extrapolation, interpolate} from 'react-native-reanimated';
import {useAnimatedStyle} from 'react-native-reanimated';

export const CustomBackdrop = ({
  animatedIndex,
  animatedPosition,
  style,
}: BottomSheetBackdropProps) => {
  const theme = useTheme();

  const containerAnimatedStyle = useAnimatedStyle(() => ({
    opacity: interpolate(
      animatedIndex.value,
      [-1, 0],
      [0, 1],
      Extrapolation.CLAMP,
    ),
  }));

  const containerStyle = useMemo(
    () => [
      style,
      {
        backgroundColor: theme.colors.backdrop,
      },
      containerAnimatedStyle,
    ],
    [style, containerAnimatedStyle, theme.colors.backdrop],
  );

  return (
    <BottomSheetBackdrop
      animatedIndex={animatedIndex}
      animatedPosition={animatedPosition}
      disappearsOnIndex={-1}
      style={containerStyle}
    />
  );
};



================================================
FILE: src/components/Sheet/index.ts
================================================
export * from './Sheet';



================================================
FILE: src/components/Sheet/Sheet.tsx
================================================
import {
  BottomSheetModal,
  BottomSheetModalProps,
  BottomSheetView,
} from '@gorhom/bottom-sheet';
import React, {forwardRef, useEffect, useMemo, useRef} from 'react';
import {useSafeAreaInsets} from 'react-native-safe-area-context';
import {BottomSheetModalMethods} from '@gorhom/bottom-sheet/lib/typescript/types';
import {Text} from 'react-native-paper';
import {CloseIcon} from '../../assets/icons';
import {useTheme} from '../../hooks';
import {styles} from './styles';
import BottomSheetKeyboardAwareScrollView from './BottomSheetAwareScrollview';
import {Dimensions, TouchableOpacity, View} from 'react-native';
import {CustomBackdrop} from './CustomBackdrop';
import {Actions} from './Actions';

export interface SheetProps extends Partial<BottomSheetModalProps> {
  children?: React.ReactNode;
  title?: string;
  isVisible?: boolean;
  onClose?: () => void;
  displayFullHeight?: boolean;
}

interface SheetComponent
  extends React.ForwardRefExoticComponent<
    SheetProps & React.RefAttributes<BottomSheetModalMethods>
  > {
  ScrollView: typeof BottomSheetKeyboardAwareScrollView;
  View: typeof BottomSheetView;
  Actions: typeof Actions;
}

export const Sheet = forwardRef(
  (
    {
      children,
      title,
      isVisible,
      displayFullHeight,
      onClose,
      ...props
    }: SheetProps,
    ref: React.Ref<BottomSheetModalMethods>,
  ) => {
    const insets = useSafeAreaInsets();
    const innerRef = useRef<BottomSheetModalMethods>(null);

    const activeRef = useMemo(() => {
      if (ref && 'current' in ref && ref.current) {
        return ref;
      }
      return innerRef;
    }, [ref, innerRef]);

    const theme = useTheme();

    useEffect(() => {
      if (isVisible) {
        activeRef?.current?.present();
      } else {
        activeRef?.current?.close();
      }
    }, [isVisible, activeRef]);

    const onDismiss = () => {
      activeRef?.current?.close();
      onClose?.();
    };

    const snapPoints = useMemo(() => {
      if (displayFullHeight) {
        return [Dimensions.get('screen').height - insets.top - 16];
      }
      return props.snapPoints;
    }, [displayFullHeight, insets, props.snapPoints]);

    return (
      <BottomSheetModal
        ref={activeRef}
        maxDynamicContentSize={
          Dimensions.get('screen').height - insets.top - 16
        }
        enableDynamicSizing={!snapPoints}
        stackBehavior="push"
        backdropComponent={CustomBackdrop}
        keyboardBlurBehavior="restore"
        activeOffsetY={[-1, 1]}
        failOffsetX={[-5, 5]}
        backgroundStyle={{
          backgroundColor: theme.colors.background,
        }}
        handleIndicatorStyle={{
          backgroundColor: theme.colors.primary,
        }}
        snapPoints={snapPoints}
        onDismiss={onDismiss}
        {...props}>
        <View style={styles.header}>
          {title && <Text variant="titleMedium">{title}</Text>}
          <TouchableOpacity
            style={styles.closeBtn}
            onPress={onDismiss}
            hitSlop={10}>
            <CloseIcon stroke={theme.colors.primary} />
          </TouchableOpacity>
        </View>
        {children}
      </BottomSheetModal>
    );
  },
) as SheetComponent;

Sheet.displayName = 'Sheet';
Sheet.ScrollView = BottomSheetKeyboardAwareScrollView;
Sheet.View = BottomSheetView;
Sheet.Actions = Actions;



================================================
FILE: src/components/Sheet/styles.ts
================================================
import {StyleSheet} from 'react-native';

export const styles = StyleSheet.create({
  container: {
    position: 'relative',
  },
  closeBtn: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  header: {
    marginHorizontal: 16,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
  },
});



================================================
FILE: src/components/Sheet/__tests__/Actions.test.tsx
================================================
import React from 'react';
import {render} from '@testing-library/react-native';
import {Actions} from '../Actions';
import {Text} from 'react-native';

describe('Actions', () => {
  it('renders children correctly', () => {
    const {getByText} = render(
      <Actions>
        <Text>Cancel</Text>
        <Text>Save</Text>
      </Actions>,
    );

    expect(getByText('Cancel')).toBeTruthy();
    expect(getByText('Save')).toBeTruthy();
  });
});



================================================
FILE: src/components/SidebarContent/index.ts
================================================
export * from './SidebarContent';



================================================
FILE: src/components/SidebarContent/SidebarContent.tsx
================================================
import React, {useContext, useEffect, useState} from 'react';
import {TouchableOpacity, View, Alert} from 'react-native';
import {observer} from 'mobx-react';
import {Divider, Drawer, Text} from 'react-native-paper';
import {GestureHandlerRootView} from 'react-native-gesture-handler';
import {
  DrawerContentScrollView,
  DrawerContentComponentProps,
} from '@react-navigation/drawer';

import {useTheme} from '../../hooks';
import {createStyles} from './styles';
import {chatSessionStore, SessionMetaData} from '../../store';
import {Menu, RenameModal} from '..';
import {
  BenchmarkIcon,
  ChatIcon,
  EditIcon,
  ModelIcon,
  PalIcon,
  SettingsIcon,
  TrashIcon,
  AppInfoIcon,
} from '../../assets/icons';
import {L10nContext} from '../../utils';
import {ROUTES} from '../../utils/navigationConstants';

// Check if app is in debug mode
const isDebugMode = __DEV__;

export const SidebarContent: React.FC<DrawerContentComponentProps> = observer(
  props => {
    const [menuVisible, setMenuVisible] = useState<string | null>(null);
    const [menuPosition, setMenuPosition] = useState({x: 0, y: 0});
    const [sessionToRename, setSessionToRename] =
      useState<SessionMetaData | null>(null);

    const theme = useTheme();
    const styles = createStyles(theme);
    const l10n = useContext(L10nContext);

    useEffect(() => {
      chatSessionStore.loadSessionList();

      // Set localized date group names whenever the component mounts
      chatSessionStore.setDateGroupNames(
        l10n.components.sidebarContent.dateGroups,
      );
    }, [l10n.components.sidebarContent.dateGroups]);

    const openMenu = (sessionId: string, event: any) => {
      const {nativeEvent} = event;
      setMenuPosition({x: nativeEvent.pageX, y: nativeEvent.pageY});
      setMenuVisible(sessionId);
    };

    const closeMenu = () => setMenuVisible(null);

    const onPressDelete = (sessionId: string) => {
      if (sessionId) {
        Alert.alert(
          l10n.components.sidebarContent.deleteChatTitle,
          l10n.components.sidebarContent.deleteChatMessage,
          [
            {
              text: l10n.common.cancel,
              style: 'cancel',
            },
            {
              text: l10n.common.delete,
              style: 'destructive',
              onPress: async () => {
                chatSessionStore.resetActiveSession();
                await chatSessionStore.deleteSession(sessionId);
                closeMenu();
              },
            },
          ],
        );
      }
      closeMenu();
    };

    return (
      <GestureHandlerRootView style={styles.sidebarContainer}>
        <View style={styles.contentWrapper}>
          <DrawerContentScrollView {...props}>
            <Drawer.Section showDivider={false}>
              <Drawer.Item
                label={l10n.components.sidebarContent.menuItems.chat}
                icon={() => <ChatIcon stroke={theme.colors.primary} />}
                onPress={() => props.navigation.navigate(ROUTES.CHAT)}
                style={styles.menuDrawerItem}
              />
              <Drawer.Item
                label={l10n.components.sidebarContent.menuItems.models}
                icon={() => <ModelIcon stroke={theme.colors.primary} />}
                onPress={() => props.navigation.navigate(ROUTES.MODELS)}
                style={styles.menuDrawerItem}
              />
              <Drawer.Item
                label={l10n.components.sidebarContent.menuItems.pals}
                icon={() => <PalIcon stroke={theme.colors.primary} />}
                onPress={() => props.navigation.navigate(ROUTES.PALS)}
                style={styles.menuDrawerItem}
              />
              <Drawer.Item
                label={l10n.components.sidebarContent.menuItems.benchmark}
                icon={() => <BenchmarkIcon stroke={theme.colors.primary} />}
                onPress={() => props.navigation.navigate(ROUTES.BENCHMARK)}
                style={styles.menuDrawerItem}
              />
              <Drawer.Item
                label={l10n.components.sidebarContent.menuItems.settings}
                icon={() => (
                  <SettingsIcon
                    width={24}
                    height={24}
                    stroke={theme.colors.primary}
                  />
                )}
                onPress={() => props.navigation.navigate(ROUTES.SETTINGS)}
                style={styles.menuDrawerItem}
              />

              <Drawer.Item
                label={l10n.components.sidebarContent.menuItems.appInfo}
                icon={() => (
                  <AppInfoIcon
                    width={24}
                    height={24}
                    stroke={theme.colors.primary}
                  />
                )}
                onPress={() => props.navigation.navigate(ROUTES.APP_INFO)}
                style={styles.menuDrawerItem}
              />

              {/* Only show Dev Tools in debug mode */}
              {isDebugMode && (
                <Drawer.Item
                  label="Dev Tools"
                  icon={() => (
                    <SettingsIcon
                      width={24}
                      height={24}
                      stroke={theme.colors.primary}
                    />
                  )}
                  onPress={() => props.navigation.navigate(ROUTES.DEV_TOOLS)}
                  style={styles.menuDrawerItem}
                />
              )}
            </Drawer.Section>
            <Divider style={styles.divider} />
            {/* Loop over the session groups and render them */}
            {Object.entries(chatSessionStore.groupedSessions).map(
              ([dateLabel, sessions]) => (
                <View key={dateLabel} style={styles.drawerSection}>
                  <Text variant="bodySmall" style={styles.dateLabel}>
                    {dateLabel}
                  </Text>
                  {sessions.map(session => {
                    const isActive =
                      chatSessionStore.activeSessionId === session.id;
                    return (
                      <View key={session.id} style={styles.sessionItem}>
                        <TouchableOpacity
                          onPress={() => {
                            chatSessionStore.setActiveSession(session.id);
                            props.navigation.navigate(ROUTES.CHAT);
                          }}
                          onLongPress={event => openMenu(session.id, event)}
                          style={styles.sessionTouchable}>
                          <Drawer.Item
                            active={isActive}
                            label={session.title}
                            style={styles.sessionDrawerItem}
                          />
                        </TouchableOpacity>

                        {/* Menu for the session item */}
                        <Menu
                          visible={menuVisible === session.id}
                          onDismiss={closeMenu}
                          anchor={menuPosition}
                          style={styles.menu}
                          contentStyle={{}}
                          anchorPosition="bottom">
                          <Menu.Item
                            onPress={() => {
                              setSessionToRename(session);
                              closeMenu();
                            }}
                            label={l10n.common.rename}
                            leadingIcon={() => (
                              <EditIcon stroke={theme.colors.primary} />
                            )}
                          />
                          <Menu.Item
                            onPress={() => onPressDelete(session.id)}
                            label={l10n.common.delete}
                            labelStyle={{color: theme.colors.error}}
                            leadingIcon={() => (
                              <TrashIcon stroke={theme.colors.error} />
                            )}
                          />
                        </Menu>
                      </View>
                    );
                  })}
                </View>
              ),
            )}
          </DrawerContentScrollView>
        </View>
        <RenameModal
          visible={sessionToRename !== null}
          onClose={() => setSessionToRename(null)}
          session={sessionToRename}
        />
      </GestureHandlerRootView>
    );
  },
);



================================================
FILE: src/components/SidebarContent/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {MD3Theme} from 'react-native-paper';

export const createStyles = (theme: MD3Theme) =>
  StyleSheet.create({
    sidebarContainer: {
      flex: 1,
      backgroundColor: theme.colors.surface,
    },
    divider: {
      marginHorizontal: 16,
      backgroundColor: theme.colors.onSurfaceVariant,
      height: 1,
      opacity: 0.1,
    },
    contentWrapper: {
      flex: 1,
      display: 'flex',
      flexDirection: 'column',
    },
    sessionDrawerItem: {
      height: 40,
    },
    menuDrawerItem: {
      height: 44,
    },
    versionText: {
      color: theme.colors.onSurfaceVariant,
      opacity: 0.7,
      fontSize: 12,
      fontWeight: '500',
    },
    drawerSection: {
      marginTop: 10,
    },
    dateLabel: {
      paddingLeft: 16,
      paddingVertical: 10,
    },
    scrollViewContent: {
      flexGrow: 1,
      minHeight: '100%',
    },
    mainContent: {
      flex: 1,
    },
    menu: {
      width: 170,
    },
    sessionItem: {
      position: 'relative',
    },
    sessionTouchable: {
      flex: 1,
    },
  });



================================================
FILE: src/components/SidebarContent/__tests__/SidebarContent.test.tsx
================================================
import React from 'react';
import {Text} from 'react-native';

import {NavigationContainer} from '@react-navigation/native';
import {
  createDrawerNavigator,
  DrawerContentComponentProps,
} from '@react-navigation/drawer';
import {render, fireEvent} from '@testing-library/react-native';

import {SidebarContent} from '../SidebarContent';

import {chatSessionStore} from '../../../store';

const ChatScreen = () => <Text>Chat Screen</Text>;
const ModelsScreen = () => <Text>Models Screen</Text>;
const SettingsScreen = () => <Text>Settings Screen</Text>;

const Drawer = createDrawerNavigator();

const renderSidebarContent = (props: DrawerContentComponentProps) => (
  <SidebarContent {...props} />
);

const TestNavigator = () => (
  <NavigationContainer>
    <Drawer.Navigator
      useLegacyImplementation={false}
      drawerContent={renderSidebarContent}>
      <Drawer.Screen name="Chat" component={ChatScreen} />
      <Drawer.Screen name="Models" component={ModelsScreen} />
      <Drawer.Screen name="Settings" component={SettingsScreen} />
    </Drawer.Navigator>
  </NavigationContainer>
);

describe('SidebarContent Component', () => {
  it('calls loadSessionList on mount', () => {
    render(<TestNavigator />);

    // loadSessionList is called when the component mounts
    expect(chatSessionStore.loadSessionList).toHaveBeenCalledTimes(1);
  });

  it('renders session groups and items correctly', () => {
    const {getByText} = render(<TestNavigator />);

    expect(getByText('Today')).toBeTruthy();
    expect(getByText('Yesterday')).toBeTruthy();

    expect(getByText('Session 1')).toBeTruthy();
    expect(getByText('Session 2')).toBeTruthy();
  });

  it('navigates to Chat screen when a session is pressed', () => {
    const {getByText, queryByText} = render(<TestNavigator />);

    // Navigate to a differnet page (as the default is chat screen)
    fireEvent.press(getByText('Models'));
    expect(queryByText('Chat Screen')).toBeNull();
    expect(getByText('Models Screen')).toBeTruthy();

    // Pressing a session should navigate to the Chat screen
    fireEvent.press(getByText('Session 1'));
    expect(getByText('Chat Screen')).toBeTruthy();
  });

  it('navigates to correct screen from drawer items', () => {
    const {getByText, queryByText} = render(<TestNavigator />);

    // Ensure the Models screen is rendered by pressing the 'Models' drawer item
    fireEvent.press(getByText('Models'));
    expect(getByText('Models Screen')).toBeTruthy();
    expect(queryByText('Chat Screen')).toBeNull();

    // Ensure the Settings screen is rendered by pressing the 'Settings' drawer item
    fireEvent.press(getByText('Settings'));
    expect(getByText('Settings Screen')).toBeTruthy();
    expect(queryByText('Models Screen')).toBeNull();
  });
});



================================================
FILE: src/components/SkillsDisplay/index.ts
================================================
export {SkillsDisplay} from './SkillsDisplay';



================================================
FILE: src/components/SkillsDisplay/SkillsDisplay.tsx
================================================
import React from 'react';
import {View, TouchableOpacity} from 'react-native';
import {Text, IconButton} from 'react-native-paper';

import {useTheme} from '../../hooks';
import {getModelSkills, SkillItem} from '../../utils';
import {L10nContext} from '../../utils';

import {createStyles} from './styles';

interface SkillsDisplayProps {
  model: {
    capabilities?: string[];
    supportsMultimodal?: boolean;
  };
  onVisionPress?: () => void;
  showLabel?: boolean;
  compact?: boolean;
  hasProjectionModelWarning?: boolean;
  onProjectionWarningPress?: () => void;
  visionEnabled?: boolean; // Whether vision is enabled for this model
  visionAvailable?: boolean; // Whether vision is available (projection model downloaded)
}

export const SkillsDisplay: React.FC<SkillsDisplayProps> = ({
  model,
  onVisionPress,
  showLabel = true,
  compact = false,
  hasProjectionModelWarning = false,
  onProjectionWarningPress,
  visionEnabled = true,
  // TODO: we need to find out if we need this?
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  visionAvailable = true,
}) => {
  const l10n = React.useContext(L10nContext);
  const theme = useTheme();
  const styles = createStyles(theme, compact);

  const skills = getModelSkills(model);

  if (!skills.length) {
    return null;
  }

  const renderSkillItem = (skill: SkillItem) => {
    const isVision = skill.key === 'vision';
    const isClickable = isVision && onVisionPress;

    // Determine vision badge state and color
    let color = theme.colors[skill.color || 'primary'];
    let iconName = skill.icon;

    if (isVision) {
      if (!visionEnabled) {
        // Vision disabled - use muted color and different icon
        color = theme.colors.textSecondary;
        iconName = 'eye-off';
        /* } else if (!visionAvailable) {
       //   // Vision enabled but not available - use warning color
       //   color = theme.colors.error;
         iconName = 'eye-off'; */
      } else {
        // Vision enabled and available - use primary color
        color = color;
        iconName = 'eye';
      }
    }

    const showWarning = isVision && hasProjectionModelWarning;

    // Get localized label
    const label =
      l10n.models.modelCapabilities[
        skill.labelKey as keyof typeof l10n.models.modelCapabilities
      ] || skill.labelKey;

    const skillContent = (
      <View style={[styles.skillItem, skill.isSpecial && styles.specialSkill]}>
        {(skill.icon || iconName) && (
          <IconButton
            icon={(iconName || skill.icon) as string}
            size={compact ? 10 : 12}
            iconColor={color}
            style={styles.skillIcon}
          />
        )}
        <Text
          style={[
            styles.skillText,
            skill.isSpecial && styles.specialSkillText,
            {color},
          ]}>
          {label}
        </Text>
        {/* Show warning badge for vision skill when projection model is missing */}
        {showWarning && (
          <TouchableOpacity
            testID="projection-warning-badge"
            onPress={onProjectionWarningPress}
            style={styles.warningBadge}
            activeOpacity={0.7}>
            <View style={styles.warningContent}>
              <IconButton
                icon="alert-circle"
                size={compact ? 12 : 14}
                iconColor={theme.colors.error}
                style={styles.warningIcon}
              />
              <Text variant="labelSmall" style={styles.warningText}>
                {l10n.models.multimodal.projectionMissingShort}
              </Text>
            </View>
          </TouchableOpacity>
        )}
      </View>
    );

    if (isClickable) {
      return (
        <TouchableOpacity
          testID="vision-skill-touchable"
          key={skill.key}
          onPress={onVisionPress}
          activeOpacity={0.7}>
          {skillContent}
        </TouchableOpacity>
      );
    }

    return <View key={skill.key}>{skillContent}</View>;
  };

  const renderSkillsText = () => {
    const textSkills = skills.filter(skill => !skill.isSpecial);
    if (!textSkills.length) {
      return null;
    }

    const hasSpecialSkills = skills.some(skill => skill.isSpecial);
    const prefix = hasSpecialSkills ? '‚Ä¢ ' : '';

    return (
      <Text style={styles.skillsText}>
        {prefix}
        {textSkills
          .map(skill => {
            const label =
              l10n.models.modelCapabilities[
                skill.labelKey as keyof typeof l10n.models.modelCapabilities
              ] || skill.labelKey;
            return label;
          })
          .join(', ')}
      </Text>
    );
  };

  return (
    <TouchableOpacity
      style={styles.container}
      onPress={model.supportsMultimodal ? onVisionPress : undefined}
      activeOpacity={model.supportsMultimodal ? 0.7 : 1}>
      <View style={styles.skillsRow}>
        {showLabel && (
          <Text style={styles.skillsLabel}>
            {l10n.models.modelCard.labels.skills}
          </Text>
        )}

        {/* Render special skills (like vision) with icons */}
        {skills
          .filter(skill => skill.isSpecial)
          .map(skill => renderSkillItem(skill))}

        {/* Render regular skills as text */}
        {renderSkillsText()}
      </View>
    </TouchableOpacity>
  );
};



================================================
FILE: src/components/SkillsDisplay/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {Theme} from '../../utils/types';

export const createStyles = (theme: Theme, compact: boolean = false) =>
  StyleSheet.create({
    container: {
      marginTop: compact ? 2 : 4,
    },
    skillsRow: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      alignItems: 'center',
    },
    skillsLabel: {
      fontSize: compact ? 10 : 12,
      fontWeight: 'bold',
      color: theme.colors.primary,
      marginRight: 4,
    },
    skillItem: {
      flexDirection: 'row',
      alignItems: 'center',
      marginLeft: 4,
    },
    specialSkill: {
      // Additional styling for special skills like vision
    },
    skillIcon: {
      margin: 0,
      padding: 0,
      width: compact ? 14 : 16,
      height: compact ? 14 : 16,
      marginRight: 0,
    },
    skillText: {
      fontSize: compact ? 10 : 12,
      fontWeight: '600',
    },
    specialSkillText: {
      fontWeight: '600',
    },
    skillsText: {
      fontSize: compact ? 10 : 12,
      color: theme.colors.onSurfaceVariant,
      flexShrink: 1,
    },
    warningBadge: {
      marginLeft: 2,
      padding: 0,
    },
    warningIcon: {
      margin: 0,
      padding: 0,
      width: compact ? 14 : 16,
      height: compact ? 14 : 16,
    },
    warningContent: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    warningText: {
      fontSize: compact ? 10 : 12,
      color: theme.colors.error,
      marginLeft: 2,
    },
  });



================================================
FILE: src/components/StatusIcon/index.ts
================================================
export * from './StatusIcon';



================================================
FILE: src/components/StatusIcon/StatusIcon.tsx
================================================
import * as React from 'react';
import {Image, StyleSheet, View} from 'react-native';

import {CircularActivityIndicator} from '../CircularActivityIndicator';

import {MessageType, Theme} from '../../utils/types';

export const StatusIcon = React.memo(
  ({
    currentUserIsAuthor,
    showStatus,
    status,
    theme,
  }: {
    currentUserIsAuthor: boolean;
    showStatus: boolean;
    status?: MessageType.Any['status'];
    theme: Theme;
  }) => {
    let statusIcon: React.ReactNode | null = null;

    if (showStatus) {
      switch (status) {
        case 'delivered':
        case 'sent':
          statusIcon = theme.icons?.deliveredIcon?.() ?? (
            <Image
              source={require('../../assets/icon-delivered.png')}
              style={{tintColor: theme.colors.primary}}
              testID="DeliveredIcon"
            />
          );
          break;
        case 'error':
          statusIcon = theme.icons?.errorIcon?.() ?? (
            <Image
              source={require('../../assets/icon-error.png')}
              style={{tintColor: theme.colors.error}}
              testID="ErrorIcon"
            />
          );
          break;
        case 'seen':
          statusIcon = theme.icons?.seenIcon?.() ?? (
            <Image
              source={require('../../assets/icon-seen.png')}
              style={{tintColor: theme.colors.primary}}
              testID="SeenIcon"
            />
          );
          break;
        case 'sending':
          statusIcon = theme.icons?.sendingIcon?.() ?? (
            <CircularActivityIndicator color={theme.colors.primary} size={10} />
          );
          break;
        default:
          break;
      }
    }

    return currentUserIsAuthor ? (
      <View style={styles.container} testID="StatusIconContainer">
        {statusIcon}
      </View>
    ) : null;
  },
);

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    height: 16,
    justifyContent: 'center',
    paddingHorizontal: 4,
    width: 16,
  },
});



================================================
FILE: src/components/StatusIcon/__tests__/StatusIcon.test.tsx
================================================
import {render} from '@testing-library/react-native';
import * as React from 'react';
import {Image, View} from 'react-native';

import {lightTheme} from '../../../utils/theme';
import {StatusIcon} from '../StatusIcon';

describe('status icon', () => {
  it('should render null if show status is false', () => {
    expect.assertions(1);
    const {queryByTestId} = render(
      <StatusIcon
        currentUserIsAuthor={false}
        showStatus={false}
        theme={lightTheme}
      />,
    );
    expect(queryByTestId('StatusIconContainer')).toBeNull();
  });

  it('should render delivered icon', () => {
    expect.assertions(1);
    const {getByTestId} = render(
      <StatusIcon
        currentUserIsAuthor
        showStatus
        status="delivered"
        theme={lightTheme}
      />,
    );
    expect(getByTestId('DeliveredIcon')).toBeDefined();
  });

  it('should render delivered icon from theme', () => {
    expect.assertions(1);
    const {queryByTestId} = render(
      <StatusIcon
        currentUserIsAuthor
        showStatus
        status="delivered"
        theme={{
          ...lightTheme,
          icons: {
            deliveredIcon: () => (
              <Image source={require('../../../assets/icon-delivered.png')} />
            ),
          },
        }}
      />,
    );
    expect(queryByTestId('DeliveredIcon')).toBeNull();
  });

  it('should render delivered icon with sent status', () => {
    expect.assertions(1);
    const {getByTestId} = render(
      <StatusIcon
        currentUserIsAuthor
        showStatus
        status="sent"
        theme={lightTheme}
      />,
    );
    expect(getByTestId('DeliveredIcon')).toBeDefined();
  });

  it('should render delivered icon with sent status from theme', () => {
    expect.assertions(1);
    const {queryByTestId} = render(
      <StatusIcon
        currentUserIsAuthor
        showStatus
        status="sent"
        theme={{
          ...lightTheme,
          icons: {
            deliveredIcon: () => (
              <Image source={require('../../../assets/icon-delivered.png')} />
            ),
          },
        }}
      />,
    );
    expect(queryByTestId('DeliveredIcon')).toBeNull();
  });

  it('should render error icon', () => {
    expect.assertions(1);
    const {getByTestId} = render(
      <StatusIcon
        currentUserIsAuthor
        showStatus
        status="error"
        theme={lightTheme}
      />,
    );
    expect(getByTestId('ErrorIcon')).toBeDefined();
  });

  it('should render error icon from theme', () => {
    expect.assertions(1);
    const {queryByTestId} = render(
      <StatusIcon
        currentUserIsAuthor
        showStatus
        status="error"
        theme={{
          ...lightTheme,
          icons: {
            errorIcon: () => (
              <Image source={require('../../../assets/icon-error.png')} />
            ),
          },
        }}
      />,
    );
    expect(queryByTestId('ErrorIcon')).toBeNull();
  });

  it('should render seen icon', () => {
    expect.assertions(1);
    const {getByTestId} = render(
      <StatusIcon
        currentUserIsAuthor
        showStatus
        status="seen"
        theme={lightTheme}
      />,
    );
    expect(getByTestId('SeenIcon')).toBeDefined();
  });

  it('should render seen icon from theme', () => {
    expect.assertions(1);
    const {queryByTestId} = render(
      <StatusIcon
        currentUserIsAuthor
        showStatus
        status="seen"
        theme={{
          ...lightTheme,
          icons: {
            seenIcon: () => (
              <Image source={require('../../../assets/icon-seen.png')} />
            ),
          },
        }}
      />,
    );
    expect(queryByTestId('SeenIcon')).toBeNull();
  });

  it('should render activity indicator', () => {
    expect.assertions(1);
    const {getByTestId} = render(
      <StatusIcon
        currentUserIsAuthor
        showStatus
        status="sending"
        theme={lightTheme}
      />,
    );
    expect(getByTestId('CircularActivityIndicator')).toBeDefined();
  });

  it('should render sending icon from theme', () => {
    expect.assertions(1);
    const {queryByTestId} = render(
      <StatusIcon
        currentUserIsAuthor
        showStatus
        status="sending"
        theme={{
          ...lightTheme,
          icons: {
            sendingIcon: () => <View />,
          },
        }}
      />,
    );
    expect(queryByTestId('CircularActivityIndicator')).toBeNull();
  });
});



================================================
FILE: src/components/StopButton/index.ts
================================================
export * from './StopButton';



================================================
FILE: src/components/StopButton/StopButton.tsx
================================================
import * as React from 'react';
import {
  GestureResponderEvent,
  StyleSheet,
  TouchableOpacity,
  TouchableOpacityProps,
} from 'react-native';

import {useTheme} from '../../hooks';
import {StopIcon} from '../../assets/icons';

// import {L10nContext} from '../../utils';

export interface StopButtonPropsAdditionalProps {
  touchableOpacityProps?: TouchableOpacityProps;
}

export interface StopButtonProps extends StopButtonPropsAdditionalProps {
  /** Callback for stop button tap event */
  onPress?: () => void;
  color?: string;
}

export const StopButton = ({
  onPress,
  touchableOpacityProps,
  color,
}: StopButtonProps) => {
  // const l10n = React.useContext(L10nContext);
  const theme = useTheme();
  const handlePress = (event: GestureResponderEvent) => {
    if (onPress) {
      onPress();
    }
    touchableOpacityProps?.onPress?.(event);
  };

  return (
    <TouchableOpacity
      //accessibilityLabel={l10n.stopButtonAccessibilityLabel}
      accessibilityRole="button"
      testID="stop-button"
      {...touchableOpacityProps}
      onPress={handlePress}
      style={styles.stopButton}>
      <StopIcon
        stroke={color ?? theme.colors.background}
        width={24}
        height={24}
      />
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  stopButton: {
    marginLeft: 16,
    // Minimum 44pt touch target for accessibility
    minHeight: 40,
    minWidth: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
});



================================================
FILE: src/components/TextDivider/index.ts
================================================
export * from './TextDivider';



================================================
FILE: src/components/TextDivider/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {Theme} from '../../utils';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    container: {
      flexDirection: 'row',
      alignItems: 'center',
      marginVertical: 12,
    },
    line: {
      flex: 1,
      height: 1,
      backgroundColor: theme.colors.outline,
      opacity: 0.5,
    },
    text: {
      marginHorizontal: 12,
      color: theme.colors.onSurfaceVariant,
      fontSize: 14,
      fontWeight: '500',
    },
  });



================================================
FILE: src/components/TextDivider/TextDivider.tsx
================================================
import React from 'react';
import {View} from 'react-native';

import {Text} from 'react-native-paper';

import {useTheme} from '../../hooks';

import {createStyles} from './styles';

interface TextDividerProps {
  text: string;
  style?: any;
  textStyle?: any;
}

export const TextDivider: React.FC<TextDividerProps> = ({
  text,
  style,
  textStyle,
}) => {
  const theme = useTheme();
  const styles = createStyles(theme);

  return (
    <View style={[styles.container, style]}>
      <View style={styles.line} />
      <Text style={[styles.text, textStyle]}>{text}</Text>
      <View style={styles.line} />
    </View>
  );
};



================================================
FILE: src/components/TextInput/index.ts
================================================
export * from './TextInput';



================================================
FILE: src/components/TextInput/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {Theme} from '../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    container: {
      borderWidth: 1,
      borderColor: theme.colors.border,
      borderRadius: 10,
      borderTopStartRadius: 10,
      borderTopEndRadius: 10,
      alignSelf: 'stretch',
      backgroundColor: 'transparent',
    },
    input: {
      backgroundColor: 'transparent',
    },
    placeholder: {
      opacity: 0.3,
    },
    divider: {
      width: 330,
      height: 0.33,
      backgroundColor: theme.colors.outlineVariant,
      marginLeft: 20,
    },
  });



================================================
FILE: src/components/TextInput/TextInput.tsx
================================================
import React, {forwardRef} from 'react';
import {View, TextInput as RNTextInput} from 'react-native';

import {
  HelperText,
  TextInput as PaperTextInput,
  TextInputProps as PaperTextInputProps,
} from 'react-native-paper';

import {useTheme} from '../../hooks';

import {createStyles} from './styles';

export type TextInputProps = PaperTextInputProps & {
  error?: boolean;
  helperText?: string;
  showDivider?: boolean;
};

export const TextInput = forwardRef<RNTextInput, TextInputProps>(
  ({style, showDivider = false, error, helperText, ...rest}, ref) => {
    const theme = useTheme();
    const styles = createStyles(theme);
    const multilineStyle =
      rest.numberOfLines && rest.numberOfLines > 1
        ? {
            minHeight: rest.numberOfLines * 18,
            textAlignVertical: 'top',
          }
        : {};

    return (
      <View>
        <PaperTextInput
          ref={ref}
          {...rest}
          dense
          underlineColor={theme.colors.border}
          style={[styles.container, style]}
          contentStyle={multilineStyle as PaperTextInputProps['contentStyle']}
          placeholderTextColor={theme.colors.placeholder}
          error={error}
        />
        {helperText && (
          <HelperText type={error ? 'error' : 'info'} visible={!!helperText}>
            {helperText}
          </HelperText>
        )}
        {showDivider && <View style={styles.divider} />}
      </View>
    );
  },
);

TextInput.displayName = 'TextInput';



================================================
FILE: src/components/TextMessage/index.ts
================================================
export * from './TextMessage';



================================================
FILE: src/components/TextMessage/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {getUserAvatarNameColor} from '../../utils';
import {MessageType, Theme, User} from '../../utils/types';

export const styles = ({
  message,
  theme,
  user,
}: {
  message: MessageType.Text;
  theme: Theme;
  user?: User;
}) =>
  StyleSheet.create({
    descriptionText: {
      ...(user?.id === message.author.id
        ? theme.fonts.sentMessageLinkDescriptionTextStyle
        : theme.fonts.receivedMessageLinkDescriptionTextStyle),
      marginTop: 4,
    },
    headerText: {
      ...theme.fonts.userNameTextStyle,
      color: getUserAvatarNameColor(
        message.author,
        theme.colors.userAvatarNameColors,
      ),
      marginBottom: 6,
    },
    titleText: {
      ...(user?.id === message.author.id
        ? theme.fonts.sentMessageLinkTitleTextStyle
        : theme.fonts.receivedMessageLinkTitleTextStyle),
    },
    text: {
      ...(user?.id === message.author.id
        ? theme.fonts.sentMessageBodyTextStyle
        : theme.fonts.receivedMessageBodyTextStyle),
    },
    textContainer: {
      marginHorizontal: theme.insets.messageInsetsHorizontal,
      marginVertical: theme.insets.messageInsetsVertical,
    },
    imageContainer: {
      marginBottom: 8,
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: 8,
    },
    imageThumbnail: {
      width: 80,
      height: 80,
      borderRadius: 8,
      overflow: 'hidden',
      backgroundColor: theme.colors.surfaceVariant,
    },
    imageContent: {
      width: '100%',
      height: '100%',
    },
    imagePreviewModal: {
      flex: 1,
      backgroundColor: 'rgba(0, 0, 0, 0.9)',
      justifyContent: 'center',
      alignItems: 'center',
    },
    imagePreviewCloseButton: {
      position: 'absolute',
      top: 50,
      right: 20,
      zIndex: 1,
    },
    imagePreviewContent: {
      width: '100%',
      height: '80%',
    },
  });



================================================
FILE: src/components/TextMessage/TextMessage.tsx
================================================
import * as React from 'react';
import {
  Linking,
  Text,
  View,
  Image,
  TouchableOpacity,
  Modal,
} from 'react-native';
import {IconButton} from 'react-native-paper';

import ParsedText from 'react-native-parsed-text';
import {
  LinkPreview,
  PreviewData,
  REGEX_LINK,
} from '@flyerhq/react-native-link-preview';

import {useTheme} from '../../hooks';

import {styles} from './styles';
import {MarkdownView} from '../MarkdownView';

import {MessageType} from '../../utils/types';
import {
  excludeDerivedMessageProps,
  getUserName,
  UserContext,
} from '../../utils';

export interface TextMessageTopLevelProps {
  /** @see {@link LinkPreviewProps.onPreviewDataFetched} */
  onPreviewDataFetched?: ({
    message,
    previewData,
  }: {
    message: MessageType.Text;
    previewData: PreviewData;
  }) => void;
  /** Enables link (URL) preview */
  usePreviewData?: boolean;
}

export interface TextMessageProps extends TextMessageTopLevelProps {
  enableAnimation?: boolean;
  message: MessageType.DerivedText;
  messageWidth: number;
  showName: boolean;
}

export const TextMessage = ({
  enableAnimation,
  message,
  messageWidth,
  onPreviewDataFetched,
  showName,
  usePreviewData,
}: TextMessageProps) => {
  const theme = useTheme();
  const user = React.useContext(UserContext);
  const [previewData, setPreviewData] = React.useState(message.previewData);
  const [selectedImageIndex, setSelectedImageIndex] = React.useState<
    number | null
  >(null);

  const {
    descriptionText,
    headerText,
    titleText,
    text,
    textContainer,
    imageContainer,
    imageThumbnail,
    imageContent,
    imagePreviewModal,
    imagePreviewCloseButton,
    imagePreviewContent,
  } = styles({
    message,
    theme,
    user,
  });

  // Extract imageUris from the message if available
  const imageUris = (message as any).imageUris || [];
  const hasImages = imageUris && imageUris.length > 0;

  const handleEmailPress = (email: string) => {
    try {
      Linking.openURL(`mailto:${email}`);
    } catch {}
  };

  const handlePreviewDataFetched = (data: PreviewData) => {
    setPreviewData(data);
    onPreviewDataFetched?.({
      // It's okay to cast here since we know it is a text message
      // type-coverage:ignore-next-line
      message: excludeDerivedMessageProps(message) as MessageType.Text,
      previewData: data,
    });
  };

  const handleUrlPress = (url: string) => {
    const uri = url.toLowerCase().startsWith('http') ? url : `https://${url}`;

    Linking.openURL(uri);
  };

  const renderPreviewDescription = (description: string) => {
    return (
      <Text numberOfLines={3} style={descriptionText}>
        {description}
      </Text>
    );
  };

  const renderPreviewHeader = (header: string) => {
    return (
      <Text numberOfLines={1} style={headerText}>
        {header}
      </Text>
    );
  };

  const renderPreviewText = (previewText: string) => {
    return (
      <ParsedText
        accessibilityRole="link"
        parse={[
          {
            onPress: handleEmailPress,
            style: [text, {textDecorationLine: 'underline'}],
            type: 'email',
          },
          {
            onPress: handleUrlPress,
            pattern: REGEX_LINK,
            style: [text, {textDecorationLine: 'underline'}],
          },
        ]}
        style={text}>
        {previewText}
      </ParsedText>
    );
  };

  const renderPreviewTitle = (title: string) => {
    return (
      <Text numberOfLines={2} style={titleText}>
        {title}
      </Text>
    );
  };

  // Render image thumbnails
  const renderImages = () => {
    if (!hasImages) {
      return null;
    }

    return (
      <View style={imageContainer}>
        {imageUris.map((uri: string, index: number) => (
          <TouchableOpacity
            key={index}
            style={imageThumbnail}
            onPress={() => setSelectedImageIndex(index)}>
            <Image source={{uri}} style={imageContent} resizeMode="cover" />
          </TouchableOpacity>
        ))}
      </View>
    );
  };

  // Render image preview modal
  const renderImagePreview = () => {
    if (selectedImageIndex === null) {
      return null;
    }

    return (
      <Modal
        visible={selectedImageIndex !== null}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setSelectedImageIndex(null)}>
        <View style={imagePreviewModal}>
          <IconButton
            icon="close"
            size={24}
            iconColor="white"
            style={imagePreviewCloseButton}
            onPress={() => setSelectedImageIndex(null)}
          />
          <Image
            source={{uri: imageUris[selectedImageIndex]}}
            style={imagePreviewContent}
            resizeMode="contain"
          />
        </View>
      </Modal>
    );
  };

  return (
    <>
      {usePreviewData &&
      !!onPreviewDataFetched &&
      REGEX_LINK.test(message.text.toLowerCase()) ? (
        <LinkPreview
          containerStyle={{
            width: previewData?.image ? messageWidth : undefined,
          }}
          enableAnimation={enableAnimation}
          header={showName ? getUserName(message.author) : undefined}
          onPreviewDataFetched={handlePreviewDataFetched}
          previewData={previewData}
          renderDescription={renderPreviewDescription}
          renderHeader={renderPreviewHeader}
          renderText={renderPreviewText}
          renderTitle={renderPreviewTitle}
          text={message.text}
          textContainerStyle={textContainer}
          touchableWithoutFeedbackProps={{
            accessibilityRole: undefined,
            accessible: false,
            disabled: true,
          }}
        />
      ) : (
        <View style={textContainer}>
          {
            // Tested inside the link preview
            /* istanbul ignore next */ showName
              ? renderPreviewHeader(getUserName(message.author))
              : null
          }

          {/* Render images above the text */}
          {renderImages()}

          <MarkdownView
            markdownText={message.text.trim()}
            maxMessageWidth={messageWidth}
            selectable={false}
          />

          {/*Platform.OS === 'ios' ? (
            <TextInput
              multiline
              editable={false}
              style={[
                text,
                {
                  lineHeight: undefined,
                },
              ]}>
              {message.text.trim()}
            </TextInput>
          ) : (
            <Text selectable={true} style={text}>
              {message.text}
            </Text>
          )*/}
        </View>
      )}

      {/* Image preview modal */}
      {renderImagePreview()}
    </>
  );
};



================================================
FILE: src/components/TextMessage/__tests__/TextMessage.test.tsx
================================================
import * as utils from '@flyerhq/react-native-link-preview/lib/utils';
import {fireEvent, render, waitFor} from '@testing-library/react-native';
import * as React from 'react';
import {Linking} from 'react-native';

import {derivedTextMessage} from '../../../../jest/fixtures';
import {TextMessage} from '../TextMessage';

describe('text message', () => {
  // eslint-disable-next-line jest/no-disabled-tests
  it.skip('renders preview image and handles link press', async () => {
    const link = 'https://github.com/flyerhq/';
    const getPreviewDataMock = jest
      .spyOn(utils, 'getPreviewData')
      .mockResolvedValue({
        description: 'description',
        image: {
          height: 460,
          url: 'https://avatars2.githubusercontent.com/u/59206044',
          width: 460,
        },
        link,
        title: 'title',
      });
    const openUrlMock = jest.spyOn(Linking, 'openURL');
    const {getByRole, getByText, debug} = render(
      <TextMessage
        message={{
          ...derivedTextMessage,
          author: {id: 'newUserId', firstName: 'John'},
          text: link,
        }}
        messageWidth={440}
        onPreviewDataFetched={jest.fn}
        showName
        usePreviewData
      />,
    );
    debug();
    const image = getByRole('image');
    expect(image).toBeDefined();
    const text = getByText(link);
    fireEvent.press(text);
    expect(openUrlMock).toHaveBeenCalledWith(link);
    getPreviewDataMock.mockRestore();
    openUrlMock.mockRestore();
  });

  // eslint-disable-next-line jest/no-disabled-tests
  it.skip('renders preview image without https and handles link press', async () => {
    expect.assertions(2);
    const link = 'github.com/flyerhq/';
    const getPreviewDataMock = jest
      .spyOn(utils, 'getPreviewData')
      .mockResolvedValue({
        description: 'description',
        image: {
          height: 460,
          url: 'https://avatars2.githubusercontent.com/u/59206044',
          width: 460,
        },
        link,
        title: 'title',
      });
    const openUrlMock = jest.spyOn(Linking, 'openURL');
    const {getByRole, getByText} = render(
      <TextMessage
        message={{...derivedTextMessage, text: link}}
        messageWidth={440}
        onPreviewDataFetched={jest.fn}
        showName={false}
        usePreviewData
      />,
    );
    await waitFor(() => getByRole('image'));
    const image = getByRole('image');
    expect(image).toBeDefined();
    const text = getByText(link);
    fireEvent.press(text);
    expect(openUrlMock).toHaveBeenCalledWith('https://' + link);
    getPreviewDataMock.mockRestore();
    openUrlMock.mockRestore();
  });

  it('renders and handles email press', async () => {
    expect.assertions(1);
    const email = 'john@flyer.chat';
    const getPreviewDataMock = jest
      .spyOn(utils, 'getPreviewData')
      .mockResolvedValue({});
    const openUrlMock = jest.spyOn(Linking, 'openURL');
    const {getByText} = render(
      <TextMessage
        message={{
          ...derivedTextMessage,
          author: {id: 'newUserId', firstName: 'John'},
          text: email,
        }}
        messageWidth={440}
        onPreviewDataFetched={jest.fn}
        showName
        usePreviewData
      />,
    );
    await waitFor(() => getByText(email));
    const text = getByText(email);
    fireEvent.press(text);
    expect(openUrlMock).toHaveBeenCalledWith(`mailto:${email}`);
    getPreviewDataMock.mockRestore();
    openUrlMock.mockRestore();
  });
});



================================================
FILE: src/components/ThinkingBubble/index.ts
================================================
export * from './ThinkingBubble';



================================================
FILE: src/components/ThinkingBubble/styles.ts
================================================
import {StyleSheet, Platform} from 'react-native';
import {Theme} from '../../utils/types';

export const createStyles = (theme: Theme) => {
  const bubbleBackground = theme.colors.thinkingBubbleBackground;
  const bubbleBorderColor = theme.colors.thinkingBubbleBorder;
  const textColor = theme.colors.thinkingBubbleText;
  const shadowColor = theme.colors.thinkingBubbleShadow;

  return StyleSheet.create({
    shadowContainer: {
      ...Platform.select({
        ios: {
          shadowColor: shadowColor,
          shadowOffset: {width: 0, height: 2},
          shadowOpacity: 0.4,
          shadowRadius: 12,
        },
        android: {
          // No need here, shadows come from elevation in the inner container
        },
      }),
    },
    container: {
      marginVertical: 16, // Increased margin for better elevation appearance
      borderRadius: 20,
      overflow: 'hidden',
      backgroundColor: bubbleBackground,
      borderWidth: 1,
      borderColor: bubbleBorderColor,
      // Platform-specific styles to ensure consistent layout behavior
      ...Platform.select({
        ios: {
          // No need here, shadows come from parrent container - overflow: 'hidden', will hide the shadow
        },
        android: {
          elevation: 8, // Moderate elevation
        },
      }),
    },
    collapsedContainer: {
      height: 30, // Reduced height for more compact appearance
      width: 140,
      alignSelf: 'flex-start',
      opacity: 0.65, // Slightly reduced opacity
      justifyContent: 'center',
      // Reduced shadow/elevation for collapsed state
      ...Platform.select({
        ios: {
          shadowOpacity: 0.2, // Reduced shadow
          shadowRadius: 6, // Smaller shadow radius
        },
        android: {
          elevation: 1, // Reduced elevation
        },
      }),
    },
    partialContainer: {
      height: 150,
    },
    headerContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 16,
      paddingVertical: 8,
      borderBottomWidth: 0,
      backgroundColor: 'transparent',
    },
    collapsedHeaderContainer: {
      paddingHorizontal: 14,
      paddingVertical: 6,
      alignItems: 'center',
    },
    headerText: {
      color: textColor,
      letterSpacing: 0.5,
    },
    chevronContainer: {
      width: 28,
      height: 28,
      alignItems: 'center',
      justifyContent: 'center',
      borderRadius: 14,
      backgroundColor: theme.colors.thinkingBubbleChevronBackground,
      borderWidth: 1,
      borderColor: theme.colors.thinkingBubbleChevronBorder,
    },
    collapsedChevronContainer: {
      width: 20,
      height: 20,
      borderRadius: 10,
    },
    contentContainer: {
      paddingHorizontal: 16,
      paddingBottom: 16,
      backgroundColor: 'transparent',
      borderRadius: 0,
    },
    // Absolute fill style for BlurView
    absoluteFill: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
    },
    maskedContentContainer: {
      flex: 1,
      position: 'relative',
      overflow: 'hidden',
      borderRadius: 0,
    },
    maskElementContainer: {
      flex: 1,
    },
    maskGradient: {
      height: 30,
      width: '100%',
    },
    maskSolid: {
      flex: 1,
      backgroundColor: 'black',
    },
  });
};



================================================
FILE: src/components/ThinkingBubble/ThinkingBubble.tsx
================================================
import React, {useState, useRef, useEffect, useContext} from 'react';
import {
  View,
  TouchableOpacity,
  Animated,
  Easing,
  ScrollView,
  LayoutAnimation,
  Platform,
  UIManager,
} from 'react-native';

import {Text} from 'react-native-paper';
import LinearGradient from 'react-native-linear-gradient';
import MaskedView from '@react-native-masked-view/masked-view';
import {ChevronDownIcon} from '../../assets/icons';

import {useTheme} from '../../hooks';
import {L10nContext} from '../../utils';

import {createStyles} from './styles';

// Enable LayoutAnimation for Android
if (
  Platform.OS === 'android' &&
  UIManager.setLayoutAnimationEnabledExperimental
) {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

enum BubbleState {
  COLLAPSED = 'collapsed',
  PARTIAL = 'partial',
  EXPANDED = 'expanded',
}

interface ThinkingBubbleProps {
  children?: React.ReactNode;
}

export const ThinkingBubble: React.FC<ThinkingBubbleProps> = ({children}) => {
  const theme = useTheme();
  const l10n = useContext(L10nContext);
  const styles = createStyles(theme);

  const [bubbleState, setBubbleState] = useState<BubbleState>(
    BubbleState.PARTIAL,
  );

  // Track animation state to optimize rendering
  const [isAnimating, setIsAnimating] = useState(false);

  const chevronRotation = useRef(new Animated.Value(0)).current;

  // Reference to the ScrollView for auto-scrolling
  const scrollViewRef = useRef<ScrollView>(null);

  const toggleState = () => {
    const isCollapsingTransition =
      bubbleState === BubbleState.EXPANDED ||
      bubbleState === BubbleState.PARTIAL;

    // Set animation flag to optimize rendering during transitions
    setIsAnimating(true);

    if (isCollapsingTransition) {
      // When collapsing, use a spring animation with bounce
      LayoutAnimation.configureNext(
        {
          duration: 450, // Longer duration
          create: {
            type: LayoutAnimation.Types.spring,
            property: LayoutAnimation.Properties.opacity,
            springDamping: 0.7, // Less damping for more bounce
          },
          update: {
            type: LayoutAnimation.Types.spring, // Bring back the spring for collapse
            springDamping: 0.7, // Less damping for more bounce
            initialVelocity: 0.5, // Higher initial velocity for more spring effect
          },
          delete: {
            type: LayoutAnimation.Types.spring,
            property: LayoutAnimation.Properties.opacity,
            springDamping: 0.7,
          },
        },
        () => {
          // Force a layout update after animation completes
          requestAnimationFrame(() => {
            // Mark animation as complete
            setIsAnimating(false);
          });
        },
      );
    } else {
      // When expanding, use a slower, more gradual animation
      LayoutAnimation.configureNext(
        {
          duration: 500, // Much longer duration for smoother expansion
          create: {
            type: LayoutAnimation.Types.easeInEaseOut,
            property: LayoutAnimation.Properties.opacity,
            //delay: 100, // Delay creation slightly
          },
          update: {
            type: LayoutAnimation.Types.spring,
            springDamping: 0.85, // Higher damping for less bounce
            initialVelocity: 0.3, // Lower initial velocity for gentler start
          },
        },
        // Add completion callback
        () => {
          requestAnimationFrame(() => {
            // Mark animation as complete
            setIsAnimating(false);
          });
        },
      );
    }

    // Update state
    switch (bubbleState) {
      case BubbleState.COLLAPSED:
        setBubbleState(BubbleState.PARTIAL);
        animateChevron(90);
        break;
      case BubbleState.PARTIAL:
        setBubbleState(BubbleState.EXPANDED);
        animateChevron(180);
        break;
      case BubbleState.EXPANDED:
        setBubbleState(BubbleState.COLLAPSED);
        animateChevron(0);
        break;
    }
  };

  // Animate chevron rotation with spring effect for collapsing
  const animateChevron = (toValue: number) => {
    // Determine if we're rotating to collapsed state (0 degrees)
    const isCollapsingRotation = toValue === 0;

    if (isCollapsingRotation) {
      // Use spring animation for collapsing to match the layout spring
      Animated.spring(chevronRotation, {
        toValue,
        friction: 8, // Lower friction for more bounce
        tension: 40, // Lower tension for more natural spring
        useNativeDriver: true,
      }).start();
    } else {
      // Use timing for expanding for more control
      Animated.timing(chevronRotation, {
        toValue,
        duration: 600, // Match the layout animation duration
        easing: Easing.bezier(0.2, 0, 0.2, 1), // Material standard for expand
        useNativeDriver: true,
      }).start();
    }
  };

  // Chevron rotation for each state
  const chevronRotationDeg = chevronRotation.interpolate({
    inputRange: [0, 90, 180],
    outputRange: ['0deg', '90deg', '180deg'],
  });

  const containerStyle = [
    styles.container,
    bubbleState === BubbleState.COLLAPSED && styles.collapsedContainer,
    bubbleState === BubbleState.PARTIAL && styles.partialContainer,
    bubbleState === BubbleState.EXPANDED && {},
  ];

  const isScrollable = bubbleState === BubbleState.PARTIAL;

  const isContentVisible = bubbleState !== BubbleState.COLLAPSED;

  // Scale animation for chevron on tap
  const chevronScale = useRef(new Animated.Value(1)).current;

  // Auto-scroll to the bottom when content changes
  useEffect(() => {
    // Only auto-scroll if we're in the partial state (scrollable)
    if (isScrollable && scrollViewRef.current) {
      // Use setTimeout to ensure the content has been rendered
      setTimeout(() => {
        scrollViewRef.current?.scrollToEnd({animated: true});
      }, 100);
    }
  }, [children, isScrollable]); // Re-run when children or scrollable state changes

  // Animate chevron scale on state change
  const animateChevronScale = () => {
    // Determine if we're transitioning to collapsed state
    const isCollapsingTransition =
      bubbleState === BubbleState.EXPANDED ||
      bubbleState === BubbleState.PARTIAL;

    if (isCollapsingTransition) {
      // More spring-like scale effect when collapsing
      Animated.sequence([
        Animated.timing(chevronScale, {
          toValue: 1.2, // Moderate scale
          duration: 200, // Slightly faster for more responsive feel
          easing: Easing.out(Easing.cubic), // Cubic easing for quick expansion
          useNativeDriver: true,
        }),
        Animated.spring(chevronScale, {
          toValue: 1,
          friction: 7,
          tension: 40,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      // Very subtle scale effect when expanding
      Animated.sequence([
        Animated.timing(chevronScale, {
          toValue: 1.1,
          duration: 250,
          easing: Easing.bezier(0.4, 0, 0.2, 1),
          useNativeDriver: true,
        }),
        Animated.timing(chevronScale, {
          toValue: 1,
          duration: 350,
          easing: Easing.bezier(0, 0, 0.2, 1),
          useNativeDriver: true,
        }),
      ]).start();
    }
  };

  const handlePress = () => {
    toggleState();
    animateChevronScale();
  };

  return (
    <TouchableOpacity
      style={bubbleState !== BubbleState.COLLAPSED && styles.shadowContainer}
      activeOpacity={0.9}
      onPress={handlePress}>
      <View style={containerStyle}>
        {/* Header */}
        <View
          style={[
            styles.headerContainer,
            bubbleState === BubbleState.COLLAPSED &&
              styles.collapsedHeaderContainer,
          ]}>
          <Text variant="titleSmall" style={styles.headerText}>
            {l10n.components.thinkingBubble.reasoning}
          </Text>
          <Animated.View
            style={[
              styles.chevronContainer,
              bubbleState === BubbleState.COLLAPSED &&
                styles.collapsedChevronContainer, // Smaller chevron in collapsed state
              {
                transform: [
                  {rotate: chevronRotationDeg},
                  {scale: chevronScale},
                ],
              },
            ]}>
            <ChevronDownIcon
              testID="chevron-icon"
              width={bubbleState === BubbleState.COLLAPSED ? 16 : 18}
              height={bubbleState === BubbleState.COLLAPSED ? 16 : 18}
              stroke={theme.colors.thinkingBubbleText}
            />
          </Animated.View>
        </View>

        {/* Content */}
        {isContentVisible && (
          <>
            {/* When animating from collapsed to partial, use a simpler view for better performance */}
            {isScrollable && isAnimating ? (
              // Simple ScrollView without MaskedView during animation for better performance
              <ScrollView
                ref={scrollViewRef}
                style={styles.contentContainer}
                showsVerticalScrollIndicator={false}
                onContentSizeChange={() =>
                  scrollViewRef.current?.scrollToEnd({animated: true})
                }>
                {children}
              </ScrollView>
            ) : isScrollable ? (
              // Use MaskedView only when not animating from collapsed to partial
              <MaskedView
                testID="masked-view"
                style={styles.maskedContentContainer}
                maskElement={
                  <View style={styles.maskElementContainer}>
                    {/* This gradient is used as a mask - transparent areas will be see-through */}
                    <LinearGradient
                      style={styles.maskGradient}
                      colors={['transparent', 'black']}
                      pointerEvents="none"
                    />
                    {/* Solid black below the gradient ensures the rest of the content is fully visible */}
                    <View style={styles.maskSolid} />
                  </View>
                }>
                {/* The actual content that will be masked */}
                <ScrollView
                  ref={scrollViewRef}
                  style={styles.contentContainer}
                  showsVerticalScrollIndicator={false}
                  onContentSizeChange={() =>
                    scrollViewRef.current?.scrollToEnd({animated: true})
                  }>
                  {children}
                </ScrollView>
              </MaskedView>
            ) : (
              <View style={styles.contentContainer}>{children}</View>
            )}
          </>
        )}
      </View>
    </TouchableOpacity>
  );
};



================================================
FILE: src/components/ThinkingBubble/__tests__/ThinkingBubble.test.tsx
================================================
import React from 'react';
import {Text} from 'react-native';
import {render, fireEvent} from '../../../../jest/test-utils';
import {ThinkingBubble} from '../ThinkingBubble';
import {L10nContext} from '../../../utils';
import {l10n} from '../../../utils/l10n';
import {LayoutAnimation} from 'react-native';
import {Animated} from 'react-native';

describe('ThinkingBubble', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    jest.useFakeTimers();
    jest.spyOn(LayoutAnimation, 'configureNext').mockImplementation(jest.fn());
    jest.spyOn(Animated, 'timing').mockImplementation(() => ({
      start: jest.fn(),
      stop: jest.fn(),
      reset: jest.fn(),
    }));

    jest.spyOn(Animated, 'spring').mockImplementation(() => ({
      start: jest.fn(),
      stop: jest.fn(),
      reset: jest.fn(),
    }));
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  const renderThinkingBubble = (children = 'Test thinking content') => {
    return render(
      <L10nContext.Provider value={l10n.en}>
        <ThinkingBubble>
          <Text testID="thinking-content">{children}</Text>
        </ThinkingBubble>
      </L10nContext.Provider>,
      {withSafeArea: true},
    );
  };

  it('renders correctly in initial PARTIAL state', () => {
    const {getByText, getByTestId} = renderThinkingBubble();

    // Check if the header text is rendered
    expect(getByText(l10n.en.components.thinkingBubble.reasoning)).toBeTruthy();

    expect(getByTestId('thinking-content')).toBeTruthy();

    // Check if the chevron icon is rendered
    expect(getByTestId('chevron-icon')).toBeTruthy();
  });

  it('transitions from PARTIAL to EXPANDED state when pressed', () => {
    const {getByText} = renderThinkingBubble();

    // Get the header text element which is part of the touchable component
    const headerText = getByText(l10n.en.components.thinkingBubble.reasoning);

    // Press the component to toggle state from PARTIAL to EXPANDED
    fireEvent.press(headerText);

    // In EXPANDED state, the content should still be visible
    // We can't directly test the state, but we can check if LayoutAnimation was called
    expect(LayoutAnimation.configureNext).toHaveBeenCalled();
  });

  it('transitions through all states when pressed multiple times', () => {
    const {getByText} = renderThinkingBubble();

    const headerText = getByText(l10n.en.components.thinkingBubble.reasoning);

    // First press: PARTIAL to EXPANDED
    fireEvent.press(headerText);
    expect(
      require('react-native').LayoutAnimation.configureNext,
    ).toHaveBeenCalledTimes(1);

    // Second press: EXPANDED to COLLAPSED
    fireEvent.press(headerText);
    expect(
      require('react-native').LayoutAnimation.configureNext,
    ).toHaveBeenCalledTimes(2);

    // Third press: COLLAPSED to PARTIAL
    fireEvent.press(headerText);
    expect(
      require('react-native').LayoutAnimation.configureNext,
    ).toHaveBeenCalledTimes(3);
  });

  it('animates the chevron when state changes', () => {
    const {getByText} = renderThinkingBubble();

    const headerText = getByText(l10n.en.components.thinkingBubble.reasoning);

    // Press to change state
    fireEvent.press(headerText);

    // Check if Animated.timing or Animated.spring was called for chevron animation
    const animatedTiming = require('react-native').Animated.timing;
    const animatedSpring = require('react-native').Animated.spring;
    expect(
      animatedTiming.mock.calls.length > 0 ||
        animatedSpring.mock.calls.length > 0,
    ).toBeTruthy();
  });

  it('auto-scrolls to the bottom when content changes', () => {
    const {rerender, getByTestId} = renderThinkingBubble('Initial content');

    // Advance timers to trigger the auto-scroll setTimeout
    jest.advanceTimersByTime(200);

    // Update the content
    rerender(
      <L10nContext.Provider value={l10n.en}>
        <ThinkingBubble>
          <Text testID="thinking-content">Updated content</Text>
        </ThinkingBubble>
      </L10nContext.Provider>,
    );

    // Advance timers again to trigger the auto-scroll for updated content
    jest.advanceTimersByTime(200);

    // Check if the content was updated
    expect(getByTestId('thinking-content').props.children).toBe(
      'Updated content',
    );
  });

  it('renders MaskedView in PARTIAL state when not animating', () => {
    const {getByTestId} = renderThinkingBubble();

    // In PARTIAL state and not animating, it should use MaskedView
    expect(getByTestId('masked-view')).toBeTruthy();
  });

  it('handles long content properly', () => {
    const longContent =
      'This is a very long content that should trigger scrolling behavior. '.repeat(
        20,
      );
    const {getByTestId} = renderThinkingBubble(longContent);

    // Check if the content is rendered
    expect(getByTestId('thinking-content')).toBeTruthy();
    expect(getByTestId('thinking-content').props.children).toBe(longContent);

    // Advance timers to trigger the auto-scroll
    jest.advanceTimersByTime(200);
  });
});



================================================
FILE: src/components/UsageStats/index.ts
================================================
export * from './UsageStats';



================================================
FILE: src/components/UsageStats/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {Theme} from '../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    container: {
      position: 'relative',
    },
    tooltip: {
      position: 'absolute',
      padding: 8,
      borderRadius: 4,
      backgroundColor: theme.colors.surface,
      elevation: 4,
      width: 120,
    },
    tooltipTitle: {
      color: theme.colors.primary,
      fontSize: 12,
      fontWeight: 'bold',
      marginBottom: 4,
    },
    tooltipText: {
      color: theme.colors.onSurface,
      fontSize: 10,
      marginBottom: 2,
    },
  });



================================================
FILE: src/components/UsageStats/UsageStats.tsx
================================================
import {View, TouchableWithoutFeedback, Text} from 'react-native';
import React, {
  useState,
  useEffect,
  useCallback,
  useMemo,
  useContext,
} from 'react';

import {Surface, Portal} from 'react-native-paper';
import DeviceInfo from 'react-native-device-info';
import {Svg, Path, Rect, Line} from 'react-native-svg';

import {useTheme} from '../../hooks';
import {L10nContext} from '../../utils';

import {createStyles} from './styles';

interface MemoryStats {
  totalMemory: number;
  usedMemory: number;
  percentage: number;
}

interface UsageStatsProps {
  width?: number;
  height?: number;
}

export const UsageStats: React.FC<UsageStatsProps> = ({
  width = 40,
  height = 20,
}) => {
  const [memoryHistory, setMemoryHistory] = useState<number[]>([]);
  const [showTooltip, setShowTooltip] = useState(false);
  const [memoryStats, setMemoryStats] = useState<MemoryStats>({
    totalMemory: 0,
    usedMemory: 0,
    percentage: 0,
  });
  const theme = useTheme();
  const l10n = useContext(L10nContext);

  const styles = useMemo(() => createStyles(theme), [theme]);

  const fetchMemoryStats = useCallback(async () => {
    try {
      const total = await DeviceInfo.getTotalMemory();
      const used = await DeviceInfo.getUsedMemory();
      const percentage = (used / total) * 100;
      setMemoryStats({totalMemory: total, usedMemory: used, percentage});
      setMemoryHistory(prev => [...prev.slice(-9), percentage]);
    } catch (error) {
      console.error('Failed to fetch memory stats:', error);
    }
  }, []);

  useEffect(() => {
    fetchMemoryStats();
    const intervalId = setInterval(fetchMemoryStats, 3000);
    return () => clearInterval(intervalId);
  }, [fetchMemoryStats]);

  const generatePath = useCallback(() => {
    if (memoryHistory.length < 2) {
      return '';
    }

    const points = memoryHistory.map((value, index) => {
      const x = (index / (memoryHistory.length - 1)) * width;
      const y = height - (value / 100) * height;
      return `${x},${y}`;
    });

    return `M${points.join(' L')}`;
  }, [memoryHistory, width, height]);

  const formatBytes = useCallback(
    (bytes: number) => {
      if (bytes === 0) {
        return '0 Bytes';
      }
      const k = 1000;
      const sizes = l10n.components.usageStats.byteSizes;
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    },
    [l10n.components.usageStats.byteSizes],
  );

  const [menuPosition, setMenuPosition] = useState({x: 0, y: 0});

  const Tooltip = useCallback(
    () => (
      <Portal>
        <Surface
          testID="memory-usage-tooltip"
          style={[
            styles.tooltip,
            {
              top: menuPosition.y + height,
              left: menuPosition.x - 10,
            },
          ]}>
          <Text style={styles.tooltipTitle}>
            {l10n.components.usageStats.tooltip.title}
          </Text>
          <Text style={styles.tooltipText}>
            {l10n.components.usageStats.tooltip.used}
            {formatBytes(memoryStats.usedMemory)}
          </Text>
          <Text style={styles.tooltipText}>
            {l10n.components.usageStats.tooltip.total}
            {formatBytes(memoryStats.totalMemory)}
          </Text>
          <Text style={styles.tooltipText}>
            {l10n.components.usageStats.tooltip.usage}
            {memoryStats.percentage.toFixed(1)}%
          </Text>
        </Surface>
      </Portal>
    ),
    [
      memoryStats,
      formatBytes,
      styles,
      menuPosition,
      height,
      l10n.components.usageStats.tooltip,
    ],
  );

  const handlePress = useCallback(
    event => {
      event.target.measure(
        (
          x: number,
          y: number,
          w: number,
          h: number,
          pageX: number,
          pageY: number,
        ) => {
          setMenuPosition({x: pageX, y: pageY});
          setShowTooltip(!showTooltip);
        },
      );
    },
    [showTooltip],
  );

  return (
    <View style={styles.container}>
      <TouchableWithoutFeedback
        testID="memory-usage-touchable"
        onPress={handlePress}>
        <View style={{width, height}}>
          <Svg testID="memory-usage-svg" width={width} height={height}>
            <Rect
              x="0"
              y="0"
              width={width}
              height={height}
              fill={theme.colors.backdrop}
              opacity={0.2}
            />

            {[25, 50, 75].map(percent => (
              <Line
                key={percent}
                x1="0"
                y1={height * (1 - percent / 100)}
                x2={width}
                y2={height * (1 - percent / 100)}
                stroke={theme.colors.onSurface}
                strokeWidth="0.5"
                opacity={0.3}
              />
            ))}

            <Path
              d={generatePath()}
              fill="none"
              stroke={theme.colors.error}
              strokeWidth={1.5}
            />
          </Svg>
        </View>
      </TouchableWithoutFeedback>
      {showTooltip && <Tooltip />}
    </View>
  );
};



================================================
FILE: src/components/UsageStats/__tests__/UsageStats.test.tsx
================================================
import React from 'react';

import DeviceInfo from 'react-native-device-info';

import {render, fireEvent, act} from '../../../../jest/test-utils';

import {UsageStats} from '../UsageStats';

describe('UsageStats Component', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  const mockMeasure = jest.fn(callback => {
    callback(0, 0, 100, 50, 10, 20); // mock x, y, width, height, pageX, pageY
  });

  it('fetches and displays memory stats correctly', async () => {
    const totalMemory = 4 * 1000 * 1000 * 1000;
    const usedMemory = 2 * 1000 * 1000 * 1000;

    (DeviceInfo.getTotalMemory as jest.Mock).mockResolvedValueOnce(totalMemory);
    (DeviceInfo.getUsedMemory as jest.Mock).mockResolvedValueOnce(usedMemory);

    const {getByText, queryByText, getByTestId} = render(
      <UsageStats width={100} height={50} />,
    );

    // Tooltip should not be visible
    expect(queryByText('Memory Usage')).toBeNull();

    // Wait for memory stats to be fetched and graph to be updated
    await act(async () => {
      jest.advanceTimersByTime(3000);
    });

    // Mock the measure function
    const touchable = getByTestId('memory-usage-touchable') as any;
    touchable._nativeTag = 'mock-tag';
    touchable.measure = mockMeasure;

    // Press the graph to display the tooltip
    fireEvent.press(touchable, {
      target: touchable,
      nativeEvent: {pageX: 10, pageY: 20},
    });

    // Check if the tooltip shows the correct values
    expect(getByText('Used: 2 GB')).toBeTruthy();
    expect(getByText('Total: 4 GB')).toBeTruthy();
    expect(getByText('Usage: 50.0%')).toBeTruthy();
  });

  it('renders the memory usage graph as an SVG', async () => {
    const totalMemory = 4 * 1000 * 1000 * 1000;
    const usedMemory = 2 * 1000 * 1000 * 1000;

    (DeviceInfo.getTotalMemory as jest.Mock).mockResolvedValueOnce(totalMemory);
    (DeviceInfo.getUsedMemory as jest.Mock).mockResolvedValueOnce(usedMemory);

    const {getByTestId} = render(<UsageStats width={100} height={50} />);

    await act(async () => {
      jest.advanceTimersByTime(3000);
    });

    // Check if the SVG is rendered
    const svgElement = getByTestId('memory-usage-svg');
    expect(svgElement).toBeTruthy();
  });

  it('toggles the tooltip on press', async () => {
    const totalMemory = 4 * 1000 * 1000 * 1000;
    const usedMemory = 2 * 1000 * 1000 * 1000;

    (DeviceInfo.getTotalMemory as jest.Mock).mockResolvedValueOnce(totalMemory);
    (DeviceInfo.getUsedMemory as jest.Mock).mockResolvedValueOnce(usedMemory);

    const {queryByTestId, getByTestId} = render(
      <UsageStats width={100} height={50} />,
    );

    await act(async () => {
      jest.advanceTimersByTime(3000);
    });

    const touchable = getByTestId('memory-usage-touchable') as any;
    touchable._nativeTag = 'mock-tag';
    touchable.measure = mockMeasure;

    // Press the graph to display the tooltip
    fireEvent.press(touchable, {
      target: touchable,
      nativeEvent: {pageX: 10, pageY: 20},
    });

    expect(getByTestId('memory-usage-tooltip')).toBeTruthy();

    // hide the tooltip
    fireEvent.press(getByTestId('memory-usage-touchable'), {
      target: touchable,
      nativeEvent: {pageX: 10, pageY: 20},
    });

    expect(queryByTestId('memory-usage-tooltip')).toBeNull();
  });
});



================================================
FILE: src/components/VideoPalEmptyPlaceholder/index.ts
================================================
export {VideoPalEmptyPlaceholder} from './VideoPalEmptyPlaceholder';



================================================
FILE: src/components/VideoPalEmptyPlaceholder/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {Theme} from '../../utils/types';

export const createStyles = ({theme}: {theme: Theme}) =>
  StyleSheet.create({
    container: {
      // Don't use flex: 1 since we're in a FlatList ListEmptyComponent
      // The FlatList already handles centering with justifyContent: 'center'
      alignItems: 'center',
      paddingHorizontal: 24,
      paddingTop: 20,
      gap: 16,
      minHeight: 400, // Ensure minimum height for proper centering
    },
    content: {
      alignItems: 'center',
      gap: 6,
      maxWidth: '100%',
    },
    title: {
      color: theme.colors.onSurface,
      textAlign: 'center',
      marginBottom: 2,
      ...theme.fonts.titleLarge,
    },
    subtitle: {
      color: theme.colors.primary,
      textAlign: 'center',
      marginBottom: 6,
      ...theme.fonts.titleSmall,
    },
    description: {
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      marginBottom: 16,
      ...theme.fonts.bodyMedium,
    },
    experimentalNotice: {
      backgroundColor: theme.colors.errorContainer,
      borderRadius: 6,
      paddingHorizontal: 12,
      paddingVertical: 6,
      marginBottom: 12,
      maxWidth: '100%',
    },
    experimentalText: {
      color: theme.colors.onErrorContainer,
      textAlign: 'center',
      ...theme.fonts.bodySmall,
    },
    instructionsContainer: {
      alignItems: 'flex-start',
      gap: 3,
      maxWidth: '100%',
    },
    instructionsTitle: {
      color: theme.colors.onSurface,
      marginBottom: 6,
      ...theme.fonts.titleSmall,
    },
    instructionStep: {
      color: theme.colors.onSurfaceVariant,
      ...theme.fonts.bodySmall,
    },

    logo: {
      width: 96,
      height: 96,
      borderRadius: 24,
    },
  });



================================================
FILE: src/components/VideoPalEmptyPlaceholder/VideoPalEmptyPlaceholder.tsx
================================================
import React, {useContext} from 'react';
import {Image, View} from 'react-native';
import {Text} from 'react-native-paper';
import {observer} from 'mobx-react';

import {useTheme} from '../../hooks';
import {createStyles} from './styles';
import {L10nContext} from '../../utils';

interface VideoPalEmptyPlaceholderProps {
  bottomComponentHeight: number;
}

export const VideoPalEmptyPlaceholder = observer(
  ({bottomComponentHeight}: VideoPalEmptyPlaceholderProps) => {
    const theme = useTheme();
    const l10n = useContext(L10nContext);
    const styles = createStyles({theme});

    return (
      <View
        style={[styles.container, {paddingBottom: bottomComponentHeight + 20}]}>
        <Image
          source={require('../../assets/pocketpal-dark-v2.png')}
          style={styles.logo}
          resizeMode="contain"
        />

        <View style={styles.content}>
          <Text style={styles.title}>{l10n.video.emptyPlaceholder.title}</Text>
          <Text style={styles.subtitle}>
            {l10n.video.emptyPlaceholder.subtitle}
          </Text>

          <View style={styles.experimentalNotice}>
            <Text style={styles.experimentalText}>
              {l10n.video.emptyPlaceholder.experimentalNotice}
            </Text>
          </View>

          <View style={styles.instructionsContainer}>
            <Text style={styles.instructionsTitle}>
              {l10n.video.emptyPlaceholder.howToUse}
            </Text>
            <Text style={styles.instructionStep}>
              {l10n.video.emptyPlaceholder.step1}
            </Text>
            <Text style={styles.instructionStep}>
              {l10n.video.emptyPlaceholder.step2}
            </Text>
            <Text style={styles.instructionStep}>
              {l10n.video.emptyPlaceholder.step3}
            </Text>
            <Text style={styles.instructionStep}>
              {l10n.video.emptyPlaceholder.step4}
            </Text>
          </View>
        </View>
      </View>
    );
  },
);



================================================
FILE: src/components/VisionControlSheet/index.ts
================================================
export * from './VisionControlSheet';



================================================
FILE: src/components/VisionControlSheet/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {Theme} from '../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    container: {
      padding: 16,
      paddingBottom: 32,
    },
    toggleContainer: {
      marginBottom: 16,
    },
    toggleHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 12,
      paddingVertical: 8,
    },
    toggleTextContainer: {
      flex: 1,
    },
    toggleTitle: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.text,
      marginBottom: 4,
    },
    helpText: {
      color: theme.colors.error,
      marginLeft: 36, // Align with toggle title
    },

    divider: {
      marginVertical: 16,
    },
    sectionTitle: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
      marginBottom: 12,
    },
    projectionModelsContainer: {
      marginBottom: 16,
    },
    disabledProjectionSelector: {
      opacity: 0.5,
    },
    warningContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
      padding: 12,
      borderRadius: 8,
      backgroundColor: theme.colors.errorContainer + '30',
      borderWidth: 1,
      borderColor: theme.colors.error + '50',
      marginBottom: 16,
    },
    warningText: {
      flex: 1,
      fontSize: 14,
      color: theme.colors.error,
      lineHeight: 18,
    },
  });



================================================
FILE: src/components/VisionControlSheet/VisionControlSheet.tsx
================================================
import React, {useContext} from 'react';
import {View} from 'react-native';
import {Text, Switch, Divider} from 'react-native-paper';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';

import {Sheet} from '../Sheet';
import {ProjectionModelSelector} from '..';
import {useTheme} from '../../hooks';
import {L10nContext} from '../../utils';
import {Model} from '../../utils/types';
import {modelStore} from '../../store';

import {createStyles} from './styles';

interface VisionControlSheetProps {
  isVisible: boolean;
  onClose: () => void;
  model: Model;
}

export const VisionControlSheet: React.FC<VisionControlSheetProps> = ({
  isVisible,
  onClose,
  model,
}) => {
  const theme = useTheme();
  const l10n = useContext(L10nContext);
  const styles = createStyles(theme);

  const visionEnabled = modelStore.getModelVisionPreference(model);
  const projectionStatus = modelStore.getProjectionModelStatus(model);

  const handleVisionToggle = async (enabled: boolean) => {
    try {
      await modelStore.setModelVisionEnabled(model.id, enabled);
    } catch (error) {
      console.error('Failed to toggle vision setting:', error);
      // The error is already handled in setModelVisionEnabled (vision state is reverted)
      // We could show a toast/snackbar here if needed
    }
  };

  const handleProjectionModelSelect = (projectionModelId: string) => {
    modelStore.setDefaultProjectionModel(model.id, projectionModelId);
  };

  const renderVisionToggle = () => {
    const isDisabled =
      !projectionStatus.isAvailable && !visionEnabled && model.isDownloaded;

    return (
      <View style={styles.toggleContainer}>
        <View style={styles.toggleHeader}>
          <Icon
            name={visionEnabled ? 'eye' : 'eye-off'}
            size={24}
            disabled={!projectionStatus.isAvailable && !visionEnabled}
            color={
              visionEnabled ? theme.colors.text : theme.colors.textSecondary
            }
          />
          <View style={styles.toggleTextContainer}>
            <Text
              style={[
                styles.toggleTitle,
                !visionEnabled && {color: theme.colors.textSecondary},
              ]}>
              {l10n.models.multimodal.visionControls.visionEnabled}
            </Text>
          </View>
          <Switch
            value={visionEnabled}
            onValueChange={handleVisionToggle}
            disabled={isDisabled}
          />
        </View>
        {isDisabled && (
          <Text variant="bodySmall" style={styles.helpText}>
            {l10n.models.multimodal.visionControls.requiresProjectionModel}
          </Text>
        )}
      </View>
    );
  };

  const renderProjectionModelSelector = () => {
    return (
      <ProjectionModelSelector
        model={model}
        onProjectionModelSelect={handleProjectionModelSelect}
        showDownloadActions={model.isDownloaded}
      />
    );
  };

  const getSheetTitle = () => {
    const maxLength = 40;
    if (model.name.length > maxLength) {
      return model.name.substring(0, maxLength) + '...';
    }
    return model.name;
  };

  return (
    <Sheet
      isVisible={isVisible}
      onClose={onClose}
      title={getSheetTitle()}
      snapPoints={['60%']}>
      <Sheet.ScrollView contentContainerStyle={styles.container}>
        {renderVisionToggle()}

        <Divider style={styles.divider} />

        {renderProjectionModelSelector()}
      </Sheet.ScrollView>
    </Sheet>
  );
};



================================================
FILE: src/components/VisionDownloadSheet/index.ts
================================================
export * from './VisionDownloadSheet';



================================================
FILE: src/components/VisionDownloadSheet/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {Theme} from '../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    container: {
      padding: 16,
      paddingBottom: 32,
    },
    description: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 24,
      lineHeight: 20,
    },
    optionsContainer: {
      gap: 12,
      marginBottom: 24,
    },
    optionCard: {
      borderRadius: 12,
      borderWidth: 1,
      borderColor: theme.colors.outline + '30',
      backgroundColor: theme.colors.surface,
      padding: 16,
    },
    optionCardSelected: {
      borderColor: theme.colors.primary,
      backgroundColor: theme.colors.primaryContainer + '20',
    },
    optionHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 8,
    },
    optionTitleRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
    },
    optionTitle: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.onSurface,
    },
    optionTitleSelected: {
      color: theme.colors.primary,
    },
    optionDescription: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 12,
      lineHeight: 18,
    },
    radioButton: {
      width: 20,
      height: 20,
      borderRadius: 10,
      borderWidth: 2,
      borderColor: theme.colors.outline,
      justifyContent: 'center',
      alignItems: 'center',
    },
    radioButtonSelected: {
      borderColor: theme.colors.primary,
    },
    radioButtonInner: {
      width: 10,
      height: 10,
      borderRadius: 5,
      backgroundColor: theme.colors.primary,
    },
    sizeChip: {
      alignSelf: 'flex-start',
      backgroundColor: theme.colors.secondaryContainer + '50',
    },
    sizeChipText: {
      fontSize: 12,
      color: theme.colors.onSecondaryContainer,
    },
    // ProjectionModelSelector-style components
    modelItem: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: 12,
      paddingHorizontal: 12,
      backgroundColor: theme.colors.surfaceVariant + '20',
      borderRadius: 8,
      borderLeftWidth: 3,
      borderLeftColor: 'transparent',
    },
    selectedModelItem: {
      borderLeftColor: theme.colors.tertiary,
      backgroundColor: theme.colors.tertiaryContainer + '20',
    },
    modelInfo: {
      flex: 1,
      marginRight: 12,
    },
    modelHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: 4,
    },
    modelIcon: {
      marginRight: 8,
    },
    modelName: {
      fontSize: 14,
      fontWeight: '500',
      color: theme.colors.onSurface,
      flex: 1,
    },
    selectedModelName: {
      fontWeight: '600',
      color: theme.colors.tertiary,
    },
    modelSize: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
      marginLeft: 20,
    },
    modelActions: {
      minWidth: 80,
      alignItems: 'flex-end',
    },
    selectArea: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingVertical: 6,
      paddingHorizontal: 8,
      borderRadius: 6,
      minWidth: 70,
      justifyContent: 'center',
    },
    selectedArea: {
      backgroundColor: theme.colors.tertiaryContainer + '30',
    },
    selectText: {
      fontSize: 12,
      fontWeight: '500',
      color: theme.colors.onSurfaceVariant,
      marginLeft: 4,
    },
    // VisionControlSheet-style components
    toggleContainer: {
      marginBottom: 16,
    },
    toggleHeader: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 12,
      paddingVertical: 8,
    },
    toggleTextContainer: {
      flex: 1,
    },
    toggleTitle: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.text,
      marginBottom: 4,
    },
    divider: {
      marginVertical: 16,
    },
    sectionTitle: {
      fontSize: 16,
      fontWeight: '600',
      color: theme.colors.text,
      marginBottom: 12,
    },
    projectionModelsContainer: {
      marginBottom: 16,
    },
    disabledProjectionSelector: {
      opacity: 0.5,
    },
    projectionModelItem: {
      paddingVertical: 8,
      paddingHorizontal: 12,
      backgroundColor: theme.colors.surfaceVariant + '20',
      borderRadius: 8,
      marginBottom: 8,
    },
    projectionModelInfo: {
      flex: 1,
    },
    projectionModelName: {
      fontSize: 14,
      fontWeight: '500',
      color: theme.colors.onSurface,
      marginBottom: 4,
    },
    projectionModelSize: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    emptyState: {
      alignItems: 'center',
      paddingVertical: 16,
    },
    emptyText: {
      textAlign: 'center',
      color: theme.colors.onSurfaceVariant,
      fontSize: 12,
      marginTop: 6,
      fontStyle: 'italic',
    },
    warningContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
      padding: 12,
      borderRadius: 8,
      backgroundColor: theme.colors.errorContainer + '30',
      borderWidth: 1,
      borderColor: theme.colors.error + '50',
      marginBottom: 16,
    },
    warningText: {
      flex: 1,
      fontSize: 14,
      color: theme.colors.error,
      lineHeight: 18,
    },
    actionsContainer: {
      flexDirection: 'row',
      // justifyContent: 'space-between',
      // alignItems: 'center',
      // width: '100%',
      paddingHorizontal: 24,
    },
  });



================================================
FILE: src/components/VisionDownloadSheet/VisionDownloadSheet.tsx
================================================
import React, {useState, useContext, useMemo} from 'react';
import {View} from 'react-native';
import {
  Text,
  Button,
  Switch,
  Divider,
  ActivityIndicator,
} from 'react-native-paper';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';

import {Sheet} from '../Sheet';
import {ProjectionModelSelector} from '../ProjectionModelSelector';
import {useTheme} from '../../hooks';
import {L10nContext, hfAsModel, getMmprojFiles} from '../../utils';
import {Model, HuggingFaceModel, ModelFile} from '../../utils/types';

import {modelStore} from '../../store';

import {createStyles} from './styles';

interface VisionDownloadSheetProps {
  isVisible: boolean;
  onClose: () => void;
  hfModel: HuggingFaceModel;
  modelFile: ModelFile;
  convertedModel: Model;
}

export const VisionDownloadSheet: React.FC<VisionDownloadSheetProps> = ({
  isVisible,
  onClose,
  hfModel,
  modelFile,
  convertedModel,
}) => {
  const theme = useTheme();
  const l10n = useContext(L10nContext);
  const styles = createStyles(theme);

  const [visionEnabled, setVisionEnabled] = useState(true);
  // Track selected projection model for UI consistency (ProjectionModelSelector expects this callback)
  const [selectedProjectionModel, setSelectedProjectionModel] = useState<
    string | null
  >(null);
  const [isDownloading, setIsDownloading] = useState(false);

  // Create projection models from HF repository data for search context
  const repositoryProjectionModels = useMemo(() => {
    const mmprojFiles = getMmprojFiles(hfModel.siblings || []);
    return mmprojFiles.map(file => hfAsModel(hfModel, file));
  }, [hfModel]);

  const handleVisionToggle = (enabled: boolean) => {
    setVisionEnabled(enabled);
    if (!enabled) {
      setSelectedProjectionModel(null);
    }
  };

  const handleProjectionModelSelect = (projectionModelId: string | null) => {
    setSelectedProjectionModel(projectionModelId);
  };

  const handleDownload = async () => {
    setIsDownloading(true);
    try {
      await modelStore.downloadHFModel(hfModel, modelFile, {
        enableVision: visionEnabled,
        projectionModelId: selectedProjectionModel || undefined,
      });
      onClose();
    } catch (error) {
      console.error('Download failed:', error);
    } finally {
      setIsDownloading(false);
    }
  };

  const renderVisionToggle = () => (
    <View style={styles.toggleContainer}>
      <View style={styles.toggleHeader}>
        <Icon
          name={visionEnabled ? 'eye' : 'eye-off'}
          size={24}
          color={visionEnabled ? theme.colors.text : theme.colors.textSecondary}
        />
        <View style={styles.toggleTextContainer}>
          <Text
            style={[
              styles.toggleTitle,
              !visionEnabled && {color: theme.colors.textSecondary},
            ]}>
            {l10n.models.multimodal.visionControls.visionEnabled}
          </Text>
        </View>
        <Switch value={visionEnabled} onValueChange={handleVisionToggle} />
      </View>
    </View>
  );

  const renderProjectionModelSelector = () => {
    if (!visionEnabled) {
      return (
        <View style={styles.projectionModelsContainer}>
          <View style={styles.disabledProjectionSelector}>
            <ProjectionModelSelector
              model={convertedModel}
              context="search"
              availableProjectionModels={repositoryProjectionModels}
              onProjectionModelSelect={handleProjectionModelSelect}
              showDownloadActions={false}
            />
          </View>
        </View>
      );
    }

    return (
      <ProjectionModelSelector
        model={convertedModel}
        context="search"
        availableProjectionModels={repositoryProjectionModels}
        onProjectionModelSelect={handleProjectionModelSelect}
        showDownloadActions={false}
      />
    );
  };

  return (
    <Sheet
      isVisible={isVisible}
      onClose={onClose}
      title={`${modelFile.rfilename}`}
      snapPoints={['60%']}>
      <Sheet.ScrollView contentContainerStyle={styles.container}>
        {renderVisionToggle()}

        <Divider style={styles.divider} />

        {renderProjectionModelSelector()}
      </Sheet.ScrollView>

      <Sheet.Actions style={styles.actionsContainer}>
        <Button mode="text" onPress={onClose} disabled={isDownloading}>
          {l10n.common.cancel}
        </Button>
        <Button
          mode="contained"
          onPress={handleDownload}
          loading={isDownloading}
          disabled={isDownloading}>
          {isDownloading ? (
            <ActivityIndicator size="small" color={theme.colors.onPrimary} />
          ) : (
            l10n.models.multimodal.download
          )}
        </Button>
      </Sheet.Actions>
    </Sheet>
  );
};



================================================
FILE: src/config/index.ts
================================================
export * from './urls';



================================================
FILE: src/config/urls.ts
================================================
import {FIREBASE_FUNCTIONS_URL} from '@env';

export const HF_DOMAIN = 'https://huggingface.co';
export const HF_API_BASE = `${HF_DOMAIN}/api/models`;

export const urls = {
  // API URLs
  modelsList: () => `${HF_API_BASE}`,
  modelTree: (modelId: string) => `${HF_API_BASE}/${modelId}/tree/main`,
  modelSpecs: (modelId: string) => `${HF_API_BASE}/${modelId}`,

  // Web URLs
  modelDownloadFile: (modelId: string, filename: string) =>
    `${HF_DOMAIN}/${modelId}/resolve/main/${filename}`,
  modelWebPage: (modelId: string) => `${HF_DOMAIN}/${modelId}`,

  // Benchmark Endpoint
  benchmarkSubmit: () => `${FIREBASE_FUNCTIONS_URL}/api/v1/submit`,

  // Feedback Endpoint
  feedbackSubmit: () => `${FIREBASE_FUNCTIONS_URL}/feedback`,
};



================================================
FILE: src/database/index.ts
================================================
import {Database} from '@nozbe/watermelondb';
import SQLiteAdapter from '@nozbe/watermelondb/adapters/sqlite';
import schema from './schema';
import migrations from './migrations';
import {ChatSession, Message, CompletionSetting, GlobalSetting} from './models';

const adapter = new SQLiteAdapter({
  schema,
  migrations,
  dbName: 'pocketpalai',
  jsi: true, // enable JSI for better performance if available
  onSetUpError: error => {
    console.error('Database setup error:', error);
  },
});

export const database = new Database({
  adapter,
  modelClasses: [ChatSession, Message, CompletionSetting, GlobalSetting],
});

export {ChatSession, Message, CompletionSetting, GlobalSetting};



================================================
FILE: src/database/migrations.ts
================================================
import {schemaMigrations} from '@nozbe/watermelondb/Schema/migrations';

export default schemaMigrations({
  migrations: [
    // Initial migration is handled by the schema
  ],
});



================================================
FILE: src/database/schema.ts
================================================
import {appSchema, tableSchema} from '@nozbe/watermelondb';

export default appSchema({
  version: 1,
  tables: [
    tableSchema({
      name: 'chat_sessions',
      columns: [
        {name: 'title', type: 'string'},
        {name: 'date', type: 'string'},
        {name: 'active_pal_id', type: 'string', isOptional: true},
        {name: 'created_at', type: 'number'},
        {name: 'updated_at', type: 'number'},
      ],
    }),
    tableSchema({
      name: 'messages',
      columns: [
        {name: 'session_id', type: 'string', isIndexed: true},
        {name: 'author', type: 'string'},
        {name: 'text', type: 'string', isOptional: true},
        {name: 'type', type: 'string'},
        {name: 'created_at', type: 'number'},
        {name: 'metadata', type: 'string'}, // JSON stringified
        {name: 'position', type: 'number'}, // For ordering
      ],
    }),
    tableSchema({
      name: 'completion_settings',
      columns: [
        {name: 'session_id', type: 'string', isIndexed: true},
        {name: 'settings', type: 'string'}, // JSON stringified
        {name: 'created_at', type: 'number'},
        {name: 'updated_at', type: 'number'},
      ],
    }),
    tableSchema({
      name: 'global_settings',
      columns: [
        {name: 'key', type: 'string', isIndexed: true},
        {name: 'value', type: 'string'}, // JSON stringified
        {name: 'created_at', type: 'number'},
        {name: 'updated_at', type: 'number'},
      ],
    }),
  ],
});



================================================
FILE: src/database/setup.ts
================================================
import {Database} from '@nozbe/watermelondb';
import SQLiteAdapter from '@nozbe/watermelondb/adapters/sqlite';
import {Platform} from 'react-native';

import schema from './schema';
import migrations from './migrations';
import {ChatSession, Message, CompletionSetting, GlobalSetting} from './models';

const adapter = new SQLiteAdapter({
  schema,
  migrations,
  dbName: 'pocketpalai',
  jsi: Platform.OS === 'ios', // Enable JSI for better performance on iOS
  onSetUpError: error => {
    console.error('Database setup error:', error);
  },
});

export const database = new Database({
  adapter,
  modelClasses: [ChatSession, Message, CompletionSetting, GlobalSetting],
});



================================================
FILE: src/database/models/ChatSession.ts
================================================
import {Model} from '@nozbe/watermelondb';
import {field, text} from '@nozbe/watermelondb/decorators';
import {Associations} from '@nozbe/watermelondb/Model';

export default class ChatSession extends Model {
  static table = 'chat_sessions';

  static associations: Associations = {
    messages: {type: 'has_many' as const, foreignKey: 'session_id'},
    // WatermelonDB doesn't have a 'has_one' type in its TypeScript definitions
    // Use 'has_many' instead and handle it as a single item in the code
    completion_settings: {type: 'has_many' as const, foreignKey: 'session_id'},
  };

  @text('title') title!: string;
  @text('date') date!: string;
  @text('active_pal_id') activePalId?: string;
  @field('created_at') createdAt!: number;
  @field('updated_at') updatedAt!: number;
}



================================================
FILE: src/database/models/CompletionSetting.ts
================================================
import {Model} from '@nozbe/watermelondb';
import {field, text} from '@nozbe/watermelondb/decorators';
import {CompletionParams} from '../../utils/completionTypes';
import {migrateCompletionSettings} from '../../utils/completionSettingsVersions';

export default class CompletionSetting extends Model {
  static table = 'completion_settings';

  static associations = {
    chat_sessions: {type: 'belongs_to' as const, key: 'session_id'},
  };

  @text('session_id') sessionId!: string;
  @text('settings') settings!: string;
  @field('created_at') createdAt!: number;
  @field('updated_at') updatedAt!: number;

  // Helper methods
  getSettings(): CompletionParams {
    try {
      const parsedSettings = JSON.parse(this.settings);

      // Check if completion settings need migration
      const migratedSettings = migrateCompletionSettings(parsedSettings);

      if (migratedSettings.version !== parsedSettings.version) {
        console.log(
          `Migrated completion settings from version ${parsedSettings.version} to ${migratedSettings.version} for session ${this.sessionId}`,
        );
        console.log(
          'Settings need to be saved by the repository with a proper database.write() call',
        );
      }

      return migratedSettings;
    } catch (error) {
      console.error('Error parsing completion settings:', error);
      // Return default settings if parsing fails
      return migrateCompletionSettings({});
    }
  }

  setSettings(settings: CompletionParams) {
    // Ensure the version is set
    if (settings.version === undefined) {
      settings = migrateCompletionSettings(settings);
    }

    return this.update(record => {
      record.settings = JSON.stringify(settings);
    });
  }
}



================================================
FILE: src/database/models/GlobalSetting.ts
================================================
import {Model} from '@nozbe/watermelondb';
import {field, text} from '@nozbe/watermelondb/decorators';
import {CompletionParams} from '../../utils/completionTypes';
import {migrateCompletionSettings} from '../../utils/completionSettingsVersions';

export default class GlobalSetting extends Model {
  static table = 'global_settings';

  @text('key') key!: string;
  @text('value') value!: string;
  @field('created_at') createdAt!: number;
  @field('updated_at') updatedAt!: number;

  // Helper methods
  getValue<T>(): T {
    // For completion settings, apply migrations if needed
    if (this.key === 'newChatCompletionSettings') {
      try {
        const parsedSettings = JSON.parse(this.value) as CompletionParams;

        // Check if settings need migration
        const migratedSettings = migrateCompletionSettings(parsedSettings);

        // If settings were migrated, log it but don't try to save automatically
        // The repository should handle saving with proper database.write() calls
        if (migratedSettings.version !== parsedSettings.version) {
          console.log(
            `Migrated global completion settings from version ${parsedSettings.version} to ${migratedSettings.version} for key ${this.key}`,
          );
          console.log(
            'Global settings need to be saved by the repository with a proper database.write() call',
          );
        }

        return migratedSettings as unknown as T;
      } catch (error) {
        console.error('Error parsing global completion settings:', error);
        // Return default settings if parsing fails
        return migrateCompletionSettings({}) as unknown as T;
      }
    }

    // For other settings, just parse the JSON
    return JSON.parse(this.value);
  }

  setValue<T>(value: T) {
    // For completion settings, ensure version is set
    if (this.key === 'newChatCompletionSettings') {
      const settings = value as unknown as CompletionParams;
      if (settings.version === undefined) {
        value = migrateCompletionSettings(settings) as unknown as T;
      }
    }

    return this.update(record => {
      record.value = JSON.stringify(value);
    });
  }
}



================================================
FILE: src/database/models/index.ts
================================================
import ChatSession from './ChatSession';
import Message from './Message';
import CompletionSetting from './CompletionSetting';
import GlobalSetting from './GlobalSetting';

export {ChatSession, Message, CompletionSetting, GlobalSetting};



================================================
FILE: src/database/models/Message.ts
================================================
import {Model} from '@nozbe/watermelondb';
import {field, text} from '@nozbe/watermelondb/decorators';
import {MessageType, User} from '../../utils/types';

export default class Message extends Model {
  static table = 'messages';

  static associations = {
    chat_sessions: {type: 'belongs_to' as const, key: 'session_id'},
  };

  @text('session_id') sessionId!: string;
  @text('author') author!: string;
  @text('text') text?: string;
  @text('type') type!: string;
  @field('created_at') createdAt!: number;
  @field('metadata') metadata!: string;
  @field('position') position!: number;

  toMessageObject(): MessageType.Any {
    const metadata = JSON.parse(this.metadata || '{}');

    const author: User = {
      id: this.author,
      ...(metadata.authorData || {}),
    };

    if (this.type === 'text') {
      return {
        id: this.id,
        type: 'text',
        text: this.text || '',
        author,
        createdAt: this.createdAt,
        metadata,
        // Extract imageUris from metadata if present
        imageUris: metadata.imageUris,
      } as MessageType.Text;
    }

    return {
      id: this.id,
      type: this.type as any,
      author,
      createdAt: this.createdAt,
      metadata,
    } as any;
  }
}



================================================
FILE: src/hooks/index.ts
================================================
export * from './usePrevious';
export * from './useTheme';
export * from './useChatSession';
export * from './useMemoryCheck';
export * from './useMessageActions';
export * from './useMoveScroll';
export * from './useStorageCheck';



================================================
FILE: src/hooks/useChatSession.ts
================================================
import React, {useRef, useCallback} from 'react';

import {toJS} from 'mobx';

import {chatSessionRepository} from '../repositories/ChatSessionRepository';

import {randId} from '../utils';
import {L10nContext} from '../utils';
import {chatSessionStore, modelStore, palStore, uiStore} from '../store';
import {createMultimodalWarning} from '../utils/errors';

import {MessageType, User} from '../utils/types';
import {activateKeepAwake, deactivateKeepAwake} from '../utils/keepAwake';
import {convertToChatMessages, removeThinkingParts} from '../utils/chat';
import {
  toApiCompletionParams,
  CompletionParams,
} from '../utils/completionTypes';

// Helper function to prepare completion parameters using OpenAI-compatible messages API
const prepareCompletion = async ({
  imageUris,
  message,
  getSystemMessage,
  activeSession,
  context,
  assistant,
  conversationIdRef,
  isMultimodalEnabled,
  l10n,
  currentMessages,
}: {
  imageUris: string[];
  message: MessageType.PartialText;
  getSystemMessage: () => any[];
  activeSession: any;
  context: any;
  assistant: User;
  conversationIdRef: string;
  isMultimodalEnabled: boolean;
  l10n: any;
  currentMessages: MessageType.Any[];
}) => {
  const sessionCompletionSettings = toJS(activeSession?.completionSettings);
  const stopWords = toJS(modelStore.activeModel?.stopWords);

  // Create user message content - always start with text
  const userMessageContent: any[] = [
    {
      type: 'text',
      text: message.text,
    },
  ];

  // Check if we have images and if multimodal is enabled
  const hasImages = imageUris && imageUris.length > 0;

  // Add images only if multimodal is enabled
  // If images exist but multimodal is not enabled, show warning but don't send images to API
  if (hasImages && isMultimodalEnabled) {
    userMessageContent.push(
      ...imageUris.map(path => ({
        type: 'image_url',
        image_url: {url: path}, // llama.rn handles file:// prefix removal
      })),
    );
  } else if (hasImages && !isMultimodalEnabled) {
    // Show warning for multimodal not enabled
    uiStore.setChatWarning(
      createMultimodalWarning(l10n.chat.multimodalNotEnabled),
    );
  }

  // Get system messages and convert chat session messages to llama.rn format
  const systemMessages = getSystemMessage();
  let chatMessages = convertToChatMessages(
    currentMessages.filter(msg => msg.type !== 'image'),
    isMultimodalEnabled,
  );

  // Check if we should include thinking parts in the context
  const includeThinkingInContext =
    (sessionCompletionSettings as CompletionParams)
      ?.include_thinking_in_context !== false;

  // If the user has disabled including thinking parts, remove them from assistant messages
  if (!includeThinkingInContext) {
    chatMessages = chatMessages.map(msg => {
      if (msg.role === 'assistant' && typeof msg.content === 'string') {
        return {
          ...msg,
          content: removeThinkingParts(msg.content),
        };
      }
      return msg;
    });
  }

  // Create the messages array for llama.rn - same format for all cases
  const messages = [
    ...systemMessages,
    ...chatMessages,
    {
      role: 'user',
      content: userMessageContent,
    },
  ];

  // Create completion params with app-specific properties
  const completionParamsWithAppProps = {
    ...sessionCompletionSettings,
    messages,
    stop: stopWords,
  };

  // Strip app-specific properties before passing to llama.rn
  const cleanCompletionParams = toApiCompletionParams(
    completionParamsWithAppProps as CompletionParams,
  );

  // Create message record in database
  const createdAt = Date.now();
  const newMessage = await chatSessionRepository.addMessageToSession(
    chatSessionStore.activeSessionId!,
    {
      author: assistant,
      createdAt: createdAt,
      id: '',
      text: '',
      type: 'text',
      metadata: {
        contextId: context.id,
        conversationId: conversationIdRef,
        copyable: true,
        multimodal: hasImages, // Simple check based on presence of images
      },
    },
  );

  const messageInfo = {
    createdAt,
    id: newMessage.id,
    sessionId: chatSessionStore.activeSessionId!,
  };

  return {cleanCompletionParams, messageInfo};
};

export const useChatSession = (
  currentMessageInfo: React.MutableRefObject<{
    createdAt: number;
    id: string;
    sessionId: string;
  } | null>,
  user: User,
  assistant: User,
) => {
  const l10n = React.useContext(L10nContext);
  const conversationIdRef = useRef<string>(randId());

  // Time-based batch processing
  // Token queue for accumulating tokens
  const tokenQueue = useRef<
    Array<{token: string; createdAt: number; id: string; sessionId: string}>
  >([]);
  const isProcessingTokens = useRef(false);
  const isMounted = useRef(true); // we use Drawer.Navigator, so the screen won't unmount. Not sure how useful this is.
  const batchTimer = useRef<NodeJS.Timeout | null>(null);
  const batchTimeout = 100; // Process batch every 100ms

  // Process all accumulated tokens in a batch
  const processTokenBatch = useCallback(async () => {
    if (isProcessingTokens.current || tokenQueue.current.length === 0) {
      return;
    }

    isProcessingTokens.current = true;
    batchTimer.current = null;

    try {
      // Take all accumulated tokens
      const tokensToProcess = [...tokenQueue.current];
      tokenQueue.current = [];
      const context = modelStore.context;

      if (context && tokensToProcess.length > 0) {
        // Group tokens by message ID
        const messageUpdates: Record<string, string> = {};

        tokensToProcess.forEach(({token, id}) => {
          messageUpdates[id] = (messageUpdates[id] || '') + token;
        });

        // Update each message in a single operation
        for (const [id, combinedToken] of Object.entries(messageUpdates)) {
          try {
            await chatSessionStore.updateMessageToken(
              {token: combinedToken},
              tokensToProcess[0].createdAt, // Use first token's timestamp
              id,
              tokensToProcess[0].sessionId, // Use first token's session
              context,
            );
          } catch (error) {
            console.error('Error updating message token batch:', error);
          }
        }
      }
    } finally {
      isProcessingTokens.current = false;

      // Schedule next batch if there are new tokens
      if (tokenQueue.current.length > 0) {
        if (isMounted.current) {
          // Normal case - component is mounted, schedule next batch
          if (!batchTimer.current) {
            batchTimer.current = setTimeout(processTokenBatch, batchTimeout);
          }
        } else {
          // Component is unmounted but we still have tokens - process immediately
          // This ensures all tokens are saved even after navigation
          processTokenBatch();
        }
      }
    }
  }, [batchTimeout]);

  // Add token to queue and schedule processing
  const queueToken = useCallback(
    (token: string, createdAt: number, id: string, sessionId: string) => {
      // Add token to queue
      tokenQueue.current.push({token, createdAt, id, sessionId});

      // Schedule processing if not already scheduled
      if (!batchTimer.current && isMounted.current) {
        batchTimer.current = setTimeout(processTokenBatch, batchTimeout);
      }
    },
    [processTokenBatch, batchTimeout],
  );

  // Cleanup on unmount
  // In Drawer.Navigator, the screen won't unmount. Not sure how useful this is.
  React.useEffect(() => {
    isMounted.current = true;
    return () => {
      // Process any remaining tokens immediately instead of waiting for the timer
      if (tokenQueue.current.length > 0 && !isProcessingTokens.current) {
        // Force process the remaining tokens
        processTokenBatch();
      }

      // After a short delay to allow processing to complete, clean up
      setTimeout(() => {
        isMounted.current = false;
        // Clear any pending timer
        if (batchTimer.current) {
          clearTimeout(batchTimer.current);
          batchTimer.current = null;
        }
      }, 500); // Give 500ms for processing to complete
    };
  }, [processTokenBatch]);

  const addMessage = async (message: MessageType.Any) => {
    await chatSessionStore.addMessageToCurrentSession(message);
  };

  const addSystemMessage = async (text: string, metadata = {}) => {
    const textMessage: MessageType.Text = {
      author: assistant,
      createdAt: Date.now(),
      id: randId(),
      text,
      type: 'text',
      metadata: {system: true, ...metadata},
    };
    await addMessage(textMessage);
  };

  const handleSendPress = async (message: MessageType.PartialText) => {
    // Extract imageUris from the message object
    const imageUris = message.imageUris;
    const context = modelStore.context;
    if (!context) {
      await addSystemMessage(l10n.chat.modelNotLoaded);
      return;
    }

    // Check if we have images in the current message
    const hasImages = imageUris && imageUris.length > 0;

    const isMultimodalEnabled = await modelStore.isMultimodalEnabled();

    // Get the current session messages BEFORE adding the new user message
    // Use toJS to get a snapshot and avoid MobX reactivity issues
    const currentMessages = toJS(chatSessionStore.currentSessionMessages);

    // Create the user message with embedded images
    const textMessage: MessageType.Text = {
      author: user,
      createdAt: Date.now(),
      id: '', // Will be set by the database
      text: message.text,
      type: 'text',
      imageUris: hasImages ? imageUris : undefined, // Include images directly in the text message
      metadata: {
        contextId: context.id,
        conversationId: conversationIdRef.current,
        copyable: true,
        multimodal: hasImages, // Mark as multimodal if it has images
      },
    };
    await addMessage(textMessage);
    modelStore.setInferencing(true);
    modelStore.setIsStreaming(false);
    chatSessionStore.setIsGenerating(true);

    // Keep screen awake during completion
    try {
      activateKeepAwake();
    } catch (error) {
      console.error('Failed to activate keep awake during chat:', error);
      // Continue with chat even if keep awake fails
    }

    const activeSession = chatSessionStore.sessions.find(
      s => s.id === chatSessionStore.activeSessionId,
    );
    let systemPrompt = '';
    if (activeSession?.activePalId) {
      const pal = palStore.pals.find(p => p.id === activeSession.activePalId);
      if (pal?.systemPrompt) {
        systemPrompt = pal.systemPrompt;
      }
    }

    const getSystemMessage = () => {
      // If no system prompt is available at all, return empty array
      if (
        !systemPrompt &&
        !modelStore.activeModel?.chatTemplate?.systemPrompt?.trim()
      ) {
        return [];
      }

      // Prefer custom system prompt, fall back to template's system prompt
      const finalSystemPrompt =
        systemPrompt ||
        modelStore.activeModel?.chatTemplate?.systemPrompt ||
        '';

      if (finalSystemPrompt?.trim() === '') {
        return [];
      }
      return [
        {
          role: 'system' as 'system',
          content: finalSystemPrompt,
        },
      ];
    };

    // Prepare completion parameters and create message record
    const {cleanCompletionParams, messageInfo} = await prepareCompletion({
      imageUris: imageUris || [],
      message,
      getSystemMessage,
      activeSession,
      context,
      assistant,
      conversationIdRef: conversationIdRef.current,
      isMultimodalEnabled,
      l10n,
      currentMessages,
    });

    currentMessageInfo.current = messageInfo;

    try {
      // Track time to first token
      const completionStartTime = Date.now();
      let timeToFirstToken: number | null = null;

      const result = await context.completion(cleanCompletionParams, data => {
        if (data.token && currentMessageInfo.current) {
          // Capture time to first token on the first token received
          if (timeToFirstToken === null) {
            timeToFirstToken = Date.now() - completionStartTime;
          }

          if (!modelStore.isStreaming) {
            modelStore.setIsStreaming(true);
          }

          // Queue each token individually for processing
          queueToken(
            data.token,
            currentMessageInfo.current.createdAt,
            currentMessageInfo.current.id,
            currentMessageInfo.current.sessionId,
          );
        }
      });

      // Log completion result with time to first token for debugging
      if (__DEV__) {
        console.log('Completion result:', {
          ...result.timings,
          time_to_first_token_ms: timeToFirstToken,
        });
      }

      // No need to flush remaining tokens as each token is processed individually
      // Just wait for the queue to finish processing
      while (tokenQueue.current.length > 0 || isProcessingTokens.current) {
        await new Promise(resolve => setTimeout(resolve, 50));
      }

      // Update only the metadata in the database
      // The text is already being updated with each token
      await chatSessionStore.updateMessage(
        currentMessageInfo.current.id,
        currentMessageInfo.current.sessionId,
        {
          metadata: {
            timings: {
              ...result.timings,
              time_to_first_token_ms: timeToFirstToken,
            },
            copyable: true,
            // Add multimodal flag if this was a multimodal completion
            multimodal: hasImages && isMultimodalEnabled,
          },
        },
      );
      modelStore.setInferencing(false);
      modelStore.setIsStreaming(false);
      chatSessionStore.setIsGenerating(false);
    } catch (error) {
      modelStore.setInferencing(false);
      modelStore.setIsStreaming(false);
      chatSessionStore.setIsGenerating(false);
      const errorMessage = (error as Error).message;
      if (errorMessage.includes('network')) {
        // TODO: This can be removed. We don't use network for chat.
        await addSystemMessage(l10n.common.networkError);
      } else {
        await addSystemMessage(`${l10n.chat.completionFailed}${errorMessage}`);
      }
    } finally {
      // Always try to deactivate keep awake in finally block
      try {
        deactivateKeepAwake();
      } catch (error) {
        console.error('Failed to deactivate keep awake after chat:', error);
      }
    }
  };

  const handleResetConversation = async () => {
    conversationIdRef.current = randId();
    await addSystemMessage(l10n.chat.conversationReset);
  };

  const handleStopPress = async () => {
    const context = modelStore.context;
    if (modelStore.inferencing && context) {
      context.stopCompletion();
    }
    // Wait for any queued tokens to finish processing
    if (tokenQueue.current.length > 0 || isProcessingTokens.current) {
      try {
        // Wait for the queue to finish processing
        while (tokenQueue.current.length > 0 || isProcessingTokens.current) {
          await new Promise(resolve => setTimeout(resolve, 50));
        }
      } catch (error) {
        console.error('Error when stopping completion:', error);
      }
    }
    modelStore.setInferencing(false);
    modelStore.setIsStreaming(false);
    // Deactivate keep awake when stopping completion
    try {
      deactivateKeepAwake();
    } catch (error) {
      console.error(
        'Failed to deactivate keep awake after stopping chat:',
        error,
      );
    }
  };

  return {
    handleSendPress,
    handleResetConversation,
    handleStopPress,
    // Add a method to check if multimodal is enabled
    isMultimodalEnabled: async () => await modelStore.isMultimodalEnabled(),
  };
};



================================================
FILE: src/hooks/useKeepAwake.ts
================================================
import {useEffect} from 'react';
import {activateKeepAwake, deactivateKeepAwake} from '../utils/keepAwake';

/**
 * React hook that prevents the screen from going to sleep while the component is mounted.
 *
 * @example
 * ```tsx
 * function VideoPlayer() {
 *   useKeepAwake(); // Screen will stay awake while VideoPlayer is mounted
 *   return <Video source={source} />;
 * }
 * ```
 */
export function useKeepAwake(): void {
  useEffect(() => {
    try {
      activateKeepAwake();
      return () => {
        try {
          deactivateKeepAwake();
        } catch (error) {
          console.error('Failed to deactivate keep awake in cleanup:', error);
        }
      };
    } catch (error) {
      console.error('Failed to activate keep awake:', error);
      // We don't rethrow here as it would crash the component
      // Instead, we log the error and let the screen timeout normally
    }
  }, []);
}



================================================
FILE: src/hooks/useMemoryCheck.ts
================================================
import React, {useEffect, useState} from 'react';
import DeviceInfo from 'react-native-device-info';
import {NativeModules} from 'react-native';
import {L10nContext} from '../utils';

const {DeviceInfoModule} = NativeModules;

function memoryRequirementEstimate(modelSize: number, isMultimodal = false) {
  // Model parameters derived by fitting a linear regression to benchmark data
  // from: https://huggingface.co/spaces/a-ghorbani/ai-phone-leaderboard
  const baseRequirement = 0.43 + (0.92 * modelSize) / 1000 / 1000 / 1000;

  // Add overhead for multimodal models
  if (isMultimodal) {
    // Additional memory for mmproj model, image processing, and larger context
    return baseRequirement + 1.8; // ~1.8GB additional overhead. THis is rough estimate and needs to be revisited.
  }

  return baseRequirement;
}

/**
 * Check if device is capable of running multimodal models
 */
export const isHighEndDevice = async (): Promise<boolean> => {
  try {
    const ram = await DeviceInfo.getTotalMemory();
    const ramGB = ram / 1000 / 1000 / 1000;

    // Get CPU info for more detailed checks
    const cpuInfo = DeviceInfoModule
      ? await DeviceInfoModule.getCPUInfo()
      : {cores: 4};
    const cpuCount = cpuInfo.cores || 4; // fallback to 4

    // Multimodal requirements (more stringent than regular models)
    const ramOK = ramGB >= 5.5; // 6GB minimum for multimodal
    const cpuOK = cpuCount >= 6; // 6+ cores for decent performance

    return ramOK && cpuOK;
  } catch (error) {
    console.error('High-end device check failed:', error);
    return false; // Conservative fallback
  }
};

export const hasEnoughMemory = async (
  modelSize: number,
  isMultimodal = false,
): Promise<boolean> => {
  const totalMemory = await DeviceInfo.getTotalMemory();
  const totalMemoryGB = totalMemory / 1000 / 1000 / 1000;
  const availableMemory = Math.min(totalMemoryGB * 0.65, totalMemoryGB - 1.2);
  const memoryRequirement = memoryRequirementEstimate(modelSize, isMultimodal);

  return memoryRequirement <= availableMemory;
};

export const useMemoryCheck = (modelSize: number, isMultimodal = false) => {
  const l10n = React.useContext(L10nContext);
  const [memoryWarning, setMemoryWarning] = useState('');
  const [shortMemoryWarning, setShortMemoryWarning] = useState('');
  const [multimodalWarning, setMultimodalWarning] = useState('');

  useEffect(() => {
    const checkMemory = async () => {
      // Reset warnings first
      setMemoryWarning('');
      setShortMemoryWarning('');
      setMultimodalWarning('');

      try {
        const hasMemory = await hasEnoughMemory(modelSize, isMultimodal);

        if (!hasMemory) {
          setShortMemoryWarning(l10n.memory.shortWarning);
          setMemoryWarning(l10n.memory.warning);
        }

        // Additional check for multimodal capability
        if (isMultimodal) {
          const isCapable = await isHighEndDevice();
          if (!isCapable) {
            setMultimodalWarning(l10n.memory.multimodalWarning);
          }
        }
      } catch (error) {
        // Clear all warnings when there's an error
        setMemoryWarning('');
        setShortMemoryWarning('');
        setMultimodalWarning('');
        console.error('Memory check failed:', error);
      }
    };

    checkMemory();
  }, [modelSize, isMultimodal, l10n]);

  return {memoryWarning, shortMemoryWarning, multimodalWarning};
};



================================================
FILE: src/hooks/useMessageActions.ts
================================================
import {useCallback} from 'react';

import Clipboard from '@react-native-clipboard/clipboard';

import {chatSessionStore, modelStore} from '../store';

import {MessageType, User} from '../utils/types';

interface UseMessageActionsProps {
  user: User;
  messages: MessageType.Any[];
  handleSendPress: (message: MessageType.PartialText) => Promise<void>;
  setInputText?: (text: string) => void;
  setInputImages?: (images: string[]) => void;
}

export const useMessageActions = ({
  user,
  messages,
  handleSendPress,
  setInputText,
  setInputImages,
}: UseMessageActionsProps) => {
  const handleCopy = useCallback((message: MessageType.Text) => {
    if (message.type === 'text') {
      Clipboard.setString(message.text.trim());
    }
  }, []);

  const handleEdit = useCallback(
    async (message: MessageType.Text) => {
      if (message.type !== 'text' || message.author.id !== user.id) {
        return;
      }

      // Enter edit mode and set input text and images
      chatSessionStore.enterEditMode(message.id);
      setInputText?.(message.text);
      setInputImages?.(message.imageUris || []);
    },
    [setInputText, setInputImages, user.id],
  );

  const handleTryAgain = useCallback(
    async (message: MessageType.Text) => {
      if (message.type !== 'text') {
        return;
      }

      // If it's the user's message, resubmit it
      if (message.author.id === user.id) {
        // Remove all messages from this point (inclusive)
        const messageText = message.text;
        const relatedImages = message.imageUris;

        await chatSessionStore.removeMessagesFromId(message.id, true);
        await handleSendPress({
          text: messageText,
          type: 'text',
          imageUris:
            relatedImages && relatedImages.length > 0
              ? relatedImages
              : undefined,
        });
      } else {
        // If it's the assistant's message, find and resubmit the last user message
        const messageIndex = messages.findIndex(msg => msg.id === message.id);
        const previousMessage = messages
          .slice(messageIndex + 1)
          .find(msg => msg.author.id === user.id && msg.type === 'text') as
          | MessageType.Text
          | undefined;

        if (previousMessage && previousMessage.text) {
          const messageText = previousMessage.text;
          const relatedImages = previousMessage.imageUris;
          await chatSessionStore.removeMessagesFromId(previousMessage.id, true);
          await handleSendPress({
            text: messageText,
            type: 'text',
            imageUris:
              relatedImages && relatedImages.length > 0
                ? relatedImages
                : undefined,
          });
        }
      }
    },
    [messages, handleSendPress, user.id],
  );

  const handleTryAgainWith = useCallback(
    async (modelId: string, message: MessageType.Text) => {
      if (modelId === modelStore.activeModelId) {
        await handleTryAgain(message);
        return;
      }
      const model = modelStore.models.find(m => m.id === modelId);
      if (model) {
        await modelStore.initContext(model);
        await handleTryAgain(message);
      }
    },
    [handleTryAgain],
  );

  return {
    handleCopy,
    handleEdit,
    handleTryAgain,
    handleTryAgainWith,
  };
};



================================================
FILE: src/hooks/useMoveScroll.ts
================================================
// This is a workaround for multiline input text not avoiding the keyboard..
// https://github.com/facebook/react-native/issues/16826#issuecomment-2254322144

import {useRef, useEffect} from 'react';
import {FlatList, Keyboard, KeyboardEvent, Platform} from 'react-native';

export const useMoveScroll = () => {
  const scrollRef = useRef<FlatList>(null);
  const keyboardHeight = useRef(Platform.OS === 'ios' ? 320 : 280);
  const visibleAreaOffset = 300; // very arbitrary number. TODO: fix this

  useEffect(() => {
    const keyboardDidShowListener = Keyboard.addListener(
      'keyboardDidShow',
      (event: KeyboardEvent) => {
        keyboardHeight.current = event.endCoordinates.height;
      },
    );

    return () => {
      keyboardDidShowListener.remove();
    };
  }, []);

  const moveScrollToDown = (inputY?: number) => {
    if (scrollRef.current) {
      setTimeout(() => {
        const offset = inputY ?? keyboardHeight.current + visibleAreaOffset;
        scrollRef.current?.scrollToOffset({
          offset: Math.max(0, offset),
          animated: true,
        });
      }, 600);
    }
  };

  return {scrollRef, moveScrollToDown};
};



================================================
FILE: src/hooks/usePrevious.ts
================================================
import * as React from 'react';

export const usePrevious = <T>(value: T) => {
  const ref = React.useRef<T>();

  React.useEffect(() => {
    ref.current = value;
  }, [value]);

  return ref.current;
};



================================================
FILE: src/hooks/useStorageCheck.ts
================================================
import {useEffect, useState, useContext} from 'react';

import DeviceInfo from 'react-native-device-info';

import {formatBytes, hasEnoughSpace} from '../utils';
import {L10nContext} from '../utils';

import {Model, ModelOrigin} from '../utils/types';

interface StorageCheckOptions {
  /**
   * Whether to periodically check storage.
   * If false, storage will only be checked once.
   * @default true
   */
  enablePeriodicCheck?: boolean;
  /**
   * Interval in milliseconds for storage checks when periodic checking is enabled
   * @default 10000 (10 seconds)
   */
  checkInterval?: number;
}

export const useStorageCheck = (
  model: Model,
  options: StorageCheckOptions = {},
) => {
  const {enablePeriodicCheck = true, checkInterval = 10000} = options;
  const l10n = useContext(L10nContext);

  const [storageStatus, setStorageStatus] = useState({
    isOk: true,
    message: '',
  });
  //const [freeDiskStorage, setFreeDiskStorage] = useState<number | null>(null);

  // Effect to check storage and set up periodic checking if enabled
  useEffect(() => {
    const abortController = new AbortController();

    const checkStorage = async () => {
      try {
        if (
          model.isDownloaded ||
          model.isLocal ||
          model.origin === ModelOrigin.LOCAL
        ) {
          return;
        }

        const isEnoughSpace = await hasEnoughSpace(model);
        if (abortController.signal.aborted) {
          return;
        }

        if (!isEnoughSpace) {
          const freeDisk = await DeviceInfo.getFreeDiskStorage('important');
          if (abortController.signal.aborted) {
            return;
          }

          // Use localized template string with variables
          const message = l10n.storage.lowStorage
            .replace('{{modelSize}}', formatBytes(model.size))
            .replace('{{freeSpace}}', formatBytes(freeDisk));

          setStorageStatus({
            isOk: false,
            message,
          });
        } else {
          setStorageStatus({
            isOk: true,
            message: '',
          });
        }
      } catch (error) {
        if (!abortController.signal.aborted) {
          console.error('Storage check failed:', error);
          setStorageStatus({isOk: false, message: l10n.storage.checkFailed});
        }
      }
    };

    checkStorage();
    let intervalId: NodeJS.Timeout | undefined;
    if (enablePeriodicCheck) {
      intervalId = setInterval(checkStorage, checkInterval);
    }

    return () => {
      abortController.abort();
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [model, enablePeriodicCheck, checkInterval, l10n]);

  return storageStatus;
};



================================================
FILE: src/hooks/useStructuredOutput.ts
================================================
import {useCallback, useRef, useState, useContext} from 'react';

import {toJS} from 'mobx';

import {modelStore} from '../store';
import {safeParseJSON} from '../utils';
import {L10nContext} from '../utils';

export const useStructuredOutput = () => {
  const [isGenerating, setIsGenerating] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const l10n = useContext(L10nContext);

  const stopRef = useRef<(() => void) | null>(null);

  const stop = useCallback(() => {
    if (stopRef.current) {
      stopRef.current();
      stopRef.current = null;
      setIsGenerating(false);
    }
  }, []);

  const generate = useCallback(
    async (
      prompt: string,
      schema: object,
      options?: {
        temperature?: number;
        top_p?: number;
        top_k?: number;
        repeat_penalty?: number;
      },
    ) => {
      if (!modelStore.context) {
        throw new Error(l10n.generation.modelNotInitialized);
      }

      setIsGenerating(true);
      setError(null);
      const stopWords = toJS(modelStore.activeModel?.stopWords);

      try {
        // Store the stop function for later use
        stopRef.current = () => modelStore.context?.stopCompletion();

        const result = await modelStore.context.completion({
          messages: [{role: 'user', content: prompt}],
          response_format: {
            type: 'json_schema',
            json_schema: {
              strict: true,
              schema,
            },
          },
          temperature: options?.temperature ?? 0.7,
          top_p: options?.top_p ?? 0.9,
          top_k: options?.top_k ?? 40,
          n_predict: 2000,

          stop: stopWords,
        });

        stopRef.current = null;
        // Parse the completion text as JSON
        return safeParseJSON(result.text);
      } catch (err) {
        const errorMessage =
          err instanceof Error ? err.message : l10n.generation.failedToGenerate;
        setError(errorMessage);
        throw err;
      } finally {
        setIsGenerating(false);
        stopRef.current = null;
      }
    },
    [l10n.generation],
  );

  return {
    generate,
    isGenerating,
    error,
    stop,
  };
};



================================================
FILE: src/hooks/useTheme.ts
================================================
import {useTheme as usePaperTheme, MD3Theme} from 'react-native-paper';

import {uiStore} from '../store';

import {Theme} from '../utils/types';
import {darkTheme, lightTheme} from '../utils/theme';

export const useTheme = (): Theme => {
  const paperTheme = usePaperTheme<MD3Theme>();

  const theme = uiStore.colorScheme === 'dark' ? darkTheme : lightTheme;

  return {
    ...paperTheme,
    ...theme,
  } as Theme;
};



================================================
FILE: src/hooks/__tests__/useChatSession.test.ts
================================================
import {LlamaContext} from '@pocketpalai/llama.rn';
import {renderHook, act} from '@testing-library/react-native';

import {textMessage} from '../../../jest/fixtures';
import {
  mockBasicModel,
  mockContextModel,
  modelsList,
} from '../../../jest/fixtures/models';

import {useChatSession} from '../useChatSession';

import {chatSessionStore, modelStore} from '../../store';

import {l10n} from '../../utils/l10n';
import {assistant} from '../../utils/chat';

const mockAssistant = {
  id: 'h3o3lc5xj',
};

beforeEach(() => {
  jest.clearAllMocks();
  modelStore.context = new LlamaContext({
    contextId: 1,
    gpu: false,
    reasonNoGPU: '',
    model: mockContextModel,
  });
});
modelStore.models = modelsList;

// Mock the applyChatTemplate function from utils/chat
const applyChatTemplateSpy = jest
  .spyOn(require('../../utils/chat'), 'applyChatTemplate')
  .mockImplementation(async () => 'mocked prompt');

describe('useChatSession', () => {
  beforeEach(() => {
    applyChatTemplateSpy.mockClear();
  });

  it('should send a message and update the chat session', async () => {
    const {result} = renderHook(() =>
      useChatSession({current: null}, textMessage.author, mockAssistant),
    );

    await act(async () => {
      await result.current.handleSendPress(textMessage);
    });

    expect(chatSessionStore.addMessageToCurrentSession).toHaveBeenCalled();
    expect(modelStore.context?.completion).toHaveBeenCalled();
  });

  it('should handle model not loaded scenario', async () => {
    modelStore.context = undefined;
    const {result} = renderHook(() =>
      useChatSession({current: null}, textMessage.author, assistant),
    );

    await act(async () => {
      await result.current.handleSendPress(textMessage);
    });

    // TODO: fix this test:         "text": "Model not loaded. Please initialize the model.",
    expect(chatSessionStore.addMessageToCurrentSession).toHaveBeenCalledWith({
      author: assistant,
      createdAt: expect.any(Number),
      id: expect.any(String),
      text: l10n.en.chat.modelNotLoaded,
      type: 'text',
      metadata: {system: true},
    });
  });

  it('should handle general errors during completion', async () => {
    const errorMessage = 'Some general error';
    if (modelStore.context) {
      modelStore.context.completion = jest
        .fn()
        .mockRejectedValueOnce(new Error(errorMessage));
    }

    const {result} = renderHook(() =>
      useChatSession({current: null}, textMessage.author, mockAssistant),
    );

    await act(async () => {
      await result.current.handleSendPress(textMessage);
    });

    expect(chatSessionStore.addMessageToCurrentSession).toHaveBeenCalledWith(
      expect.objectContaining({
        text: `Completion failed: ${errorMessage}`,
        author: assistant,
      }),
    );
  });

  it('should buffer and flush tokens correctly', async () => {
    const timings = {token_per_second: '1'};

    // Mock the updateMessageToken function to track the tokens
    const originalUpdateMessageToken = chatSessionStore.updateMessageToken;
    const mockUpdateMessageToken = jest
      .fn()
      .mockImplementation(
        async (
          data: any,
          createdAt: number,
          id: string,
          sessionId: string,
          context: any,
        ) => {
          return originalUpdateMessageToken.call(
            chatSessionStore,
            data,
            createdAt,
            id,
            sessionId,
            context,
          );
        },
      );
    chatSessionStore.updateMessageToken = mockUpdateMessageToken;

    // Mock the completion function to call onData with tokens
    if (modelStore.context) {
      modelStore.context.completion = jest
        .fn()
        .mockImplementation((_params, onData) => {
          onData({token: 'Hello'});
          onData({token: ', '});
          onData({token: 'world!'});
          return Promise.resolve({timings: timings, usage: {}});
        });
    }

    const {result} = renderHook(() =>
      useChatSession({current: null}, textMessage.author, mockAssistant),
    );

    await act(async () => {
      await result.current.handleSendPress(textMessage);
    });

    // Wait for all promises to resolve and throttling to complete
    // This is necessary because throttling is time-based
    await act(async () => {
      await new Promise(resolve => setTimeout(resolve, 1000));
    });

    // Verify that updateMessageToken was called at least once
    expect(mockUpdateMessageToken).toHaveBeenCalled();

    // Get all the calls to updateMessageToken
    const calls = mockUpdateMessageToken.mock.calls;

    // Due to throttling, the tokens might be batched differently
    // What's important is that all the content is there
    const allTokens = calls.map(call => call[0].token).join('');

    expect(allTokens).toContain('Hello');
    expect(allTokens).toContain(', ');
    expect(allTokens).toContain('world!');

    // Restore the original function
    chatSessionStore.updateMessageToken = originalUpdateMessageToken;

    expect(chatSessionStore.updateMessage).toHaveBeenCalled();

    const matchingCall = (
      chatSessionStore.updateMessage as jest.Mock
    ).mock.calls.find(
      ([, , {metadata}]) =>
        metadata && metadata.timings && metadata.copyable === true,
    );

    expect(matchingCall).toBeDefined();

    // Check that the metadata includes the original timings plus time_to_first_token_ms
    const actualMetadata = matchingCall[2].metadata;
    expect(actualMetadata.copyable).toBe(true);
    expect(actualMetadata.timings).toEqual(
      expect.objectContaining({
        ...timings,
        time_to_first_token_ms: expect.any(Number),
      }),
    );

    // Verify time_to_first_token_ms is a reasonable value (should be >= 0)
    expect(
      actualMetadata.timings.time_to_first_token_ms,
    ).toBeGreaterThanOrEqual(0);
  });

  it('should reset the conversation', () => {
    const {result} = renderHook(() =>
      useChatSession({current: null}, textMessage.author, mockAssistant),
    );

    result.current.handleResetConversation();

    expect(chatSessionStore.addMessageToCurrentSession).toHaveBeenCalledWith(
      expect.objectContaining({
        text: l10n.en.chat.conversationReset,
        author: assistant,
      }),
    );
  });

  it('should not stop completion when inferencing is false', () => {
    const {result} = renderHook(() =>
      useChatSession({current: null}, textMessage.author, mockAssistant),
    );

    result.current.handleStopPress();

    expect(modelStore.context?.stopCompletion).not.toHaveBeenCalled();
  });

  it('should set inferencing correctly during send', async () => {
    let resolveCompletion: (value: any) => void;
    const completionPromise = new Promise(resolve => {
      resolveCompletion = resolve;
    });

    if (modelStore.context) {
      modelStore.context.completion = jest
        .fn()
        .mockImplementation(() => completionPromise);
    }

    const {result} = renderHook(() =>
      useChatSession({current: null}, textMessage.author, mockAssistant),
    );

    const sendPromise = act(async () => {
      await result.current.handleSendPress(textMessage);
    });

    await act(async () => {
      await new Promise(resolve => setTimeout(resolve, 0));
    });
    expect(modelStore.inferencing).toBe(true);

    await act(async () => {
      resolveCompletion!({timings: {total: 100}, usage: {}});
      await sendPromise;
    });
    expect(modelStore.inferencing).toBe(false);
  });

  test.each([
    {systemPrompt: undefined, shouldInclude: false, description: 'undefined'},
    {systemPrompt: '', shouldInclude: false, description: 'empty string'},
    {systemPrompt: '   ', shouldInclude: false, description: 'whitespace-only'},
    {
      systemPrompt: 'You are a helpful assistant',
      shouldInclude: true,
      description: 'valid prompt',
    },
    {
      systemPrompt: '  Trimmed prompt  ',
      shouldInclude: true,
      description: 'prompt with whitespace',
    },
  ])(
    'should handle system prompt for $description',
    async ({systemPrompt, shouldInclude}) => {
      const testModel = {
        ...mockBasicModel,
        id: 'test-model',
        chatTemplate: {...mockBasicModel.chatTemplate, systemPrompt},
      };

      modelStore.models = [testModel];
      modelStore.setActiveModel(testModel.id);

      // Mock the completion function to capture the messages passed to it
      let capturedMessages: any[] = [];
      if (modelStore.context) {
        modelStore.context.completion = jest
          .fn()
          .mockImplementation((params, _onData) => {
            capturedMessages = params.messages || [];
            return Promise.resolve({timings: {total: 100}, usage: {}});
          });
      }

      const {result} = renderHook(() =>
        useChatSession({current: null}, textMessage.author, mockAssistant),
      );

      await act(async () => {
        await result.current.handleSendPress(textMessage);
      });

      if (shouldInclude && systemPrompt?.trim()) {
        // Check that a system message was included in the messages passed to completion
        expect(capturedMessages.some(msg => msg.role === 'system')).toBe(true);
        const systemMessage = capturedMessages.find(
          msg => msg.role === 'system',
        );
        expect(systemMessage.content).toBe(systemPrompt);
      } else {
        // Check that no system message was included
        expect(capturedMessages.some(msg => msg.role === 'system')).toBe(false);
      }
    },
  );
});



================================================
FILE: src/hooks/__tests__/useMemoryCheck.test.ts
================================================
import DeviceInfo from 'react-native-device-info';
import {renderHook} from '@testing-library/react-hooks';

import {largeMemoryModel, localModel} from '../../../jest/fixtures/models';

// Unmock the hook for actual testing
jest.unmock('../useMemoryCheck');

import {useMemoryCheck} from '../useMemoryCheck';

import {l10n} from '../../utils/l10n';

describe('useMemoryCheck', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('returns no warning when model size is within safe memory limits', async () => {
    const {result, waitForNextUpdate} = renderHook(() =>
      useMemoryCheck(localModel.size),
    );

    try {
      await waitForNextUpdate();
    } catch (error) {
      // Ignoring timeout
    }

    expect(result.current).toEqual({
      memoryWarning: '',
      shortMemoryWarning: '',
      multimodalWarning: '',
    });
  });

  it('returns memory warning when model size exceeds safe memory limits', async () => {
    const {result, waitForNextUpdate} = renderHook(() =>
      useMemoryCheck(largeMemoryModel.size),
    );

    try {
      await waitForNextUpdate();
    } catch (error) {
      // Ignoring timeout
    }

    expect(result.current).toEqual({
      memoryWarning: l10n.en.memory.warning,
      shortMemoryWarning: l10n.en.memory.shortWarning,
      multimodalWarning: '',
    });
  });

  it('handles errors gracefully when memory check fails', async () => {
    (DeviceInfo.getTotalMemory as jest.Mock).mockRejectedValue(
      new Error('Memory error'),
    );

    // Spy on console.error to ensure it gets called with the correct error
    const consoleErrorSpy = jest
      .spyOn(console, 'error')
      .mockImplementation(() => {});

    const {result, waitForNextUpdate} = renderHook(() =>
      useMemoryCheck(largeMemoryModel.size),
    );

    try {
      await waitForNextUpdate();
    } catch (error) {
      // Ignoring timeout
    }

    // Ensure no warnings are shown when there's an error
    expect(result.current).toEqual({
      memoryWarning: '',
      shortMemoryWarning: '',
      multimodalWarning: '',
    });

    // Ensure the error is logged. TODO: check if there is a better way.
    expect(consoleErrorSpy).toHaveBeenCalledWith(
      'Memory check failed:',
      new Error('Memory error'),
    );

    consoleErrorSpy.mockRestore();
  });
});



================================================
FILE: src/hooks/__tests__/useMessageActions.test.ts
================================================
import Clipboard from '@react-native-clipboard/clipboard';
import {renderHook, act} from '@testing-library/react-hooks';

import {textMessage, user} from '../../../jest/fixtures';
import {createModel} from '../../../jest/fixtures/models';

import {useMessageActions} from '../useMessageActions';

import {chatSessionStore, modelStore} from '../../store';

jest.mock('@react-native-clipboard/clipboard', () => ({
  setString: jest.fn(),
}));

describe('useMessageActions', () => {
  const mockSetInputText = jest.fn();
  const mockHandleSendPress = jest.fn();
  const messages = [
    {
      ...textMessage,
      id: '1',
      text: 'Hello',
      author: user,
    },
    {
      ...textMessage,
      id: '2',
      text: 'Hi there',
      author: {id: 'assistant'},
    },
  ];

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('copies message text to clipboard', () => {
    const {result} = renderHook(() =>
      useMessageActions({
        user,
        messages,
        handleSendPress: mockHandleSendPress,
        setInputText: mockSetInputText,
      }),
    );

    act(() => {
      result.current.handleCopy({
        ...textMessage,
        text: 'Copy this text',
        type: 'text',
      });
    });

    expect(Clipboard.setString).toHaveBeenCalledWith('Copy this text');
  });

  it('enters edit mode for user message', () => {
    const {result} = renderHook(() =>
      useMessageActions({
        user,
        messages,
        handleSendPress: mockHandleSendPress,
        setInputText: mockSetInputText,
      }),
    );

    const userMessage = {
      ...textMessage,
      id: 'test-id',
      text: 'Edit this message',
      author: user,
      type: 'text' as const,
    };

    act(() => {
      result.current.handleEdit(userMessage);
    });

    expect(chatSessionStore.enterEditMode).toHaveBeenCalledWith('test-id');
    expect(mockSetInputText).toHaveBeenCalledWith('Edit this message');
  });

  it('does not enter edit mode for assistant message', () => {
    const {result} = renderHook(() =>
      useMessageActions({
        user,
        messages,
        handleSendPress: mockHandleSendPress,
        setInputText: mockSetInputText,
      }),
    );

    const assistantMessage = {
      ...textMessage,
      author: {id: 'assistant'},
      type: 'text' as const,
    };

    act(() => {
      result.current.handleEdit(assistantMessage);
    });

    expect(chatSessionStore.enterEditMode).not.toHaveBeenCalled();
    expect(mockSetInputText).not.toHaveBeenCalled();
  });

  describe('handleTryAgain', () => {
    it('resubmits user message', async () => {
      const {result} = renderHook(() =>
        useMessageActions({
          user,
          messages,
          handleSendPress: mockHandleSendPress,
          setInputText: mockSetInputText,
        }),
      );

      const userMessage = {
        ...textMessage,
        id: '1',
        text: 'Try again with this',
        author: user,
        type: 'text' as const,
      };

      await act(async () => {
        await result.current.handleTryAgain(userMessage);
      });

      expect(chatSessionStore.removeMessagesFromId).toHaveBeenCalledWith(
        '1',
        true,
      );
      expect(mockHandleSendPress).toHaveBeenCalledWith({
        text: 'Try again with this',
        type: 'text',
      });
    });

    it('resubmits last user message when retrying assistant message', async () => {
      const _messages = [
        {
          ...textMessage,
          id: '2',
          text: 'Assistant response',
          author: {id: 'assistant'},
          type: 'text' as const,
        },
        {
          ...textMessage,
          id: '1',
          text: 'User message',
          author: user,
          type: 'text' as const,
        },
      ];

      const {result} = renderHook(() =>
        useMessageActions({
          user,
          messages: _messages,
          handleSendPress: mockHandleSendPress,
          setInputText: mockSetInputText,
        }),
      );

      await act(async () => {
        await result.current.handleTryAgain(_messages[1]);
      });

      expect(chatSessionStore.removeMessagesFromId).toHaveBeenCalledWith(
        '1',
        true,
      );
      expect(mockHandleSendPress).toHaveBeenCalledWith({
        text: 'User message',
        type: 'text',
      });
    });
  });

  describe('handleTryAgainWith', () => {
    it('uses current model if model ID matches', async () => {
      const {result} = renderHook(() =>
        useMessageActions({
          user,
          messages,
          handleSendPress: mockHandleSendPress,
          setInputText: mockSetInputText,
        }),
      );

      modelStore.activeModelId = 'model-1';

      await act(async () => {
        await result.current.handleTryAgainWith('model-1', messages[0]);
      });

      expect(modelStore.initContext).not.toHaveBeenCalled();
      expect(chatSessionStore.removeMessagesFromId).toHaveBeenCalled();
      expect(mockHandleSendPress).toHaveBeenCalled();
    });

    it('initializes new model if model ID differs', async () => {
      const {result} = renderHook(() =>
        useMessageActions({
          user,
          messages,
          handleSendPress: mockHandleSendPress,
          setInputText: mockSetInputText,
        }),
      );

      modelStore.activeModelId = 'model-1';
      modelStore.models = [createModel({id: 'model-2', name: 'Model 2'})];

      await act(async () => {
        await result.current.handleTryAgainWith('model-2', messages[0]);
      });

      expect(modelStore.initContext).toHaveBeenCalled();
      expect(chatSessionStore.removeMessagesFromId).toHaveBeenCalled();
      expect(mockHandleSendPress).toHaveBeenCalled();
    });
  });
});



================================================
FILE: src/hooks/__tests__/useStorageCheck.test.ts
================================================
import {act, renderHook} from '@testing-library/react-hooks';

import {largeDiskModel, basicModel} from '../../../jest/fixtures/models';

import {useStorageCheck} from '../useStorageCheck';

describe('useStorageCheck', () => {
  it('returns storage OK status when there is enough space', async () => {
    const {result} = renderHook(() => useStorageCheck(basicModel));

    expect(result.current).toEqual({
      isOk: true,
      message: '',
    });
  });

  it('returns storage low message when there is not enough space', async () => {
    const {result, waitForNextUpdate} = renderHook(() =>
      useStorageCheck(largeDiskModel),
    );

    await waitForNextUpdate();

    expect(result.current).toEqual(
      expect.objectContaining({
        isOk: false,
        message: expect.stringContaining('Storage low!'),
      }),
    );
  });

  it('does not update state when unmounted (cleanup test)', async () => {
    const {result, unmount, waitForNextUpdate} = renderHook(() =>
      useStorageCheck(largeDiskModel),
    );

    unmount();

    // wait for the state to update (which should not happen after unmount)
    await act(async () => {
      try {
        await waitForNextUpdate();
      } catch (error) {
        // Ignoring timeout
      }
    });

    expect(result.current).toEqual({
      isOk: true,
      message: '',
    });
  });
});



================================================
FILE: src/hooks/__tests__/useStructuredOutput.test.ts
================================================
import {renderHook, act} from '@testing-library/react-hooks';
import {useStructuredOutput} from '../useStructuredOutput';
import {modelStore} from '../../store';

// Mock the modelStore
jest.mock('../../store', () => ({
  modelStore: {
    context: {
      completion: jest.fn(),
    },
  },
}));

describe('useStructuredOutput', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    // Reset modelStore.context for each test
    (modelStore as any).context = {
      completion: jest.fn(),
    };
  });

  it('should generate structured output successfully', async () => {
    const mockResponse = {text: '{"key": "value"}'};
    (modelStore.context!.completion as jest.Mock).mockResolvedValueOnce(
      mockResponse,
    );

    const {result} = renderHook(() => useStructuredOutput());

    const prompt = 'test prompt';
    const schema = {type: 'object', properties: {key: {type: 'string'}}};

    let output;
    await act(async () => {
      output = await result.current.generate(prompt, schema);
    });

    expect(output).toEqual({key: 'value'});
    expect(result.current.isGenerating).toBe(false);
    expect(result.current.error).toBeNull();
    expect(modelStore.context?.completion).toHaveBeenCalledWith({
      messages: [{role: 'user', content: prompt}],
      response_format: {
        type: 'json_schema',
        json_schema: {
          strict: true,
          schema,
        },
      },
      temperature: 0.7,
      top_p: 0.9,
      top_k: 40,
      n_predict: 2000,
    });
  });

  it('should handle custom options', async () => {
    const mockResponse = {text: '{"key": "value"}'};
    (modelStore.context!.completion as jest.Mock).mockResolvedValueOnce(
      mockResponse,
    );

    const {result} = renderHook(() => useStructuredOutput());

    const options = {
      temperature: 0.5,
      top_p: 0.8,
      top_k: 30,
      repeat_penalty: 1.1,
    };

    await act(async () => {
      await result.current.generate('test', {}, options);
    });

    expect(modelStore.context?.completion).toHaveBeenCalledWith(
      expect.objectContaining({
        temperature: options.temperature,
        top_p: options.top_p,
        top_k: options.top_k,
      }),
    );
  });

  it('should handle invalid JSON response', async () => {
    const mockResponse = {text: 'invalid json'};
    (modelStore.context!.completion as jest.Mock).mockResolvedValueOnce(
      mockResponse,
    );

    const {result} = renderHook(() => useStructuredOutput());

    let output;
    await act(async () => {
      output = await result.current.generate('test', {});
    });

    expect(output).toEqual({prompt: '', error: expect.any(Error)});
    expect(result.current.isGenerating).toBe(false);
  });

  it('should handle uninitialized model context', async () => {
    // Mock modelStore with undefined context
    (modelStore as any).context = undefined;

    const {result} = renderHook(() => useStructuredOutput());

    let error;
    await act(async () => {
      try {
        await result.current.generate('test', {});
      } catch (e) {
        error = e;
      }
    });

    expect(error).toBeInstanceOf(Error);
    expect(error.message).toBe('Model context not initialized');
    expect(result.current.isGenerating).toBe(false);
  });

  it('should handle completion error', async () => {
    const errorMessage = 'Completion failed';
    (modelStore.context!.completion as jest.Mock).mockRejectedValueOnce(
      new Error(errorMessage),
    );

    const {result} = renderHook(() => useStructuredOutput());

    let error;
    await act(async () => {
      try {
        await result.current.generate('test', {});
      } catch (e) {
        error = e;
      }
    });

    expect(error).toBeDefined();
    expect(error.message).toBe(errorMessage);
    expect(result.current.isGenerating).toBe(false);
    expect(result.current.error).toBe(errorMessage);
  });
});



================================================
FILE: src/hooks/__tests__/useTheme.test.ts
================================================
import {renderHook} from '@testing-library/react-native';
import {act} from 'react-test-renderer';

jest.unmock('../useTheme');
jest.unmock('../../store');
import {useTheme} from '../useTheme';

import {uiStore} from '../../store';

import {darkTheme, lightTheme} from '../../utils/theme';

describe('useTheme', () => {
  beforeEach(() => {
    uiStore.setColorScheme('light');
  });

  it('should return light theme when colorScheme is light', () => {
    const {result} = renderHook(() => useTheme());

    expect(result.current).toEqual(
      expect.objectContaining({
        ...lightTheme,
      }),
    );
  });

  it('should return dark theme when colorScheme is dark', async () => {
    uiStore.setColorScheme('dark');

    const {result} = renderHook(() => useTheme());

    // Wait for the next update to ensure the theme change is applied
    await act(async () => {
      await Promise.resolve();
    });

    expect(result.current).toEqual(
      expect.objectContaining({
        ...darkTheme,
      }),
    );
  });
});



================================================
FILE: src/repositories/ChatSessionRepository.ts
================================================
import {Q} from '@nozbe/watermelondb';
import * as RNFS from '@dr.pogodin/react-native-fs';

import {
  database,
  ChatSession,
  Message,
  CompletionSetting,
  GlobalSetting,
} from '../database';

import {SessionMetaData} from '../store/ChatSessionStore';

import {MessageType} from '../utils/types';
import {CompletionParams} from '../utils/completionTypes';
import {
  defaultCompletionParams,
  migrateCompletionSettings,
} from '../utils/completionSettingsVersions';

// Default completion settings without prompt and stop
const defaultCompletionSettings = {...defaultCompletionParams};
delete defaultCompletionSettings.prompt;
delete defaultCompletionSettings.stop;

class ChatSessionRepository {
  // Check if we need to migrate from JSON files
  async checkAndMigrateFromJSON(): Promise<boolean> {
    try {
      // Check if we've already migrated
      const migrationFlagPath = `${RNFS.DocumentDirectoryPath}/db-migration-complete.flag`;
      const migrationComplete = await RNFS.exists(migrationFlagPath);

      if (migrationComplete) {
        console.log('Database migration already completed');
        return false;
      }

      // Check if old JSON data exists
      const oldDataPath = `${RNFS.DocumentDirectoryPath}/session-metadata.json`;
      const oldDataExists = await RNFS.exists(oldDataPath);

      if (!oldDataExists) {
        // No old data to migrate, mark as complete
        await RNFS.writeFile(migrationFlagPath, 'true');
        return false;
      }

      console.log('Starting migration from JSON to WatermelonDB...');

      // Read old data
      const jsonData = await RNFS.readFile(oldDataPath);
      const sessions: SessionMetaData[] = JSON.parse(jsonData);

      // Begin database transaction for atomic migration
      await database.write(async () => {
        // Migrate each session
        for (const session of sessions) {
          // Create session record
          const newSession = await database.collections
            .get('chat_sessions')
            .create((record: any) => {
              record.title = session.title;
              record.date = session.date;
              if (session.activePalId) {
                record.activePalId = session.activePalId;
              }
            });

          // Ensure the completion settings have a version
          const migratedSettings = migrateCompletionSettings(
            session.completionSettings,
          );

          await database.collections
            .get('completion_settings')
            .create((record: any) => {
              record.sessionId = newSession.id;
              record.settings = JSON.stringify(migratedSettings);
            });

          for (let i = 0; i < session.messages.length; i++) {
            const msg = session.messages[i];

            // Extract author ID and prepare metadata with author data
            // Handle both string authors and object authors
            const authorId =
              typeof msg.author === 'string'
                ? msg.author
                : msg.author?.id || 'unknown';
            const metadata = msg.metadata || {};

            // Store author data in metadata for reconstruction
            if (typeof msg.author === 'object' && msg.author !== null) {
              if (
                msg.author.firstName ||
                msg.author.lastName ||
                msg.author.imageUrl
              ) {
                metadata.authorData = {
                  firstName: msg.author.firstName,
                  lastName: msg.author.lastName,
                  imageUrl: msg.author.imageUrl,
                  role: msg.author.role,
                };
              }
            }

            try {
              // Check if createdAt is valid
              if (!msg.createdAt) {
                console.warn(
                  'Message has no createdAt timestamp, using current time',
                );
              }

              await database.collections
                .get('messages')
                .create((record: any) => {
                  record.sessionId = newSession.id; // Use sessionId (JavaScript property), not session_id (DB column)
                  record.author = authorId;
                  if (msg.type === 'text') {
                    record.text = msg.text;
                  }
                  record.type = msg.type;
                  record.metadata = JSON.stringify(metadata);
                  record.position = session.messages.length - i; // Reverse order for correct sorting
                  record.createdAt = msg.createdAt || Date.now(); // Use createdAt, not created_at
                });
            } catch (error) {
              console.error('Error creating message record:', error);
              throw error; // Re-throw to stop the migration
            }
          }
        }

        // Migrate global settings if they exist
        const globalSettingsPath = `${RNFS.DocumentDirectoryPath}/global-completion-settings.json`;
        const globalSettingsExist = await RNFS.exists(globalSettingsPath);

        if (globalSettingsExist) {
          const globalSettingsData = await RNFS.readFile(globalSettingsPath);
          const globalSettings: CompletionParams =
            JSON.parse(globalSettingsData);

          // Ensure the global settings have a version
          const migratedGlobalSettings =
            migrateCompletionSettings(globalSettings);

          await database.collections
            .get('global_settings')
            .create((record: any) => {
              record.key = 'newChatCompletionSettings';
              record.value = JSON.stringify(migratedGlobalSettings);
            });
        }
      });

      // Mark migration as complete
      await RNFS.writeFile(migrationFlagPath, 'true');
      console.log('Migration from JSON to WatermelonDB completed successfully');

      return true;
    } catch (error) {
      console.error('Error during migration:', error);
      return false;
    }
  }

  // Get all sessions grouped by date
  async getAllSessions(): Promise<ChatSession[]> {
    const sessions = await database.collections
      .get('chat_sessions')
      .query()
      .fetch();
    return sessions as unknown as ChatSession[];
  }

  // Get a single session with its messages and settings
  async getSessionById(id: string): Promise<{
    session: ChatSession;
    messages: Message[];
    completionSettings: CompletionSetting;
  } | null> {
    const session = await database.collections
      .get('chat_sessions')
      .find(id)
      .catch(() => null);

    if (!session) {
      return null;
    }

    const messages = await database.collections
      .get('messages')
      .query(Q.where('session_id', id), Q.sortBy('position', Q.desc))
      .fetch();

    // Since we're using 'has_many' for completion_settings in the model (TypeScript limitation),
    // we need to fetch as an array and get the first item
    const completionSettingsArray = await database.collections
      .get('completion_settings')
      .query(Q.where('session_id', id))
      .fetch();

    const completionSettings =
      completionSettingsArray.length > 0 ? completionSettingsArray[0] : null;

    return {
      session: session as unknown as ChatSession,
      messages: messages as unknown as Message[],
      completionSettings: completionSettings as unknown as CompletionSetting,
    };
  }

  // Create a new session
  async createSession(
    title: string,
    initialMessages: MessageType.Any[] = [],
    completionSettings: CompletionParams = defaultCompletionSettings,
    activePalId?: string,
  ): Promise<ChatSession> {
    let newSession: any;

    await database.write(async () => {
      // Create session
      newSession = await database.collections
        .get('chat_sessions')
        .create((record: any) => {
          record.title = title;
          record.date = new Date().toISOString();
          if (activePalId) {
            record.activePalId = activePalId;
          }
        });

      // Create completion settings with version
      const migratedSettings = migrateCompletionSettings(completionSettings);

      await database.collections
        .get('completion_settings')
        .create((record: any) => {
          record.sessionId = newSession.id;
          record.settings = JSON.stringify(migratedSettings);
        });

      // Create initial messages if any
      for (let i = 0; i < initialMessages.length; i++) {
        const msg = initialMessages[i];

        const authorId = msg.author.id;
        const metadata = msg.metadata || {};

        if (
          msg.author.firstName ||
          msg.author.lastName ||
          msg.author.imageUrl
        ) {
          metadata.authorData = {
            firstName: msg.author.firstName,
            lastName: msg.author.lastName,
            imageUrl: msg.author.imageUrl,
            role: msg.author.role,
          };
        }
        if (msg.type === 'text' && msg.imageUris) {
          metadata.imageUris = msg.imageUris;
        }

        await database.collections.get('messages').create((record: any) => {
          record.sessionId = newSession.id;
          record.author = authorId;
          if (msg.type === 'text') {
            record.text = msg.text;
          }
          record.type = msg.type;
          record.metadata = JSON.stringify(metadata);
          record.position = initialMessages.length - i; // Reverse order
          record.createdAt = msg.createdAt || Date.now();
        });
      }
    });

    return newSession as unknown as ChatSession;
  }

  // Delete a session
  async deleteSession(id: string): Promise<void> {
    const session = await database.collections
      .get('chat_sessions')
      .find(id)
      .catch(() => null);

    if (!session) {
      return;
    }

    await database.write(async () => {
      // Delete associated messages
      const messages = await database.collections
        .get('messages')
        .query(Q.where('session_id', id))
        .fetch();

      for (const message of messages) {
        await message.destroyPermanently();
      }

      // Delete associated completion settings
      const settings = await database.collections
        .get('completion_settings')
        .query(Q.where('session_id', id))
        .fetch();

      for (const setting of settings) {
        await setting.destroyPermanently();
      }

      // Delete the session itself
      await session.destroyPermanently();
    });
  }

  // Add a message to a session
  async addMessageToSession(
    sessionId: string,
    message: MessageType.Any,
  ): Promise<Message> {
    let newMessage: any;

    await database.write(async () => {
      // Get the highest position
      const messages = await database.collections
        .get('messages')
        .query(Q.where('session_id', sessionId))
        .fetch();

      // Calculate highest position - need to cast to any to access position property
      const positions = messages.map(m => (m as any).position || 0);
      const highestPosition = positions.length > 0 ? Math.max(...positions) : 0;

      // Extract author ID from User object
      const authorId = message.author.id;

      // Store additional author data in metadata
      const metadata = message.metadata || {};
      if (
        message.author.firstName ||
        message.author.lastName ||
        message.author.imageUrl
      ) {
        metadata.authorData = {
          firstName: message.author.firstName,
          lastName: message.author.lastName,
          imageUrl: message.author.imageUrl,
          role: message.author.role,
          // Add any other User properties you need
        };
      }

      // Store imageUris in metadata for text messages
      if (message.type === 'text' && (message as MessageType.Text).imageUris) {
        metadata.imageUris = (message as MessageType.Text).imageUris;
      }

      newMessage = await database.collections
        .get('messages')
        .create((record: any) => {
          record.sessionId = sessionId;
          record.author = authorId; // Store just the ID
          if (message.type === 'text') {
            record.text = message.text;
          }
          record.type = message.type;
          record.metadata = JSON.stringify(metadata);
          record.position = highestPosition + 1;
          record.createdAt = message.createdAt || Date.now();
        });
    });

    return newMessage as unknown as Message;
  }

  // Update a message
  async updateMessage(
    id: string,
    update: Partial<MessageType.Text>,
  ): Promise<boolean> {
    try {
      const message = await database.collections
        .get('messages')
        .find(id)
        .catch(() => null);

      if (!message) {
        console.warn(
          `Message with ID ${id} not found in database, cannot update`,
        );
        return false;
      }

      await database.write(async () => {
        await message.update((record: any) => {
          if (update.text !== undefined) {
            record.text = update.text;
          }
          if (update.metadata !== undefined) {
            record.metadata = JSON.stringify(update.metadata);
          }
        });
      });

      return true;
    } catch (error) {
      console.error('Error updating message:', error);
      return false;
    }
  }

  // Update session completion settings
  async updateSessionCompletionSettings(
    sessionId: string,
    settings: CompletionParams,
  ): Promise<void> {
    const completionSettingsArray = await database.collections
      .get('completion_settings')
      .query(Q.where('session_id', sessionId))
      .fetch();

    if (completionSettingsArray.length === 0) {
      return;
    }

    const completionSettings = completionSettingsArray[0];

    await database.write(async () => {
      // Ensure settings have a version
      const migratedSettings = migrateCompletionSettings(settings);

      await completionSettings.update((record: any) => {
        record.settings = JSON.stringify(migratedSettings);
      });
    });
  }

  // Get global completion settings
  async getGlobalCompletionSettings(): Promise<CompletionParams> {
    const globalSettingsArray = await database.collections
      .get('global_settings')
      .query(Q.where('key', 'newChatCompletionSettings'))
      .fetch();

    if (globalSettingsArray.length === 0) {
      return defaultCompletionSettings;
    }

    const globalSettings = globalSettingsArray[0] as any;
    return JSON.parse(globalSettings.value);
  }

  // Save global completion settings
  async saveGlobalCompletionSettings(
    settings: CompletionParams,
  ): Promise<void> {
    await database.write(async () => {
      const existingSettingsArray = await database.collections
        .get('global_settings')
        .query(Q.where('key', 'newChatCompletionSettings'))
        .fetch();

      const migratedSettings = migrateCompletionSettings(settings);

      if (existingSettingsArray.length > 0) {
        const existingSettings = existingSettingsArray[0];
        await existingSettings.update((record: any) => {
          record.value = JSON.stringify(migratedSettings);
        });
      } else {
        await database.collections
          .get('global_settings')
          .create((record: any) => {
            record.key = 'newChatCompletionSettings';
            record.value = JSON.stringify(migratedSettings);
          });
      }
    });
  }

  // Update session title
  async updateSessionTitle(sessionId: string, newTitle: string): Promise<void> {
    const session = await database.collections
      .get('chat_sessions')
      .find(sessionId)
      .catch(() => null);

    if (!session) {
      return;
    }

    await database.write(async () => {
      await session.update((record: any) => {
        record.title = newTitle;
      });
    });
  }

  // Set active pal for a session
  async setSessionActivePal(sessionId: string, palId?: string): Promise<void> {
    const session = await database.collections
      .get('chat_sessions')
      .find(sessionId)
      .catch(() => null);

    if (!session) {
      return;
    }

    await database.write(async () => {
      await session.update((record: any) => {
        record.activePalId = palId || null;
      });
    });
  }

  // Delete a message by ID
  async deleteMessage(id: string): Promise<void> {
    const message = await database.collections
      .get('messages')
      .find(id)
      .catch(() => null);

    if (!message) {
      return;
    }

    await database.write(async () => {
      await message.destroyPermanently();
    });
  }

  // Reset migration flag for testing
  async resetMigration(): Promise<void> {
    try {
      const migrationFlagPath = `${RNFS.DocumentDirectoryPath}/db-migration-complete.flag`;
      if (await RNFS.exists(migrationFlagPath)) {
        await RNFS.unlink(migrationFlagPath);
        console.log('Migration flag reset successfully');
      } else {
        console.log('Migration flag does not exist');
      }

      // Clear the database for a clean migration test
      await database.write(async () => {
        // Get all collections
        const collections = [
          'chat_sessions',
          'messages',
          'completion_settings',
          'global_settings',
        ];

        // Delete all records in each collection
        for (const collectionName of collections) {
          const records = await database.collections
            .get(collectionName)
            .query()
            .fetch();

          for (const record of records) {
            await record.destroyPermanently();
          }
        }
      });

      console.log('Database cleared for migration test');
    } catch (error) {
      console.error('Failed to reset migration:', error);
    }
  }

  /**
   * Migrates settings for all sessions and global settings if needed
   * This should be called periodically to ensure all settings are up to date
   */
  async migrateAllSettings(): Promise<void> {
    try {
      console.log('Checking for settings that need migration...');

      // Get all completion settings
      const completionSettings = (await database.collections
        .get('completion_settings')
        .query()
        .fetch()) as CompletionSetting[];

      // Get all global settings
      const globalSettings = (await database.collections
        .get('global_settings')
        .query()
        .fetch()) as GlobalSetting[];

      // Check which settings need migration
      const settingsToMigrate = completionSettings.filter(setting => {
        try {
          const parsedSettings = JSON.parse(setting.settings);
          const migratedSettings = migrateCompletionSettings(parsedSettings);
          return migratedSettings.version !== parsedSettings.version;
        } catch (error) {
          console.error('Error checking if settings need migration:', error);
          return false;
        }
      });

      // Check which global settings need migration
      const globalSettingsToMigrate = globalSettings.filter(setting => {
        if (setting.key !== 'newChatCompletionSettings') {
          return false;
        }

        try {
          const parsedSettings = JSON.parse(setting.value);
          const migratedSettings = migrateCompletionSettings(parsedSettings);
          return migratedSettings.version !== parsedSettings.version;
        } catch (error) {
          console.error(
            'Error checking if global settings need migration:',
            error,
          );
          return false;
        }
      });

      console.log(
        `Found ${settingsToMigrate.length} session settings and ${globalSettingsToMigrate.length} global settings that need migration`,
      );

      // Migrate settings in a single transaction
      if (settingsToMigrate.length > 0 || globalSettingsToMigrate.length > 0) {
        await database.write(async () => {
          // Migrate completion settings
          for (const setting of settingsToMigrate) {
            const parsedSettings = JSON.parse(setting.settings);
            const migratedSettings = migrateCompletionSettings(parsedSettings);

            await setting.update((record: any) => {
              record.settings = JSON.stringify(migratedSettings);
            });

            console.log(
              `Migrated settings for session ${setting.sessionId} from version ${parsedSettings.version} to ${migratedSettings.version}`,
            );
          }

          // Migrate global settings
          for (const setting of globalSettingsToMigrate) {
            const parsedSettings = JSON.parse(setting.value);
            const migratedSettings = migrateCompletionSettings(parsedSettings);

            await setting.update((record: any) => {
              record.value = JSON.stringify(migratedSettings);
            });

            console.log(
              `Migrated global settings for key ${setting.key} from version ${parsedSettings.version} to ${migratedSettings.version}`,
            );
          }
        });

        console.log('Settings migration completed successfully');
      } else {
        console.log('No settings need migration');
      }
    } catch (error) {
      console.error('Error migrating settings:', error);
    }
  }
}

export const chatSessionRepository = new ChatSessionRepository();



================================================
FILE: src/repositories/__tests__/ChatSessionRepository.test.ts
================================================
import {chatSessionRepository} from '../ChatSessionRepository';

// Mock the database
jest.mock('../../database', () => ({
  database: {
    write: jest.fn().mockImplementation(async callback => {
      await callback();
    }),
    collections: {
      get: jest.fn().mockReturnValue({
        create: jest.fn(),
        find: jest.fn(),
        query: jest.fn().mockReturnValue({
          where: jest.fn().mockReturnThis(),
          sortBy: jest.fn().mockReturnThis(),
          fetch: jest.fn().mockResolvedValue([]),
        }),
      }),
    },
  },
}));

// Mock RNFS
jest.mock('@dr.pogodin/react-native-fs', () => ({
  DocumentDirectoryPath: '/mock/path',
  exists: jest.fn().mockResolvedValue(false),
  readFile: jest.fn().mockResolvedValue('[]'),
  writeFile: jest.fn().mockResolvedValue(undefined),
  unlink: jest.fn().mockResolvedValue(undefined),
}));

describe('ChatSessionRepository', () => {
  it('should have all required methods', () => {
    // Verify that the repository has all the expected methods
    expect(chatSessionRepository).toBeDefined();
    expect(typeof chatSessionRepository.getAllSessions).toBe('function');
    expect(typeof chatSessionRepository.getSessionById).toBe('function');
    expect(typeof chatSessionRepository.createSession).toBe('function');
    expect(typeof chatSessionRepository.deleteSession).toBe('function');
    expect(typeof chatSessionRepository.addMessageToSession).toBe('function');
    expect(typeof chatSessionRepository.updateMessage).toBe('function');
    expect(typeof chatSessionRepository.updateSessionCompletionSettings).toBe(
      'function',
    );
    expect(typeof chatSessionRepository.getGlobalCompletionSettings).toBe(
      'function',
    );
    expect(typeof chatSessionRepository.saveGlobalCompletionSettings).toBe(
      'function',
    );
    expect(typeof chatSessionRepository.updateSessionTitle).toBe('function');
    expect(typeof chatSessionRepository.setSessionActivePal).toBe('function');
    expect(typeof chatSessionRepository.deleteMessage).toBe('function');
    // These might be private methods, so we don't test for them
    // expect(typeof chatSessionRepository.resetMigration).toBe('function');
    // expect(typeof chatSessionRepository.migrateAllSettings).toBe('function');
    // expect(typeof chatSessionRepository.checkAndMigrateFromJSON).toBe('function');
  });

  it('should be able to call getAllSessions without errors', async () => {
    await expect(chatSessionRepository.getAllSessions()).resolves.not.toThrow();
  });

  it('should be able to call getSessionById without errors', async () => {
    await expect(
      chatSessionRepository.getSessionById('test-id'),
    ).resolves.not.toThrow();
  });

  it('should be able to call getGlobalCompletionSettings without errors', async () => {
    await expect(
      chatSessionRepository.getGlobalCompletionSettings(),
    ).resolves.not.toThrow();
  });
});



================================================
FILE: src/screens/index.ts
================================================
export * from './AboutScreen';
export * from './BenchmarkScreen';
export * from './ChatScreen';
export * from './ModelsScreen';
export * from './PalsScreen';
export * from './SettingsScreen';

// Dev tools screen. Only available in debug mode.
export * from './DevToolsScreen';



================================================
FILE: src/screens/AboutScreen/AboutScreen.tsx
================================================
import React, {useState, useContext} from 'react';
import {
  View,
  ScrollView,
  TouchableOpacity,
  Alert,
  Linking,
  Platform,
} from 'react-native';

import DeviceInfo from 'react-native-device-info';
import Clipboard from '@react-native-clipboard/clipboard';
import {Text, Button, SegmentedButtons} from 'react-native-paper';
import {SafeAreaView, useSafeAreaInsets} from 'react-native-safe-area-context';

import {submitFeedback} from '../../api/feedback';

import {
  CopyIcon,
  GithubIcon,
  ChevronRightIcon,
  HeartIcon,
} from '../../assets/icons';

import {Sheet, TextInput} from '../../components';
import {useTheme} from '../../hooks';
import {createStyles} from './styles';
import {L10nContext} from '../../utils';

const GithubButtonIcon = ({color}: {color: string}) => (
  <GithubIcon stroke={color} />
);

const ChevronRightButtonIcon = ({color}: {color: string}) => (
  <ChevronRightIcon stroke={color} />
);

export const AboutScreen: React.FC = () => {
  const theme = useTheme();
  const insets = useSafeAreaInsets();
  const styles = createStyles(theme, insets);
  const l10n = useContext(L10nContext);
  const [showFeedback, setShowFeedback] = useState(false);

  const [appInfo, setAppInfo] = React.useState({
    version: '',
    build: '',
  });

  const [useCase, setUseCase] = useState('');
  const [featureRequests, setFeatureRequests] = useState('');
  const [generalFeedback, setGeneralFeedback] = useState('');
  const [usageFrequency, setUsageFrequency] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  React.useEffect(() => {
    const version = DeviceInfo.getVersion();
    const buildNumber = DeviceInfo.getBuildNumber();
    setAppInfo({
      version,
      build: buildNumber,
    });
  }, []);

  const copyVersionToClipboard = () => {
    const versionString = `Version ${appInfo.version} (${appInfo.build})`;
    Clipboard.setString(versionString);
    Alert.alert(
      l10n.about.versionCopiedTitle,
      l10n.about.versionCopiedDescription,
    );
  };

  const handleSubmit = async () => {
    if (!useCase && !featureRequests && !generalFeedback) {
      Alert.alert(l10n.feedback.validation.required);
      return;
    }

    setIsSubmitting(true);
    try {
      await submitFeedback({
        useCase,
        featureRequests,
        generalFeedback,
        usageFrequency,
      });
      Alert.alert('Success', l10n.feedback.success);
      setShowFeedback(false);
      // Clear form
      setUseCase('');
      setFeatureRequests('');
      setGeneralFeedback('');
      setUsageFrequency('');
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : l10n.feedback.error.general;
      Alert.alert('Error', errorMessage);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <SafeAreaView style={styles.safeArea} edges={['bottom']}>
      <ScrollView contentContainerStyle={styles.container}>
        <View style={styles.card}>
          <View style={styles.header}>
            <View style={styles.headerContent}>
              <Text variant="titleLarge" style={styles.title}>
                PocketPal AI
              </Text>
              <Text variant="bodyMedium" style={styles.description}>
                {l10n.about.description}
              </Text>
              <View style={styles.versionContainer}>
                <TouchableOpacity
                  style={styles.versionButton}
                  onPress={copyVersionToClipboard}>
                  <Text style={styles.versionText}>
                    v{appInfo.version} ({appInfo.build})
                  </Text>
                  <CopyIcon
                    width={16}
                    height={16}
                    stroke={theme.colors.textSecondary}
                  />
                </TouchableOpacity>
              </View>
            </View>
          </View>

          <View style={styles.section}>
            <Text style={styles.sectionTitle}>{l10n.about.supportProject}</Text>
            <Text variant="bodyMedium" style={styles.description}>
              {l10n.about.supportProjectDescription}
            </Text>
            <Button
              mode="outlined"
              onPress={() =>
                Linking.openURL('https://github.com/a-ghorbani/pocketpal-ai')
              }
              style={styles.actionButton}
              icon={GithubButtonIcon}>
              {l10n.about.githubButton}
            </Button>
            {Platform.OS !== 'ios' && (
              <>
                <Text style={styles.orText}>{l10n.about.orText}</Text>
                <TouchableOpacity
                  style={styles.supportButton}
                  onPress={() =>
                    Linking.openURL('https://www.buymeacoffee.com/aghorbani')
                  }>
                  <HeartIcon stroke={theme.colors.onPrimary} />
                  <Text style={styles.supportButtonText}>
                    {l10n.about.sponsorButton}
                  </Text>
                </TouchableOpacity>
              </>
            )}
            <Text style={styles.orText}>{l10n.about.orBy}</Text>
            <Button
              mode="outlined"
              style={styles.actionButton}
              contentStyle={styles.feedbackButtonContent}
              icon={ChevronRightButtonIcon}
              onPress={() => setShowFeedback(true)}>
              {l10n.feedback.shareThoughtsButton}
            </Button>
          </View>
        </View>
      </ScrollView>

      <Sheet
        title={l10n.feedback.title}
        isVisible={showFeedback}
        displayFullHeight
        onClose={() => setShowFeedback(false)}>
        <Sheet.ScrollView contentContainerStyle={styles.feedbackForm}>
          <View style={styles.field}>
            <Text style={styles.label}>{l10n.feedback.useCase.label}</Text>
            <TextInput
              defaultValue={useCase}
              onChangeText={setUseCase}
              placeholder={l10n.feedback.useCase.placeholder}
              multiline
              numberOfLines={4}
            />
          </View>

          <View style={styles.field}>
            <Text style={styles.label}>
              {l10n.feedback.featureRequests.label}
            </Text>
            <TextInput
              defaultValue={featureRequests}
              onChangeText={setFeatureRequests}
              placeholder={l10n.feedback.featureRequests.placeholder}
              multiline
              numberOfLines={4}
            />
          </View>

          <View style={styles.field}>
            <Text style={styles.label}>
              {l10n.feedback.generalFeedback.label}
            </Text>
            <TextInput
              defaultValue={generalFeedback}
              onChangeText={setGeneralFeedback}
              placeholder={l10n.feedback.generalFeedback.placeholder}
              multiline
              numberOfLines={4}
            />
          </View>

          <View style={styles.field}>
            <Text style={styles.label}>
              {l10n.feedback.usageFrequency.label}
            </Text>
            <SegmentedButtons
              value={usageFrequency}
              onValueChange={setUsageFrequency}
              buttons={[
                {
                  value: 'daily',
                  label: l10n.feedback.usageFrequency.options.daily,
                },
                {
                  value: 'weekly',
                  label: l10n.feedback.usageFrequency.options.weekly,
                },
                {
                  value: 'monthly',
                  label: l10n.feedback.usageFrequency.options.monthly,
                },
                {
                  value: 'rarely',
                  label: l10n.feedback.usageFrequency.options.rarely,
                },
              ]}
              style={styles.segmentedButtons}
            />
          </View>
        </Sheet.ScrollView>
        <Sheet.Actions>
          <View style={styles.secondaryButtons}>
            <Button mode="text" onPress={() => setShowFeedback(false)}>
              {l10n.common.cancel}
            </Button>
          </View>
          <Button
            mode="contained"
            onPress={handleSubmit}
            loading={isSubmitting}
            disabled={isSubmitting}>
            {l10n.feedback.submit}
          </Button>
        </Sheet.Actions>
      </Sheet>
    </SafeAreaView>
  );
};



================================================
FILE: src/screens/AboutScreen/index.ts
================================================
export * from './AboutScreen';



================================================
FILE: src/screens/AboutScreen/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {EdgeInsets} from 'react-native-safe-area-context';
import {Theme} from '../../utils/types';

export const createStyles = (theme: Theme, insets: EdgeInsets) =>
  StyleSheet.create({
    safeArea: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    container: {
      flexGrow: 1,
      padding: theme.spacing.default,
      paddingBottom: theme.spacing.default + insets.bottom,
    },
    card: {
      backgroundColor: theme.colors.surface,
      borderRadius: theme.borders.default,
      overflow: 'hidden',
      shadowColor: theme.colors.shadow,
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.1,
      shadowRadius: 8,
      elevation: 4,
    },
    header: {
      padding: theme.spacing.default * 2,
      backgroundColor: theme.colors.surfaceContainerHighest,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.surfaceVariant,
    },
    headerContent: {
      gap: theme.spacing.default,
    },
    title: {
      ...theme.fonts.headlineLarge,
      color: theme.colors.onSurface,
      marginBottom: theme.spacing.default / 2,
      letterSpacing: -0.5,
    },
    description: {
      color: theme.colors.onSurfaceVariant,
      marginBottom: theme.spacing.default,
      lineHeight: 24,
    },
    versionContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: theme.spacing.default / 2,
    },
    versionButton: {
      flexDirection: 'row',
      alignItems: 'center',
      backgroundColor: theme.colors.surfaceContainerHigh,
      paddingHorizontal: theme.spacing.default,
      paddingVertical: theme.spacing.default / 2,
      borderRadius: theme.borders.default,
      gap: theme.spacing.default / 2,
      borderWidth: 1,
      borderColor: theme.colors.surfaceVariant,
    },
    versionText: {
      ...theme.fonts.bodyMedium,
      color: theme.colors.onSurface,
    },
    section: {
      padding: theme.spacing.default * 2,
      borderBottomWidth: 1,
      borderBottomColor: theme.colors.surfaceVariant,
    },
    sectionTitle: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onSurface,
      marginBottom: theme.spacing.default,
    },
    actionButton: {
      borderWidth: 1,
      borderColor: theme.colors.surfaceVariant,
    },
    orText: {
      ...theme.fonts.bodyMedium,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      marginVertical: theme.spacing.default,
      opacity: 0.7,
    },
    supportButton: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: theme.colors.primary,
      padding: theme.spacing.default,
      borderRadius: theme.borders.default,
      gap: theme.spacing.default / 2,
      shadowColor: theme.colors.primary,
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.2,
      shadowRadius: 4,
      elevation: 2,
    },
    supportButtonText: {
      ...theme.fonts.titleMedium,
      color: theme.colors.onPrimary,
      letterSpacing: 0.5,
    },
    feedbackButtonContent: {
      flexDirection: 'row-reverse',
    },
    feedbackForm: {
      padding: theme.spacing.default,
    },
    field: {
      marginBottom: theme.spacing.default,
    },
    label: {
      ...theme.fonts.labelMedium,
      color: theme.colors.onSurface,
      marginBottom: theme.spacing.default / 2,
    },
    segmentedButtons: {
      marginTop: theme.spacing.default / 2,
    },
    submitButton: {
      marginTop: theme.spacing.default,
    },
    secondaryButtons: {
      flexDirection: 'row',
    },
  });



================================================
FILE: src/screens/AboutScreen/__tests__/AboutScreen.test.tsx
================================================
import React from 'react';
import {Alert, Linking, Platform} from 'react-native';
import {render, fireEvent, act} from '../../../../jest/test-utils';
import {AboutScreen} from '../AboutScreen';
import {submitFeedback} from '../../../api/feedback';
import {l10n} from '../../../utils/l10n';

// Mock DeviceInfo
jest.mock('react-native-device-info', () => ({
  getVersion: jest.fn().mockReturnValue('1.0.0'),
  getBuildNumber: jest.fn().mockReturnValue('100'),
}));

// Mock Clipboard
jest.mock('@react-native-clipboard/clipboard', () => ({
  setString: jest.fn(),
}));

// Mock Linking
jest.mock('react-native/Libraries/Linking/Linking', () => ({
  openURL: jest.fn().mockImplementation(() => Promise.resolve()),
}));

// Mock feedback API
jest.mock('../../../api/feedback', () => ({
  submitFeedback: jest.fn().mockResolvedValue(undefined),
}));

jest.spyOn(Alert, 'alert');

describe('AboutScreen', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders correctly', () => {
    const {getByText} = render(<AboutScreen />);

    expect(getByText('PocketPal AI')).toBeTruthy();
    expect(getByText('v1.0.0 (100)')).toBeTruthy();
    expect(getByText(l10n.en.about.supportProject)).toBeTruthy();
    expect(getByText(l10n.en.about.githubButton)).toBeTruthy();
  });

  it('copies version to clipboard when version button is pressed', () => {
    const {getByText} = render(<AboutScreen />);

    fireEvent.press(getByText('v1.0.0 (100)'));

    expect(Alert.alert).toHaveBeenCalledWith(
      l10n.en.about.versionCopiedTitle,
      l10n.en.about.versionCopiedDescription,
    );
  });

  it('opens GitHub URL when GitHub button is pressed', () => {
    const {getByText} = render(<AboutScreen />);

    fireEvent.press(getByText('Star on GitHub'));

    expect(Linking.openURL).toHaveBeenCalledWith(
      'https://github.com/a-ghorbani/pocketpal-ai',
    );
  });

  it('opens Buy Me a Coffee URL when sponsor button is pressed on non-iOS platforms', () => {
    Platform.OS = 'android';
    const {getByText} = render(<AboutScreen />);

    fireEvent.press(getByText(l10n.en.about.sponsorButton));

    expect(Linking.openURL).toHaveBeenCalledWith(
      'https://www.buymeacoffee.com/aghorbani',
    );
  });

  it('does not show sponsor button on iOS', () => {
    Platform.OS = 'ios';
    const {queryByText} = render(<AboutScreen />);

    expect(queryByText(l10n.en.about.sponsorButton)).toBeNull();
  });

  it('opens feedback form when share thoughts button is pressed', async () => {
    const {getByText, findByText} = render(<AboutScreen />);

    fireEvent.press(getByText(l10n.en.feedback.shareThoughtsButton));

    expect(await findByText(l10n.en.feedback.useCase.label)).toBeTruthy();
    expect(
      await findByText(l10n.en.feedback.featureRequests.label),
    ).toBeTruthy();
    expect(
      await findByText(l10n.en.feedback.generalFeedback.label),
    ).toBeTruthy();
    expect(
      await findByText(l10n.en.feedback.usageFrequency.label),
    ).toBeTruthy();
  });

  it('submits feedback successfully', async () => {
    const {findByText, getByText, findByPlaceholderText} = render(
      <AboutScreen />,
    );

    // Open feedback form
    fireEvent.press(getByText(l10n.en.feedback.shareThoughtsButton));

    const useCaseInput = await findByPlaceholderText(
      l10n.en.feedback.useCase.placeholder,
    );
    fireEvent.changeText(useCaseInput, 'Test use case');

    const featureRequestsInput = await findByPlaceholderText(
      l10n.en.feedback.featureRequests.placeholder,
    );
    fireEvent.changeText(featureRequestsInput, 'Test feature request');

    const generalFeedbackInput = await findByPlaceholderText(
      l10n.en.feedback.generalFeedback.placeholder,
    );
    fireEvent.changeText(generalFeedbackInput, 'Test feedback');

    const dailyButton = await findByText(
      l10n.en.feedback.usageFrequency.options.daily,
    );
    fireEvent.press(dailyButton);

    // Submit form
    const submitButton = await findByText(l10n.en.feedback.submit);
    await act(async () => {
      fireEvent.press(submitButton);
    });

    expect(submitFeedback).toHaveBeenCalledWith({
      useCase: 'Test use case',
      featureRequests: 'Test feature request',
      generalFeedback: 'Test feedback',
      usageFrequency: 'daily',
    });

    expect(Alert.alert).toHaveBeenCalledWith(
      'Success',
      'Thank you for your feedback!',
    );
  });

  it('shows validation error when submitting empty feedback', async () => {
    const {getByText, findByText} = render(<AboutScreen />);

    // Open feedback form
    fireEvent.press(getByText(l10n.en.feedback.shareThoughtsButton));

    // Submit empty form
    const submitButton = await findByText(l10n.en.feedback.submit);
    await act(async () => {
      fireEvent.press(submitButton);
    });

    expect(Alert.alert).toHaveBeenCalledWith(
      l10n.en.feedback.validation.required,
    );
    expect(submitFeedback).not.toHaveBeenCalled();
  });

  it('handles feedback submission error', async () => {
    (submitFeedback as jest.Mock).mockRejectedValueOnce(new Error('API Error'));

    const {getByText, findByText, findByPlaceholderText} = render(
      <AboutScreen />,
    );

    // Open feedback form
    fireEvent.press(getByText(l10n.en.feedback.shareThoughtsButton));

    // Fill out form
    fireEvent.changeText(
      await findByPlaceholderText(l10n.en.feedback.useCase.placeholder),
      'Test use case',
    );

    // Submit form
    const submitButton = await findByText(l10n.en.feedback.submit);
    await act(async () => {
      fireEvent.press(submitButton);
    });

    expect(Alert.alert).toHaveBeenCalledWith('Error', 'API Error');
  });
});



================================================
FILE: src/screens/BenchmarkScreen/BenchmarkScreen.tsx
================================================
import {View, ScrollView} from 'react-native';
import React, {useState, useCallback, useContext} from 'react';

import {v4 as uuidv4} from 'uuid';
import {observer} from 'mobx-react';
import RNDeviceInfo from 'react-native-device-info';
import Slider from '@react-native-community/slider';
import {SafeAreaView} from 'react-native-safe-area-context';
import {Text, Button, Card, ActivityIndicator, Icon} from 'react-native-paper';

import {submitBenchmark} from '../../api/benchmark';

import {Menu, Dialog, Checkbox} from '../../components';

import {useTheme} from '../../hooks';
import {L10nContext} from '../../utils';

import {createStyles} from './styles';
import {DeviceInfoCard} from './DeviceInfoCard';
import {BenchResultCard} from './BenchResultCard';

import {modelStore, benchmarkStore, uiStore} from '../../store';

import type {DeviceInfo, Model} from '../../utils/types';
import {BenchmarkConfig, BenchmarkResult} from '../../utils/types';

const DEFAULT_CONFIGS: BenchmarkConfig[] = [
  {pp: 512, tg: 128, pl: 1, nr: 3, label: 'Default'},
  {pp: 128, tg: 32, pl: 1, nr: 3, label: 'Fast'},
];

const getBinarySteps = (min: number, max: number): number[] => {
  const steps: number[] = [];
  let current = min;
  while (current <= max) {
    steps.push(current);
    current *= 2;
  }
  return steps;
};

const BENCHMARK_PARAMS_METADATA = {
  pp: {
    validation: {min: 64, max: 4096},
    descriptionKey:
      'Number of prompt processing tokens (max: physical batch size)',
    steps: getBinarySteps(64, 4096),
  },
  tg: {
    validation: {min: 32, max: 2048},
    descriptionKey: 'Number of text generation tokens',
    steps: getBinarySteps(32, 2048),
  },
  pl: {
    validation: {min: 1, max: 4},
    descriptionKey: 'Pipeline parallel size',
    steps: [1, 2, 3, 4],
  },
  nr: {
    validation: {min: 1, max: 10},
    descriptionKey: 'Number of repetitions',
    steps: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
  },
};

export const BenchmarkScreen: React.FC = observer(() => {
  const [isRunning, setIsRunning] = useState(false);
  const [selectedConfig, setSelectedConfig] = useState<BenchmarkConfig>(
    DEFAULT_CONFIGS[0],
  );
  const [showModelMenu, setShowModelMenu] = useState(false);
  const [selectedModel, setSelectedModel] = useState<Model | null>(null);
  const [showAdvancedDialog, setShowAdvancedDialog] = useState(false);
  const [deleteConfirmVisible, setDeleteConfirmVisible] = useState(false);
  const [pendingDeleteTimestamp, setPendingDeleteTimestamp] = useState<
    string | null
  >(null);
  const [deleteAllConfirmVisible, setDeleteAllConfirmVisible] = useState(false);
  const [deviceInfo, setDeviceInfo] = useState<DeviceInfo | null>(null);
  const [showShareDialog, setShowShareDialog] = useState(false);
  const [showDetails, setShowDetails] = useState(false);
  const [dontShowAgain, setDontShowAgain] = useState(false);
  const [pendingShareResult, setPendingShareResult] =
    useState<BenchmarkResult | null>(null);
  const [shareError, setShareError] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const theme = useTheme();
  const styles = createStyles(theme);
  const l10n = useContext(L10nContext);

  const handleSliderChange = (name: string, value: number) => {
    setSelectedConfig(prev => ({
      ...prev,
      [name]: value,
      label: 'Custom',
    }));
  };

  const handleModelSelect = async (model: Model) => {
    setShowModelMenu(false);
    if (model.id !== modelStore.activeModelId) {
      try {
        await modelStore.initContext(model);
        setSelectedModel(model);
      } catch (error) {
        if (error instanceof Error) {
          console.error('Model initialization error:', error);
        }
      }
    } else {
      setSelectedModel(model);
    }
  };

  const trackPeakMemoryUsage = async () => {
    try {
      const total = await RNDeviceInfo.getTotalMemory();
      const used = await RNDeviceInfo.getUsedMemory();
      const percentage = (used / total) * 100;
      return {total, used, percentage};
    } catch (error) {
      console.error('Failed to fetch memory stats:', error);
      return null;
    }
  };

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const stopBenchmark = async () => {
    if (modelStore.context) {
      try {
        // TODO: This is not working for bench.
        await modelStore.context.stopCompletion();
      } catch (error) {
        console.error('Error stopping benchmark:', error);
      }
    }
  };

  const runBenchmark = async () => {
    if (!modelStore.context || !modelStore.activeModel) {
      return;
    }

    setIsRunning(true);
    let peakMemoryUsage: NonNullable<
      BenchmarkResult['peakMemoryUsage']
    > | null = null;
    let memoryCheckInterval: ReturnType<typeof setInterval> | undefined;
    const startTime = Date.now();

    try {
      // Start memory tracking
      memoryCheckInterval = setInterval(async () => {
        const currentUsage = await trackPeakMemoryUsage();
        if (
          currentUsage &&
          (!peakMemoryUsage ||
            currentUsage.percentage > peakMemoryUsage.percentage)
        ) {
          peakMemoryUsage = currentUsage;
        }
      }, 1000);

      const {modelDesc, modelSize, modelNParams, ppAvg, ppStd, tgAvg, tgStd} =
        await modelStore.context.bench(
          selectedConfig.pp,
          selectedConfig.tg,
          selectedConfig.pl,
          selectedConfig.nr,
        );

      const wallTimeMs = Date.now() - startTime;

      const result: BenchmarkResult = {
        config: selectedConfig,
        modelDesc,
        modelSize,
        modelNParams,
        ppAvg,
        ppStd,
        tgAvg,
        tgStd,
        timestamp: new Date().toISOString(),
        modelId: modelStore.activeModel.id,
        modelName: modelStore.activeModel.name,
        oid: modelStore.activeModel.hfModelFile?.oid,
        rfilename: modelStore.activeModel.hfModelFile?.rfilename,
        filename: modelStore.activeModel.filename,
        peakMemoryUsage: peakMemoryUsage || undefined,
        wallTimeMs,
        uuid: uuidv4(),
        initSettings: modelStore.activeContextSettings,
      };

      benchmarkStore.addResult(result);
    } catch (error) {
      if (error instanceof Error) {
        console.error('Benchmark error:', error);
      }
    } finally {
      clearInterval(memoryCheckInterval);
      setIsRunning(false);
    }
  };

  const handlePresetSelect = (config: BenchmarkConfig) => {
    setSelectedConfig(config);
  };

  const handleDeleteResult = (timestamp: string) => {
    setPendingDeleteTimestamp(timestamp);
    setDeleteConfirmVisible(true);
  };

  const handleConfirmDelete = () => {
    if (pendingDeleteTimestamp) {
      benchmarkStore.removeResult(pendingDeleteTimestamp);
    }
    setDeleteConfirmVisible(false);
    setPendingDeleteTimestamp(null);
  };

  const handleDeleteAll = () => {
    setDeleteAllConfirmVisible(true);
  };

  const handleConfirmDeleteAll = () => {
    benchmarkStore.clearResults();
    setDeleteAllConfirmVisible(false);
  };

  const handleDeviceInfo = useCallback((info: DeviceInfo) => {
    setDeviceInfo(info);
  }, []);

  const handleShareResult = async (result: BenchmarkResult) => {
    if (!deviceInfo) {
      throw new Error('Device information not available');
    }
    if (result.submitted) {
      throw new Error('This benchmark has already been submitted');
    }
    try {
      const response = await submitBenchmark(deviceInfo, result);
      console.log('Benchmark submitted successfully:', response);
      benchmarkStore.markAsSubmitted(result.uuid);
    } catch (error) {
      console.error('Failed to submit benchmark:', error);
      throw error;
    }
  };

  const handleSharePress = async (result: BenchmarkResult) => {
    if (!uiStore.benchmarkShareDialog.shouldShow) {
      await handleShareResult(result);
      return;
    }
    setPendingShareResult(result);
    setShowShareDialog(true);
  };

  const handleConfirmShare = async () => {
    if (dontShowAgain) {
      uiStore.setBenchmarkShareDialogPreference(false);
    }
    setIsSubmitting(true);
    try {
      if (pendingShareResult) {
        await handleShareResult(pendingShareResult);
      }
      setShowShareDialog(false);
      setPendingShareResult(null);
    } catch (error) {
      setShareError(
        error instanceof Error ? error.message : 'Failed to share benchmark',
      );
    } finally {
      setIsSubmitting(false);
    }
  };

  const getMaxPPValue = () => {
    if (!modelStore.activeContextSettings) {
      return BENCHMARK_PARAMS_METADATA.pp.validation.max;
    }
    return Math.min(
      modelStore.activeContextSettings.n_ubatch,
      BENCHMARK_PARAMS_METADATA.pp.validation.max,
    );
  };

  const renderModelSelector = () => (
    <Menu
      visible={showModelMenu}
      onDismiss={() => setShowModelMenu(false)}
      anchorPosition="bottom"
      selectable
      anchor={
        <Button
          mode="outlined"
          onPress={() => setShowModelMenu(true)}
          contentStyle={styles.modelSelectorContent}
          icon={({color}) => (
            <Icon source="chevron-down" size={24} color={color} />
          )}>
          {selectedModel?.name ||
            modelStore.activeModel?.name ||
            l10n.benchmark.modelSelector.prompt}
        </Button>
      }>
      {modelStore.availableModels.map(model => (
        <Menu.Item
          key={model.id}
          onPress={() => handleModelSelect(model)}
          label={model.name}
          leadingIcon={
            model.id === modelStore.activeModelId ? 'check' : undefined
          }
        />
      ))}
    </Menu>
  );

  const renderSlider = ({
    name,
    testId,
  }: {
    name: keyof typeof BENCHMARK_PARAMS_METADATA;
    testId?: string;
  }) => {
    const metadata = BENCHMARK_PARAMS_METADATA[name];
    let steps = metadata.steps;

    if (name === 'pp') {
      const maxValue = getMaxPPValue();
      steps = steps.filter(step => step <= maxValue);
    }

    const stepIndex = steps.indexOf(selectedConfig[name]);

    return (
      <View style={styles.settingItem}>
        <Text variant="labelSmall" style={styles.settingLabel}>
          {name.toUpperCase()}
        </Text>
        <Slider
          testID={testId ?? `${name}-slider`}
          style={styles.slider}
          minimumValue={0}
          maximumValue={steps.length - 1}
          step={1}
          value={stepIndex}
          onValueChange={index => {
            const value = steps[Math.round(index)];
            handleSliderChange(name, value);
          }}
          thumbTintColor={theme.colors.primary}
          minimumTrackTintColor={theme.colors.primary}
        />
        <View style={styles.sliderDescriptionContainer}>
          <Text style={styles.description}>
            {metadata.descriptionKey}
            {name === 'pp' && modelStore.activeContextSettings && (
              <Text style={styles.maxValueHint}>
                {' '}
                {l10n.benchmark.messages.modelMaxValue.replace(
                  '{{maxValue}}',
                  getMaxPPValue().toString(),
                )}
              </Text>
            )}
          </Text>
          <Text style={styles.settingValue}>{selectedConfig[name]}</Text>
        </View>
      </View>
    );
  };

  const renderAdvancedSettings = () => (
    <Dialog
      testID="advanced-settings-dialog"
      visible={showAdvancedDialog}
      onDismiss={() => setShowAdvancedDialog(false)}
      title={l10n.benchmark.dialogs.advancedSettings.title}
      scrollable
      actions={[
        {
          label: l10n.benchmark.buttons.done,
          onPress: () => setShowAdvancedDialog(false),
        },
      ]}>
      <View>
        <Text variant="titleMedium" style={styles.sectionTitle}>
          {l10n.benchmark.dialogs.advancedSettings.testProfile}
        </Text>
        <View style={styles.presetContainer}>
          {DEFAULT_CONFIGS.map((config, index) => (
            <Button
              key={index}
              mode={selectedConfig === config ? 'contained' : 'outlined'}
              onPress={() => handlePresetSelect(config)}
              style={styles.presetButton}>
              {config.label}
            </Button>
          ))}
        </View>

        <Text variant="titleMedium" style={styles.sectionTitle}>
          {l10n.benchmark.dialogs.advancedSettings.customParameters}
        </Text>
        <Text variant="bodySmall" style={styles.advancedDescription}>
          {l10n.benchmark.dialogs.advancedSettings.description}
        </Text>
        <View style={styles.slidersContainer}>
          {renderSlider({name: 'pp'})}
          {renderSlider({name: 'tg'})}
          {renderSlider({name: 'nr'})}
        </View>
      </View>
    </Dialog>
  );

  const renderWarningMessage = () => (
    <View style={styles.warningContainer}>
      <Text variant="bodySmall" style={styles.warningText}>
        {l10n.benchmark.messages.testWarning}
      </Text>
    </View>
  );

  const renderShareDialog = () => (
    <Dialog
      testID="share-benchmark-dialog"
      visible={showShareDialog}
      onDismiss={() => {
        setShowShareDialog(false);
        setPendingShareResult(null);
      }}
      title={l10n.benchmark.dialogs.shareResults.title}
      scrollable
      actions={[
        {
          testID: 'share-benchmark-dialog-cancel-button',
          label: l10n.benchmark.buttons.cancel,
          onPress: () => {
            setShowShareDialog(false);
            setPendingShareResult(null);
            setShareError(null);
          },
          disabled: isSubmitting,
        },
        {
          testID: 'share-benchmark-dialog-confirm-button',
          label: isSubmitting
            ? l10n.benchmark.buttons.sharing
            : l10n.benchmark.buttons.share,
          onPress: handleConfirmShare,
          mode: 'contained',
          loading: isSubmitting,
          disabled: isSubmitting,
        },
      ]}>
      <Text variant="bodyMedium" style={styles.dialogSection}>
        {l10n.benchmark.dialogs.shareResults.sharedDataTitle}
      </Text>
      <View style={styles.dialogList}>
        <Text variant="bodyMedium">
          {l10n.benchmark.dialogs.shareResults.deviceAndModelInfo}
        </Text>
        <Text variant="bodyMedium">
          {l10n.benchmark.dialogs.shareResults.performanceMetrics}
        </Text>
      </View>

      <Button
        testID="share-benchmark-dialog-view-raw-data-button"
        mode="text"
        onPress={() => setShowDetails(!showDetails)}
        icon={showDetails ? 'chevron-up' : 'chevron-down'}
        style={styles.detailsButton}>
        {showDetails
          ? l10n.benchmark.buttons.hideRawData
          : l10n.benchmark.buttons.viewRawData}
      </Button>

      {showDetails && pendingShareResult && deviceInfo && (
        <View
          testID="share-benchmark-dialog-raw-data-container"
          style={styles.detailsContainer}>
          <Text variant="bodySmall" style={styles.codeBlock}>
            {JSON.stringify(
              {
                deviceInfo,
                benchmark: pendingShareResult,
              },
              null,
              2,
            )}
          </Text>
        </View>
      )}

      {shareError && <Text style={styles.errorText}>{shareError}</Text>}

      <View style={styles.checkboxContainer}>
        <Checkbox
          testID="dont-show-again-checkbox"
          checked={dontShowAgain}
          onPress={() => setDontShowAgain(!dontShowAgain)}
        />
        <Text
          variant="bodySmall"
          style={styles.checkboxLabel}
          onPress={() => setDontShowAgain(!dontShowAgain)}>
          {l10n.benchmark.dialogs.shareResults.dontShowAgain}
        </Text>
      </View>
    </Dialog>
  );

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <ScrollView style={styles.scrollView}>
        <Card elevation={0} style={styles.card}>
          <Card.Content>
            <DeviceInfoCard onDeviceInfo={handleDeviceInfo} />
            {renderModelSelector()}

            {modelStore.loadingModel ? (
              <View style={styles.loadingContainer}>
                <ActivityIndicator
                  testID="loading-indicator-model-init"
                  size="large"
                />
                <Text style={styles.loadingText}>
                  {l10n.benchmark.messages.initializingModel}
                </Text>
              </View>
            ) : (
              <>
                {!modelStore.context ? (
                  <Text style={styles.warning}>
                    {l10n.benchmark.messages.pleaseSelectModel}
                  </Text>
                ) : (
                  <>
                    <Button
                      testID="advanced-settings-button"
                      mode="text"
                      onPress={() => setShowAdvancedDialog(true)}
                      icon="tune"
                      style={styles.advancedButton}>
                      {l10n.benchmark.buttons.advancedSettings}
                    </Button>

                    {!isRunning && renderWarningMessage()}

                    <Button
                      testID="start-test-button"
                      mode="contained"
                      onPress={runBenchmark}
                      disabled={isRunning}
                      style={styles.button}>
                      {isRunning
                        ? l10n.benchmark.buttons.runningTest
                        : l10n.benchmark.buttons.startTest}
                    </Button>

                    {isRunning && (
                      <View style={styles.loadingContainer}>
                        <ActivityIndicator
                          testID="loading-indicator-benchmark"
                          size="large"
                        />
                        <Text style={styles.warningText}>
                          {l10n.benchmark.messages.keepScreenOpen}
                        </Text>
                      </View>
                    )}

                    {renderAdvancedSettings()}
                  </>
                )}
              </>
            )}

            {benchmarkStore.results.length > 0 && (
              <View style={styles.resultsCard}>
                <View style={styles.resultsHeader}>
                  <Text variant="titleSmall">
                    {l10n.benchmark.sections.testResults}
                  </Text>
                  <Button
                    testID="clear-all-button"
                    mode="text"
                    onPress={handleDeleteAll}
                    icon="delete"
                    compact>
                    {l10n.benchmark.buttons.clearAll}
                  </Button>
                </View>
                {benchmarkStore.results.map((result, index) => (
                  <View key={index} style={styles.resultItem}>
                    <BenchResultCard
                      result={result}
                      onDelete={handleDeleteResult}
                      onShare={handleSharePress}
                    />
                  </View>
                ))}
              </View>
            )}

            <Dialog
              visible={deleteConfirmVisible}
              onDismiss={() => setDeleteConfirmVisible(false)}
              title={l10n.benchmark.dialogs.deleteResult.title}
              actions={[
                {
                  label: l10n.benchmark.buttons.cancel,
                  onPress: () => setDeleteConfirmVisible(false),
                },
                {
                  label: l10n.benchmark.buttons.delete,
                  onPress: handleConfirmDelete,
                },
              ]}>
              <Text>{l10n.benchmark.dialogs.deleteResult.message}</Text>
            </Dialog>

            <Dialog
              testID="clear-all-dialog"
              visible={deleteAllConfirmVisible}
              onDismiss={() => setDeleteAllConfirmVisible(false)}
              title={l10n.benchmark.dialogs.clearAllResults.title}
              actions={[
                {
                  testID: 'clear-all-dialog-cancel-button',
                  label: l10n.benchmark.buttons.cancel,
                  onPress: () => setDeleteAllConfirmVisible(false),
                },
                {
                  testID: 'clear-all-dialog-confirm-button',
                  label: l10n.benchmark.buttons.clearAll,
                  onPress: handleConfirmDeleteAll,
                },
              ]}>
              <Text>{l10n.benchmark.dialogs.clearAllResults.message}</Text>
            </Dialog>

            {renderShareDialog()}
          </Card.Content>
        </Card>
      </ScrollView>
    </SafeAreaView>
  );
});



================================================
FILE: src/screens/BenchmarkScreen/index.ts
================================================
export * from './BenchmarkScreen';



================================================
FILE: src/screens/BenchmarkScreen/styles.ts
================================================
import {Platform, StyleSheet} from 'react-native';
import type {Theme} from '../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollView: {
      flex: 1,
      padding: 16,
    },
    card: {
      marginBottom: 16,
    },
    description: {
      flex: 1,
      color: theme.colors.onSurfaceVariant,
      paddingRight: 8,
      fontSize: 12,
    },
    warning: {
      color: theme.colors.error,
      marginVertical: 8,
      textAlign: 'center',
    },
    button: {
      marginVertical: 6,
    },
    loadingContainer: {
      alignItems: 'center',
      marginVertical: 8,
    },
    loadingText: {
      marginTop: 8,
      color: theme.colors.onSurfaceVariant,
    },
    modelSelectorContent: {
      justifyContent: 'space-between',
      flexDirection: 'row-reverse',
      alignItems: 'center',
    },
    presetContainer: {
      flexDirection: 'row',
      marginBottom: 16,
      justifyContent: 'space-around',
      flexWrap: 'wrap',
      gap: 8,
    },
    presetButton: {
      flex: 1,
      minWidth: 100,
      marginHorizontal: 4,
    },
    slidersContainer: {
      marginTop: 16,
    },
    sliderDescriptionContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    settingItem: {
      marginBottom: 16,
    },
    settingLabel: {
      color: theme.colors.primary,
      marginBottom: 0,
    },
    settingValue: {
      textAlign: 'right',
      color: theme.colors.onSurface,
      marginTop: 0,
      minWidth: 40,
      marginLeft: 8,
    },
    slider: {
      //height: 40,
      ...Platform.select({
        android: {
          marginLeft: -12,
          marginRight: -10,
        },
      }),
    },
    sectionTitle: {
      color: theme.colors.primary,
      marginBottom: 8,
    },
    advancedButton: {
      marginBottom: 6,
    },
    advancedDescription: {
      marginBottom: 16,
      color: theme.colors.onSurfaceVariant,
      fontSize: 12,
    },
    warningContainer: {
      backgroundColor: theme.colors.errorContainer,
      padding: 16,
      borderRadius: 8,
      marginBottom: 16,
    },
    warningList: {
      marginTop: 8,
      paddingLeft: 8,
    },
    warningText: {
      color: theme.colors.error,
      marginVertical: 4,
    },
    resultsHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: 8,
    },
    resultsCard: {
      marginTop: 16,
      padding: 0,
    },
    resultItem: {
      marginBottom: 16,
    },
    errorText: {
      marginTop: 16,
      color: theme.colors.error,
    },
    dialogList: {
      marginVertical: 10,
      paddingLeft: 8,
    },
    dialogSection: {
      marginTop: 16,
      marginBottom: 8,
      fontWeight: '600',
    },
    link: {
      textDecorationLine: 'underline',
    },
    detailsButton: {
      marginTop: 16,
      alignSelf: 'flex-start',
    },
    detailsContainer: {
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: 8,
      padding: 12,
      marginTop: 8,
    },
    codeBlock: {
      fontFamily: Platform.select({ios: 'Menlo', android: 'monospace'}),
      fontSize: 11,
    },
    checkboxContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginTop: 24,
      paddingTop: 16,
      borderTopWidth: 1,
      borderTopColor: theme.colors.surfaceVariant,
    },
    checkboxLabel: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 12,
      marginLeft: 12,
      flex: 1,
    },
    maxValueHint: {
      color: theme.colors.onSurfaceVariant,
      fontStyle: 'italic',
    },
  });



================================================
FILE: src/screens/BenchmarkScreen/__tests__/BenchmarkScreen.test.tsx
================================================
import React from 'react';
import {NativeModules} from 'react-native';

import {cloneDeep} from 'lodash';
import {LlamaContext} from '@pocketpalai/llama.rn';

import {submitBenchmark} from '../../../api/benchmark';

import {fireEvent, render, waitFor} from '../../../../jest/test-utils';
import {
  mockResult,
  mockSubmittedResult,
} from '../../../../jest/fixtures/benchmark';

import {BenchmarkScreen} from '../BenchmarkScreen';

import {benchmarkStore, modelStore, uiStore} from '../../../store';
import {mockContextModel} from '../../../../jest/fixtures/models';

jest.mock('../../../api/benchmark', () => ({
  submitBenchmark: jest.fn().mockResolvedValue(undefined),
}));

describe('BenchmarkScreen', () => {
  beforeEach(() => {
    benchmarkStore.results = [
      cloneDeep(mockResult),
      cloneDeep(mockSubmittedResult),
    ];
    jest.clearAllMocks();
  });

  describe('Model Initialization', () => {
    it('should show loading indicator during model initialization', async () => {
      const initPromise = new Promise(resolve => setTimeout(resolve, 100));
      (modelStore.initContext as jest.Mock).mockReturnValue(initPromise);
      modelStore.isContextLoading = true;
      modelStore.loadingModel = modelStore.models[0];

      const {getByTestId} = render(<BenchmarkScreen />);

      // Verify loading indicator is shown
      expect(getByTestId('loading-indicator-model-init')).toBeDefined();

      // Wait for initialization to complete
      await initPromise;
    });

    it('should hide loading indicator after model initialization completes', async () => {
      // Loading context
      modelStore.isContextLoading = true;
      modelStore.loadingModel = modelStore.models[0];

      const {getByTestId, queryByTestId} = render(<BenchmarkScreen />);
      expect(getByTestId('loading-indicator-model-init')).toBeDefined();

      // Complete loading
      modelStore.isContextLoading = false;
      modelStore.loadingModel = undefined;

      // Verify loading indicator is removed
      await waitFor(() => {
        expect(queryByTestId('loading-indicator-model-init')).toBeNull();
      });
    });

    it('should show model selector with available models', () => {
      const {getByText} = render(<BenchmarkScreen />);

      // Open model selector
      fireEvent.press(getByText('Select Model'));

      // Verify available models are shown
      modelStore.availableModels.forEach(model => {
        expect(getByText(model.name)).toBeDefined();
      });
    });

    it('should initialize model when selected', async () => {
      const {getByText} = render(<BenchmarkScreen />);
      const modelToSelect = modelStore.availableModels[0];

      // Open model selector and select a model
      fireEvent.press(getByText('Select Model'));
      fireEvent.press(getByText(modelToSelect.name));

      // Verify initContext was called
      expect(modelStore.initContext).toHaveBeenCalledWith(modelToSelect);
    });
  });

  describe('Benchmark Execution', () => {
    it('handles submission of benchmark results', async () => {
      const {getByTestId} = render(<BenchmarkScreen />);

      const submitButton = getByTestId('submit-benchmark-button');
      fireEvent.press(submitButton);

      await waitFor(() => {
        expect(getByTestId('share-benchmark-dialog')).toBeDefined();
      });

      const confirmButton = getByTestId(
        'share-benchmark-dialog-confirm-button',
      );
      fireEvent.press(confirmButton);

      await waitFor(() => {
        expect(submitBenchmark).toHaveBeenCalled();
      });
    });

    it('should show benchmark loading indicator during execution', async () => {
      modelStore.activeModelId = modelStore.models[0].id;
      modelStore.context = new LlamaContext({
        contextId: 1,
        gpu: false,
        reasonNoGPU: '',
        model: mockContextModel,
      });

      const {getByText, getByTestId} = render(<BenchmarkScreen />);

      // Start benchmark
      fireEvent.press(getByTestId('start-test-button'));

      expect(getByTestId('loading-indicator-benchmark')).toBeDefined();
      expect(getByText('Please keep this screen open.')).toBeDefined();
    });

    it('should disable start button during benchmark execution', async () => {
      modelStore.activeModelId = modelStore.models[0].id;
      modelStore.context = new LlamaContext({
        contextId: 1,
        gpu: false,
        reasonNoGPU: '',
        model: mockContextModel,
      });
      const {getByTestId} = render(<BenchmarkScreen />);
      const startButton = getByTestId('start-test-button');

      // Start benchmark
      fireEvent.press(startButton);

      console.log(startButton.props.accessibilityState.disabled);
      await waitFor(() => {
        expect(startButton.props.accessibilityState.disabled).toBe(true);
      });
    });
  });

  describe('Memory Usage Tracking', () => {
    beforeAll(() => {
      // Mock DeviceInfoModule
      NativeModules.DeviceInfoModule = {
        getCPUInfo: jest.fn().mockResolvedValue({
          cores: 8,
          processors: ['CPU1', 'CPU2', 'CPU3', 'CPU4'],
        }),
      };
    });

    it('should display memory usage in results', async () => {
      const result = {
        ...mockResult,
        peakMemoryUsage: {
          total: 8 * 1000 * 1000 * 1000,
          used: 4 * 1000 * 1000 * 1000,
          percentage: 50,
        },
      };
      benchmarkStore.results = [result];

      const {getByText} = render(<BenchmarkScreen />);

      // Verify memory usage display
      expect(getByText('Peak Memory')).toBeDefined();
      expect(getByText('50.0%')).toBeDefined();
      expect(getByText('4 GB / 8 GB')).toBeDefined();
    });
  });

  describe('Advanced Settings', () => {
    it('should apply preset configurations correctly', async () => {
      modelStore.activeModelId = modelStore.models[0].id;
      modelStore.context = new LlamaContext({
        contextId: 1,
        gpu: false,
        reasonNoGPU: '',
        model: mockContextModel,
      });

      const {getByText, getByTestId} = render(<BenchmarkScreen />);

      // Open advanced settings
      fireEvent.press(getByTestId('advanced-settings-button'));
      await waitFor(() =>
        expect(getByTestId('advanced-settings-dialog')).toBeDefined(),
      );

      // Select Fast preset
      fireEvent.press(getByText('Fast'));

      // Verify preset values
      await waitFor(() => {
        const ppSlider = getByTestId('pp-slider');
        const tgSlider = getByTestId('tg-slider');
        expect(ppSlider.props.value).toBe(1);
        expect([0, undefined]).toContain(tgSlider.props.value); // slider could be undefined if it is zero or minimum value?
      });
    });
  });

  describe('Device Info Integration', () => {
    it('renders device info card', () => {
      const {getByText} = render(<BenchmarkScreen />);
      expect(getByText('Device Information')).toBeDefined();
    });

    it('should include device info in benchmark submission', async () => {
      const {getByTestId} = render(<BenchmarkScreen />);

      // Wait for device info to be collected
      await waitFor(() => {
        expect(getByTestId('device-info-card')).toBeDefined();
      });

      // Trigger benchmark submission
      const submitButton = getByTestId('submit-benchmark-button');
      fireEvent.press(submitButton);

      const confirmButton = getByTestId(
        'share-benchmark-dialog-confirm-button',
      );
      fireEvent.press(confirmButton);

      // Verify device info is included in submission
      await waitFor(() => {
        expect(submitBenchmark).toHaveBeenCalledWith(
          expect.objectContaining({
            model: expect.any(String),
            systemName: expect.any(String),
            systemVersion: expect.any(String),
          }),
          expect.any(Object),
        );
      });
    });
  });

  describe('Share Dialog Preferences', () => {
    it('should respect "dont show again" preference when is false', async () => {
      benchmarkStore.results = [
        cloneDeep(mockResult),
        cloneDeep(mockSubmittedResult),
        cloneDeep(mockResult),
      ];
      // Force to show confirm dialog
      uiStore.benchmarkShareDialog.shouldShow = true;

      const {getByTestId, queryByTestId, getAllByTestId} = render(
        <BenchmarkScreen />,
      );

      // Trigger share
      const submitButton = getAllByTestId('submit-benchmark-button')[0];
      fireEvent.press(submitButton);

      // Wait for the dialog to appear
      await waitFor(() => {
        expect(getByTestId('share-benchmark-dialog')).toBeDefined();
      });

      // Set "don't show again"
      const checkbox = getByTestId('dont-show-again-checkbox');
      fireEvent.press(checkbox);

      // Confirm share
      const confirmButton = getByTestId(
        'share-benchmark-dialog-confirm-button',
      );
      fireEvent.press(confirmButton);

      // wait for the submission to be called
      await waitFor(() => {
        expect(submitBenchmark).toHaveBeenCalled();
      });

      // wait for the dialog to be closed
      await waitFor(() => {
        expect(queryByTestId('share-benchmark-dialog')).toBeNull();
      });

      // Verify preference was saved
      expect(uiStore.setBenchmarkShareDialogPreference).toHaveBeenCalledWith(
        false,
      );

      // Since the store is mock we need to manually set the state
      uiStore.benchmarkShareDialog.shouldShow = false;

      // Share another result
      const submitButton2 = getByTestId('submit-benchmark-button');
      fireEvent.press(submitButton2);

      expect(queryByTestId('share-benchmark-dialog')).toBeNull();
    });

    it('should respect "dont show again" preference when is true', async () => {
      benchmarkStore.results = [
        cloneDeep(mockResult),
        cloneDeep(mockSubmittedResult),
        cloneDeep(mockResult),
      ];
      uiStore.benchmarkShareDialog.shouldShow = true;
      const {getByTestId, queryByTestId, getAllByTestId} = render(
        <BenchmarkScreen />,
      );

      // Trigger share
      const submitButton = getAllByTestId('submit-benchmark-button')[0];
      fireEvent.press(submitButton);

      // Wait for the dialog to appear
      await waitFor(() => {
        expect(getByTestId('share-benchmark-dialog')).toBeDefined();
      });

      // Confirm share
      const confirmButton = getByTestId(
        'share-benchmark-dialog-confirm-button',
      );
      fireEvent.press(confirmButton);

      // wait for the submission to be called
      await waitFor(() => {
        expect(submitBenchmark).toHaveBeenCalled();
      });

      benchmarkStore.results = [mockResult, mockSubmittedResult];

      // wait for the dialog to be closed
      await waitFor(() => {
        expect(queryByTestId('share-benchmark-dialog')).toBeNull();
      });

      // Since the store is mock we need to manually set the state
      uiStore.benchmarkShareDialog.shouldShow = true;

      // Share another result
      const submitButton2 = getByTestId('submit-benchmark-button');
      fireEvent.press(submitButton2);

      await waitFor(() => {
        expect(getByTestId('share-benchmark-dialog')).toBeDefined();
      });
    });

    it('should show raw data in share dialog', async () => {
      const {getByTestId, getByText} = render(<BenchmarkScreen />);

      // Trigger share
      const submitButton = getByTestId('submit-benchmark-button');
      fireEvent.press(submitButton);

      // Show raw data
      const viewRawDataButton = getByTestId(
        'share-benchmark-dialog-view-raw-data-button',
      );
      fireEvent.press(viewRawDataButton);

      // Verify raw data is shown
      await waitFor(() => {
        expect(
          getByTestId('share-benchmark-dialog-raw-data-container'),
        ).toBeDefined();
      });
      expect(getByText(/"deviceInfo":/)).toBeDefined();
      expect(getByText(/"benchmark":/)).toBeDefined();
    });
  });

  describe('Result Management', () => {
    it('renders benchmark results when available', async () => {
      benchmarkStore.results = [mockResult];
      const {getByText} = render(<BenchmarkScreen />);

      await waitFor(() => {
        expect(getByText('Test Results')).toBeDefined();
        expect(getByText(mockResult.modelName)).toBeDefined();
      });
    });

    it('should delete individual result', async () => {
      // Add results to store
      benchmarkStore.results = [mockResult, mockSubmittedResult];

      const {getAllByTestId, getByText} = render(<BenchmarkScreen />);

      // Delete first result
      const deleteButtons = getAllByTestId('delete-result-button');
      fireEvent.press(deleteButtons[0]);

      // Confirm deletion
      fireEvent.press(getByText('Delete'));

      // Verify deletion
      expect(benchmarkStore.removeResult).toHaveBeenCalledWith(
        mockResult.timestamp,
      );
    });

    it('should cancel result deletion', async () => {
      // Add results to store
      benchmarkStore.results = [mockResult];

      const {getAllByTestId, getByText} = render(<BenchmarkScreen />);

      // Attempt to delete result
      const deleteButtons = getAllByTestId('delete-result-button');
      fireEvent.press(deleteButtons[0]);

      // Cancel deletion
      fireEvent.press(getByText('Cancel'));

      // Verify result was not deleted
      expect(benchmarkStore.removeResult).not.toHaveBeenCalled();
    });

    it('allows clearing all results after confirmation', async () => {
      benchmarkStore.results = [mockResult];
      const {getByTestId} = render(<BenchmarkScreen />);

      // Click clear all button
      const clearButton = getByTestId('clear-all-button');
      fireEvent.press(clearButton);

      // Confirm in the dialog
      const confirmButton = getByTestId('clear-all-dialog-confirm-button');
      fireEvent.press(confirmButton);

      expect(benchmarkStore.results.length).toBe(0);
    });

    it('should clear all results', async () => {
      // Add results to store
      benchmarkStore.results = [mockResult, mockSubmittedResult];

      const {getByTestId} = render(<BenchmarkScreen />);

      // Clear all results
      const clearAllButton = getByTestId('clear-all-button');
      fireEvent.press(clearAllButton);

      // Confirm clear all
      const confirmButton = getByTestId('clear-all-dialog-confirm-button');
      fireEvent.press(confirmButton);

      // Verify all results were cleared
      expect(benchmarkStore.clearResults).toHaveBeenCalled();
    });

    it('keeps results if clear all is cancelled', async () => {
      benchmarkStore.results = [mockResult];
      const {getByTestId} = render(<BenchmarkScreen />);

      // Click clear all button
      const clearButton = getByTestId('clear-all-button');
      fireEvent.press(clearButton);

      // Cancel in the dialog
      const cancelButton = getByTestId('clear-all-dialog-cancel-button');
      fireEvent.press(cancelButton);

      expect(benchmarkStore.results.length).toBe(1);
    });
  });
});



================================================
FILE: src/screens/BenchmarkScreen/BenchResultCard/BenchResultCard.tsx
================================================
import React, {useState, useContext} from 'react';
import {View, Linking} from 'react-native';

import {Card, Text, Button, Tooltip} from 'react-native-paper';

import {useTheme} from '../../../hooks';
import {L10nContext} from '../../../utils';

import {createStyles} from './styles';

import {BenchmarkResult} from '../../../utils/types';
import {formatBytes, formatNumber} from '../../../utils';
import {NetworkError, AppCheckError, ServerError} from '../../../utils/errors';

type Props = {
  result: BenchmarkResult;
  onDelete: (timestamp: string) => void;
  onShare: (result: BenchmarkResult) => Promise<void>;
};

type ErrorType = 'network' | 'appCheck' | 'server' | 'generic' | null;

export const BenchResultCard = ({result, onDelete, onShare}: Props) => {
  const theme = useTheme();
  const styles = createStyles(theme);
  const l10n = useContext(L10nContext);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [submitError, setSubmitError] = useState<string | null>(null);
  const [errorType, setErrorType] = useState<ErrorType>(null);

  const handleSubmit = async () => {
    setIsSubmitting(true);
    setSubmitError(null);
    setErrorType(null);

    try {
      await onShare(result);
    } catch (error) {
      if (error instanceof NetworkError) {
        setErrorType('network');
        setSubmitError(error.message);
      } else if (error instanceof AppCheckError) {
        setErrorType('appCheck');
        setSubmitError(error.message);
      } else if (error instanceof ServerError) {
        setErrorType('server');
        setSubmitError(error.message);
      } else {
        setErrorType('generic');
        setSubmitError(
          error instanceof Error
            ? error.message
            : l10n.benchmark.benchmarkResultCard.errors.failedToSubmit,
        );
      }
    } finally {
      setIsSubmitting(false);
    }
  };

  const formatDuration = (ms: number) => {
    if (ms < 1000) {
      return `${ms}ms`;
    }
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    if (minutes > 0) {
      const remainingSeconds = seconds % 60;
      return `${minutes}m ${remainingSeconds}s`;
    }
    return `${seconds}s`;
  };

  const openLeaderboard = () => {
    Linking.openURL(
      'https://huggingface.co/spaces/a-ghorbani/ai-phone-leaderboard',
    );
  };

  const getErrorIcon = () => {
    switch (errorType) {
      case 'network':
        return 'üì∂'; // wifi icon
      case 'appCheck':
        return 'üîí'; // lock icon
      case 'server':
        return 'üñ•Ô∏è'; // server icon
      default:
        return '‚ùå'; // generic error icon
    }
  };

  const getRetryText = () => {
    switch (errorType) {
      case 'network':
        return l10n.benchmark.benchmarkResultCard.errors.networkRetry;
      case 'appCheck':
        return l10n.benchmark.benchmarkResultCard.errors.appCheckRetry;
      case 'server':
        return l10n.benchmark.benchmarkResultCard.errors.serverRetry;
      default:
        return l10n.benchmark.benchmarkResultCard.errors.genericRetry;
    }
  };

  const getErrorStyle = () => {
    if (!errorType) {
      return styles.errorGeneric;
    }

    const capitalized = errorType.charAt(0).toUpperCase() + errorType.slice(1);

    return styles[`error${capitalized}`] || styles.errorGeneric;
  };

  return (
    <Card elevation={0} style={styles.resultCard}>
      <Card.Content>
        <View style={styles.resultHeader}>
          <View style={styles.headerLeft}>
            <Text variant="titleSmall" style={styles.modelName}>
              {result.modelName}
            </Text>
            <Text style={styles.modelMeta}>
              {formatBytes(result.modelSize)} ‚Ä¢{' '}
              {formatNumber(result.modelNParams, 2, true, false)}{' '}
              {l10n.benchmark.benchmarkResultCard.modelMeta.params}
            </Text>
          </View>
          <Button
            testID="delete-result-button"
            mode="text"
            onPress={() => onDelete(result.timestamp)}
            icon="delete"
            compact
            style={styles.deleteButton}>
            {l10n.benchmark.benchmarkResultCard.actions.deleteButton}
          </Button>
        </View>

        <View style={styles.configContainer}>
          <View style={styles.configBar}>
            <Text variant="labelSmall">
              {l10n.benchmark.benchmarkResultCard.config.title}
            </Text>
            <Text style={styles.configText}>
              {l10n.benchmark.benchmarkResultCard.config.format
                .replace('{{pp}}', result.config.pp.toString())
                .replace('{{tg}}', result.config.tg.toString())
                .replace('{{pl}}', result.config.pl.toString())
                .replace('{{nr}}', result.config.nr.toString())}
            </Text>
          </View>

          {result.initSettings && (
            <View style={styles.configBar}>
              <Text variant="labelSmall">
                {l10n.benchmark.benchmarkResultCard.modelSettings.title}
              </Text>
              <View style={styles.configTextContainer}>
                <Text style={styles.configText}>
                  {l10n.benchmark.benchmarkResultCard.modelSettings.context.replace(
                    '{{context}}',
                    result.initSettings.n_context.toString(),
                  )}{' '}
                  ‚Ä¢{' '}
                  {l10n.benchmark.benchmarkResultCard.modelSettings.batch.replace(
                    '{{batch}}',
                    result.initSettings.n_batch.toString(),
                  )}{' '}
                  ‚Ä¢{' '}
                  {l10n.benchmark.benchmarkResultCard.modelSettings.ubatch.replace(
                    '{{ubatch}}',
                    result.initSettings.n_ubatch.toString(),
                  )}
                </Text>
                <Text style={styles.configText}>
                  {l10n.benchmark.benchmarkResultCard.modelSettings.cpuThreads.replace(
                    '{{threads}}',
                    result.initSettings.n_threads.toString(),
                  )}{' '}
                  ‚Ä¢{' '}
                  {l10n.benchmark.benchmarkResultCard.modelSettings.gpuLayers.replace(
                    '{{layers}}',
                    result.initSettings.n_gpu_layers.toString(),
                  )}
                </Text>
                {result.initSettings.flash_attn ? (
                  <Text style={styles.configText}>
                    {
                      l10n.benchmark.benchmarkResultCard.modelSettings
                        .flashAttentionEnabled
                    }{' '}
                    ‚Ä¢{' '}
                    {l10n.benchmark.benchmarkResultCard.modelSettings.cacheTypes
                      .replace(
                        '{{cacheK}}',
                        result.initSettings.cache_type_k.toString(),
                      )
                      .replace(
                        '{{cacheV}}',
                        result.initSettings.cache_type_v.toString(),
                      )}
                  </Text>
                ) : (
                  <Text style={styles.configText}>
                    {
                      l10n.benchmark.benchmarkResultCard.modelSettings
                        .flashAttentionDisabled
                    }
                  </Text>
                )}
              </View>
            </View>
          )}
        </View>

        <View style={styles.resultsContainer}>
          <View style={styles.resultRow}>
            <View style={styles.resultItem}>
              <Text style={styles.resultValue}>
                {result.ppAvg.toFixed(2)}
                <Text style={styles.resultUnit}>
                  {' '}
                  {l10n.benchmark.benchmarkResultCard.results.tokensPerSecond}
                </Text>
              </Text>
              <Text style={styles.resultLabel}>
                {l10n.benchmark.benchmarkResultCard.results.promptProcessing}
              </Text>
              <Text style={styles.resultStd}>¬±{result.ppStd.toFixed(2)}</Text>
            </View>
            <View style={styles.resultItem}>
              <Text style={styles.resultValue}>
                {result.tgAvg.toFixed(2)}
                <Text style={styles.resultUnit}>
                  {' '}
                  {l10n.benchmark.benchmarkResultCard.results.tokensPerSecond}
                </Text>
              </Text>
              <Text style={styles.resultLabel}>
                {l10n.benchmark.benchmarkResultCard.results.tokenGeneration}
              </Text>
              <Text style={styles.resultStd}>¬±{result.tgStd.toFixed(2)}</Text>
            </View>
          </View>

          {(result.wallTimeMs || result.peakMemoryUsage) && (
            <View style={styles.resultRow}>
              {result.wallTimeMs && (
                <View style={styles.resultItem}>
                  <Text style={styles.resultValue}>
                    {formatDuration(result.wallTimeMs)}
                  </Text>
                  <Text style={styles.resultLabel}>
                    {l10n.benchmark.benchmarkResultCard.results.totalTime}
                  </Text>
                </View>
              )}
              {result.peakMemoryUsage && (
                <View style={styles.resultItem}>
                  <Text style={styles.resultValue}>
                    {result.peakMemoryUsage.percentage.toFixed(1)}%
                  </Text>
                  <Text style={styles.resultLabel}>
                    {l10n.benchmark.benchmarkResultCard.results.peakMemory}
                  </Text>
                  <Text style={styles.resultStd}>
                    {formatBytes(result.peakMemoryUsage.used, 0)} /{' '}
                    {formatBytes(result.peakMemoryUsage.total, 0)}
                  </Text>
                </View>
              )}
            </View>
          )}
          <Text style={styles.timestamp}>
            {new Date(result.timestamp).toLocaleString()}
          </Text>
        </View>

        <View style={styles.footer}>
          {result.submitted ? (
            <View style={styles.shareContainer}>
              <Text variant="bodySmall" style={styles.submittedText}>
                {l10n.benchmark.benchmarkResultCard.actions.submittedText}{' '}
                <Text onPress={openLeaderboard} style={styles.leaderboardLink}>
                  {l10n.benchmark.benchmarkResultCard.actions.leaderboardLink}
                </Text>
              </Text>
            </View>
          ) : !result.oid ? (
            <Tooltip
              title={
                l10n.benchmark.benchmarkResultCard.actions.cannotShareTooltip
              }>
              <View style={styles.tooltipContainer}>
                <Text variant="bodySmall" style={styles.disabledText}>
                  {l10n.benchmark.benchmarkResultCard.actions.cannotShare}
                </Text>
                <Text style={styles.infoIcon}>‚ìò</Text>
              </View>
            </Tooltip>
          ) : (
            <View style={styles.actionContainer}>
              <Button
                testID="submit-benchmark-button"
                mode="outlined"
                onPress={handleSubmit}
                loading={isSubmitting}
                disabled={isSubmitting}
                icon="share"
                compact
                style={styles.submitButton}>
                {l10n.benchmark.benchmarkResultCard.actions.submitButton}
              </Button>
              <Text
                variant="bodySmall"
                onPress={openLeaderboard}
                style={styles.leaderboardLink}>
                {l10n.benchmark.benchmarkResultCard.actions.viewLeaderboard}
              </Text>
            </View>
          )}
        </View>

        {submitError && (
          <View style={[styles.errorContainer, getErrorStyle()]}>
            <Text style={styles.errorText}>
              {getErrorIcon()} {submitError}
            </Text>
            {errorType && (
              <Button
                mode="text"
                onPress={handleSubmit}
                disabled={isSubmitting || errorType === 'server'}
                compact
                style={styles.retryButton}>
                {getRetryText()}
              </Button>
            )}
          </View>
        )}
      </Card.Content>
    </Card>
  );
};



================================================
FILE: src/screens/BenchmarkScreen/BenchResultCard/index.ts
================================================
export * from './BenchResultCard';



================================================
FILE: src/screens/BenchmarkScreen/BenchResultCard/styles.ts
================================================
import {StyleSheet} from 'react-native';
import type {Theme} from '../../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    resultCard: {
      backgroundColor: theme.colors.surface,
      borderRadius: 16,
      borderWidth: 1,
      borderColor: theme.colors.surfaceVariant,
    },
    resultHeader: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
      marginBottom: 16,
    },
    headerLeft: {
      flex: 1,
      marginRight: 16,
    },
    modelName: {
      color: theme.colors.onSurface,
      marginBottom: 4,
      //fontSize: 18,
      //fontWeight: '500',
    },
    modelMeta: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    configContainer: {
      borderTopWidth: 1,
      borderBottomWidth: 1,
      borderColor: theme.colors.surfaceVariant,
      marginVertical: 8,
      paddingHorizontal: 12,
    },
    configBar: {
      flexDirection: 'column',
      alignItems: 'flex-start',
      paddingVertical: 8,
      gap: 4,
    },
    configText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
      flex: 1,
    },
    configTextContainer: {
      gap: 4,
      width: '100%',
    },
    resultsContainer: {
      marginBottom: 16,
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: 12,
      padding: 16,
    },
    resultRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'stretch',
      marginBottom: 16,
    },
    resultItem: {
      flex: 1,
      paddingHorizontal: 8,
    },
    resultValue: {
      fontSize: 16,
      color: theme.colors.onSurface,
      fontWeight: '500',
      marginBottom: 2,
    },
    resultUnit: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
      fontWeight: 'normal',
    },
    resultLabel: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 1,
      letterSpacing: 0.1,
    },
    resultStd: {
      fontSize: 10,
      color: theme.colors.onSurfaceVariant,
    },
    deleteButton: {
      marginTop: -8,
      marginRight: -8,
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingTop: 12,
      borderTopWidth: 1,
      borderColor: theme.colors.surfaceVariant,
    },
    timestamp: {
      fontSize: 11,
      color: theme.colors.onSurfaceVariant,
    },
    submitButton: {
      borderColor: theme.colors.primary,
      borderRadius: 16,
    },
    errorText: {
      color: theme.colors.error,
      marginTop: 8,
      fontSize: 12,
    },
    submittedText: {
      color: theme.colors.primary,
      fontSize: 12,
    },
    tooltipContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 4,
    },
    infoIcon: {
      fontSize: 14,
      opacity: 0.6,
    },
    disabledText: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 12,
      fontStyle: 'italic',
    },
    shareContainer: {
      alignItems: 'center',
      gap: 8,
    },
    actionContainer: {
      flex: 1,
      alignItems: 'center',
      gap: 8,
    },
    shareTextContainer: {
      flex: 1,
      marginRight: 16,
    },
    sharePrompt: {
      color: theme.colors.primary,
      fontWeight: '500',
      marginBottom: 2,
    },
    shareSubtext: {
      color: theme.colors.onSurfaceVariant,
      fontSize: 11,
    },
    leaderboardLink: {
      color: theme.colors.primary,
      textDecorationLine: 'underline',
    },
    errorContainer: {
      marginTop: 10,
      padding: 10,
      borderRadius: 6,
      borderWidth: 1,
      backgroundColor: theme.colors.errorContainer,
      borderColor: theme.colors.error,
    },
    errorNetwork: {
      backgroundColor: theme.colors.errorContainer || '#FFF9C4',
      borderColor: theme.colors.error || '#FBC02D',
    },
    errorAppCheck: {
      backgroundColor: theme.colors.errorContainer,
      borderColor: theme.colors.error,
    },
    errorServer: {
      backgroundColor: theme.colors.surfaceVariant,
      borderColor: theme.colors.onSurfaceVariant,
    },
    errorGeneric: {
      backgroundColor: theme.colors.errorContainer,
      borderColor: theme.colors.error,
    },
    retryButton: {
      marginTop: 5,
      alignSelf: 'flex-end',
    },
  });



================================================
FILE: src/screens/BenchmarkScreen/BenchResultCard/__tests__/BenchResultCard.test.tsx
================================================
import React from 'react';
import {Linking, Alert} from 'react-native';
import {fireEvent, render, act, waitFor} from '../../../../../jest/test-utils';
import {BenchResultCard} from '../BenchResultCard';
import {BenchmarkResult, CacheType} from '../../../../utils/types';
import {
  NetworkError,
  AppCheckError,
  ServerError,
} from '../../../../utils/errors';

// Mock Linking
jest.mock('react-native/Libraries/Linking/Linking', () => ({
  openURL: jest.fn().mockImplementation(() => Promise.resolve()),
}));

// Mock Alert
jest.spyOn(Alert, 'alert').mockImplementation(jest.fn());

describe('BenchResultCard', () => {
  const mockResult: BenchmarkResult = {
    config: {
      pp: 1,
      tg: 1,
      pl: 512,
      nr: 3,
      label: 'Default',
    },
    modelDesc: 'Test Model',
    modelSize: 1000 * 1000 * 500, // 500 MB
    modelNParams: 7000000000, // 7B
    ppAvg: 20.5,
    ppStd: 1.2,
    tgAvg: 30.5,
    tgStd: 2.1,
    timestamp: new Date().toISOString(),
    modelId: 'test-model-id',
    modelName: 'Test Model',
    filename: 'test-model.gguf',
    uuid: 'test-uuid',
    oid: 'model-oid', // This is needed for sharing
    initSettings: {
      n_context: 2048,
      n_batch: 512,
      n_ubatch: 128,
      n_threads: 4,
      n_gpu_layers: 20,
      flash_attn: true,
      cache_type_k: CacheType.F16,
      cache_type_v: CacheType.F16,
    },
    wallTimeMs: 5000, // 5 seconds
    peakMemoryUsage: {
      total: 8 * 1000 * 1000 * 1000, // 8 GB
      used: 4 * 1000 * 1000 * 1000, // 4 GB
      percentage: 50,
    },
  };

  const mockSubmittedResult = {
    ...mockResult,
    submitted: true,
  };

  const mockLocalModelResult = {
    ...mockResult,
    oid: undefined, // Local models don't have an OID
  };

  const mockOnDelete = jest.fn();
  const mockOnShare = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
    mockOnShare.mockResolvedValue(undefined);
  });

  it('renders benchmark result data correctly', () => {
    const {getByText} = render(
      <BenchResultCard
        result={mockResult}
        onDelete={mockOnDelete}
        onShare={mockOnShare}
      />,
    );

    // Model info
    expect(getByText('Test Model')).toBeTruthy();
    expect(getByText(/500 MB/)).toBeTruthy();
    expect(getByText(/7B params/)).toBeTruthy();

    // Benchmark results
    expect(getByText('20.50 t/s')).toBeTruthy();
    expect(getByText('30.50 t/s')).toBeTruthy();
    expect(getByText('¬±1.20')).toBeTruthy();
    expect(getByText('¬±2.10')).toBeTruthy();

    // Configuration
    expect(getByText(/PP: 1 ‚Ä¢ TG: 1 ‚Ä¢ PL: 512 ‚Ä¢ Rep: 3/)).toBeTruthy();

    // Memory & time
    expect(getByText('5s')).toBeTruthy();
    expect(getByText('50.0%')).toBeTruthy();
    expect(getByText(/4 GB \/ 8 GB/)).toBeTruthy();
  });

  it('formats different durations correctly', () => {
    // Test with milliseconds
    const shortResult = {...mockResult, wallTimeMs: 500};
    const {getByText, rerender} = render(
      <BenchResultCard
        result={shortResult}
        onDelete={mockOnDelete}
        onShare={mockOnShare}
      />,
    );
    expect(getByText('500ms')).toBeTruthy();

    // Test with seconds
    const secondsResult = {...mockResult, wallTimeMs: 3500};
    rerender(
      <BenchResultCard
        result={secondsResult}
        onDelete={mockOnDelete}
        onShare={mockOnShare}
      />,
    );
    expect(getByText('3s')).toBeTruthy();

    // Test with minutes and seconds
    const minutesResult = {...mockResult, wallTimeMs: 125000}; // 2m 5s
    rerender(
      <BenchResultCard
        result={minutesResult}
        onDelete={mockOnDelete}
        onShare={mockOnShare}
      />,
    );
    expect(getByText('2m 5s')).toBeTruthy();
  });

  it('handles delete button press', () => {
    const {getByTestId} = render(
      <BenchResultCard
        result={mockResult}
        onDelete={mockOnDelete}
        onShare={mockOnShare}
      />,
    );

    const deleteButton = getByTestId('delete-result-button');
    fireEvent.press(deleteButton);

    expect(mockOnDelete).toHaveBeenCalledWith(mockResult.timestamp);
  });

  it('shows submitted state correctly', () => {
    const {getByText} = render(
      <BenchResultCard
        result={mockSubmittedResult}
        onDelete={mockOnDelete}
        onShare={mockOnShare}
      />,
    );

    expect(getByText(/‚úì Shared to/)).toBeTruthy();
    expect(getByText(/AI Phone Leaderboard ‚Üó/)).toBeTruthy();
  });

  it('disables sharing for local models', () => {
    const {getByText} = render(
      <BenchResultCard
        result={mockLocalModelResult}
        onDelete={mockOnDelete}
        onShare={mockOnShare}
      />,
    );

    expect(getByText('Cannot share')).toBeTruthy();
  });

  it('opens leaderboard when link is clicked', () => {
    const {getByText} = render(
      <BenchResultCard
        result={mockResult}
        onDelete={mockOnDelete}
        onShare={mockOnShare}
      />,
    );

    const leaderboardLink = getByText('View leaderboard ‚Üó');
    fireEvent.press(leaderboardLink);

    expect(Linking.openURL).toHaveBeenCalledWith(
      'https://huggingface.co/spaces/a-ghorbani/ai-phone-leaderboard',
    );
  });

  it('submits benchmark data when submit button is pressed', async () => {
    const {getByTestId} = render(
      <BenchResultCard
        result={mockResult}
        onDelete={mockOnDelete}
        onShare={mockOnShare}
      />,
    );

    const submitButton = getByTestId('submit-benchmark-button');
    await act(async () => {
      fireEvent.press(submitButton);
    });

    expect(mockOnShare).toHaveBeenCalledWith(mockResult);
  });

  it('handles network errors', async () => {
    mockOnShare.mockRejectedValueOnce(
      new NetworkError('No internet connection. Please connect and try again.'),
    );

    const {getByTestId, getByText} = render(
      <BenchResultCard
        result={mockResult}
        onDelete={mockOnDelete}
        onShare={mockOnShare}
      />,
    );

    const submitButton = getByTestId('submit-benchmark-button');
    await act(async () => {
      fireEvent.press(submitButton);
    });

    await waitFor(() => {
      expect(getByText(/üì∂.*No internet connection/)).toBeTruthy();
      expect(getByText('Check connection & retry')).toBeTruthy();
    });
  });

  it('handles app check errors', async () => {
    mockOnShare.mockRejectedValueOnce(
      new AppCheckError('App verification failed.'),
    );

    const {getByTestId, getByText} = render(
      <BenchResultCard
        result={mockResult}
        onDelete={mockOnDelete}
        onShare={mockOnShare}
      />,
    );

    const submitButton = getByTestId('submit-benchmark-button');
    await act(async () => {
      fireEvent.press(submitButton);
    });

    await waitFor(() => {
      expect(getByText(/üîí.*App verification failed/)).toBeTruthy();
      expect(getByText('Retry submission')).toBeTruthy();
    });
  });

  it('handles server errors', async () => {
    mockOnShare.mockRejectedValueOnce(
      new ServerError('Our servers are experiencing issues.'),
    );

    const {getByTestId, getByText} = render(
      <BenchResultCard
        result={mockResult}
        onDelete={mockOnDelete}
        onShare={mockOnShare}
      />,
    );

    const submitButton = getByTestId('submit-benchmark-button');
    await act(async () => {
      fireEvent.press(submitButton);
    });

    await waitFor(() => {
      expect(getByText(/üñ•Ô∏è.*Our servers are experiencing issues/)).toBeTruthy();
      expect(getByText('Try again later')).toBeTruthy();
    });
  });

  it('handles unknown errors', async () => {
    mockOnShare.mockRejectedValueOnce(new Error('Unknown error occurred'));

    const {getByTestId, getByText} = render(
      <BenchResultCard
        result={mockResult}
        onDelete={mockOnDelete}
        onShare={mockOnShare}
      />,
    );

    const submitButton = getByTestId('submit-benchmark-button');
    await act(async () => {
      fireEvent.press(submitButton);
    });

    await waitFor(() => {
      expect(getByText(/‚ùå.*Unknown error occurred/)).toBeTruthy();
      expect(getByText('Retry')).toBeTruthy();
    });
  });

  it('allows retrying after a network error', async () => {
    mockOnShare.mockRejectedValueOnce(new NetworkError('Network error'));

    const {getByTestId, getByText} = render(
      <BenchResultCard
        result={mockResult}
        onDelete={mockOnDelete}
        onShare={mockOnShare}
      />,
    );

    // First attempt - triggers error
    const submitButton = getByTestId('submit-benchmark-button');
    await act(async () => {
      fireEvent.press(submitButton);
    });

    // Clear the mock so the retry will succeed
    mockOnShare.mockClear();
    mockOnShare.mockResolvedValueOnce(undefined);

    // Retry
    await waitFor(() => {
      const retryButton = getByText('Check connection & retry');
      fireEvent.press(retryButton);
    });

    expect(mockOnShare).toHaveBeenCalledWith(mockResult);
  });

  it('opens leaderboard when link is clicked on submitted results', () => {
    const {getByText} = render(
      <BenchResultCard
        result={mockSubmittedResult}
        onDelete={mockOnDelete}
        onShare={mockOnShare}
      />,
    );

    const leaderboardText = getByText(/AI Phone Leaderboard ‚Üó/);
    fireEvent.press(leaderboardText);

    expect(Linking.openURL).toHaveBeenCalledWith(
      'https://huggingface.co/spaces/a-ghorbani/ai-phone-leaderboard',
    );
  });

  it('renders without initSettings or peakMemoryUsage', () => {
    const minimalResult = {
      ...mockResult,
      initSettings: undefined,
      peakMemoryUsage: undefined,
      wallTimeMs: undefined,
    };

    const {queryByText} = render(
      <BenchResultCard
        result={minimalResult}
        onDelete={mockOnDelete}
        onShare={mockOnShare}
      />,
    );

    // These should not be in the DOM
    expect(queryByText('Model Settings')).toBeNull();
    expect(queryByText('Peak Memory')).toBeNull();
    expect(queryByText('Total Time')).toBeNull();
  });
});



================================================
FILE: src/screens/BenchmarkScreen/DeviceInfoCard/DeviceInfoCard.tsx
================================================
import React, {useEffect, useState, useContext} from 'react';
import {View, TouchableOpacity} from 'react-native';
import {Platform, NativeModules} from 'react-native';

import {Card, Text, Icon} from 'react-native-paper';
import RNDeviceInfo from 'react-native-device-info';

import {Divider} from '../../../components';

import {useTheme} from '../../../hooks';
import {L10nContext} from '../../../utils';

import {createStyles} from './styles';

import {DeviceInfo} from '../../../utils/types';

const {DeviceInfoModule} = NativeModules;

const getChipsetInfo = async () => {
  if (Platform.OS !== 'android' || !DeviceInfoModule) {
    return '';
  }
  try {
    return await DeviceInfoModule.getChipset();
  } catch (e) {
    console.warn('Failed to get chipset info:', e);
    return '';
  }
};

const getCPUInfo = async () => {
  if (!DeviceInfoModule) {
    console.warn('DeviceInfoModule not available');
    return {
      cores: 0,
      processors: [],
      features: [],
      socModel: '',
      hasFp16: false,
      hasDotProd: false,
      hasSve: false,
      hasI8mm: false,
    };
  }
  try {
    const info = await DeviceInfoModule.getCPUInfo();
    if (!info) {
      return null;
    }

    return Platform.OS === 'ios'
      ? {
          cores: info.cores || 0,
          processors: [],
          features: [],
          socModel: '',
          hasFp16: false,
          hasDotProd: false,
          hasSve: false,
          hasI8mm: false,
        }
      : info;
  } catch (e) {
    console.warn('Failed to get CPU info:', e);
    return null;
  }
};

type Props = {
  onDeviceInfo?: (info: DeviceInfo) => void;
  testId?: string;
};

export const DeviceInfoCard = ({onDeviceInfo, testId}: Props) => {
  const theme = useTheme();
  const styles = createStyles(theme);
  const l10n = useContext(L10nContext);

  const [deviceInfo, setDeviceInfo] = useState({
    model: RNDeviceInfo.getModel(),
    systemName: Platform.OS === 'ios' ? 'iOS' : 'Android',
    systemVersion: String(Platform.Version || ''),
    brand: RNDeviceInfo.getBrand(),
    cpuArch: [] as string[],
    isEmulator: false,
    version: RNDeviceInfo.getVersion(),
    buildNumber: RNDeviceInfo.getBuildNumber(),
    device: '',
    deviceId: '',
    totalMemory: 0,
    chipset: '',
    cpu: '',
    cpuDetails: {
      cores: 0,
      processors: [] as Array<{
        processor: string;
        'model name': string;
        'cpu MHz': string;
        vendor_id: string;
      }>,
      socModel: '',
      features: [] as string[],
      hasFp16: false,
      hasDotProd: false,
      hasSve: false,
      hasI8mm: false,
    },
  });
  const [expanded, setExpanded] = useState(false);

  useEffect(() => {
    Promise.all([
      RNDeviceInfo.supportedAbis(),
      RNDeviceInfo.isEmulator(),
      RNDeviceInfo.getDevice(),
      RNDeviceInfo.getDeviceId(),
      RNDeviceInfo.getTotalMemory(),
      getChipsetInfo(),
      getCPUInfo(),
    ]).then(
      ([abis, emulator, device, deviceId, totalMem, chipset, cpuInfo]) => {
        const newDeviceInfo = {
          model: RNDeviceInfo.getModel(),
          systemName: Platform.OS === 'ios' ? 'iOS' : 'Android',
          systemVersion: String(Platform.Version || ''),
          brand: RNDeviceInfo.getBrand(),
          version: RNDeviceInfo.getVersion(),
          buildNumber: RNDeviceInfo.getBuildNumber(),
          cpuArch: abis,
          isEmulator: emulator,
          device,
          deviceId,
          totalMemory: totalMem,
          chipset,
          cpu: '',
          cpuDetails:
            typeof cpuInfo === 'object'
              ? cpuInfo
              : {
                  cores: 0,
                  processors: [],
                  socModel: '',
                  features: [],
                  hasFp16: false,
                  hasDotProd: false,
                  hasSve: false,
                  hasI8mm: false,
                },
        };

        setDeviceInfo(newDeviceInfo);
        onDeviceInfo?.(newDeviceInfo);
      },
    );
  }, [onDeviceInfo]);

  const formatBytes = (bytes: number) => {
    const gb = bytes / (1024 * 1024 * 1024);
    return `${gb.toFixed(1)} GB`;
  };

  return (
    <Card
      testID={testId ?? 'device-info-card'}
      elevation={0}
      style={styles.deviceInfoCard}>
      <TouchableOpacity onPress={() => setExpanded(!expanded)}>
        <View style={styles.headerRow}>
          <View style={styles.headerContent}>
            <Text variant="titleSmall">
              {l10n.benchmark.deviceInfoCard.title}
            </Text>
            <Text variant="bodySmall" style={styles.headerSummary}>
              {l10n.benchmark.deviceInfoCard.deviceSummary
                .replace('{{brand}}', deviceInfo.brand)
                .replace('{{model}}', deviceInfo.model)
                .replace('{{systemName}}', deviceInfo.systemName)
                .replace('{{systemVersion}}', deviceInfo.systemVersion)}
            </Text>
            <Text variant="bodySmall" style={styles.headerSummary}>
              {l10n.benchmark.deviceInfoCard.coreSummary
                .replace('{{cores}}', deviceInfo.cpuDetails.cores.toString())
                .replace('{{memory}}', formatBytes(deviceInfo.totalMemory))}
            </Text>
          </View>
          <Icon
            source={expanded ? 'chevron-up' : 'chevron-down'}
            size={24}
            color={theme.colors.onSurface}
          />
        </View>
      </TouchableOpacity>

      {expanded && (
        <>
          <Divider />
          <Card.Content>
            <View style={styles.section}>
              <Text variant="labelSmall" style={styles.sectionTitle}>
                {l10n.benchmark.deviceInfoCard.sections.basicInfo}
              </Text>
              <View style={styles.deviceInfoRow}>
                <Text variant="labelSmall" style={styles.deviceInfoLabel}>
                  {l10n.benchmark.deviceInfoCard.fields.architecture}
                </Text>
                <Text variant="bodySmall" style={styles.deviceInfoValue}>
                  {Array.isArray(deviceInfo.cpuArch)
                    ? deviceInfo.cpuArch.join(', ')
                    : deviceInfo.cpuArch}
                </Text>
              </View>
              <View style={styles.deviceInfoRow}>
                <Text variant="labelSmall" style={styles.deviceInfoLabel}>
                  {l10n.benchmark.deviceInfoCard.fields.totalMemory}
                </Text>
                <Text variant="bodySmall" style={styles.deviceInfoValue}>
                  {formatBytes(deviceInfo.totalMemory)}
                </Text>
              </View>
              <View style={styles.deviceInfoRow}>
                <Text variant="labelSmall" style={styles.deviceInfoLabel}>
                  {l10n.benchmark.deviceInfoCard.fields.deviceId}
                </Text>
                <Text variant="bodySmall" style={styles.deviceInfoValue}>
                  {Platform.OS === 'ios'
                    ? deviceInfo.deviceId
                    : `${deviceInfo.device} (${deviceInfo.deviceId})`}
                </Text>
              </View>
            </View>

            <View style={styles.section}>
              <Text variant="labelSmall" style={styles.sectionTitle}>
                {l10n.benchmark.deviceInfoCard.sections.cpuDetails}
              </Text>
              <View style={styles.deviceInfoRow}>
                <Text variant="labelSmall" style={styles.deviceInfoLabel}>
                  {l10n.benchmark.deviceInfoCard.fields.cpuCores}
                </Text>
                <Text variant="bodySmall" style={styles.deviceInfoValue}>
                  {deviceInfo.cpuDetails.cores}
                </Text>
              </View>
              {deviceInfo.cpuDetails.processors[0]?.['model name'] && (
                <View style={styles.deviceInfoRow}>
                  <Text variant="labelSmall" style={styles.deviceInfoLabel}>
                    {l10n.benchmark.deviceInfoCard.fields.cpuModel}
                  </Text>
                  <Text variant="bodySmall" style={styles.deviceInfoValue}>
                    {deviceInfo.cpuDetails.processors[0]['model name']}
                  </Text>
                </View>
              )}
              {Platform.OS === 'android' && deviceInfo.chipset && (
                <View style={styles.deviceInfoRow}>
                  <Text variant="labelSmall" style={styles.deviceInfoLabel}>
                    {l10n.benchmark.deviceInfoCard.fields.chipset}
                  </Text>
                  <Text variant="bodySmall" style={styles.deviceInfoValue}>
                    {deviceInfo.chipset}
                  </Text>
                </View>
              )}
              {Platform.OS === 'android' && (
                <View style={styles.deviceInfoRow}>
                  <Text variant="labelSmall" style={styles.deviceInfoLabel}>
                    {l10n.benchmark.deviceInfoCard.fields.instructions}
                  </Text>
                  <Text variant="bodySmall" style={styles.deviceInfoValue}>
                    {l10n.benchmark.deviceInfoCard.instructions.format
                      .replace(
                        '{{fp16}}',
                        deviceInfo.cpuDetails.hasFp16
                          ? l10n.benchmark.deviceInfoCard.instructions.yes
                          : l10n.benchmark.deviceInfoCard.instructions.no,
                      )
                      .replace(
                        '{{dotProd}}',
                        deviceInfo.cpuDetails.hasDotProd
                          ? l10n.benchmark.deviceInfoCard.instructions.yes
                          : l10n.benchmark.deviceInfoCard.instructions.no,
                      )
                      .replace(
                        '{{sve}}',
                        deviceInfo.cpuDetails.hasSve
                          ? l10n.benchmark.deviceInfoCard.instructions.yes
                          : l10n.benchmark.deviceInfoCard.instructions.no,
                      )
                      .replace(
                        '{{i8mm}}',
                        deviceInfo.cpuDetails.hasI8mm
                          ? l10n.benchmark.deviceInfoCard.instructions.yes
                          : l10n.benchmark.deviceInfoCard.instructions.no,
                      )}
                  </Text>
                </View>
              )}
            </View>

            <View style={styles.section}>
              <Text variant="labelSmall" style={styles.sectionTitle}>
                {l10n.benchmark.deviceInfoCard.sections.appInfo}
              </Text>
              <View style={styles.deviceInfoRow}>
                <Text variant="labelSmall" style={styles.deviceInfoLabel}>
                  {l10n.benchmark.deviceInfoCard.fields.version}
                </Text>
                <Text variant="bodySmall" style={styles.deviceInfoValue}>
                  {deviceInfo.version} ({deviceInfo.buildNumber})
                </Text>
              </View>
            </View>
          </Card.Content>
        </>
      )}
    </Card>
  );
};



================================================
FILE: src/screens/BenchmarkScreen/DeviceInfoCard/index.ts
================================================
export * from './DeviceInfoCard';



================================================
FILE: src/screens/BenchmarkScreen/DeviceInfoCard/styles.ts
================================================
import {StyleSheet} from 'react-native';

import type {Theme} from '../../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    deviceInfoCard: {
      marginBottom: 16,
      backgroundColor: theme.colors.surface,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      borderRadius: 15,
    },
    deviceInfoRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 4,
    },
    deviceInfoLabel: {
      color: theme.colors.onSurfaceVariant,
    },
    deviceInfoValue: {
      color: theme.colors.onSurface,
    },
    headerRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      padding: 16,
    },
    headerContent: {
      flex: 1,
    },
    headerSummary: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 4,
    },
    section: {
      marginVertical: 8,
    },
    sectionTitle: {
      color: theme.colors.primary,
      marginBottom: 8,
      textTransform: 'uppercase',
    },
  });



================================================
FILE: src/screens/BenchmarkScreen/DeviceInfoCard/__tests__/DeviceInfoCard.test.tsx
================================================
import React from 'react';
import {Platform} from 'react-native';
import {fireEvent, render, waitFor} from '../../../../../jest/test-utils';
import {DeviceInfoCard} from '../DeviceInfoCard';

// Mock react-native-device-info
jest.mock('react-native-device-info', () => ({
  getModel: jest.fn().mockReturnValue('iPhone 13'),
  getBrand: jest.fn().mockReturnValue('Apple'),
  getVersion: jest.fn().mockReturnValue('1.0.0'),
  getBuildNumber: jest.fn().mockReturnValue('100'),
  supportedAbis: jest.fn().mockResolvedValue(['arm64']),
  isEmulator: jest.fn().mockResolvedValue(false),
  getDevice: jest.fn().mockResolvedValue('iPhone14,2'),
  getDeviceId: jest.fn().mockResolvedValue('device-id-123'),
  getTotalMemory: jest.fn().mockResolvedValue(6 * 1024 * 1024 * 1024), // 6GB
}));

describe('DeviceInfoCard', () => {
  const mockOnDeviceInfo = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
    Platform.OS = 'ios';
  });

  it('renders basic device information correctly', async () => {
    const {getByText, getByTestId, debug} = render(
      <DeviceInfoCard onDeviceInfo={mockOnDeviceInfo} />,
    );

    debug();

    // Wait for the device info to load
    await waitFor(() => {
      expect(getByText('Device Information')).toBeTruthy();
      expect(getByText(/iPhone 13/)).toBeTruthy();
    });

    // Check that card exists
    expect(getByTestId('device-info-card')).toBeTruthy();
  });

  it('can be expanded and collapsed', async () => {
    const {getByText, queryByText} = render(
      <DeviceInfoCard onDeviceInfo={mockOnDeviceInfo} />,
    );

    // Wait for the device info to load
    await waitFor(() => {
      expect(getByText('Device Information')).toBeTruthy();
    });

    // Initially, detailed info should not be visible
    expect(queryByText('Basic Info')).toBeNull();

    // Expand the card
    fireEvent.press(getByText('Device Information'));

    // Now detailed info should be visible
    expect(getByText('Basic Info')).toBeTruthy();
    expect(getByText('Architecture')).toBeTruthy();
    expect(getByText('Total Memory')).toBeTruthy();
    expect(getByText('Device ID')).toBeTruthy();
    expect(getByText('CPU Details')).toBeTruthy();

    // Collapse the card
    fireEvent.press(getByText('Device Information'));

    // Detailed info should be hidden again
    expect(queryByText('Basic Info')).toBeNull();
  });

  it('calls onDeviceInfo with device information when loaded', async () => {
    render(<DeviceInfoCard onDeviceInfo={mockOnDeviceInfo} />);

    // Wait for device info to be loaded and callback to be called
    await waitFor(() => {
      expect(mockOnDeviceInfo).toHaveBeenCalled();
      const deviceInfo = mockOnDeviceInfo.mock.calls[0][0];

      // Check the passed deviceInfo object
      expect(deviceInfo.model).toBe('iPhone 13');
      expect(deviceInfo.brand).toBe('Apple');
      expect(deviceInfo.systemName).toBe('iOS');
      expect(deviceInfo.cpuArch).toEqual(['arm64']);
      expect(deviceInfo.totalMemory).toBe(6 * 1024 * 1024 * 1024);
    });
  });

  it('allows specifying a custom testId', async () => {
    const {getByTestId} = render(
      <DeviceInfoCard
        onDeviceInfo={mockOnDeviceInfo}
        testId="custom-device-info"
      />,
    );

    await waitFor(() => {
      expect(getByTestId('custom-device-info')).toBeTruthy();
    });
  });
});



================================================
FILE: src/screens/ChatScreen/ChatScreen.tsx
================================================
import React, {useRef, ReactNode} from 'react';

import {observer} from 'mobx-react';

import {Bubble, ChatView, ErrorSnackbar} from '../../components';

import {useChatSession} from '../../hooks';

import {modelStore, chatSessionStore, palStore, uiStore} from '../../store';

import {L10nContext} from '../../utils';
import {MessageType} from '../../utils/types';
import {user, assistant} from '../../utils/chat';

import {VideoPalScreen} from './VideoPalScreen';
import {PalType} from '../../components/PalsSheets/types';

const renderBubble = ({
  child,
  message,
  nextMessageInGroup,
  scale,
}: {
  child: ReactNode;
  message: MessageType.Any;
  nextMessageInGroup: boolean;
  scale?: any;
}) => (
  <Bubble
    child={child}
    message={message}
    nextMessageInGroup={nextMessageInGroup}
    scale={scale}
  />
);

export const ChatScreen: React.FC = observer(() => {
  const currentMessageInfo = useRef<{
    createdAt: number;
    id: string;
    sessionId: string;
  } | null>(null);
  const l10n = React.useContext(L10nContext);

  const {handleSendPress, handleStopPress, isMultimodalEnabled} =
    useChatSession(currentMessageInfo, user, assistant);

  // Check if multimodal is enabled
  const [multimodalEnabled, setMultimodalEnabled] = React.useState(false);

  React.useEffect(() => {
    const checkMultimodal = async () => {
      const enabled = await isMultimodalEnabled();
      setMultimodalEnabled(enabled);
    };

    checkMultimodal();
  }, [isMultimodalEnabled]);

  const thinkingSupported = modelStore.activeModel?.supportsThinking ?? false;

  const thinkingEnabled = (() => {
    const currentSession = chatSessionStore.sessions.find(
      s => s.id === chatSessionStore.activeSessionId,
    );
    const settings =
      currentSession?.completionSettings ??
      chatSessionStore.newChatCompletionSettings;
    return settings.enable_thinking ?? true;
  })();

  // Show loading bubble only during the thinking phase (inferencing but not streaming)
  const isThinking = modelStore.inferencing && !modelStore.isStreaming;

  const handleThinkingToggle = async (enabled: boolean) => {
    const currentSession = chatSessionStore.sessions.find(
      s => s.id === chatSessionStore.activeSessionId,
    );

    if (currentSession) {
      // Update session-specific settings
      const updatedSettings = {
        ...currentSession.completionSettings,
        enable_thinking: enabled,
      };
      await chatSessionStore.updateSessionCompletionSettings(updatedSettings);
    } else {
      // Update global settings for new chats
      const updatedSettings = {
        ...chatSessionStore.newChatCompletionSettings,
        enable_thinking: enabled,
      };
      await chatSessionStore.setNewChatCompletionSettings(updatedSettings);
    }
  };

  const activePalId = chatSessionStore.activePalId;
  const activePal = activePalId
    ? palStore.pals.find(p => p.id === activePalId)
    : undefined;
  const isVideoPal = activePal?.palType === PalType.VIDEO;

  // If the active pal is a video pal, show the video pal screen
  if (isVideoPal) {
    return <VideoPalScreen />;
  }

  // Otherwise, show the regular chat view
  return (
    <>
      <ChatView
        renderBubble={renderBubble}
        messages={chatSessionStore.currentSessionMessages}
        onSendPress={handleSendPress}
        onStopPress={handleStopPress}
        user={user}
        isStopVisible={modelStore.inferencing}
        isThinking={isThinking}
        isStreaming={modelStore.isStreaming}
        sendButtonVisibilityMode="always"
        showImageUpload={true}
        isVisionEnabled={multimodalEnabled}
        inputProps={{
          showThinkingToggle: thinkingSupported,
          isThinkingEnabled: thinkingEnabled,
          onThinkingToggle: handleThinkingToggle,
        }}
        textInputProps={{
          editable: !!modelStore.context,
          placeholder: !modelStore.context
            ? modelStore.isContextLoading
              ? l10n.chat.loadingModel
              : l10n.chat.modelNotLoaded
            : l10n.chat.typeYourMessage,
        }}
      />
      {uiStore.chatWarning && (
        <ErrorSnackbar
          error={uiStore.chatWarning}
          onDismiss={() => uiStore.clearChatWarning()}
        />
      )}
    </>
  );
});



================================================
FILE: src/screens/ChatScreen/index.ts
================================================
export * from './ChatScreen';



================================================
FILE: src/screens/ChatScreen/VideoPalScreen.tsx
================================================
import React, {useState, useCallback, useContext, useEffect} from 'react';
import {View, StyleSheet, Alert} from 'react-native';
import {observer} from 'mobx-react';
import {ChatView, EmbeddedVideoView} from '../../components';
import {L10nContext, UserContext} from '../../utils';
import {modelStore, palStore} from '../../store';
import 'react-native-get-random-values';
import {user as defaultUser} from '../../utils/chat';
import {PalType} from '../../components/PalsSheets/types';
import {VideoPal} from '../../store/PalStore';

export const VideoPalScreen = observer(() => {
  const l10n = useContext(L10nContext);

  const contextUser = useContext(UserContext);
  const user = contextUser || defaultUser;

  const [isCameraActive, setIsCameraActive] = useState(false);
  const [responseText, setResponseText] = useState('');
  const [promptText, setPromptText] = useState('What do you see?');
  const [captureInterval, setCaptureInterval] = useState(1000); // Default to 1 second
  const [lastAnalysisTime, setLastAnalysisTime] = useState(0);
  const [isStoppingCamera, setIsStoppingCamera] = useState(false);

  // Get the active VideoPal to access its captureInterval setting
  const activeVideoPal = React.useMemo(() => {
    if (palStore.pals.length > 0) {
      const videoPal = palStore.pals.find(p => p.palType === PalType.VIDEO) as
        | VideoPal
        | undefined;

      if (videoPal) {
        return videoPal;
      }
    }
    return undefined;
  }, []);

  // Initialize captureInterval from the active VideoPal
  useEffect(() => {
    if (activeVideoPal?.captureInterval) {
      setCaptureInterval(activeVideoPal.captureInterval);
    }
  }, [activeVideoPal]);

  // Initialize the model with the projection model if needed
  useEffect(() => {
    if (
      activeVideoPal &&
      !modelStore.activeModel &&
      activeVideoPal.defaultModel
    ) {
      const palDefaultModel = modelStore.availableModels.find(
        m => m.id === activeVideoPal.defaultModel?.id,
      );

      if (palDefaultModel) {
        console.log('Initializing Video Pal model with projection model');

        // Check if this model supports multimodal and has a default projection model
        if (
          palDefaultModel.supportsMultimodal &&
          palDefaultModel.defaultProjectionModel
        ) {
          // Find the default projection model
          const projectionModel = modelStore.availableModels.find(
            m => m.id === palDefaultModel.defaultProjectionModel,
          );

          if (projectionModel) {
            console.log(
              'Found default projection model:',
              projectionModel.name,
            );
            // Get the projection model path
            modelStore
              .getModelFullPath(projectionModel)
              .then(projectionModelPath => {
                console.log(
                  'Initializing with projection model path:',
                  projectionModelPath,
                );
                // Initialize with both the main model and projection model
                modelStore.initContext(palDefaultModel, projectionModelPath);
              })
              .catch(error => {
                console.error('Failed to get projection model path:', error);
                // Fall back to initializing without projection model
                modelStore.initContext(palDefaultModel);
              });
          } else {
            console.warn(
              'Default projection model not found, initializing without it',
            );
            modelStore.initContext(palDefaultModel);
          }
        } else {
          console.log(
            'Model does not support multimodal or has no default projection model',
          );
          modelStore.initContext(palDefaultModel);
        }
      }
    }
  }, [activeVideoPal]);

  // Handle starting the camera
  const handleStartCamera = useCallback(async () => {
    if (!modelStore.context) {
      Alert.alert(l10n.chat.modelNotLoaded, l10n.chat.pleaseLoadModel, [
        {
          text: l10n.common.ok,
        },
      ]);
      return;
    }

    // Check if multimodal is enabled
    try {
      const isEnabled = await modelStore.isMultimodalEnabled();
      if (!isEnabled) {
        Alert.alert(
          'Multimodal Not Enabled',
          'This model does not support image analysis. Please load a multimodal model.',
          [
            {
              text: l10n.common.ok,
            },
          ],
        );
        return;
      }

      setIsCameraActive(true);
    } catch (error) {
      console.error('Error checking multimodal capability:', error);
      Alert.alert('Error', 'Failed to check if model supports images.', [
        {
          text: l10n.common.ok,
        },
      ]);
    }
  }, [l10n]);

  // Handle stopping the camera
  const handleStopCamera = useCallback(async () => {
    setIsStoppingCamera(true);

    // Stop any ongoing completion first
    if (modelStore.inferencing || modelStore.isStreaming) {
      try {
        await modelStore.context?.stopCompletion();
      } catch (error) {
        console.error('Error stopping completion:', error);
      }
    }

    // Clear response text and stop camera
    setResponseText('');
    setIsCameraActive(false);
    setIsStoppingCamera(false);
  }, []);

  // Handle capture interval change
  const handleCaptureIntervalChange = useCallback(
    (interval: number) => {
      setCaptureInterval(interval);

      // Update the VideoPal's captureInterval setting
      if (activeVideoPal) {
        palStore.updatePal(activeVideoPal.id, {
          captureInterval: interval,
        });
      }
    },
    [activeVideoPal],
  );

  // Handle image capture from the video stream
  const handleImageCapture = useCallback(
    async (imageBase64: string) => {
      // Don't process if we're stopping the camera
      if (isStoppingCamera) {
        return;
      }

      // Throttle analysis to avoid overwhelming the model
      const now = Date.now();
      if (now - lastAnalysisTime < captureInterval) {
        return;
      }

      setLastAnalysisTime(now);

      // Clear the previous response text before starting a new analysis
      setResponseText('');

      // Get the system prompt from the active VideoPal
      const systemPrompt = activeVideoPal?.systemPrompt || '';

      try {
        // Start the completion with the base64 image using the user-editable prompt
        await modelStore.startImageCompletion({
          prompt: promptText,
          image_path: imageBase64, // Now passing base64 data URL instead of file path
          systemMessage: systemPrompt,
          onToken: token => {
            // Only update response text if we're not stopping the camera
            if (!isStoppingCamera) {
              setResponseText(prev => prev + token);
            }
          },
          onComplete: () => {
            // This is called when the entire completion is done
            // We don't need to set the text again as we've been building it token by token
          },
          onError: error => {
            console.error('Error processing image:', error);
          },
        });
      } catch (error) {
        console.error('Error processing image:', error);
      }
    },
    [
      promptText,
      captureInterval,
      lastAnalysisTime,
      activeVideoPal,
      isStoppingCamera,
    ],
  );

  // Render the chat view with embedded camera when active
  return (
    <UserContext.Provider value={user}>
      <View style={styles.container}>
        {isCameraActive ? (
          // Full-screen camera view with response overlay
          <View style={styles.fullScreenContainer}>
            <EmbeddedVideoView
              onCapture={handleImageCapture}
              onClose={handleStopCamera}
              captureInterval={captureInterval}
              onCaptureIntervalChange={handleCaptureIntervalChange}
              responseText={responseText}
            />
          </View>
        ) : (
          // Regular chat view when camera is not active
          <ChatView
            messages={[]}
            onSendPress={() => {}}
            onStopPress={() => modelStore.context?.stopCompletion()}
            user={user}
            isStopVisible={modelStore.inferencing}
            isThinking={modelStore.inferencing && !modelStore.isStreaming}
            isStreaming={modelStore.isStreaming}
            sendButtonVisibilityMode="editing"
            textInputProps={{
              editable: !modelStore.isStreaming && !isCameraActive,
              value: promptText,
              onChangeText: setPromptText,
            }}
            inputProps={{
              palType: PalType.VIDEO,
              isCameraActive: isCameraActive,
              onStartCamera: handleStartCamera,
              promptText: promptText,
              onPromptTextChange: setPromptText,
            }}
          />
        )}
      </View>
    </UserContext.Provider>
  );
});

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  fullScreenContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    zIndex: 10,
  },
});



================================================
FILE: src/screens/ChatScreen/__tests__/ChatScreen.test.tsx
================================================
import React from 'react';

import {LlamaContext} from '@pocketpalai/llama.rn';
import {render, fireEvent, act, waitFor} from '../../../../jest/test-utils';
import {ChatScreen} from '../ChatScreen';

import {chatSessionStore, modelStore} from '../../../store';

import {l10n} from '../../../utils/l10n';
import {mockContextModel} from '../../../../jest/fixtures/models';

describe('ChatScreen', () => {
  let llamaRN;

  beforeEach(() => {
    jest.clearAllMocks();
    llamaRN = require('@pocketpalai/llama.rn');
  });

  it('renders correctly when model is not loaded', () => {
    const {getByPlaceholderText} = render(<ChatScreen />, {
      withNavigation: true,
    });
    expect(getByPlaceholderText(l10n.en.chat.modelNotLoaded)).toBeTruthy();
  });

  it('renders correctly when model is loading', () => {
    modelStore.isContextLoading = true;
    const {getByPlaceholderText} = render(<ChatScreen />, {
      withNavigation: true,
    });
    expect(getByPlaceholderText(l10n.en.chat.loadingModel)).toBeTruthy();
  });

  it('renders correctly when model is loaded', () => {
    modelStore.context = new LlamaContext({
      contextId: 1,
      gpu: false,
      reasonNoGPU: '',
      model: mockContextModel,
    });
    const {getByPlaceholderText} = render(<ChatScreen />, {
      withNavigation: true,
    });
    expect(getByPlaceholderText(l10n.en.chat.typeYourMessage)).toBeTruthy();
  });

  it('handles sending a message', async () => {
    modelStore.context = new LlamaContext({
      contextId: 1,
      gpu: false,
      reasonNoGPU: '',
      model: mockContextModel,
    });
    modelStore.context.completion = jest.fn().mockResolvedValue({
      timings: {predicted_per_token_ms: 10, predicted_per_second: 100},
    });

    const {getByPlaceholderText, getByTestId} = render(<ChatScreen />, {
      withNavigation: true,
    });
    const input = getByPlaceholderText(l10n.en.chat.typeYourMessage);

    await act(async () => {
      fireEvent.changeText(input, 'Hello, PocketPal AI!');
    });

    const sendButton = getByTestId('send-button');
    fireEvent.press(sendButton);

    await waitFor(() => {
      expect(chatSessionStore.addMessageToCurrentSession).toHaveBeenCalledWith(
        expect.objectContaining({
          author: expect.objectContaining({id: 'y9d7f8pgn'}),
          text: 'Hello, PocketPal AI!',
        }),
      );
    });

    await waitFor(() => {
      expect(modelStore.context).toBeTruthy();
      if (modelStore.context) {
        expect(modelStore.context.completion).toHaveBeenCalled();
      }
    });
  });

  it('handles sending a message failure', async () => {
    modelStore.context = new LlamaContext({
      contextId: 1,
      gpu: false,
      reasonNoGPU: '',
      model: mockContextModel,
    });
    modelStore.context.completion = jest
      .fn()
      .mockRejectedValue(new Error('Completion failed'));

    const {getByPlaceholderText, getByTestId} = render(<ChatScreen />, {
      withNavigation: true,
    });
    const input = getByPlaceholderText(l10n.en.chat.typeYourMessage);

    await act(async () => {
      fireEvent.changeText(input, 'Hello, PocketPal!');
    });

    const sendButton = getByTestId('send-button');
    await act(async () => {
      fireEvent.press(sendButton);
    });

    expect(chatSessionStore.addMessageToCurrentSession).toHaveBeenCalledWith(
      expect.objectContaining({
        author: expect.objectContaining({id: 'h3o3lc5xj'}),
        text: 'Completion failed: Completion failed',
        metadata: expect.objectContaining({system: true}),
      }),
    );
  });

  it('renders different message types correctly', async () => {
    modelStore.context = new LlamaContext({
      contextId: 1,
      gpu: false,
      reasonNoGPU: '',
      model: mockContextModel,
    });
    jest
      .spyOn(chatSessionStore, 'currentSessionMessages', 'get')
      .mockReturnValue([
        {
          id: 'unique-message-id-1',
          author: {id: 'y9d7f8pgn'},
          text: 'User message',
          type: 'text',
        },
        {
          id: 'unique-message-id-2',
          author: {id: 'h3o3lc5xj'},
          text: 'Assistant message',
          type: 'text',
        },
        {
          id: 'unique-message-id-3',
          author: {id: 'system'},
          text: 'System message',
          type: 'text',
        },
      ]);

    const {getByText} = render(<ChatScreen />, {
      withNavigation: true,
    });

    expect(getByText('User message')).toBeTruthy();
    expect(getByText('Assistant message')).toBeTruthy();
    expect(getByText('System message')).toBeTruthy();
  });

  it('stops ongoing completion when stop button is pressed', async () => {
    modelStore.context = new llamaRN.LlamaContext({
      contextId: 1,
      gpu: false,
      reasonNoGPU: '',
      model: {},
    });
    if (modelStore.context) {
      modelStore.context.completion = jest
        .fn()
        .mockReturnValue(new Promise(() => {})); // Never resolves
    }

    const {getByPlaceholderText, getByTestId} = render(<ChatScreen />, {
      withNavigation: true,
    });
    const input = getByPlaceholderText(l10n.en.chat.typeYourMessage);

    await act(async () => {
      fireEvent.changeText(input, 'Hello, AI!');
    });

    await act(async () => {
      const sendButton = getByTestId('send-button');
      fireEvent.press(sendButton);
      modelStore.setInferencing(true); // since mock doesn't really set inferencing
    });

    await waitFor(
      () => {
        expect(getByTestId('stop-button')).toBeTruthy();
      },
      {
        timeout: 1000,
      },
    );

    const stopButton = getByTestId('stop-button');
    await act(async () => {
      fireEvent.press(stopButton);
    });

    expect(modelStore.context?.stopCompletion).toHaveBeenCalled();
  });
});



================================================
FILE: src/screens/ChatScreen/ModelNotLoadedMessage/index.ts
================================================
export * from './ModelNotLoadedMessage';



================================================
FILE: src/screens/ChatScreen/ModelNotLoadedMessage/ModelNotLoadedMessage.tsx
================================================
import React, {useState, useEffect} from 'react';
import {View} from 'react-native';

import {Snackbar} from 'react-native-paper';
import {useNavigation} from '@react-navigation/native';
import {DrawerNavigationProp} from '@react-navigation/drawer';

import {useTheme} from '../../../hooks';

import {styles} from './styles';

import {modelStore} from '../../../store';

import {L10nContext} from '../../../utils';
import {Model, RootDrawerParamList} from '../../../utils/types';

type ModelNotLoadedScreenNavigationProp =
  DrawerNavigationProp<RootDrawerParamList>;

export const ModelNotLoadedMessage: React.FC = () => {
  const l10n = React.useContext(L10nContext);
  const navigation = useNavigation<ModelNotLoadedScreenNavigationProp>();
  const [lastUsedModel, setLastUsedModel] = useState<Model | undefined>(
    undefined,
  );

  useEffect(() => {
    const model = modelStore.lastUsedModel;
    setLastUsedModel(model);
  }, []); // Runs on mount to check if the model is available

  const theme = useTheme();

  const loadModelDirectly = () => {
    if (lastUsedModel) {
      modelStore
        .initContext(lastUsedModel)
        .then(() => {
          console.log('initialized');
        })
        .catch(e => {
          console.log(`Error: ${e}`);
        });
    }
  };

  const navigateToModelsPage = () => {
    navigation.navigate('Models');
  };

  const onDismiss = () => {
    // TODO: Handle dismiss logic
  };

  return (
    <View style={styles.container}>
      <Snackbar
        visible={true}
        onDismiss={onDismiss}
        action={{
          label: lastUsedModel ? l10n.chat.load : l10n.chat.goToModels,
          onPress: lastUsedModel ? loadModelDirectly : navigateToModelsPage,
          labelStyle: {color: theme.colors.inverseSecondary},
        }}>
        {lastUsedModel ? l10n.chat.readyToChat : l10n.chat.pleaseLoadModel}
      </Snackbar>
    </View>
  );
};



================================================
FILE: src/screens/ChatScreen/ModelNotLoadedMessage/styles.ts
================================================
import {StyleSheet} from 'react-native';

export const styles = StyleSheet.create({
  container: {
    minHeight: 85, // Ensure minimum height. This is used to set the paddingBottoms in the chat view.
    backgroundColor: 'transparent',
  },
});



================================================
FILE: src/screens/ChatScreen/ModelNotLoadedMessage/__tests__/ModelNotLoadedMessage.test.tsx
================================================
import React from 'react';

import {createDrawerNavigator} from '@react-navigation/drawer';
import {render, fireEvent, act} from '../../../../../jest/test-utils';

import {ModelNotLoadedMessage} from '../ModelNotLoadedMessage';

import {modelStore} from '../../../../store';

import {l10n} from '../../../../utils/l10n';
import {basicModel, modelsList} from '../../../../../jest/fixtures/models';

const Drawer = createDrawerNavigator();
const mockNavigate = jest.fn();

//jest.useFakeTimers();

jest.mock('@react-navigation/native', () => {
  const actualNav = jest.requireActual('@react-navigation/native');
  return {
    ...actualNav,
    useNavigation: () => ({
      navigate: mockNavigate,
    }),
  };
});

const customRender = (ui, {...renderOptions} = {}) => {
  return render(
    <Drawer.Navigator useLegacyImplementation={false}>
      <Drawer.Screen name="Test" component={() => ui} />
    </Drawer.Navigator>,
    {...renderOptions, withNavigation: true},
  );
};

describe('ModelNotLoadedMessage', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    modelStore.models = modelsList;
    modelStore.lastUsedModelId = undefined;
    (modelStore.initContext as jest.Mock).mockReset();
  });

  it('renders correctly when no last used model exists', () => {
    const {getByText} = customRender(<ModelNotLoadedMessage />);
    expect(getByText(l10n.en.chat.pleaseLoadModel)).toBeTruthy();
  });

  it('renders correctly when last used model exists', () => {
    modelStore.lastUsedModelId = modelStore.models[0].id;
    const {getByText} = customRender(<ModelNotLoadedMessage />);

    expect(getByText(l10n.en.chat.readyToChat)).toBeTruthy();
    expect(getByText(l10n.en.chat.load)).toBeTruthy();
  });

  it('navigates to Models page when no last model exists', () => {
    const {getByText} = customRender(<ModelNotLoadedMessage />);

    fireEvent.press(getByText(l10n.en.chat.goToModels));

    expect(mockNavigate).toHaveBeenCalledWith('Models');
  });

  it('loads last used model when available', async () => {
    modelStore.lastUsedModelId = basicModel.id;
    (modelStore.initContext as jest.Mock).mockResolvedValue(undefined);

    const {getByText} = customRender(<ModelNotLoadedMessage />);

    await act(async () => {
      fireEvent.press(getByText(l10n.en.chat.load));
    });

    expect(modelStore.initContext).toHaveBeenCalledWith(basicModel);
  });

  it('handles model loading error correctly', async () => {
    modelStore.lastUsedModelId = basicModel.id;

    const mockError = new Error('Failed to load model');
    (modelStore.initContext as jest.Mock).mockRejectedValue(mockError);

    // TODO: is there a better way to test this that relying on console.log?
    const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

    const {getByText} = customRender(<ModelNotLoadedMessage />);

    await act(async () => {
      fireEvent.press(getByText(l10n.en.chat.load));
    });

    expect(modelStore.initContext).toHaveBeenCalledWith(basicModel);
    expect(consoleSpy).toHaveBeenCalledWith(`Error: ${mockError}`);

    consoleSpy.mockRestore();
  });

  it('updates last used model state on mount', async () => {
    modelStore.lastUsedModelId = basicModel.id;

    const {getByText} = customRender(<ModelNotLoadedMessage />);

    await act(async () => {
      await new Promise(resolve => setTimeout(resolve, 0));
    });

    expect(getByText(l10n.en.chat.readyToChat)).toBeTruthy();
  });
});



================================================
FILE: src/screens/DevToolsScreen/DevToolsScreen.tsx
================================================
import React from 'react';
import {View, ScrollView, Alert} from 'react-native';
import {SafeAreaView} from 'react-native-safe-area-context';
import {Card, Text, Button, IconButton} from 'react-native-paper';
import {createStackNavigator} from '@react-navigation/stack';
import {useNavigation, ParamListBase} from '@react-navigation/native';
import {DrawerNavigationProp} from '@react-navigation/drawer';

import {useTheme} from '../../hooks';
import {createStyles} from './styles';
import {chatSessionRepository} from '../../repositories/ChatSessionRepository';
import {TestCompletionScreen, DatabaseInspectorScreen} from './screens';

// Define the stack navigator param list
type DevToolsStackParamList = {
  DevToolsHome: undefined;
  TestCompletion: undefined;
  DatabaseInspector: undefined;
};

const Stack = createStackNavigator<DevToolsStackParamList>();

// Define the navigation type
type DevToolsScreenNavigationProp = DrawerNavigationProp<ParamListBase>;

// Header button components
const BackButton = ({
  canGoBack,
  onPress,
  navigation,
}: {
  canGoBack?: boolean;
  onPress?: () => void;
  navigation: DevToolsScreenNavigationProp;
}) => (
  <IconButton
    icon="arrow-left"
    onPress={() => {
      if (canGoBack && onPress) {
        onPress();
      } else {
        navigation.goBack();
      }
    }}
  />
);

const MenuButton = ({
  navigation,
}: {
  navigation: DevToolsScreenNavigationProp;
}) => <IconButton icon="menu" onPress={() => navigation.openDrawer()} />;

// Main DevTools Home Screen
const DevToolsHomeScreen: React.FC = () => {
  const navigation = useNavigation();
  const theme = useTheme();
  const styles = createStyles(theme);

  const resetMigration = async () => {
    try {
      await chatSessionRepository.resetMigration();
      Alert.alert(
        'Success',
        'Migration reset successful. Please restart the app.',
      );
    } catch (error) {
      console.error('Failed to reset migration:', error);
      Alert.alert(
        'Error',
        'Failed to reset migration: ' + (error as Error).message,
      );
    }
  };

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <ScrollView style={styles.scrollView}>
        <Card elevation={1} style={styles.card}>
          <Card.Title title="Developer Tools" />
          <Card.Content>
            <Text variant="bodyMedium" style={styles.description}>
              These tools are for development and debugging purposes only. They
              will not be available in the release version of the app.
            </Text>
          </Card.Content>
        </Card>

        {/* Test Completion Card */}
        <Card elevation={1} style={styles.card}>
          <Card.Title title="Test Completion" />
          <Card.Content>
            <Text variant="bodyMedium" style={styles.description}>
              Test the completion API with various parameters and see the
              results. Useful for debugging model behavior and testing different
              completion settings.
            </Text>
            <View style={styles.buttonContainer}>
              <Button
                mode="contained"
                onPress={() => navigation.navigate('TestCompletion' as never)}
                style={styles.button}>
                Open Test Completion
              </Button>
            </View>
          </Card.Content>
        </Card>

        {/* Database Inspector Card */}
        <Card elevation={1} style={styles.card}>
          <Card.Title title="Database Inspector" />
          <Card.Content>
            <Text variant="bodyMedium" style={styles.description}>
              View and inspect the contents of the database tables. Useful for
              debugging data persistence issues and verifying database
              structure.
            </Text>
            <View style={styles.buttonContainer}>
              <Button
                mode="contained"
                onPress={() =>
                  navigation.navigate('DatabaseInspector' as never)
                }
                style={styles.button}>
                Open Database Inspector
              </Button>
            </View>
          </Card.Content>
        </Card>

        {/* Database Migration Card */}
        <Card elevation={1} style={styles.card}>
          <Card.Title title="Database Migration" />
          <Card.Content>
            <Text variant="bodyMedium" style={styles.description}>
              Reset the database migration flag and clear the database. This is
              useful for testing the migration process from JSON to database
              storage.
            </Text>
            <Text variant="bodyMedium" style={styles.warningText}>
              Warning: This will delete all data in the database!
            </Text>
            <View style={styles.buttonContainer}>
              <Button
                mode="contained"
                onPress={() => {
                  Alert.alert(
                    'Reset Database Migration',
                    'This will delete all data in the database. Are you sure you want to continue?',
                    [
                      {
                        text: 'Cancel',
                        style: 'cancel',
                      },
                      {
                        text: 'Reset',
                        style: 'destructive',
                        onPress: resetMigration,
                      },
                    ],
                  );
                }}
                style={styles.button}>
                Reset Migration
              </Button>
            </View>
          </Card.Content>
        </Card>
      </ScrollView>
    </SafeAreaView>
  );
};

// Stack Navigator for DevTools
export const DevToolsScreen: React.FC = () => {
  const theme = useTheme();
  const drawerNavigation = useNavigation<DevToolsScreenNavigationProp>();

  // Create header options
  const screenOptions = {
    headerStyle: {
      backgroundColor: theme.colors.background,
    },
    headerTintColor: theme.colors.onBackground,
    headerLeft: (props: any) => (
      <BackButton
        navigation={drawerNavigation}
        canGoBack={props.canGoBack}
        onPress={props.onPress}
      />
    ),
  };

  // Create home screen options
  const homeScreenOptions = {
    title: 'Dev Tools',
    headerLeft: () => <MenuButton navigation={drawerNavigation} />,
  };

  return (
    <Stack.Navigator
      initialRouteName="DevToolsHome"
      screenOptions={screenOptions}>
      <Stack.Screen
        name="DevToolsHome"
        component={DevToolsHomeScreen}
        options={homeScreenOptions}
      />
      <Stack.Screen
        name="TestCompletion"
        component={TestCompletionScreen}
        options={{
          title: 'Test Completion',
        }}
      />
      <Stack.Screen
        name="DatabaseInspector"
        component={DatabaseInspectorScreen}
        options={{
          title: 'Database Inspector',
        }}
      />
    </Stack.Navigator>
  );
};



================================================
FILE: src/screens/DevToolsScreen/index.ts
================================================
export * from './DevToolsScreen';



================================================
FILE: src/screens/DevToolsScreen/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {Theme} from '../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollView: {
      flex: 1,
    },
    card: {
      marginHorizontal: 16,
      marginVertical: 8,
      backgroundColor: theme.colors.surface,
    },
    title: {
      marginBottom: 16,
      color: theme.colors.onSurface,
    },
    description: {
      marginBottom: 16,
      color: theme.colors.onSurfaceVariant,
    },
    buttonContainer: {
      marginTop: 8,
      flexDirection: 'row',
      justifyContent: 'flex-end',
    },
    button: {
      marginLeft: 8,
    },
    divider: {
      marginVertical: 16,
    },
    warningText: {
      color: theme.colors.error,
      marginBottom: 16,
    },
  });



================================================
FILE: src/screens/DevToolsScreen/screens/index.ts
================================================
export * from './TestCompletionScreen';
export {default as DatabaseInspectorScreen} from './DatabaseInspectorScreen';



================================================
FILE: src/screens/DevToolsScreen/screens/DatabaseInspectorScreen/DatabaseInspectorScreen.tsx
================================================
import React, {useEffect, useState} from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  SafeAreaView,
  Alert,
} from 'react-native';
import {Card, Button} from 'react-native-paper';
import {database} from '../../../../database';
import {chatSessionRepository} from '../../../../repositories/ChatSessionRepository';
import {useNavigation} from '@react-navigation/native';

// Define the collections we want to inspect
const COLLECTIONS = [
  'chat_sessions',
  'messages',
  'completion_settings',
  'global_settings',
];

const DatabaseInspectorScreen = () => {
  const navigation = useNavigation();
  const [collectionData, setCollectionData] = useState<{
    [key: string]: Array<any>;
  }>({});
  const [selectedCollection, setSelectedCollection] = useState<string | null>(
    null,
  );
  const [selectedRecord, setSelectedRecord] = useState<any | null>(null);

  // Load data for all collections
  const loadAllCollections = async () => {
    const data: {[key: string]: Array<any>} = {};

    for (const collectionName of COLLECTIONS) {
      try {
        const records = await database.collections
          .get(collectionName)
          .query()
          .fetch();

        data[collectionName] = records.map(record => ({
          ...record._raw,
        }));
      } catch (error) {
        console.error(`Error fetching ${collectionName}:`, error);
        data[collectionName] = [];
      }
    }

    setCollectionData(data);
  };

  useEffect(() => {
    loadAllCollections();
  }, []);

  const resetMigration = async () => {
    try {
      await chatSessionRepository.resetMigration();
      Alert.alert('Migration reset successful', 'Please restart the app.');
    } catch (error) {
      console.error('Failed to reset migration:', error);
      Alert.alert(
        'Failed to reset migration',
        error instanceof Error ? error.message : 'Unknown error occurred',
      );
    }
  };

  const renderCollectionList = () => {
    return (
      <Card style={styles.card}>
        <Card.Title title="Database Collections" />
        <Card.Content>
          {COLLECTIONS.map(collectionName => (
            <TouchableOpacity
              key={collectionName}
              style={styles.collectionItem}
              onPress={() => setSelectedCollection(collectionName)}>
              <Text style={styles.collectionName}>{collectionName}</Text>
              <Text style={styles.recordCount}>
                {collectionData[collectionName]?.length || 0} records
              </Text>
            </TouchableOpacity>
          ))}
        </Card.Content>
        <Card.Actions>
          <Button onPress={loadAllCollections}>Refresh</Button>
          <Button onPress={resetMigration}>Reset Migration</Button>
        </Card.Actions>
      </Card>
    );
  };

  const renderRecordList = () => {
    if (!selectedCollection) {
      return null;
    }

    const records = collectionData[selectedCollection] || [];

    return (
      <Card style={styles.card}>
        <Card.Title
          title={`${selectedCollection} (${records.length})`}
          subtitle="Tap a record to view details"
        />
        <Card.Content>
          <ScrollView style={styles.recordList}>
            {records.length === 0 ? (
              <Text style={styles.emptyText}>No records found</Text>
            ) : (
              records.map(record => (
                <TouchableOpacity
                  key={record.id}
                  style={styles.recordItem}
                  onPress={() => setSelectedRecord(record)}>
                  <Text style={styles.recordId}>{record.id}</Text>
                  {record.title && (
                    <Text style={styles.recordTitle}>{record.title}</Text>
                  )}
                  {record.session_id && (
                    <Text style={styles.recordSessionId}>
                      Session: {record.session_id}
                    </Text>
                  )}
                </TouchableOpacity>
              ))
            )}
          </ScrollView>
        </Card.Content>
        <Card.Actions>
          <Button onPress={() => setSelectedCollection(null)}>Back</Button>
        </Card.Actions>
      </Card>
    );
  };

  // Find related records for a given record
  const findRelatedRecords = (record: any, collection: string) => {
    const relatedRecords: {[key: string]: any[]} = {};

    // If this is a chat_session, find related messages and completion_settings
    if (collection === 'chat_sessions') {
      const sessionId = record.id;
      const messages = (collectionData.messages || []).filter(
        msg => msg.session_id === sessionId,
      );
      const settings = (collectionData.completion_settings || []).filter(
        setting => setting.session_id === sessionId,
      );

      if (messages.length > 0) {
        relatedRecords.messages = messages;
      }

      if (settings.length > 0) {
        relatedRecords.completion_settings = settings;
      }
    }

    // If this is a message, find related chat_session
    if (collection === 'messages' && record.session_id) {
      const session = (collectionData.chat_sessions || []).find(
        s => s.id === record.session_id,
      );

      if (session) {
        relatedRecords.chat_sessions = [session];
      }
    }

    // If this is a completion_setting, find related chat_session
    if (collection === 'completion_settings' && record.session_id) {
      const session = (collectionData.chat_sessions || []).find(
        s => s.id === record.session_id,
      );

      if (session) {
        relatedRecords.chat_sessions = [session];
      }
    }

    return relatedRecords;
  };

  const renderRecordDetails = () => {
    if (!selectedRecord) {
      return null;
    }

    // Find the current record index and collection
    const records = collectionData[selectedCollection || ''] || [];
    const currentIndex = records.findIndex(
      record => record.id === selectedRecord.id,
    );

    // Determine if there are previous/next records
    const hasPrevious = currentIndex > 0;
    const hasNext = currentIndex < records.length - 1;

    // Find related records
    const relatedRecords = findRelatedRecords(
      selectedRecord,
      selectedCollection || '',
    );

    return (
      <Card style={styles.card}>
        <Card.Title
          title="Record Details"
          subtitle={`${selectedCollection} (${currentIndex + 1}/${
            records.length
          })`}
        />
        <Card.Content>
          <ScrollView style={styles.recordDetails}>
            {Object.entries(selectedRecord).map(([key, value]) => (
              <View key={key} style={styles.detailItem}>
                <Text style={styles.detailKey}>{key}:</Text>
                <Text style={styles.detailValue}>
                  {typeof value === 'object'
                    ? JSON.stringify(value, null, 2)
                    : String(value)}
                </Text>
              </View>
            ))}

            {/* Related Records Section */}
            {Object.keys(relatedRecords).length > 0 && (
              <View style={styles.relatedRecordsSection}>
                <Text style={styles.relatedRecordsTitle}>Related Records:</Text>
                {Object.entries(relatedRecords).map(
                  ([collection, relatedItems]) => (
                    <View key={collection} style={styles.relatedCollection}>
                      <Text style={styles.relatedCollectionTitle}>
                        {collection} ({relatedItems.length})
                      </Text>
                      {relatedItems.map(record => (
                        <TouchableOpacity
                          key={record.id}
                          style={styles.relatedRecord}
                          onPress={() => {
                            setSelectedCollection(collection);
                            setSelectedRecord(record);
                          }}>
                          <Text style={styles.relatedRecordId}>
                            {record.id}
                          </Text>
                          {record.title && (
                            <Text style={styles.relatedRecordTitle}>
                              {record.title}
                            </Text>
                          )}
                        </TouchableOpacity>
                      ))}
                    </View>
                  ),
                )}
              </View>
            )}
          </ScrollView>
        </Card.Content>
        <Card.Actions style={styles.cardActions}>
          <Button onPress={() => setSelectedRecord(null)} mode="outlined">
            Back
          </Button>
          <View style={styles.navigationButtons}>
            <Button
              onPress={() => setSelectedRecord(records[currentIndex - 1])}
              disabled={!hasPrevious}
              mode="text"
              icon="chevron-left">
              Prev
            </Button>
            <Button
              onPress={() => setSelectedRecord(records[currentIndex + 1])}
              disabled={!hasNext}
              mode="text"
              icon="chevron-right"
              contentStyle={styles.next}>
              Next
            </Button>
          </View>
        </Card.Actions>
      </Card>
    );
  };

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.headerTitle}>Database Inspector</Text>
        <TouchableOpacity
          style={styles.closeButton}
          onPress={() => navigation.goBack()}>
          <Text style={styles.closeButtonText}>Close</Text>
        </TouchableOpacity>
      </View>
      <ScrollView style={styles.content}>
        {selectedRecord
          ? renderRecordDetails()
          : selectedCollection
          ? renderRecordList()
          : renderCollectionList()}
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    backgroundColor: '#2c3e50',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: 'white',
  },
  closeButton: {
    padding: 8,
  },
  closeButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
  content: {
    flex: 1,
    padding: 16,
  },
  card: {
    marginBottom: 16,
  },
  collectionItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  collectionName: {
    fontSize: 16,
    fontWeight: '500',
  },
  recordCount: {
    color: '#666',
  },
  recordList: {
    maxHeight: 400,
  },
  recordItem: {
    padding: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  recordId: {
    fontSize: 14,
    color: '#666',
    marginBottom: 4,
  },
  recordTitle: {
    fontSize: 16,
    fontWeight: '500',
  },
  recordSessionId: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
  },
  emptyText: {
    textAlign: 'center',
    padding: 20,
    color: '#666',
  },
  recordDetails: {
    maxHeight: 500,
  },
  detailItem: {
    marginBottom: 8,
  },
  detailKey: {
    fontSize: 14,
    fontWeight: '500',
    color: '#333',
  },
  detailValue: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
  cardActions: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  navigationButtons: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  relatedRecordsSection: {
    marginTop: 20,
    borderTopWidth: 1,
    borderTopColor: '#e0e0e0',
    paddingTop: 12,
  },
  relatedRecordsTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 8,
    color: '#333',
  },
  relatedCollection: {
    marginBottom: 12,
  },
  relatedCollectionTitle: {
    fontSize: 14,
    fontWeight: '500',
    color: '#666',
    marginBottom: 4,
  },
  relatedRecord: {
    backgroundColor: '#f0f0f0',
    padding: 8,
    borderRadius: 4,
    marginBottom: 4,
    marginLeft: 8,
  },
  relatedRecordId: {
    fontSize: 12,
    color: '#888',
  },
  relatedRecordTitle: {
    fontSize: 13,
    fontWeight: '500',
  },
  next: {
    flexDirection: 'row-reverse',
  },
});

export default DatabaseInspectorScreen;



================================================
FILE: src/screens/DevToolsScreen/screens/DatabaseInspectorScreen/index.ts
================================================
export {default} from './DatabaseInspectorScreen';



================================================
FILE: src/screens/DevToolsScreen/screens/TestCompletionScreen/index.ts
================================================
export * from './TestCompletionScreen';



================================================
FILE: src/screens/DevToolsScreen/screens/TestCompletionScreen/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {Theme} from '../../../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollView: {
      flex: 1,
    },
    card: {
      margin: 16,
      backgroundColor: theme.colors.surface,
    },
    title: {
      marginBottom: 16,
      textAlign: 'center',
    },
    modelSelectorContent: {
      width: '100%',
      justifyContent: 'flex-start',
      marginBottom: 16,
    },
    loadingContainer: {
      alignItems: 'center',
      justifyContent: 'center',
      padding: 20,
    },
    loadingText: {
      marginTop: 10,
      color: theme.colors.onSurfaceVariant,
    },
    warning: {
      color: theme.colors.error,
      textAlign: 'center',
      marginVertical: 20,
    },
    testButtonsContainer: {
      marginVertical: 16,
    },
    testRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      marginBottom: 8,
    },
    testButton: {
      flex: 1,
      marginHorizontal: 4,
    },
    resultsContainer: {
      marginTop: 16,
    },
    resultCard: {
      marginBottom: 16,
    },
    resultText: {
      fontFamily: 'monospace',
      fontSize: 14,
      lineHeight: 20,
    },
    streamingText: {
      fontFamily: 'monospace',
      fontSize: 14,
      lineHeight: 20,
      marginTop: 10,
    },
    errorText: {
      color: theme.colors.error,
      fontFamily: 'monospace',
      fontSize: 14,
    },
    divider: {
      marginVertical: 12,
    },
    sectionTitle: {
      fontWeight: 'bold',
      marginBottom: 8,
    },
    codeBlock: {
      fontFamily: 'monospace',
      fontSize: 12,
      backgroundColor: theme.colors.surfaceVariant,
      padding: 8,
      borderRadius: 4,
    },
    testOptionsContainer: {
      marginVertical: 12,
      padding: 8,
      backgroundColor: theme.colors.surfaceVariant,
      borderRadius: 8,
    },
    optionLabel: {
      marginBottom: 8,
      fontWeight: 'bold',
    },
    jinjaOption: {
      marginTop: 12,
    },
  });



================================================
FILE: src/screens/DevToolsScreen/screens/TestCompletionScreen/TestCompletionScreen.tsx
================================================
/* eslint-disable no-useless-escape */
import React, {useState} from 'react';
import {View, ScrollView} from 'react-native';

import {observer} from 'mobx-react';
import {JinjaFormattedChatResult} from '@pocketpalai/llama.rn';
import {CompletionParams} from '../../../../utils/completionTypes';
import Clipboard from '@react-native-clipboard/clipboard';
import {SafeAreaView} from 'react-native-safe-area-context';
import {
  Text,
  Button,
  Card,
  ActivityIndicator,
  Divider,
  IconButton,
  SegmentedButtons,
} from 'react-native-paper';

import {Menu} from '../../../../components';

import {useTheme} from '../../../../hooks';

import {createStyles} from './styles';

import {modelStore} from '../../../../store';

import {Model, ChatMessage} from '../../../../utils/types';

// JSON Schema to GBNF example
const JSON_SCHEMA_EXAMPLE = `
{
  "type": "object",
  "properties": {
    "name": { "type": "string" },
    "age": { "type": "number" },
    "isActive": { "type": "boolean" },
    "tags": {
      "type": "array",
      "items": { "type": "string" }
    }
  },
  "required": ["name", "age"]
}`;

// GBNF grammar for JSON
const JSON_GBNF = `
root   ::= object
value  ::= object | array | string | number | ("true" | "false" | "null") ws

object ::=
  "{" ws (
            string ":" ws value
    ("," ws string ":" ws value)*
  )? "}" ws

array  ::=
  "[" ws (
            value
    ("," ws value)*
  )? "]" ws

string ::=
  "\"" (
    [^"\\\x7F\x00-\x1F] |
    "\\" (["\\\\bfnrt] | "u" [0-9a-fA-F]{4}) # escapes
  )* "\"" ws

number ::= ("-"? ([0-9] | [1-9] [0-9]{0,15})) ("." [0-9]+)? ([eE] [-+]? [0-9] [1-9]{0,15})? ws

# Optional space: by convention, applied in this grammar after literal chars when allowed
ws ::= | " " | "\\n" [ \\t]{0,20}
`;

// Tool definition for tool calling test
const TOOLS = [
  {
    type: 'function',
    function: {
      name: 'get_weather',
      description: 'Get the current weather in a given location',
      parameters: {
        type: 'object',
        properties: {
          location: {
            type: 'string',
            description: 'The city and state, e.g. San Francisco, CA',
          },
          unit: {
            type: 'string',
            enum: ['celsius', 'fahrenheit'],
            description: 'The temperature unit to use',
          },
        },
        required: ['location'],
      },
    },
  },
];

// Sample chat messages for testing
const SAMPLE_CHAT_MESSAGES: ChatMessage[] = [
  {
    role: 'system',
    content: 'You are a helpful assistant that provides concise responses.',
  },
  {
    role: 'user',
    content: 'Hello! Tell me a short joke.',
  },
];

export const TestCompletionScreen: React.FC = observer(() => {
  const [showModelMenu, setShowModelMenu] = useState(false);
  const [selectedModel, setSelectedModel] = useState<Model | null>(null);
  const [isRunning, setIsRunning] = useState(false);
  const [currentTest, setCurrentTest] = useState<string | null>(null);
  const [results, setResults] = useState<{
    [key: string]: {
      text: string;
      formattedPrompt?: string;
      rawResult?: any;
      timings?: any;
      toolCalls?: any;
      error?: string;
    };
  }>({});
  const [tokenBuffer, setTokenBuffer] = useState('');
  const [textCompletionMethod, setTextCompletionMethod] = useState('direct');
  const [useJinja, setUseJinja] = useState(false);
  const [formattedChatDetails, setFormattedChatDetails] = useState<{
    prompt?: string;
    format?: number;
    grammar?: string;
    grammar_lazy?: boolean;
    grammar_triggers?: any[];
    preserved_tokens?: string[];
    additional_stops?: string[];
  } | null>(null);

  const theme = useTheme();
  const styles = createStyles(theme);

  // Common stop words for all tests
  const stopWords = [
    '</s>',
    // '<|end|>',
    '<|eot_id|>',
    '<|end_of_text|>',
    '<|im_end|>',
    '<|EOT|>',
    '<|END_OF_TURN_TOKEN|>',
    '<|end_of_turn|>',
    '<|endoftext|>',
    '<|return|>',
  ];

  const handleModelSelect = async (model: Model) => {
    setShowModelMenu(false);
    if (model.id !== modelStore.activeModelId) {
      try {
        await modelStore.initContext(model);
        setSelectedModel(model);
      } catch (error) {
        console.error('Model initialization error:', error);
      }
    } else {
      setSelectedModel(model);
    }
  };

  const copyToClipboard = (text: string) => {
    Clipboard.setString(text);
  };

  /**
   * Tests the chat completion API using messages format
   *
   * Expected behavior:
   * - Takes an array of messages in the OpenAI format (system, user, assistant)
   * - The model should respond as if continuing the conversation
   * - Results should show the generated text and timing information
   * - Tokens should stream in real-time during generation
   */
  const runChatCompletionTest = async () => {
    if (!modelStore.context) {
      return;
    }
    console.log('------------- runChatCompletionTest -------------');

    setIsRunning(true);
    setCurrentTest('chatCompletion');
    setTokenBuffer('');

    try {
      const completionParams: CompletionParams = {
        messages: [
          {
            role: 'system',
            content:
              'This is a conversation between user and assistant, a friendly chatbot.',
          },
          {
            role: 'user',
            content: 'Hello! Tell me a short joke.',
          },
        ],
        n_predict: 100,
        stop: stopWords,
      };

      const result = await modelStore.context.completion(
        completionParams,
        data => {
          if (data.token) {
            setTokenBuffer(prev => prev + data.token);
          }
        },
      );

      setResults(prev => ({
        ...prev,
        chatCompletion: {
          text: result.text,
          timings: result.timings,
        },
      }));
    } catch (error) {
      setResults(prev => ({
        ...prev,
        chatCompletion: {
          text: '',
          error: error instanceof Error ? error.message : 'Unknown error',
        },
      }));
    } finally {
      setIsRunning(false);
      setCurrentTest(null);
    }
  };

  /**
   * Tests text completion with a direct prompt string
   *
   * Expected behavior:
   * - Takes a raw text prompt without using the chat template
   * - The model should continue the text from where the prompt ends
   * - Results should show the generated text, the original prompt, and timing information
   * - Custom stop words (Llama:, User:) should prevent the model from generating new turns
   */
  const runTextCompletionDirectTest = async () => {
    if (!modelStore.context) {
      return;
    }
    console.log('------------- runTextCompletionDirectTest -------------');

    setIsRunning(true);
    setCurrentTest('textCompletion');
    setTokenBuffer('');

    try {
      const completionParams: CompletionParams = {
        prompt:
          'This is a conversation between user and llama, a friendly chatbot. respond in simple markdown.\n\nUser: Hello! Tell me a short joke.\nLlama:',
        n_predict: 100,
        stop: [...stopWords, 'Llama:', 'User:'],
      };

      const result = await modelStore.context.completion(
        completionParams,
        data => {
          if (data.token) {
            setTokenBuffer(prev => prev + data.token);
          }
        },
      );

      setResults(prev => ({
        ...prev,
        textCompletion: {
          text: result.text,
          formattedPrompt: completionParams.prompt,
          timings: result.timings,
        },
      }));
    } catch (error) {
      setResults(prev => ({
        ...prev,
        textCompletion: {
          text: '',
          error: error instanceof Error ? error.message : 'Unknown error',
        },
      }));
    } finally {
      setIsRunning(false);
      setCurrentTest(null);
    }
  };

  /**
   * Tests text completion using the formatted chat approach
   *
   * Expected behavior:
   * - Converts chat messages to a formatted prompt using getFormattedChat
   * - With Jinja disabled: Uses the model's built-in chat template
   * - With Jinja enabled: Uses the Jinja template parser for more advanced formatting
   * - Results should show the generated text, formatted prompt, and detailed formatting information
   * - Demonstrates how chat messages are converted to prompts behind the scenes
   */
  const runTextCompletionFormattedTest = async () => {
    if (!modelStore.context) {
      return;
    }
    console.log('------------- runTextCompletionFormattedTest -------------');

    setIsRunning(true);
    setCurrentTest('textCompletion');
    setTokenBuffer('');

    try {
      // Get formatted chat using context's getFormattedChat
      let formattedChat: string | JinjaFormattedChatResult;

      formattedChat = await modelStore.context.getFormattedChat(
        SAMPLE_CHAT_MESSAGES,
        null, // Use default template
        {
          jinja: useJinja,
        },
      );

      // Store formatted chat details for display
      if (typeof formattedChat !== 'string') {
        setFormattedChatDetails({
          prompt: formattedChat.prompt,
          format: formattedChat.chat_format,
          grammar: formattedChat.grammar,
          grammar_lazy: formattedChat.grammar_lazy,
          grammar_triggers: formattedChat.grammar_triggers,
          preserved_tokens: formattedChat.preserved_tokens,
          additional_stops: formattedChat.additional_stops,
        });
      } else {
        setFormattedChatDetails({
          prompt: formattedChat,
        });
      }

      const prompt =
        typeof formattedChat === 'string'
          ? formattedChat
          : formattedChat.prompt;

      const completionParams: CompletionParams = {
        prompt,
        n_predict: 100,
        stop: stopWords,
      };

      const result = await modelStore.context.completion(
        completionParams,
        data => {
          if (data.token) {
            setTokenBuffer(prev => prev + data.token);
          }
        },
      );

      setResults(prev => ({
        ...prev,
        textCompletion: {
          text: result.text,
          formattedPrompt: prompt,
          timings: result.timings,
          rawResult: typeof formattedChat !== 'string' ? formattedChat : null,
        },
      }));
    } catch (error) {
      setResults(prev => ({
        ...prev,
        textCompletion: {
          text: '',
          error: error instanceof Error ? error.message : 'Unknown error',
        },
      }));
    } finally {
      setIsRunning(false);
      setCurrentTest(null);
    }
  };

  /**
   * Wrapper function to run the appropriate text completion test based on user selection
   */
  const runTextCompletionTest = async () => {
    console.log('------------- runTextCompletionTest -------------');
    if (textCompletionMethod === 'direct') {
      await runTextCompletionDirectTest();
    } else {
      await runTextCompletionFormattedTest();
    }
  };

  /**
   * Tests the tool calling functionality
   *
   * Expected behavior:
   * - Uses Jinja templates to enable function calling capabilities
   * - The model should recognize the need to call the weather tool based on the query
   * - Results should include both the text response and structured tool_calls data
   * - Tool calls should contain the function name and parameters (location, unit)
   * - Demonstrates how models can generate structured data for API calls
   */
  const runToolCallingTest = async () => {
    console.log('------------- runToolCallingTest -------------');
    if (!modelStore.context) {
      return;
    }

    setIsRunning(true);
    setCurrentTest('toolCalling');
    setTokenBuffer('');

    try {
      const completionParams: CompletionParams = {
        messages: [
          {
            role: 'system',
            content:
              'You are a helpful assistant that can answer questions and help with tasks.',
          },
          {
            role: 'user',
            content: "What's the weather like in San Francisco?",
          },
        ],
        n_predict: 200,
        stop: stopWords,
        jinja: true,
        tool_choice: 'auto',
        tools: TOOLS,
      };

      const result = await modelStore.context.completion(
        completionParams,
        data => {
          if (data.token) {
            setTokenBuffer(prev => prev + data.token);
          }
        },
      );

      setResults(prev => ({
        ...prev,
        toolCalling: {
          text: result.text,
          timings: result.timings,
          toolCalls: result.tool_calls,
        },
      }));
    } catch (error) {
      setResults(prev => ({
        ...prev,
        toolCalling: {
          text: '',
          error: error instanceof Error ? error.message : 'Unknown error',
        },
      }));
    } finally {
      setIsRunning(false);
      setCurrentTest(null);
    }
  };

  /**
   * Tests grammar-constrained generation using GBNF
   *
   * Expected behavior:
   * - Uses a GBNF grammar to constrain the model's output to valid JSON format
   * - The model should generate a properly structured JSON object with name, age, isActive, and tags
   * - Output should be syntactically valid JSON regardless of model's tendencies
   * - Demonstrates how to enforce specific output formats without fine-tuning
   * - Grammar is applied directly in the completion parameters
   */
  const runGrammarSamplingTest = async () => {
    console.log('------------- runGrammarSamplingTest -------------');
    if (!modelStore.context) {
      return;
    }

    setIsRunning(true);
    setCurrentTest('grammarSampling');
    setTokenBuffer('');

    try {
      // Use the existing context and apply grammar in the completion parameters
      const completionParams: CompletionParams = {
        messages: [
          {
            role: 'system',
            content: 'You are a helpful assistant that generates valid JSON.',
          },
          {
            role: 'user',
            content:
              'Generate a JSON object for a person with name, age, isActive status, and an array of tags.',
          },
        ],
        n_predict: 200,
        stop: stopWords,
        grammar: JSON_GBNF, // Grammar is applied here
      };

      const result = await modelStore.context.completion(
        completionParams,
        data => {
          if (data.token) {
            setTokenBuffer(prev => prev + data.token);
          }
        },
      );

      setResults(prev => ({
        ...prev,
        grammarSampling: {
          text: result.text,
          timings: result.timings,
        },
      }));
    } catch (error) {
      setResults(prev => ({
        ...prev,
        grammarSampling: {
          text: '',
          error: error instanceof Error ? error.message : 'Unknown error',
        },
      }));
    } finally {
      setIsRunning(false);
      setCurrentTest(null);
    }
  };

  /**
   * Tests the getFormattedChat function with various parameter combinations
   *
   * Expected behavior:
   * - Runs multiple test cases with different formatting options
   * - Default: Basic chat formatting using the model's built-in template
   * - With Jinja: Enhanced formatting using the Jinja template parser
   * - With JSON Schema: Formatting with JSON schema constraints
   * - With Tools: Formatting with tool definitions for function calling
   * - Results should show how different parameters affect the formatted output
   * - Useful for debugging and understanding the chat formatting process
   */
  const runFormattedChatTest = async () => {
    console.log('------------- runFormattedChatTest -------------');
    if (!modelStore.context) {
      return;
    }

    setIsRunning(true);
    setCurrentTest('formattedChat');
    setTokenBuffer('');

    try {
      // Test with different combinations of parameters
      const testCases = [
        {
          name: 'Default',
          params: {},
        },
        {
          name: 'With Jinja',
          params: {jinja: true},
        },
        {
          name: 'With JSON Schema',
          params: {
            jinja: true,
            response_format: {
              type: 'json_object' as const,
              schema: JSON_SCHEMA_EXAMPLE,
            },
          },
        },
        {
          name: 'With Tools',
          params: {
            jinja: true,
            tools: TOOLS,
            tool_choice: 'auto',
          },
        },
      ];

      const _results: Array<{
        name: string;
        result: string | JinjaFormattedChatResult;
      }> = [];

      for (const testCase of testCases) {
        console.log('testCase', testCase);
        try {
          const formattedChat = await modelStore.context.getFormattedChat(
            SAMPLE_CHAT_MESSAGES,
            null,
            testCase.params as any,
          );

          _results.push({
            name: testCase.name,
            result: formattedChat,
          });
        } catch (error) {
          console.log(`Error in test case "${testCase.name}":`, error);
          _results.push({
            name: testCase.name,
            result: `Error: ${
              error instanceof Error ? error.message : 'Unknown error'
            }`,
          });
        }
      }
      console.log('results', _results);

      setResults(prev => ({
        ...prev,
        formattedChat: {
          text: JSON.stringify(_results, null, 2),
        },
      }));
    } catch (error) {
      console.log('error', error);
      setResults(prev => ({
        ...prev,
        formattedChat: {
          text: '',
          error: error instanceof Error ? error.message : 'Unknown error',
        },
      }));
    } finally {
      setIsRunning(false);
      setCurrentTest(null);
    }
  };

  /**
   * Tests grammar-constrained generation with various trigger configurations
   *
   * Grammar triggers allow for conditional activation of grammar-based sampling:
   * - When grammar_lazy is false: Grammar is applied from the beginning of generation
   * - When grammar_lazy is true: Grammar is only applied after a trigger is detected
   *
   * The four types of triggers are:
   * - TOKEN (0): Activates when an exact token is generated
   * - WORD (1): Activates when a complete word is generated
   * - PATTERN (2): Activates when a pattern appears anywhere in the text
   * - PATTERN_START (3): Activates when a pattern appears at the start of a token
   *
   * This test function helps understand how different trigger configurations affect
   * the model's output when generating JSON. It's particularly useful for:
   * 1. Testing when grammar constraints are activated
   * 2. Comparing the quality of outputs with different trigger strategies
   * 3. Finding the optimal trigger configuration for specific use cases
   *
   * Expected behavior:
   * - Tests different ways to configure grammar triggers
   * - Helps understand how the current implementation handles grammar triggers
   */
  const runGrammarTriggersTest = async () => {
    console.log('------------- runGrammarTriggersTest -------------');
    if (!modelStore.context) {
      return;
    }

    setIsRunning(true);
    setCurrentTest('grammarTriggers');
    setTokenBuffer('');

    try {
      // Test different grammar trigger configurations
      const testCases = [
        {
          name: 'No Triggers (Regular Grammar)',
          params: {
            grammar: JSON_GBNF,
            grammar_lazy: false,
          },
          // This test uses standard grammar-based sampling without lazy loading
          // Expected: The model will strictly follow the JSON grammar from the beginning
          // of generation, producing valid JSON that matches the GBNF grammar
        },
        {
          name: 'Lazy Grammar (No Specific Triggers)',
          params: {
            grammar: JSON_GBNF,
            grammar_lazy: true,
          },
          // This test enables lazy grammar but doesn't specify any triggers
          // Expected: The model will generate text freely until it encounters a pattern
          // that would naturally activate the grammar, then switch to grammar-constrained generation
          // May not produce valid JSON if no natural trigger occurs
        },
        {
          name: 'With at_start=true',
          params: {
            grammar: JSON_GBNF,
            grammar_lazy: true,
            grammar_triggers: [{type: 3, value: 'true', token: 0}], // type 3 = PATTERN_START
          },
          // This test uses PATTERN_START trigger with value 'true'
          // Expected: The grammar will be activated when 'true' appears at the start of a token
          // This should trigger grammar enforcement when the model tries to generate a boolean value
        },
        {
          name: 'With at_start=false',
          params: {
            grammar: JSON_GBNF,
            grammar_lazy: true,
            grammar_triggers: [{type: 2, value: 'false', token: 0}], // type 2 = PATTERN
          },
          // This test uses PATTERN trigger with value 'false'
          // Expected: The grammar will be activated when 'false' appears anywhere in the text
          // This should trigger grammar enforcement when the model generates a boolean value
        },
        {
          name: 'With word trigger',
          params: {
            grammar: JSON_GBNF,
            grammar_lazy: true,
            grammar_triggers: [{type: 1, value: 'json', token: 0}], // type 1 = WORD
            preserved_tokens: ['json'],
          },
          // This test uses WORD trigger with value 'json'
          // Expected: The grammar will be activated when the complete word 'json' appears
          // This might trigger if the model mentions JSON in its response
        },
        {
          name: 'With token trigger',
          params: {
            grammar: JSON_GBNF,
            grammar_lazy: true,
            grammar_triggers: [{type: 0, value: '{', token: 0}], // type 0 = TOKEN
          },
          // This test uses TOKEN trigger with value '{'
          // Expected: The grammar will be activated when the model generates the '{' character
          // This should trigger as soon as the model starts to create a JSON object
        },
      ];

      const _results: Array<{
        name: string;
        text?: string;
        error?: string;
        params: any;
      }> = [];

      for (const testCase of testCases) {
        try {
          console.log(`Testing: ${testCase.name}`);

          const completionParams: CompletionParams = {
            messages: [
              {
                role: 'system',
                content: 'You are a helpful assistant that generates JSON.',
              },
              {
                role: 'user',
                content:
                  'Generate a JSON object for a person with name, age, and isActive status.',
              },
            ],
            n_predict: 150,
            stop: stopWords,
            ...testCase.params,
          };

          const result = await modelStore.context.completion(
            completionParams,
            data => {
              if (data.token) {
                setTokenBuffer(prev => prev + data.token);
              }
            },
          );

          _results.push({
            name: testCase.name,
            text: result.text,
            params: testCase.params,
          });
        } catch (error) {
          _results.push({
            name: testCase.name,
            error: error instanceof Error ? error.message : 'Unknown error',
            params: testCase.params,
          });
        }
      }

      setResults(prev => ({
        ...prev,
        grammarTriggers: {
          text: JSON.stringify(results, null, 2),
        },
      }));
    } catch (error) {
      setResults(prev => ({
        ...prev,
        grammarTriggers: {
          text: '',
          error: error instanceof Error ? error.message : 'Unknown error',
        },
      }));
    } finally {
      setIsRunning(false);
      setCurrentTest(null);
    }
  };

  const renderModelSelector = () => (
    <Menu
      visible={showModelMenu}
      onDismiss={() => setShowModelMenu(false)}
      anchorPosition="bottom"
      selectable
      anchor={
        <Button
          mode="outlined"
          onPress={() => setShowModelMenu(true)}
          contentStyle={styles.modelSelectorContent}>
          {selectedModel?.name ||
            modelStore.activeModel?.name ||
            'Select Model'}
        </Button>
      }>
      {modelStore.availableModels.map(model => (
        <Menu.Item
          key={model.id}
          onPress={() => handleModelSelect(model)}
          label={model.name}
          leadingIcon={
            model.id === modelStore.activeModelId ? 'check' : undefined
          }
        />
      ))}
    </Menu>
  );

  const renderTestButton = (
    testId: string,
    label: string,
    onPress: () => Promise<void>,
    disabled: boolean = false,
  ) => (
    <Button
      mode="contained"
      onPress={onPress}
      disabled={disabled || isRunning}
      style={styles.testButton}>
      {label}
    </Button>
  );

  const renderResultCard = (testId: string, title: string) => {
    const result = results[testId];
    if (!result && currentTest !== testId) {
      return null;
    }

    return (
      <Card style={styles.resultCard}>
        <Card.Title
          title={title}
          right={props =>
            result?.text ? (
              <IconButton
                {...props}
                icon="content-copy"
                onPress={() => copyToClipboard(result.text)}
              />
            ) : null
          }
        />
        <Card.Content>
          {currentTest === testId ? (
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" />
              <Text style={styles.streamingText}>{tokenBuffer}</Text>
            </View>
          ) : result ? (
            <>
              {result.error ? (
                <Text style={styles.errorText}>{result.error}</Text>
              ) : (
                <>
                  {result.formattedPrompt && (
                    <>
                      <Text style={styles.sectionTitle}>Formatted Prompt:</Text>
                      <Text style={styles.codeBlock}>
                        {result.formattedPrompt}
                      </Text>
                      <Divider style={styles.divider} />
                    </>
                  )}

                  <Text style={styles.sectionTitle}>Result:</Text>
                  <Text style={styles.resultText}>{result.text}</Text>

                  {result.rawResult && (
                    <>
                      <Divider style={styles.divider} />
                      <Text style={styles.sectionTitle}>
                        Raw Formatted Chat Result:
                      </Text>
                      <Text style={styles.codeBlock}>
                        {JSON.stringify(result.rawResult, null, 2)}
                      </Text>
                    </>
                  )}

                  {formattedChatDetails &&
                    testId === 'textCompletion' &&
                    textCompletionMethod === 'formatted' && (
                      <>
                        <Divider style={styles.divider} />
                        <Text style={styles.sectionTitle}>
                          Formatted Chat Details:
                        </Text>
                        <Text style={styles.codeBlock}>
                          {JSON.stringify(formattedChatDetails, null, 2)}
                        </Text>
                      </>
                    )}

                  {result.toolCalls && (
                    <>
                      <Divider style={styles.divider} />
                      <Text style={styles.sectionTitle}>Tool Calls:</Text>
                      <Text style={styles.codeBlock}>
                        {JSON.stringify(result.toolCalls, null, 2)}
                      </Text>
                    </>
                  )}

                  {result.timings && (
                    <>
                      <Divider style={styles.divider} />
                      <Text style={styles.sectionTitle}>Timings:</Text>
                      <Text style={styles.codeBlock}>
                        {JSON.stringify(result.timings, null, 2)}
                      </Text>
                    </>
                  )}
                </>
              )}
            </>
          ) : null}
        </Card.Content>
      </Card>
    );
  };

  return (
    <SafeAreaView style={styles.container} edges={['bottom']}>
      <ScrollView style={styles.scrollView}>
        <Card elevation={0} style={styles.card}>
          <Card.Content>
            <Text variant="titleLarge" style={styles.title}>
              Completion Test Suite
            </Text>

            {renderModelSelector()}

            {modelStore.loadingModel ? (
              <View style={styles.loadingContainer}>
                <ActivityIndicator size="large" />
                <Text style={styles.loadingText}>Initializing model...</Text>
              </View>
            ) : (
              <>
                {!modelStore.context ? (
                  <Text style={styles.warning}>
                    Please select and initialize a model first
                  </Text>
                ) : (
                  <View style={styles.testButtonsContainer}>
                    <View style={styles.testRow}>
                      {renderTestButton(
                        'chatCompletion',
                        'Chat Completion',
                        runChatCompletionTest,
                      )}
                      {renderTestButton(
                        'formattedChat',
                        'Formatted Chat Test',
                        runFormattedChatTest,
                      )}
                    </View>

                    <View style={styles.testOptionsContainer}>
                      <Text style={styles.optionLabel}>
                        Text Completion Method:
                      </Text>
                      <SegmentedButtons
                        value={textCompletionMethod}
                        onValueChange={setTextCompletionMethod}
                        buttons={[
                          {value: 'direct', label: 'Direct'},
                          {value: 'formatted', label: 'Formatted'},
                        ]}
                      />

                      {textCompletionMethod === 'formatted' && (
                        <View style={styles.jinjaOption}>
                          <Text style={styles.optionLabel}>Use Jinja:</Text>
                          <SegmentedButtons
                            value={useJinja ? 'true' : 'false'}
                            onValueChange={value =>
                              setUseJinja(value === 'true')
                            }
                            buttons={[
                              {value: 'false', label: 'No'},
                              {value: 'true', label: 'Yes'},
                            ]}
                          />
                        </View>
                      )}
                    </View>

                    <View style={styles.testRow}>
                      {renderTestButton(
                        'textCompletion',
                        'Text Completion',
                        runTextCompletionTest,
                      )}
                    </View>

                    <View style={styles.testRow}>
                      {renderTestButton(
                        'toolCalling',
                        'Tool Calling',
                        runToolCallingTest,
                      )}
                      {renderTestButton(
                        'grammarSampling',
                        'Grammar Sampling',
                        runGrammarSamplingTest,
                      )}
                    </View>

                    <View style={styles.testRow}>
                      {renderTestButton(
                        'grammarTriggers',
                        'Grammar Triggers Test',
                        runGrammarTriggersTest,
                      )}
                    </View>
                  </View>
                )}
              </>
            )}

            <View style={styles.resultsContainer}>
              {renderResultCard('chatCompletion', 'Chat Completion Result')}
              {renderResultCard('textCompletion', 'Text Completion Result')}
              {renderResultCard('toolCalling', 'Tool Calling Result')}
              {renderResultCard('grammarSampling', 'Grammar Sampling Result')}
              {renderResultCard('formattedChat', 'Formatted Chat Test Results')}
              {renderResultCard(
                'grammarTriggers',
                'Grammar Triggers Test Results',
              )}
            </View>
          </Card.Content>
        </Card>
      </ScrollView>
    </SafeAreaView>
  );
});



================================================
FILE: src/screens/ModelsScreen/index.ts
================================================
export * from './ModelsScreen';



================================================
FILE: src/screens/ModelsScreen/ModelsScreen.tsx
================================================
import React, {useState, useContext, useEffect} from 'react';
import {
  FlatList,
  RefreshControl,
  Platform,
  Alert,
  KeyboardAvoidingView,
} from 'react-native';

import {reaction, computed} from 'mobx';
import {v4 as uuidv4} from 'uuid';
import 'react-native-get-random-values';
import {observer} from 'mobx-react-lite';
import * as RNFS from '@dr.pogodin/react-native-fs';
import DocumentPicker from 'react-native-document-picker';
import {Portal} from 'react-native-paper';

import {useTheme} from '../../hooks';

import {FABGroup} from './FABGroup';
import {ModelCard} from './ModelCard';
import {createStyles} from './styles';
import {HFModelSearch} from './HFModelSearch';
import {ModelAccordion} from './ModelAccordion';
import {
  DownloadErrorDialog,
  ErrorSnackbar,
  ModelSettingsSheet,
} from '../../components';

import {uiStore, modelStore, hfStore, UIStore} from '../../store';

import {L10nContext} from '../../utils';
import {Model, ModelOrigin} from '../../utils/types';
import {ErrorState} from '../../utils/errors';

export const ModelsScreen: React.FC = observer(() => {
  const l10n = useContext(L10nContext);
  const [refreshing, setRefreshing] = useState<boolean>(false);
  const [hfSearchVisible, setHFSearchVisible] = useState(false);
  const [_, setTrigger] = useState<boolean>(false);
  const [selectedModel, setSelectedModel] = useState<Model | undefined>();
  const [settingsVisible, setSettingsVisible] = useState(false);

  // Centralized error state tracking - derive directly from MobX stores
  const [activeError, setActiveError] = useState<ErrorState | null>(null);
  const [isShowingErrorDialog, setIsShowingErrorDialog] = useState(false);

  const theme = useTheme();
  const styles = createStyles(theme);

  const filters = uiStore.pageStates.modelsScreen.filters;
  const expandedGroups = uiStore.pageStates.modelsScreen.expandedGroups;

  // Set up MobX reactions to track store changes
  useEffect(() => {
    // Create a reaction for error handling
    const errorDisposer = reaction(
      // Track these observable values
      () => ({
        hfError: hfStore.error,
        downloadError: modelStore.downloadError,
      }),
      // React to changes
      data => {
        // First check if there's a download error that should show a dialog
        const hasDialogError =
          data.downloadError && data.downloadError.metadata?.modelId;

        setIsShowingErrorDialog(!!hasDialogError);

        // Then determine which error to show in the snackbar
        if (hasDialogError) {
          // If showing a dialog, don't show snackbar
          setActiveError(null);
        } else if (data.hfError) {
          // If we have an HF error, show it
          setActiveError(data.hfError);
        } else if (data.downloadError) {
          // For download errors without model ID, show in snackbar
          setActiveError(data.downloadError);
        } else {
          // No errors to show
          setActiveError(null);
        }
      },
    );

    // Clean up the reaction when component unmounts
    return () => {
      errorDisposer();
    };
  }, []); // Only run setup once

  const onRefresh = async () => {
    setRefreshing(true);
    await modelStore.refreshDownloadStatuses();
    setTrigger(prev => !prev);
    setRefreshing(false);
  };

  const handleOpenSettings = (model: Model) => {
    setSelectedModel(model);
    setSettingsVisible(true);
  };

  const handleCloseSettings = () => {
    setSettingsVisible(false);
    setSelectedModel(undefined);
  };

  const handleDismissError = () => {
    // Clear errors from both stores
    hfStore.clearError();
    modelStore.clearDownloadError();
  };

  const handleRetryAction = () => {
    if (activeError?.context === 'search') {
      hfStore.fetchModels();
    } else if (activeError?.context === 'download') {
      modelStore.retryDownload();
    }
    handleDismissError();
  };

  const handleAddLocalModel = async () => {
    DocumentPicker.pick({
      type:
        Platform.OS === 'ios' ? 'public.data' : DocumentPicker.types.allFiles,
    })
      .then(async res => {
        let [file] = res;
        if (file) {
          // Assign a default name if file.name is null or undefined
          // Not sure if this can ever happen, though.
          let fileName =
            file.name || file.uri.split('/').pop() || `file_${uuidv4()}`;

          const permanentDir = `${RNFS.DocumentDirectoryPath}/models/local`;
          let permanentPath = `${permanentDir}/${fileName}`;
          if (!(await RNFS.exists(permanentDir))) {
            await RNFS.mkdir(permanentDir);
          }

          if (await RNFS.exists(permanentPath)) {
            const choice = await new Promise<'replace' | 'keep' | 'cancel'>(
              resolve => {
                Alert.alert(
                  l10n.models.fileManagement.fileAlreadyExists,
                  l10n.models.fileManagement.fileAlreadyExistsMessage,
                  [
                    {
                      text: l10n.models.fileManagement.replace,
                      onPress: () => resolve('replace'),
                    },
                    {
                      text: l10n.models.fileManagement.keepBoth,
                      onPress: () => resolve('keep'),
                    },
                    {
                      text: l10n.common.cancel,
                      onPress: () => resolve('cancel'),
                      style: 'cancel',
                    },
                  ],
                );
              },
            );

            switch (choice) {
              case 'replace':
                await RNFS.unlink(permanentPath);
                break;
              case 'keep':
                let counter = 1;
                const nameParts = fileName.split('.');
                const ext = nameParts.length > 1 ? nameParts.pop() : '';
                const name = nameParts.join('.');
                do {
                  permanentPath = `${permanentDir}/${name}_${counter}.${ext}`;
                  counter++;
                } while (await RNFS.exists(permanentPath));
                break;
              case 'cancel':
                console.log('File copy cancelled by user');
                return;
            }
          }

          await RNFS.copyFile(file.uri, permanentPath);
          await modelStore.addLocalModel(permanentPath);
          setTrigger(prev => !prev);
        }
      })
      .catch(e => console.log('No file picked, error: ', e.message));
  };

  const activeModelId = modelStore.activeModel?.id;
  const models = modelStore.displayModels;

  // useMemo uses shallow comaprison for dependencies,
  // so we use computed instead for deep comparison
  // (model state changes not-downloaded -> downloaded)
  const filteredAndSortedModels = computed(() => {
    let result = models;
    if (filters.includes('downloaded')) {
      result = result.filter(model => model.isDownloaded);
    }
    if (!filters.includes('grouped')) {
      result = result.sort((a, b) => {
        if (a.isDownloaded && !b.isDownloaded) {
          return -1;
        }
        if (!a.isDownloaded && b.isDownloaded) {
          return 1;
        }
        return 0;
      });
    }
    if (filters.includes('hf')) {
      result = result.filter(model => model.origin === ModelOrigin.HF);
    }
    return result;
  }).get();

  const getGroupDisplayName = (key: string) => {
    switch (key) {
      case UIStore.GROUP_KEYS.READY_TO_USE:
        return l10n.models.labels.availableToUse;
      case UIStore.GROUP_KEYS.AVAILABLE_TO_DOWNLOAD:
        return l10n.models.labels.availableToDownload;
      default:
        return key;
    }
  };

  const groupedModels = computed(() => {
    if (!filters.includes('grouped')) {
      return {
        [UIStore.GROUP_KEYS.READY_TO_USE]: filteredAndSortedModels.filter(
          model => model.isDownloaded,
        ),
        [UIStore.GROUP_KEYS.AVAILABLE_TO_DOWNLOAD]:
          filteredAndSortedModels.filter(model => !model.isDownloaded),
      };
    }

    return filteredAndSortedModels.reduce((acc, item) => {
      const groupKey =
        item.origin === ModelOrigin.LOCAL || item.isLocal
          ? l10n.models.labels.localModel
          : item.type || l10n.models.labels.unknownGroup;

      if (!acc[groupKey]) {
        acc[groupKey] = [];
      }
      acc[groupKey].push(item);
      return acc;
    }, {} as Record<string, Model[]>);
  }).get();

  const toggleGroup = (type: string) => {
    const currentExpandedGroups =
      uiStore.pageStates.modelsScreen.expandedGroups;
    const updatedExpandedGroups = {
      ...currentExpandedGroups,
      [type]: !currentExpandedGroups[type],
    };
    uiStore.setValue('modelsScreen', 'expandedGroups', updatedExpandedGroups);
  };

  //const {scrollRef, moveScrollToDown} = useMoveScroll();

  const renderGroupHeader = ({item: group}) => {
    const isExpanded = expandedGroups[group.type];
    const displayName = filters.includes('grouped')
      ? group.type
      : getGroupDisplayName(group.type);
    const description =
      !filters.includes('grouped') &&
      group.type === UIStore.GROUP_KEYS.AVAILABLE_TO_DOWNLOAD
        ? l10n.models.labels.useAddButtonForMore
        : undefined;
    return (
      <ModelAccordion
        group={{...group, type: displayName}}
        expanded={isExpanded}
        description={description}
        onPress={() => toggleGroup(group.type)}>
        <FlatList
          data={group.items}
          keyExtractor={subItem => subItem.id}
          renderItem={({item: subItem}) => (
            <ModelCard
              model={subItem}
              activeModelId={activeModelId}
              onOpenSettings={() => handleOpenSettings(subItem)}
            />
          )}
        />
      </ModelAccordion>
    );
  };

  const flatListModels = Object.keys(groupedModels)
    .map(type => ({
      type,
      items: groupedModels[type],
    }))
    .filter(group => group.items.length > 0);

  return (
    <KeyboardAvoidingView
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 100 : 80}
      style={styles.container}>
      {/* Show Error Snackbar only if no dialog is visible */}
      {!isShowingErrorDialog && activeError && (
        <ErrorSnackbar
          error={activeError}
          onDismiss={handleDismissError}
          onRetry={handleRetryAction}
        />
      )}

      <FlatList
        testID="flat-list"
        keyboardDismissMode="on-drag"
        keyboardShouldPersistTaps="handled"
        contentContainerStyle={styles.listContainer}
        data={flatListModels}
        keyExtractor={item => item.type}
        extraData={activeModelId}
        renderItem={renderGroupHeader}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            colors={[theme.colors.primary]}
          />
        }
      />

      {/* DownloadErrorDialog with Portal for better visibility */}
      <Portal>
        <DownloadErrorDialog
          visible={isShowingErrorDialog}
          onDismiss={() => {
            modelStore.clearDownloadError();
          }}
          error={modelStore.downloadError}
          model={
            modelStore.downloadError?.metadata?.modelId
              ? modelStore.models.find(
                  m => m.id === modelStore.downloadError?.metadata?.modelId,
                )
              : undefined
          }
          onTryAgain={modelStore.retryDownload}
        />
      </Portal>

      <HFModelSearch
        visible={hfSearchVisible}
        onDismiss={() => setHFSearchVisible(false)}
      />
      <FABGroup
        onAddHFModel={() => setHFSearchVisible(true)}
        onAddLocalModel={handleAddLocalModel}
      />
      <ModelSettingsSheet
        isVisible={settingsVisible}
        onClose={handleCloseSettings}
        model={selectedModel}
      />
    </KeyboardAvoidingView>
  );
});



================================================
FILE: src/screens/ModelsScreen/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {Theme} from '../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    safeArea: {
      flex: 1,
    },
    container: {
      flex: 1,
      padding: 10,
      backgroundColor: theme.colors.background,
    },
    listContainer: {
      paddingBottom: 150,
    },
    filterContainer: {
      flexDirection: 'row',
      padding: 4,
      gap: 1,
      justifyContent: 'flex-end',
    },
    filterIcon: {
      borderRadius: 8,
      marginHorizontal: 2,
    },
  });



================================================
FILE: src/screens/ModelsScreen/__tests__/ModelsScreen.test.tsx
================================================
import React from 'react';
import {Alert} from 'react-native';

import * as RNFS from '@dr.pogodin/react-native-fs';
import DocumentPicker from 'react-native-document-picker';
import {fireEvent, render, waitFor, act} from '../../../../jest/test-utils';

import {ModelsScreen} from '../ModelsScreen';

import {modelStore, uiStore} from '../../../store';
import {
  basicModel,
  downloadedModel,
  hfModel1,
  hfModel2,
} from '../../../../jest/fixtures/models';

jest.useFakeTimers();

describe('ModelsScreen', () => {
  beforeEach(() => {
    //(useTheme as jest.Mock).mockReturnValue(mockTheme);
    jest.clearAllMocks();
  });

  it('renders correctly', async () => {
    const {getByTestId} = render(<ModelsScreen />, {
      withNavigation: true,
    });
    expect(getByTestId('flat-list')).toBeTruthy();
    expect(getByTestId('fab-group')).toBeTruthy();
  });

  it('refreshes models on pull-to-refresh', async () => {
    const {getByTestId} = render(<ModelsScreen />, {
      withNavigation: true,
    });

    const flatList = getByTestId('flat-list');
    const refreshControl = flatList.props.refreshControl;
    await act(async () => {
      refreshControl.props.onRefresh();
    });

    expect(modelStore.refreshDownloadStatuses).toHaveBeenCalled();
  });

  it('opens HF model search when the HF FAB is pressed', async () => {
    const {getByTestId} = render(<ModelsScreen />, {
      withNavigation: true,
    });

    // Open the FAB group
    const fabGroup = getByTestId('fab-group');
    fireEvent.press(fabGroup);

    // Wait for the FAB group to open and its children to be accessible
    await waitFor(() => {
      const hfFab = getByTestId('hf-fab', {includeHiddenElements: true});
      expect(hfFab).toBeTruthy();
    });
    const hfFab = getByTestId('hf-fab', {includeHiddenElements: true});

    await act(async () => {
      fireEvent.press(hfFab);
    });

    // Verify HFModelSearch is rendered
    await waitFor(() => {
      const hfModelSearch = getByTestId('hf-model-search-view');
      expect(hfModelSearch).toBeTruthy();
    });
  });

  it('adds a local model when the plus FAB is pressed', async () => {
    (DocumentPicker.pick as jest.Mock).mockResolvedValue([
      {
        uri: '/mock/file/path',
        name: 'mockModelFile.bin',
      },
    ]);

    // Mock RNFS.exists to return false for the destination path so no alert is shown
    (RNFS.exists as jest.Mock).mockImplementation(async (path: string) => {
      if (path.includes('/path/to/documents/models/local/mockModelFile.bin')) {
        return false; // File doesn't exist, so no alert will be shown
      }
      return true; // Other paths exist by default
    });

    const {getByTestId} = render(<ModelsScreen />, {
      withNavigation: true,
    });

    // Open the FAB group
    const fabGroup = getByTestId('fab-group');
    fireEvent.press(fabGroup);

    // Wait for the FAB group to open and its children to be accessible
    await waitFor(() => {
      const localFab = getByTestId('local-fab', {includeHiddenElements: true});
      expect(localFab).toBeTruthy();
    });
    const addLocalModelButton = getByTestId('local-fab', {
      includeHiddenElements: true,
    });

    await act(async () => {
      if (addLocalModelButton) {
        fireEvent.press(addLocalModelButton);
      }
    });

    await waitFor(() => {
      expect(DocumentPicker.pick).toHaveBeenCalled();
      expect(RNFS.copyFile).toHaveBeenCalledWith(
        '/mock/file/path',
        '/path/to/documents/models/local/mockModelFile.bin',
      );
      expect(modelStore.addLocalModel).toHaveBeenCalledWith(
        '/path/to/documents/models/local/mockModelFile.bin',
      );
    });
  });

  it('shows a confirmation alert if file already exists and replaces it', async () => {
    (RNFS.exists as jest.Mock).mockResolvedValue(true);
    (DocumentPicker.pick as jest.Mock).mockResolvedValue([
      {
        uri: '/mock/file/path',
        name: 'mockModelFile.bin',
      },
    ]);

    jest.spyOn(Alert, 'alert').mockImplementation((_, __, buttons) => {
      buttons![0].onPress!();
    });

    const {getByTestId} = render(<ModelsScreen />, {
      withNavigation: true,
    });

    // Open the FAB group
    const fabGroup = getByTestId('fab-group');
    fireEvent.press(fabGroup);

    // Wait for the FAB group to open and its children to be accessible
    await waitFor(() => {
      const localFab = getByTestId('local-fab', {includeHiddenElements: true});
      expect(localFab).toBeTruthy();
    });
    const addLocalModelButton = getByTestId('local-fab', {
      includeHiddenElements: true,
    });

    await act(async () => {
      fireEvent.press(addLocalModelButton);
    });

    await waitFor(() => {
      expect(Alert.alert).toHaveBeenCalled();
      expect(RNFS.unlink).toHaveBeenCalledWith(
        '/path/to/documents/models/local/mockModelFile.bin',
      );
      expect(RNFS.copyFile).toHaveBeenCalled();
      expect(modelStore.addLocalModel).toHaveBeenCalled();
    });
  });

  it('does not replace or copy the file when user cancels the action', async () => {
    (RNFS.exists as jest.Mock).mockResolvedValue(true);
    (DocumentPicker.pick as jest.Mock).mockResolvedValue([
      {
        uri: '/mock/file/path',
        name: 'mockModelFile.bin',
      },
    ]);

    jest.spyOn(Alert, 'alert').mockImplementation((_, __, buttons) => {
      // pressing "Cancel"
      buttons![2].onPress!();
    });

    const {getByTestId} = render(<ModelsScreen />, {
      withNavigation: true,
    });
    // Open the FAB group
    const fabGroup = getByTestId('fab-group');
    fireEvent.press(fabGroup);

    // Wait for the FAB group to open and its children to be accessible
    await waitFor(() => {
      const localFab = getByTestId('local-fab', {includeHiddenElements: true});
      expect(localFab).toBeTruthy();
    });
    const addLocalModelButton = getByTestId('local-fab', {
      includeHiddenElements: true,
    });

    await act(async () => {
      fireEvent.press(addLocalModelButton);
    });

    await waitFor(() => {
      expect(Alert.alert).toHaveBeenCalled();
      expect(RNFS.unlink).not.toHaveBeenCalled(); // File should not be unlinked (deleted)
      expect(RNFS.copyFile).not.toHaveBeenCalled(); // File should not be copied
      expect(modelStore.addLocalModel).not.toHaveBeenCalled(); // Model should not be added
    });
  });

  it('keeps both files when user chooses to keep both', async () => {
    (RNFS.exists as jest.Mock).mockResolvedValueOnce(true); // File already exists
    (DocumentPicker.pick as jest.Mock).mockResolvedValue([
      {
        uri: '/mock/file/path',
        name: 'mockModelFile.bin',
      },
    ]);

    jest.spyOn(Alert, 'alert').mockImplementation((_, __, buttons) => {
      // pressing "Keep Both"
      buttons![1].onPress!();
    });

    let counter = 1;
    (RNFS.exists as jest.Mock).mockImplementation(async path => {
      if (path.includes(`mockModelFile_${counter}.bin`)) {
        return false; // Ensure new file doesn't exist
      }
      return true; // Original file exists
    });

    const {getByTestId} = render(<ModelsScreen />, {
      withNavigation: true,
    });

    // Open the FAB group
    const fabGroup = getByTestId('fab-group');
    fireEvent.press(fabGroup);

    // Wait for the FAB group to open and its children to be accessible
    await waitFor(() => {
      const localFab = getByTestId('local-fab', {includeHiddenElements: true});
      expect(localFab).toBeTruthy();
    });
    const addLocalModelButton = getByTestId('local-fab', {
      includeHiddenElements: true,
    });

    await act(async () => {
      fireEvent.press(addLocalModelButton);
    });

    await waitFor(() => {
      expect(Alert.alert).toHaveBeenCalled();
      expect(RNFS.unlink).not.toHaveBeenCalled(); // Original file should not be deleted
      expect(RNFS.copyFile).toHaveBeenCalledWith(
        '/mock/file/path',
        `/path/to/documents/models/local/mockModelFile_${counter}.bin`,
      );
      expect(modelStore.addLocalModel).toHaveBeenCalledWith(
        `/path/to/documents/models/local/mockModelFile_${counter}.bin`,
      );
    });
  });

  // TODO: fix this test
  // eslint-disable-next-line jest/no-disabled-tests
  it.skip('hides reset dialog on cancel', async () => {
    const {getByTestId, queryByTestId} = render(<ModelsScreen />, {
      withNavigation: true,
    });

    // Open the FAB group
    const fabGroup = getByTestId('fab-group');
    fireEvent.press(fabGroup);

    // Wait for the FAB group to open and its children to be accessible
    await waitFor(() => {
      const resetFab = getByTestId('reset-fab', {includeHiddenElements: true});
      expect(resetFab).toBeTruthy();
    });
    const resetFab = getByTestId('reset-fab', {includeHiddenElements: true});

    await act(async () => {
      fireEvent.press(resetFab);
    });

    // Wait for dialog to be visible
    await waitFor(() => {
      expect(getByTestId('reset-dialog')).toBeTruthy();
    });

    // Press cancel button
    const cancelButton = getByTestId('cancel-reset-button');
    await act(async () => {
      fireEvent.press(cancelButton);
    });

    // Wait for dialog to be hidden
    await waitFor(
      () => {
        expect(queryByTestId('reset-dialog')).toBeNull();
      },
      {
        timeout: 10000,
      },
    );
  }, 15000);

  // Add tests for model filtering and grouping
  describe('Model filtering and grouping', () => {
    beforeEach(() => {
      jest.clearAllMocks();
      // Set up mock models
      modelStore.models = [downloadedModel, basicModel, hfModel1, hfModel2];
    });

    it('should filter downloaded models when downloaded filter is active', async () => {
      uiStore.pageStates.modelsScreen.filters = ['downloaded'];

      const {getByText, queryByText} = render(<ModelsScreen />, {
        withNavigation: true,
      });

      await waitFor(() => {
        expect(getByText('downloaded model')).toBeTruthy();
        expect(queryByText('basic model')).toBeNull();
      });
    });

    it('should filter HF models when HF filter is active', async () => {
      uiStore.pageStates.modelsScreen.filters = ['hf'];

      const {getByText, queryByText} = render(<ModelsScreen />, {
        withNavigation: true,
      });

      // Open the Available to Download group, since hf mocked models are not downloaded.
      const button = getByText('Available to Download');
      fireEvent.press(button);

      await waitFor(() => {
        expect(getByText('hf-model-name-1')).toBeTruthy();
        expect(queryByText('basic model')).toBeNull();
      });
    });

    it('should group models by type when grouped filter is active', async () => {
      uiStore.pageStates.modelsScreen.filters = ['grouped'];

      const {getByText} = render(<ModelsScreen />, {
        withNavigation: true,
      });

      await waitFor(() => {
        expect(getByText('Test Model Type')).toBeTruthy();
      });
    });

    it('should group models into ready-to-use and available-to-download when not grouped', async () => {
      uiStore.pageStates.modelsScreen.filters = [];

      const {getByText} = render(<ModelsScreen />, {
        withNavigation: true,
      });

      await waitFor(() => {
        expect(getByText('Ready to Use')).toBeTruthy();
        expect(getByText('Available to Download')).toBeTruthy();
      });
    });

    it('should handle group expansion and collapse', async () => {
      uiStore.pageStates.modelsScreen.filters = [];

      const {getByText, queryByText} = render(<ModelsScreen />, {
        withNavigation: true,
      });

      // Not downloaded model should not be visible
      await waitFor(() => {
        expect(queryByText('basic model')).toBeNull();
      });

      const availableGroup = getByText('Available to Download');
      fireEvent.press(availableGroup);

      // Not downloaded model should be visible after expanding the group
      await waitFor(() => {
        expect(getByText('basic model')).toBeTruthy();
      });
    });
  });
});



================================================
FILE: src/screens/ModelsScreen/ChatTemplatePicker/ChatTemplatePicker.tsx
================================================
import React, {useMemo, useContext} from 'react';
import {StyleSheet, View} from 'react-native';

import {Text} from 'react-native-paper';
import RNPickerSelect from 'react-native-picker-select';
import Icon from 'react-native-vector-icons/MaterialIcons';

import {useTheme} from '../../../hooks';
import {L10nContext} from '../../../utils';

import {styles} from './styles';

import {chatTemplates} from '../../../utils/chat';

const pickerHeight = 30;

interface TemplatePickerProps {
  selectedTemplateName: string | null;
  handleChatTemplateNameChange: (value: string) => void;
}

const DropdownIcon = () => {
  const theme = useTheme();
  return (
    <Icon name="keyboard-arrow-down" size={24} color={theme.colors.onSurface} />
  );
};

export const ChatTemplatePicker: React.FC<TemplatePickerProps> = ({
  selectedTemplateName,
  handleChatTemplateNameChange,
}) => {
  const theme = useTheme();
  const l10n = useContext(L10nContext);

  const pickerItems = useMemo(
    () =>
      Object.entries(chatTemplates).map(([key, template]) => ({
        label: template.name,
        value: key,
      })),
    [],
  );

  const pickerStyle = useMemo(
    () =>
      StyleSheet.create({
        inputIOS: {
          height: pickerHeight,
          paddingVertical: 0,
          paddingHorizontal: 10,
          paddingRight: 30,
          color: theme.colors.onSurface,
        },
        inputAndroid: {
          height: pickerHeight,
          paddingVertical: 0,
          paddingHorizontal: 10,
          paddingRight: 30,
          color: theme.colors.onSurface,
        },
        placeholder: {
          color: theme.colors.secondary,
        },
        iconContainer: {
          justifyContent: 'center',
          alignItems: 'center',
          height: pickerHeight,
        },
      }),
    [theme.colors.onSurface, theme.colors.secondary],
  );

  return (
    <View style={styles.container}>
      <Text variant="labelMedium">{l10n.models.chatTemplate.label}</Text>
      <View style={styles.pickerContainer}>
        <RNPickerSelect
          onValueChange={handleChatTemplateNameChange}
          items={pickerItems}
          value={selectedTemplateName}
          placeholder={{}}
          style={pickerStyle}
          Icon={DropdownIcon}
          useNativeAndroidPickerStyle={false} // Disabled native Android picker style
        />
      </View>
    </View>
  );
};



================================================
FILE: src/screens/ModelsScreen/ChatTemplatePicker/index.ts
================================================
export * from './ChatTemplatePicker';



================================================
FILE: src/screens/ModelsScreen/ChatTemplatePicker/styles.ts
================================================
import {StyleSheet} from 'react-native';

export const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  pickerContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
  },
});



================================================
FILE: src/screens/ModelsScreen/ChatTemplatePicker/__tests__/ChatTemplatePicker.test.tsx
================================================
import React from 'react';

import {render, fireEvent} from '@testing-library/react-native';

import {ChatTemplatePicker} from '../ChatTemplatePicker';

jest.useFakeTimers();

jest.mock('../../../../utils/chat', () => ({
  chatTemplates: {
    template1: {name: 'Template 1'},
    template2: {name: 'Template 2'},
  },
}));

describe('ChatTemplatePicker', () => {
  it('renders correctly with initial value', () => {
    const {getByText, getByTestId} = render(
      <ChatTemplatePicker
        selectedTemplateName="template1"
        handleChatTemplateNameChange={jest.fn()}
      />,
    );

    expect(getByText('Base Chat Template:')).toBeTruthy();
    expect(getByTestId('text_input').props.value).toBe('Template 1');
  });

  it('displays the correct templates in the picker', () => {
    const {getByText, getByTestId} = render(
      <ChatTemplatePicker
        selectedTemplateName="template2"
        handleChatTemplateNameChange={jest.fn()}
      />,
    );

    expect(getByText('Base Chat Template:')).toBeTruthy();
    expect(getByTestId('text_input').props.value).toBe('Template 2');
  });

  it('calls handleChatTemplateNameChange when a template is selected', () => {
    const mockHandleChatTemplateNameChange = jest.fn();
    const {getByTestId} = render(
      <ChatTemplatePicker
        selectedTemplateName="template1"
        handleChatTemplateNameChange={mockHandleChatTemplateNameChange}
      />,
    );

    const textInput = getByTestId('text_input');
    fireEvent(textInput, 'onValueChange', 'template2');
    expect(mockHandleChatTemplateNameChange).toHaveBeenCalledWith('template2');
  });
});



================================================
FILE: src/screens/ModelsScreen/FABGroup/FABGroup.tsx
================================================
import {Image} from 'react-native';
import React, {useContext, useMemo, useState} from 'react';

import {FAB} from 'react-native-paper';

import {L10nContext} from '../../../utils';
import {styles} from './styles';

interface FABGroupProps {
  onAddHFModel: () => void;
  onAddLocalModel: () => void;
}

const HFIcon: React.FC<any> = props => (
  <Image
    source={require('../../../assets/icon-hf.png')}
    style={styles.icon}
    {...props}
  />
);

export const FABGroup: React.FC<FABGroupProps> = ({
  onAddHFModel,
  onAddLocalModel,
}) => {
  const [open, setOpen] = useState(false);
  const l10n = useContext(L10nContext);

  const onStateChange = ({open: isOpen}) => setOpen(isOpen);

  const actions = useMemo(
    () => [
      {
        testID: 'hf-fab',
        icon: HFIcon,
        label: l10n.models.buttons.addFromHuggingFace,
        onPress: () => {
          onAddHFModel();
        },
      },
      {
        testID: 'local-fab',
        icon: 'folder-plus',
        label: l10n.models.buttons.addLocalModel,
        onPress: () => {
          onAddLocalModel();
        },
      },
    ],
    [l10n, onAddHFModel, onAddLocalModel],
  );

  return (
    <FAB.Group
      testID="fab-group"
      open={open}
      visible={true}
      icon={open ? 'close' : 'plus'}
      actions={actions}
      onStateChange={onStateChange}
      onPress={() => {
        if (open) {
          console.log('FAB Group closed');
        } else {
          console.log('FAB Group opened');
        }
      }}
      fabStyle={styles.fab}
      accessibilityLabel={open ? 'Close menu' : 'Open menu'}
    />
  );
};



================================================
FILE: src/screens/ModelsScreen/FABGroup/index.ts
================================================
export {FABGroup} from './FABGroup';



================================================
FILE: src/screens/ModelsScreen/FABGroup/styles.ts
================================================
import {StyleSheet} from 'react-native';

export const styles = StyleSheet.create({
  fab: {
    bottom: 0,
    right: 16,
  },
  icon: {
    width: 24,
    height: 24,
  },
});



================================================
FILE: src/screens/ModelsScreen/HFModelSearch/HFModelSearch.tsx
================================================
import React, {
  useState,
  useCallback,
  useMemo,
  useRef,
  useEffect,
  useContext,
} from 'react';

import {observer} from 'mobx-react';
import debounce from 'lodash/debounce';
import {Portal, PaperProvider} from 'react-native-paper';
import {
  BottomSheetModal,
  BottomSheetBackdrop,
  BottomSheetScrollView,
  BottomSheetModalProvider,
} from '@gorhom/bottom-sheet';

import {useTheme} from '../../../hooks';

import {createStyles} from './styles';
import {SearchView} from './SearchView';
import {DetailsView} from './DetailsView';

import {hfStore} from '../../../store';

import {HuggingFaceModel} from '../../../utils/types';
import {L10nContext} from '../../../utils';

interface HFModelSearchProps {
  visible: boolean;
  onDismiss: () => void;
}

const DEBOUNCE_DELAY = 500;

export const HFModelSearch: React.FC<HFModelSearchProps> = observer(
  ({visible, onDismiss}) => {
    const l10n = useContext(L10nContext);
    const theme = useTheme();
    const styles = createStyles(theme);

    const [detailsVisible, setDetailsVisible] = useState(false);
    const [selectedModel, setSelectedModel] = useState<HuggingFaceModel | null>(
      null,
    );

    const searchSheetRef = useRef<BottomSheetModal>(null);
    const detailsSheetRef = useRef<BottomSheetModal>(null);

    // Clear state when closed
    useEffect(() => {
      if (!visible) {
        setSelectedModel(null);
      }
    }, [visible]);

    const debouncedSearch = useMemo(
      () =>
        debounce(async (query: string) => {
          hfStore.setSearchQuery(query);
          await hfStore.fetchModels();
        }, DEBOUNCE_DELAY),
      [], // Empty dependencies since we don't want to recreate this
    );

    // Update search query without triggering immediate search
    const handleSearchChange = useCallback(
      (query: string) => {
        debouncedSearch(query);
      },
      [debouncedSearch],
    );

    useEffect(() => {
      if (visible) {
        handleSearchChange(hfStore.searchQuery);
      }
    }, [handleSearchChange, visible]);

    useEffect(() => {
      if (visible) {
        searchSheetRef.current?.present();
      }
    }, [visible]);

    useEffect(() => {
      if (detailsVisible) {
        detailsSheetRef.current?.present();
      }
    }, [detailsVisible]);

    const handleModelSelect = async (model: HuggingFaceModel) => {
      setSelectedModel(model);
      setDetailsVisible(true);
      await hfStore.fetchModelData(model.id);
      const updatedModel = hfStore.getModelById(model.id);
      if (updatedModel) {
        setSelectedModel({...updatedModel});
      }
    };

    const renderBackdrop = useCallback(
      props => (
        <BottomSheetBackdrop
          {...props}
          disappearsOnIndex={-1}
          appearsOnIndex={0}
          opacity={0.5}
          pressBehavior="close"
        />
      ),
      [],
    );

    const handleSheetDismiss = () => {
      console.log('Search sheet dismissed, clearing error state');
      // Clear error state when the sheet is closed
      hfStore.clearError();
      onDismiss();
    };

    return (
      <Portal>
        <BottomSheetModalProvider>
          <BottomSheetModal
            ref={searchSheetRef}
            index={0}
            snapPoints={['92%']}
            enableDynamicSizing={false}
            onDismiss={handleSheetDismiss}
            enablePanDownToClose
            enableContentPanningGesture={false}
            handleIndicatorStyle={styles.bottomSheetHandle}
            backgroundStyle={styles.bottomSheetBackground}
            keyboardBehavior="extend"
            keyboardBlurBehavior="restore"
            android_keyboardInputMode="adjustResize"
            backdropComponent={renderBackdrop}>
            {/*
            We need PaperProvider here because:
            1. BottomSheetModal creates a new React portal/root that's outside
               the main component tree
            2. When content is portaled, it loses access to the context (including theme)
               from the original component tree
            3. By wrapping the bottom sheet content with PaperProvider, we restore
               the theme context for all Paper components inside
          */}
            <PaperProvider theme={theme}>
              <L10nContext.Provider value={l10n}>
                <SearchView
                  testID="hf-model-search-view"
                  onModelSelect={handleModelSelect}
                  onChangeSearchQuery={handleSearchChange}
                />
              </L10nContext.Provider>
            </PaperProvider>
          </BottomSheetModal>

          <BottomSheetModal
            ref={detailsSheetRef}
            index={0}
            snapPoints={['90%']}
            enableDynamicSizing={false}
            onDismiss={() => setDetailsVisible(false)}
            enablePanDownToClose
            stackBehavior="push"
            handleIndicatorStyle={styles.bottomSheetHandle}
            backgroundStyle={styles.bottomSheetBackground}
            backdropComponent={renderBackdrop}>
            {/* PaperProvider is needed here to restore theme context. see the comment above. */}
            <PaperProvider theme={theme}>
              <L10nContext.Provider value={l10n}>
                <BottomSheetScrollView>
                  {selectedModel && <DetailsView hfModel={selectedModel} />}
                </BottomSheetScrollView>
              </L10nContext.Provider>
            </PaperProvider>
          </BottomSheetModal>
        </BottomSheetModalProvider>
      </Portal>
    );
  },
);



================================================
FILE: src/screens/ModelsScreen/HFModelSearch/index.ts
================================================
export {HFModelSearch} from './HFModelSearch';



================================================
FILE: src/screens/ModelsScreen/HFModelSearch/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {Theme} from '../../../utils/types';

export const createStyles = (theme: Theme) => {
  return StyleSheet.create({
    bottomSheetHandle: {
      backgroundColor: theme.colors.primary,
      width: 40,
      height: 4,
    },
    bottomSheetBackground: {
      backgroundColor: theme.colors.background,
    },
  });
};



================================================
FILE: src/screens/ModelsScreen/HFModelSearch/styles.tsx
================================================
import {StyleSheet} from 'react-native';
import {Theme} from '../../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    // ... existing styles ...
    bottomSheetHandle: {
      backgroundColor: theme.colors.onSurface,
      opacity: 0.5,
    },
    bottomSheetBackground: {
      backgroundColor: theme.colors.background,
    },
  });



================================================
FILE: src/screens/ModelsScreen/HFModelSearch/DetailsView/DetailsView.tsx
================================================
import React, {useContext} from 'react';
import {View} from 'react-native';

import {Text, Chip, Tooltip} from 'react-native-paper';

import {ModelTypeTag} from '../../../../components';

import {useTheme} from '../../../../hooks';

import {createStyles} from './styles';
import {ModelFileCard} from './ModelFileCard';

import {HuggingFaceModel} from '../../../../utils/types';
import {
  extractHFModelTitle,
  formatNumber,
  L10nContext,
  timeAgo,
  isVisionRepo,
  getLLMFiles,
} from '../../../../utils';

interface DetailsViewProps {
  hfModel: HuggingFaceModel;
}

export const DetailsView = ({hfModel}: DetailsViewProps) => {
  const theme = useTheme();
  const styles = createStyles(theme);
  const l10n = useContext(L10nContext);

  // Check if this is a vision repository
  const isVision = isVisionRepo(hfModel.siblings || []);

  // Get LLM files (non-mmproj files) - projection models are hidden from UI
  const llmFiles = getLLMFiles(hfModel.siblings || []);

  return (
    <View style={styles.content}>
      <View style={styles.authorRow}>
        <Text variant="headlineSmall" style={styles.modelAuthor}>
          {hfModel.author}
        </Text>
        {isVision && (
          <ModelTypeTag
            type="vision"
            label={l10n.models?.vision || 'Vision'}
            size="medium"
          />
        )}
      </View>
      <View style={styles.titleContainer}>
        <Tooltip title={hfModel.id}>
          <Text
            ellipsizeMode="middle"
            numberOfLines={1}
            variant="headlineSmall"
            style={styles.modelTitle}>
            {extractHFModelTitle(hfModel.id)}
          </Text>
        </Tooltip>
      </View>
      <View style={styles.modelStats}>
        <Chip icon="clock" compact style={styles.stat}>
          {timeAgo(hfModel.lastModified, l10n, 'long')}
        </Chip>
        <Chip icon="download" compact style={styles.stat}>
          {formatNumber(hfModel.downloads, 0)}
        </Chip>
        <Chip icon="heart" compact style={styles.stat}>
          {formatNumber(hfModel.likes, 0)}
        </Chip>
        {hfModel.trendingScore > 20 && (
          <Chip icon="trending-up" style={styles.stat} compact mode="outlined">
            üî•
          </Chip>
        )}
      </View>
      <Text variant="titleLarge" style={styles.sectionTitle}>
        {l10n.models.details.title}
      </Text>

      {/* Show LLM files only - projection models are hidden per enhanced UX */}
      {llmFiles.length > 0 &&
        llmFiles.map(file => (
          <ModelFileCard
            key={file.rfilename}
            modelFile={file}
            hfModel={hfModel}
          />
        ))}

      {/* TODO: Currently projection models are hidden from UI,
      we should add them to the model card like in a dropdown form.*/}
    </View>
  );
};



================================================
FILE: src/screens/ModelsScreen/HFModelSearch/DetailsView/index.ts
================================================
export * from './DetailsView';



================================================
FILE: src/screens/ModelsScreen/HFModelSearch/DetailsView/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {Theme} from '../../../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    container: {
      flex: 1,
    },
    scrollView: {
      flex: 1,
      width: '100%',
      height: '100%',
      padding: 16,
    },
    scrollContent: {
      flexGrow: 1,
    },
    content: {
      padding: 16,
    },
    authorRow: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: 8,
      gap: 8,
    },
    modelAuthor: {
      marginBottom: 0,
    },
    titleContainer: {
      marginBottom: 16,
    },
    modelTitleRow: {
      flexDirection: 'row',
      alignItems: 'center',
      flexWrap: 'wrap',
    },
    modelTitle: {
      fontWeight: 'bold',
    },
    modelStats: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: 4,
      marginBottom: 24,
    },
    stat: {
      backgroundColor: theme.colors.surfaceVariant,
    },
    sectionTitle: {
      fontSize: 20,
      fontWeight: 'bold',
      marginTop: 16,
      marginBottom: 8,
      color: theme.colors.onSurface,
    },
    sectionSubtitle: {
      fontSize: 16,
      fontWeight: '600',
      marginTop: 12,
      marginBottom: 4,
      color: theme.colors.onSurfaceVariant,
    },
  });



================================================
FILE: src/screens/ModelsScreen/HFModelSearch/DetailsView/__tests__/DetailsView.test.tsx
================================================
import React from 'react';
import {render} from '../../../../../../jest/test-utils';
import {DetailsView} from '../DetailsView';
import {
  mockHFModel1,
  mockHFModel2,
} from '../../../../../../jest/fixtures/models';
import {formatNumber, timeAgo} from '../../../../../utils';
import {l10n} from '../../../../../utils/l10n';

describe('DetailsView', () => {
  it('renders basic model information', () => {
    const {getByText} = render(<DetailsView hfModel={mockHFModel1} />);

    // Check author and model name are displayed
    expect(getByText(mockHFModel1.author)).toBeDefined();
    expect(getByText('hf-model-name-1')).toBeDefined();
  });

  it('renders model statistics', () => {
    const {getByText} = render(<DetailsView hfModel={mockHFModel1} />);

    // Check stats are displayed with correct formatting
    expect(
      getByText(timeAgo(mockHFModel1.lastModified, l10n.en, 'long')),
    ).toBeDefined();
    expect(getByText(formatNumber(mockHFModel1.downloads, 0))).toBeDefined();
    expect(getByText(formatNumber(mockHFModel1.likes, 0))).toBeDefined();
  });

  it('shows trending indicator for high trending score', () => {
    const {getByText} = render(
      <DetailsView hfModel={{...mockHFModel2, trendingScore: 21}} />,
    );

    // mockHFModel2 has trendingScore > 20
    expect(getByText('üî•')).toBeDefined();
  });

  it('renders model files section', () => {
    const {getByText} = render(<DetailsView hfModel={mockHFModel1} />);

    expect(getByText('Available GGUF Files')).toBeDefined();
    // Check if file names are displayed
    mockHFModel1.siblings.forEach(file => {
      expect(getByText(file.rfilename)).toBeDefined();
    });
  });
});



================================================
FILE: src/screens/ModelsScreen/HFModelSearch/DetailsView/ModelFileCard/index.ts
================================================
export {ModelFileCard} from './ModelFileCard';



================================================
FILE: src/screens/ModelsScreen/HFModelSearch/DetailsView/ModelFileCard/ModelFileCard.tsx
================================================
import React, {FC, useState, useContext, useMemo} from 'react';
import {Alert, View, StyleSheet, Pressable} from 'react-native';
import {computed} from 'mobx';
import {observer} from 'mobx-react';
import LinearGradient from 'react-native-linear-gradient';
import {
  IconButton,
  Text,
  Tooltip,
  Snackbar,
  Portal,
  Chip,
} from 'react-native-paper';

import {useTheme, useMemoryCheck} from '../../../../../hooks';
import {createStyles} from './styles';
import {modelStore} from '../../../../../store';
import {
  formatBytes,
  hfAsModel,
  L10nContext,
  isProjectionModel,
  getVisionModelSizeBreakdown,
  isVisionRepo,
} from '../../../../../utils';
import {isLegacyQuantization} from '../../../../../utils/modelSettings';
import {
  HuggingFaceModel,
  Model,
  ModelFile,
  ModelOrigin,
} from '../../../../../utils/types';
import {VisionDownloadSheet} from '../../../../../components';
import {ChevronRightIcon} from '../../../../../assets/icons';

interface ModelFileCardProps {
  modelFile: ModelFile;
  hfModel: HuggingFaceModel;
}

type Warning = {
  type: string;
  icon: string;
  message: string;
  shortMessage: string;
};

export const ModelFileCard: FC<ModelFileCardProps> = observer(
  ({modelFile, hfModel}) => {
    const [showWarning, setShowWarning] = useState(false);
    const [showVisionSheet, setShowVisionSheet] = useState(false);
    const theme = useTheme();
    const l10n = useContext(L10nContext);

    // Memoize to prevent unnecessary re-renders
    const isProjection = useMemo(
      () => isProjectionModel(modelFile.rfilename),
      [modelFile.rfilename],
    );
    const styles = useMemo(
      () => createStyles(theme, isProjection),
      [theme, isProjection],
    );
    const HF_YELLOW = '#FFD21E';

    // Check if we have all the necessary data, as some are fetched async, like size.
    const isModelInfoReady = Boolean(
      modelFile.size !== undefined && modelFile.canFitInStorage !== undefined,
    );

    const convertedModel = useMemo(
      () => hfAsModel(hfModel, modelFile),
      [hfModel, modelFile],
    );

    const storeModel = modelStore.models.find(m => m.id === convertedModel.id);

    const isDownloading = storeModel
      ? modelStore.isDownloading(storeModel.id)
      : false;
    const downloadProgress = storeModel?.progress || 0;
    const downloadSpeed = storeModel?.downloadSpeed;

    const isBookmarked = computed(() =>
      modelStore.models.some(model => model.hfModelFile?.oid === modelFile.oid),
    ).get();

    const isDownloaded = computed(() =>
      modelStore.models.some(
        model => model.hfModelFile?.oid === modelFile.oid && model.isDownloaded,
      ),
    ).get();

    const {shortMemoryWarning, multimodalWarning} = useMemoryCheck(
      convertedModel.size,
      convertedModel.supportsMultimodal,
    );

    const warnings = [
      !modelFile.canFitInStorage && {
        type: 'storage',
        icon: 'zip-disk',
        message: l10n.models.modelFile.warnings.storage.message,
        shortMessage: l10n.models.modelFile.warnings.storage.shortMessage,
      },
      shortMemoryWarning && {
        type: 'memory',
        icon: 'memory',
        message: l10n.models.modelFile.warnings.memory.message,
        shortMessage: shortMemoryWarning,
      },
      multimodalWarning && {
        type: 'multimodal',
        icon: 'alert-circle-outline',
        message: multimodalWarning,
        shortMessage: l10n.memory.shortWarning,
      },
      isLegacyQuantization(modelFile.rfilename) && {
        type: 'legacy',
        icon: 'alert-circle-outline',
        message: l10n.models.modelFile.warnings.legacy.message,
        shortMessage: l10n.models.modelFile.warnings.legacy.shortMessage,
      },
    ].filter((w): w is Warning => Boolean(w));

    const handleBookmark = () => {
      if (!isBookmarked) {
        modelStore.addHFModel(hfModel, modelFile);
      }
    };

    const handleUnbookmark = () => {
      if (isBookmarked) {
        const model = modelStore.models.find(
          (m: Model) => m.hfModelFile?.oid === modelFile.oid,
        );
        if (model?.origin === ModelOrigin.PRESET) {
          Alert.alert(
            l10n.models.modelFile.alerts.cannotRemoveTitle,
            l10n.models.modelFile.alerts.modelPreset,
          );
        } else if (model?.isDownloaded) {
          Alert.alert(
            l10n.models.modelFile.alerts.cannotRemoveTitle,
            l10n.models.modelFile.alerts.downloadedFirst,
          );
        } else if (model) {
          Alert.alert(
            l10n.models.modelFile.alerts.removeTitle,
            l10n.models.modelFile.alerts.removeMessage,
            [
              {text: l10n.common.cancel, style: 'cancel'},
              {
                text: l10n.models.modelFile.buttons.remove,
                onPress: () => {
                  const removed = modelStore.removeModelFromList(model);
                  if (!removed) {
                    Alert.alert(
                      'Error',
                      l10n.models.modelFile.alerts.removeError,
                    );
                  }
                },
              },
            ],
          );
        }
      }
    };

    const toggleBookmark = () => {
      if (isBookmarked) {
        handleUnbookmark();
      } else {
        handleBookmark();
      }
    };

    const handleDownload = () => {
      if (isDownloaded) {
        Alert.alert(
          l10n.models.modelFile.alerts.alreadyDownloadedTitle,
          l10n.models.modelFile.alerts.alreadyDownloadedMessage,
        );
      } else {
        // Direct download with default projection for all models
        // VisionDownloadSheet is only opened via the vision chip
        modelStore.downloadHFModel(hfModel, modelFile, {enableVision: true});
      }
    };

    const handleCancel = () => {
      if (storeModel && isDownloading) {
        modelStore.cancelDownload(storeModel.id);
      }
    };

    const handleDelete = () => {
      const model = modelStore.models.find(
        m => m.hfModelFile?.oid === modelFile.oid,
      );
      if (model?.isDownloaded) {
        Alert.alert(
          l10n.models.modelFile.alerts.deleteTitle,
          l10n.models.modelFile.alerts.deleteMessage,
          [
            {text: l10n.common.cancel, style: 'cancel'},
            {
              text: l10n.common.delete,
              onPress: async () => {
                await modelStore.deleteModel(model);
              },
            },
          ],
        );
      }
    };

    const downloadIcon = isDownloaded
      ? 'delete'
      : modelFile.canFitInStorage
      ? 'download-outline'
      : 'download-off-outline';

    const handleWarningPress = () => {
      setShowWarning(true);
    };

    const handleDismissWarning = () => {
      setShowWarning(false);
    };

    // Get enhanced size display for vision models
    const getEnhancedSizeDisplay = () => {
      if (!modelFile.size) {
        return '';
      }

      // Check if this is a vision model
      const isVision = isVisionRepo(hfModel.siblings || []);
      const isProjModel = isProjectionModel(modelFile.rfilename);
      const isVisionLLM = isVision && !isProjModel;

      if (isVisionLLM) {
        const sizeBreakdown = getVisionModelSizeBreakdown(modelFile, hfModel);
        if (sizeBreakdown.hasProjection) {
          return `${formatBytes(sizeBreakdown.totalSize, 2, false, true)}`;
        }
      }

      return formatBytes(modelFile.size, 2, false, true);
    };

    return (
      <View style={styles.fileCardContainer}>
        <LinearGradient
          colors={[theme.dark ? HF_YELLOW + '90' : HF_YELLOW, 'transparent']}
          locations={[1, 1]}
          start={{x: 0, y: 0}}
          end={{x: 1, y: 0}}
          style={[
            StyleSheet.absoluteFill,
            {width: `${downloadProgress}%`},
            styles.gradientBackground,
          ]}
        />
        <View style={styles.fileContent}>
          <View style={styles.header}>
            <View style={styles.fileInfo}>
              <Text
                variant="titleSmall"
                numberOfLines={1}
                ellipsizeMode="middle"
                style={styles.fileName}>
                {modelFile.rfilename}
              </Text>
              <View style={styles.metadataRow}>
                {isModelInfoReady && modelFile.size && (
                  <Text variant="labelSmall" style={styles.fileSize}>
                    {getEnhancedSizeDisplay()}
                  </Text>
                )}
                {isModelInfoReady && warnings.length > 0 && (
                  <Pressable onPress={handleWarningPress}>
                    <View style={styles.warningChip}>
                      <IconButton
                        icon={warnings[0].icon}
                        iconColor={theme.colors.onErrorContainer}
                        size={12}
                        style={styles.warningIcon}
                      />
                      <Text style={styles.warningText}>
                        {warnings.length > 1
                          ? l10n.models.modelFile.warnings.multiple.replace(
                              '{count}',
                              warnings.length.toString(),
                            )
                          : warnings[0].shortMessage}
                      </Text>
                    </View>
                  </Pressable>
                )}
                {Boolean(hfModel.gated) && (
                  <View style={styles.warningChip}>
                    <IconButton
                      icon="lock"
                      iconColor={theme.colors.primary}
                      size={12}
                      style={styles.warningIcon}
                    />
                    <Text style={styles.gatedText}>
                      {l10n.components.hfTokenSheet.gatedModelIndicator}
                    </Text>
                  </View>
                )}
              </View>

              {/* Vision indicator chip for multimodal models */}
              {convertedModel.supportsMultimodal && (
                <View style={styles.visionChipContainer}>
                  <Chip
                    mode="flat"
                    compact
                    icon="eye"
                    style={styles.visionChip}
                    textStyle={styles.visionChipText}
                    onPress={() => setShowVisionSheet(true)}>
                    {isDownloaded
                      ? l10n.models.multimodal.visionControls.visionEnabled
                      : l10n.models.multimodal.visionControls
                          .includesVisionCapability}
                  </Chip>
                  <ChevronRightIcon
                    width={16}
                    height={16}
                    stroke={theme.colors.onSurfaceVariant}
                  />
                </View>
              )}

              {/* Download Speed */}
              {isDownloading && downloadSpeed && (
                <Text variant="bodySmall" style={styles.downloadSpeed}>
                  {l10n.models.modelFile.labels.downloadSpeed.replace(
                    '{speed}',
                    downloadSpeed,
                  )}
                </Text>
              )}
            </View>
            <View style={styles.fileActions}>
              <IconButton
                testID="bookmark-button"
                icon={isBookmarked ? 'bookmark' : 'bookmark-outline'}
                onPress={toggleBookmark}
                size={20}
                animated
              />
              {isDownloading ? (
                <IconButton
                  testID="cancel-button"
                  icon="close"
                  onPress={handleCancel}
                  size={20}
                  animated
                />
              ) : (
                <Tooltip
                  enterTouchDelay={50}
                  title={
                    isModelInfoReady && !modelFile.canFitInStorage
                      ? l10n.models.modelFile.warnings.storage.message
                      : ''
                  }>
                  <View>
                    <IconButton
                      testID="download-button"
                      icon={downloadIcon}
                      onPress={
                        isDownloaded
                          ? handleDelete
                          : isDownloading
                          ? handleCancel
                          : handleDownload
                      }
                      size={20}
                      animated
                      disabled={
                        !isModelInfoReady ||
                        (!isDownloaded && !modelFile.canFitInStorage)
                      }
                    />
                  </View>
                </Tooltip>
              )}
            </View>
          </View>
        </View>
        <Portal>
          <Snackbar
            visible={showWarning}
            onDismiss={handleDismissWarning}
            duration={1000 + 2000 * warnings.length}
            style={styles.snackbarContainer}
            action={{
              label: l10n.common.dismiss,
              onPress: handleDismissWarning,
              labelStyle: {color: theme.colors.inverseSecondary},
            }}>
            <View style={styles.snackbarContent}>
              {warnings.map((warning, index) => (
                <Text key={warning.type} style={styles.snackbarText}>
                  {warnings.length > 1
                    ? `${index + 1}. ${warning.message}`
                    : warning.message}
                </Text>
              ))}
            </View>
          </Snackbar>
        </Portal>

        {/* Vision Download Options Sheet */}
        <VisionDownloadSheet
          isVisible={showVisionSheet}
          onClose={() => setShowVisionSheet(false)}
          hfModel={hfModel}
          modelFile={modelFile}
          convertedModel={convertedModel}
        />
      </View>
    );
  },
);



================================================
FILE: src/screens/ModelsScreen/HFModelSearch/DetailsView/ModelFileCard/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {Theme} from '../../../../../utils/types';

export const createStyles = (theme: Theme, isProjectionModel) =>
  StyleSheet.create({
    fileCardContainer: {
      marginVertical: 6,
      backgroundColor: isProjectionModel
        ? theme.colors.tertiaryContainer
        : theme.colors.surfaceVariant,
      borderRadius: 12,
      overflow: 'hidden', // Important for gradient containment
      position: 'relative', // For absolute positioning of gradient
    },
    gradientBackground: {
      position: 'absolute',
      left: 0,
      top: 0,
      bottom: 0,
      height: '100%', // Ensures full height
      borderRadius: 8,
    },
    fileContent: {
      padding: 12,
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 8,
      //marginBottom: 4,
    },
    fileInfo: {
      flex: 1,
      marginRight: 4,
    },
    fileNameContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      flexWrap: 'wrap',
      gap: 4,
    },
    fileName: {
      //fontSize: 14,
      color: isProjectionModel
        ? theme.colors.onTertiaryContainer
        : theme.colors.onSurface,
      letterSpacing: -0.2,
      flex: 1,
    },
    metadataRow: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 6,
      marginTop: 4,
      flexWrap: 'wrap',
    },
    visionChipContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 0,
      marginTop: 4,
      flexWrap: 'wrap',
      //backgroundColor: 'red',
    },
    fileSize: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.9,
    },
    fileActions: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: -4,
    },
    downloadSpeed: {
      //fontSize: 13,
      color: theme.colors.onSurfaceVariant,
      //fontWeight: '500',
    },
    fileSizeSeparator: {
      fontSize: 13,
      color: theme.colors.onSurfaceVariant,
      opacity: 0.5,
    },
    warningChip: {
      flexDirection: 'row',
      alignItems: 'center',
      backgroundColor: theme.colors.errorContainer,
      borderRadius: 12,
      paddingVertical: 2,
      paddingHorizontal: 6,
      gap: 4,
    },
    warningIcon: {
      width: 14,
      height: 14,
      margin: 0,
    },
    warningText: {
      fontSize: 12,
      color: theme.colors.onErrorContainer,
      fontWeight: '500',
    },
    progressContainer: {
      marginTop: 8,
    },
    progressBar: {
      height: 2,
      backgroundColor: theme.colors.primary,
      opacity: 0.2,
      borderRadius: 1,
      overflow: 'hidden',
    },
    progressFill: {
      position: 'absolute',
      left: 0,
      top: 0,
      bottom: 0,
      backgroundColor: theme.colors.primary,
      borderRadius: 1,
    },
    snackbarContent: {
      flexDirection: 'column',
      gap: 4,
    },
    snackbarText: {
      color: theme.colors.inverseOnSurface,
    },
    snackbarContainer: {
      marginBottom: 8,
      width: '90%',
      alignSelf: 'center',
    },
    gatedText: {
      color: theme.colors.primary,
      fontSize: 10,
    },
    visionChip: {
      backgroundColor: 'transparent',
      marginStart: 0,
      // borderColor: theme.colors.primary + '50',
      //height: 24,
    },
    visionChipText: {
      fontSize: 11,
      color: theme.colors.text,
      fontWeight: '500',
    },
  });



================================================
FILE: src/screens/ModelsScreen/HFModelSearch/DetailsView/ModelFileCard/__tests__/ModelFileCard.test.tsx
================================================
import React from 'react';
import {Alert} from 'react-native';

import {render, fireEvent, act} from '../../../../../../../jest/test-utils';
import {
  hfModel1,
  createModel,
  mockHFModel1,
  modelsList,
} from '../../../../../../../jest/fixtures/models';

import {ModelFileCard} from '../ModelFileCard';

import {downloadManager} from '../../../../../../services/downloads';

import {modelStore} from '../../../../../../store';

describe('ModelFileCard', () => {
  const mockModelFile = {
    rfilename: 'test-model.gguf',
    size: 1000 * 1000 * 500, // 1GB
    oid: 'test-oid',
    canFitInStorage: true,
  };
  let downloadedHFModel;

  beforeEach(() => {
    downloadedHFModel = createModel({
      ...hfModel1,
      isDownloaded: true,
    });
    modelStore.models = modelsList;
    jest.clearAllMocks();
    jest.spyOn(Alert, 'alert');

    (downloadManager.isDownloading as jest.Mock).mockReset();
  });

  it('renders correctly with initial props', () => {
    const {getByText} = render(
      <ModelFileCard modelFile={mockModelFile} hfModel={mockHFModel1} />,
    );

    expect(getByText('test-model.gguf')).toBeTruthy();
    expect(getByText('500 MB')).toBeTruthy();
  });

  it('handles bookmark toggle when not bookmarked', async () => {
    const {getByTestId} = render(
      <ModelFileCard modelFile={mockModelFile} hfModel={mockHFModel1} />,
    );

    await act(async () => {
      fireEvent.press(getByTestId('bookmark-button'));
    });

    expect(modelStore.addHFModel).toHaveBeenCalledWith(
      mockHFModel1,
      mockModelFile,
    );
  });

  it('shows alert when trying to remove downloaded model', async () => {
    modelStore.models = [downloadedHFModel];

    const {getByTestId} = render(
      <ModelFileCard
        modelFile={downloadedHFModel.hfModelFile!}
        hfModel={downloadedHFModel.hfModel!}
      />,
    );

    await act(async () => {
      fireEvent.press(getByTestId('bookmark-button'));
    });

    expect(Alert.alert).toHaveBeenCalledWith(
      'Cannot Remove',
      'The model is downloaded. Please delete the file first.',
    );
  });

  it('handles download initiation', async () => {
    const {getByTestId} = render(
      <ModelFileCard
        modelFile={mockHFModel1.siblings[0]}
        hfModel={mockHFModel1}
      />,
    );

    await act(async () => {
      fireEvent.press(getByTestId('download-button'));
    });

    expect(modelStore.downloadHFModel).toHaveBeenCalledWith(
      mockHFModel1,
      mockHFModel1.siblings[0],
      {enableVision: true},
    );
  });

  it('handles download cancellation', async () => {
    modelStore.models = [hfModel1];

    (downloadManager.isDownloading as jest.Mock).mockImplementation(modelId => {
      return modelId === hfModel1.id;
    });
    const {getByTestId} = render(
      <ModelFileCard
        modelFile={hfModel1.hfModelFile!}
        hfModel={hfModel1.hfModel!}
      />,
    );

    await act(async () => {
      fireEvent.press(getByTestId('cancel-button'));
    });

    expect(modelStore.cancelDownload).toHaveBeenCalledWith(hfModel1.id);
  });

  it('disables download button when storage is insufficient', () => {
    const insufficientStorageFile = {
      ...mockModelFile,
      canFitInStorage: false,
    };

    const {getByTestId} = render(
      <ModelFileCard
        modelFile={insufficientStorageFile}
        hfModel={mockHFModel1}
      />,
    );

    expect(
      getByTestId('download-button').props.accessibilityState.disabled,
    ).toBe(true);
  });

  it('shows delete confirmation for downloaded model', async () => {
    modelStore.models = [downloadedHFModel];

    const {getByTestId} = render(
      <ModelFileCard
        modelFile={downloadedHFModel.hfModelFile!}
        hfModel={downloadedHFModel.hfModel!}
      />,
    );

    await act(async () => {
      fireEvent.press(getByTestId('download-button'));
    });

    expect(Alert.alert).toHaveBeenCalledWith(
      'Delete Model',
      'Are you sure you want to delete this downloaded model?',
      expect.any(Array),
    );
  });
});



================================================
FILE: src/screens/ModelsScreen/HFModelSearch/SearchView/index.ts
================================================
export * from './SearchView';



================================================
FILE: src/screens/ModelsScreen/HFModelSearch/SearchView/SearchView.tsx
================================================
import React, {useState, useEffect, useContext} from 'react';
import {Keyboard, Platform, TouchableOpacity, View} from 'react-native';

import {observer} from 'mobx-react';
import {Text, Chip, Button} from 'react-native-paper';
import {useSafeAreaInsets} from 'react-native-safe-area-context';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import {KeyboardAwareScrollView} from 'react-native-keyboard-controller';
import {BottomSheetFlatList, BottomSheetView} from '@gorhom/bottom-sheet';

import {Divider, Searchbar, ModelTypeTag} from '../../../../components';

import {useTheme} from '../../../../hooks';

import {createStyles} from './styles';

import {hfStore} from '../../../../store';

import {HuggingFaceModel} from '../../../../utils/types';
import {
  extractHFModelTitle,
  formatNumber,
  timeAgo,
  L10nContext,
  isVisionRepo,
} from '../../../../utils';

interface SearchViewProps {
  testID?: string;
  onModelSelect: (model: HuggingFaceModel) => void;
  onChangeSearchQuery: (query: string) => void;
}

export const SearchView = observer(
  ({testID, onModelSelect, onChangeSearchQuery}: SearchViewProps) => {
    const theme = useTheme();
    const insets = useSafeAreaInsets();
    const l10n = useContext(L10nContext);
    const [keyboardVisible, setKeyboardVisible] = useState(false);

    useEffect(() => {
      const keyboardWillShow = Keyboard.addListener(
        Platform.OS === 'ios' ? 'keyboardWillShow' : 'keyboardDidShow',
        () => setKeyboardVisible(true),
      );
      const keyboardWillHide = Keyboard.addListener(
        Platform.OS === 'ios' ? 'keyboardWillHide' : 'keyboardDidHide',
        () => setKeyboardVisible(false),
      );

      return () => {
        keyboardWillShow.remove();
        keyboardWillHide.remove();
      };
    }, []);

    const styles = createStyles(theme, keyboardVisible ? 0 : insets.bottom);
    const [searchQuery, setSearchQuery] = useState('');

    const handleSearchChange = (query: string) => {
      setSearchQuery(query);
      onChangeSearchQuery(query);
    };

    const renderItem = ({item}: {item: HuggingFaceModel}) => {
      // Check if this is a vision repository
      const isVision = isVisionRepo(item.siblings || []);

      return (
        <TouchableOpacity key={item.id} onPress={() => onModelSelect(item)}>
          <Text variant="labelMedium" style={styles.modelAuthor}>
            {item.author}
          </Text>
          <View style={styles.modelNameContainer}>
            <Text style={styles.modelName}>{extractHFModelTitle(item.id)}</Text>
          </View>
          <View style={styles.statsContainer}>
            {isVision && (
              <ModelTypeTag type="vision" label={l10n.models.vision} />
            )}
            <View style={styles.statItem}>
              <Icon
                name="clock-outline"
                size={12}
                color={theme.colors.onSurfaceVariant}
              />
              <Text variant="labelSmall" style={styles.statText}>
                {timeAgo(item.lastModified, l10n, 'short')}
              </Text>
            </View>
            <View style={styles.statItem}>
              <Icon
                name="download-outline"
                size={12}
                color={theme.colors.onSurfaceVariant}
              />
              <Text variant="labelSmall" style={styles.statText}>
                {formatNumber(item.downloads)}
              </Text>
            </View>
            <View style={styles.statItem}>
              <Icon
                name="heart-outline"
                size={12}
                color={theme.colors.onSurfaceVariant}
              />
              <Text variant="labelSmall" style={styles.statText}>
                {formatNumber(item.likes)}
              </Text>
            </View>
            {Boolean(item.gated) && (
              <Chip compact mode="outlined" textStyle={styles.gatedChipText}>
                <Icon name="lock" size={12} color={theme.colors.primary} />{' '}
                {l10n.components.hfTokenSheet.gatedModelIndicator}
              </Chip>
            )}
          </View>
          <Divider style={styles.divider} />
        </TouchableOpacity>
      );
    };

    // Renders the appropriate empty state based on loading, error or no results
    const renderEmptyState = observer(() => {
      if (hfStore.isLoading) {
        console.log('renderEmptyState Loading');
        return null;
      }

      if (hfStore.error) {
        return (
          <View style={styles.emptyStateContainer}>
            <Icon
              name="alert-circle-outline"
              size={24}
              color={theme.colors.onSurfaceVariant}
            />
            <Text style={styles.noResultsText}>
              {l10n.models.search.errorOccurred}
            </Text>
            <Text style={styles.errorText}>{hfStore.error.message}</Text>
            {hfStore.error.code === 'authentication' && (
              <Text style={styles.errorHintText}>
                {l10n.components.hfTokenSheet.searchErrorHint}
              </Text>
            )}
            {hfStore.error.code === 'authentication' && hfStore.useHfToken && (
              <Button
                mode="outlined"
                style={styles.disableTokenButton}
                onPress={() => {
                  hfStore.setUseHfToken(false);
                  hfStore.clearError();
                  hfStore.fetchModels();
                }}>
                {l10n.components.hfTokenSheet.disableAndRetry}
              </Button>
            )}
          </View>
        );
      }

      if (searchQuery.length > 0) {
        return (
          <Text style={styles.noResultsText}>
            {l10n.models.search.noResults}
          </Text>
        );
      }

      return null;
    });

    return (
      <BottomSheetView style={styles.contentContainer} testID={testID}>
        <BottomSheetFlatList
          data={hfStore.models}
          keyExtractor={(item: HuggingFaceModel) => item.id}
          renderItem={renderItem}
          contentContainerStyle={styles.list}
          renderScrollComponent={props => (
            <KeyboardAwareScrollView bottomOffset={100} {...props} />
          )}
          onEndReached={() => {
            hfStore.fetchMoreModels();
          }}
          onEndReachedThreshold={0.3}
          maintainVisibleContentPosition={
            hfStore.models.length > 0
              ? {
                  minIndexForVisible: 0,
                }
              : null
          }
          ListEmptyComponent={renderEmptyState}
          ListFooterComponent={observer(() =>
            hfStore.isLoading ? (
              <Text style={styles.loadingMoreText}>
                {l10n.models.search.loadingMore}
              </Text>
            ) : null,
          )}
        />
        <Searchbar
          value={searchQuery}
          onChangeText={handleSearchChange}
          placeholder={l10n.models.search.searchPlaceholder}
          containerStyle={styles.searchbarContainer}
        />
      </BottomSheetView>
    );
  },
);



================================================
FILE: src/screens/ModelsScreen/HFModelSearch/SearchView/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {Theme} from '../../../../utils/types';

export const createStyles = (theme: Theme, bottomInset: number) =>
  StyleSheet.create({
    contentContainer: {
      flex: 1,
      justifyContent: 'space-between',
    },
    list: {
      padding: 16,
      paddingBottom: 100,
    },
    divider: {
      marginVertical: 12,
    },
    modelAuthor: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
      marginBottom: 2,
    },
    modelNameContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: 4,
      flexWrap: 'wrap',
    },
    modelName: {
      fontSize: 16,
      fontWeight: '500',
      color: theme.colors.onSurface,
    },
    statsContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 12,
    },
    statItem: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 4,
    },
    statText: {
      fontSize: 12,
      color: theme.colors.onSurfaceVariant,
    },
    noResultsText: {
      textAlign: 'center',
      marginTop: 20,
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
    },
    searchbarContainer: {
      position: 'absolute',
      bottom: bottomInset,
      left: 0,
      right: 0,
    },
    loadingMoreText: {
      textAlign: 'center',
      padding: 16,
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    gatedChipText: {
      fontSize: 10,
    },
    emptyStateContainer: {
      alignItems: 'center',
      justifyContent: 'center',
      marginTop: 20,
      marginBottom: 20,
      padding: 16,
      borderWidth: 1,
      borderColor: theme.colors.outline,
      borderRadius: 8,
      backgroundColor: theme.colors.surfaceVariant,
      width: '90%',
      alignSelf: 'center',
    },
    errorText: {
      color: theme.colors.error,
      marginTop: 8,
    },
    errorHintText: {
      color: theme.colors.onSurfaceVariant,
      marginTop: 8,
      textAlign: 'center',
      fontSize: 14,
      fontStyle: 'italic',
      paddingHorizontal: 20,
    },
    disableTokenButton: {
      marginTop: 10,
      alignSelf: 'center',
    },
  });



================================================
FILE: src/screens/ModelsScreen/ModelAccordion/index.ts
================================================
export * from './ModelAccordion';



================================================
FILE: src/screens/ModelsScreen/ModelAccordion/ModelAccordion.tsx
================================================
import React from 'react';
import {StyleSheet} from 'react-native';

import {List} from 'react-native-paper';
import {observer} from 'mobx-react-lite';

import {useTheme} from '../../../hooks';

import {styles} from './styles';

import {modelStore} from '../../../store';

interface ModelAccordionProps {
  group: any;
  expanded: boolean;
  onPress: () => void;
  children: React.ReactNode;
  description?: string;
}

export const ModelAccordion: React.FC<ModelAccordionProps> = observer(
  ({group, expanded, onPress, children, description}) => {
    const {colors} = useTheme();
    const activeModel = modelStore.activeModel;
    const activeGroup = activeModel && activeModel.type === group.type;

    const accordionStyles = StyleSheet.flatten([
      styles.accordion,
      activeGroup && {
        backgroundColor: colors.tertiaryContainer,
        borderColor: colors.primary,
      },
    ]);

    return (
      <List.Accordion
        testID={`model-accordion-${group.type}`}
        title={group.type}
        titleStyle={StyleSheet.flatten([
          styles.accordionTitle,
          {color: colors.secondary},
        ])}
        description={description}
        descriptionStyle={styles.accordionDescription}
        expanded={expanded}
        onPress={onPress}
        style={accordionStyles}>
        {children}
      </List.Accordion>
    );
  },
);



================================================
FILE: src/screens/ModelsScreen/ModelAccordion/styles.ts
================================================
import {StyleSheet} from 'react-native';

export const styles = StyleSheet.create({
  accordion: {
    borderRadius: 8,
    height: 55,
  },
  accordionTitle: {
    fontSize: 14,
  },
  accordionDescription: {
    fontSize: 12,
    paddingBottom: 10,
  },
});



================================================
FILE: src/screens/ModelsScreen/ModelAccordion/__tests__/ModelAccordion.test.tsx
================================================
import React from 'react';

import {List} from 'react-native-paper';
import {render, fireEvent} from '@testing-library/react-native';

import {themeFixtures} from '../../../../../jest/fixtures/theme';

import {ModelAccordion} from '../ModelAccordion';

import {modelStore} from '../../../../store';

describe('ModelAccordion', () => {
  beforeEach(() => {
    modelStore.activeModelId = undefined;
  });

  it('renders the accordion with correct title and children', () => {
    const group = {type: 'Test Group'};
    const {getByText} = render(
      <ModelAccordion group={group} expanded={true} onPress={jest.fn()}>
        <List.Item title="First item" />
        <List.Item title="Second item" />
      </ModelAccordion>,
    );

    expect(getByText('Test Group')).toBeTruthy();
    expect(getByText('First item')).toBeTruthy();
    expect(getByText('Second item')).toBeTruthy();
  });

  it('renders the accordion with correct title and children when expanded is false', () => {
    const group = {type: 'Test Group'};
    const {getByText, queryByText} = render(
      <ModelAccordion group={group} expanded={false} onPress={jest.fn()}>
        <List.Item title="First item" />
        <List.Item title="Second item" />
      </ModelAccordion>,
    );

    expect(getByText('Test Group')).toBeTruthy();
    expect(queryByText('First item')).toBeNull();
    expect(queryByText('Second item')).toBeNull();
  });

  it('calls onPress when the accordion is pressed', () => {
    const mockOnPress = jest.fn();
    const group = {type: 'Test Group'};

    const {getByText} = render(
      <ModelAccordion group={group} expanded={false} onPress={mockOnPress}>
        <List.Item title="Child Item" />
      </ModelAccordion>,
    );

    fireEvent.press(getByText('Test Group'));
    expect(mockOnPress).toHaveBeenCalled();
  });

  it('displays the expanded state correctly', async () => {
    const group = {type: 'Test Group'};

    const {getByText, queryByText, rerender} = render(
      <ModelAccordion group={group} expanded={false} onPress={jest.fn()}>
        <List.Item title="Child Item" />
      </ModelAccordion>,
    );

    expect(queryByText('Child Item')).toBeNull();

    rerender(
      <ModelAccordion group={group} expanded={true} onPress={jest.fn()}>
        <List.Item title="Child Item" />
      </ModelAccordion>,
    );

    expect(getByText('Child Item')).toBeTruthy();
  });

  it('applies active group styles when activeModel matches group type', () => {
    const activeModel = modelStore.models[0];
    modelStore.activeModelId = activeModel.id;

    const {getByTestId} = render(
      <ModelAccordion
        group={{type: activeModel.type}}
        expanded={false}
        onPress={jest.fn()}>
        <List.Item title="Child Item" />
      </ModelAccordion>,
    );

    const accordion = getByTestId(`model-accordion-${activeModel.type}`).parent;

    expect(accordion?.props.style).toEqual(
      // Wow, this is a mess.
      expect.arrayContaining([
        expect.arrayContaining([
          expect.objectContaining({
            backgroundColor: themeFixtures.lightTheme.colors.tertiaryContainer,
            borderColor: themeFixtures.lightTheme.colors.primary,
          }),
        ]),
      ]),
    );
  });
});



================================================
FILE: src/screens/ModelsScreen/ModelCard/index.ts
================================================
export * from './ModelCard';



================================================
FILE: src/screens/ModelsScreen/ModelCard/ModelCard.tsx
================================================
import React, {useCallback, useState, useEffect} from 'react';
import {Alert, Linking, View} from 'react-native';

import {observer} from 'mobx-react-lite';
import {useNavigation} from '@react-navigation/native';
import {DrawerNavigationProp} from '@react-navigation/drawer';
import {
  Card,
  ProgressBar,
  Button,
  IconButton,
  Text,
  TouchableRipple,
  HelperText,
  ActivityIndicator,
  Snackbar,
} from 'react-native-paper';

import {Divider, VisionControlSheet} from '../../../components';

import {useTheme, useMemoryCheck, useStorageCheck} from '../../../hooks';

import {createStyles} from './styles';

import {uiStore, modelStore} from '../../../store';

import {
  Model,
  ModelOrigin,
  ModelType,
  RootDrawerParamList,
} from '../../../utils/types';
import {
  getModelDescription,
  L10nContext,
  checkModelFileIntegrity,
} from '../../../utils';
import {SkillsDisplay} from '../../../components';

type ChatScreenNavigationProp = DrawerNavigationProp<RootDrawerParamList>;

interface ModelCardProps {
  model: Model;
  activeModelId?: string;
  onFocus?: () => void;
  onOpenSettings?: () => void;
}

export const ModelCard: React.FC<ModelCardProps> = observer(
  ({model, activeModelId, onOpenSettings}) => {
    const l10n = React.useContext(L10nContext);
    const theme = useTheme();
    const styles = createStyles(theme);

    const navigation = useNavigation<ChatScreenNavigationProp>();

    const [snackbarVisible, setSnackbarVisible] = useState(false); // Snackbar visibility
    const [integrityError, setIntegrityError] = useState<string | null>(null);

    const [showVisionControlSheet, setShowVisionControlSheet] = useState(false);

    const {memoryWarning, shortMemoryWarning, multimodalWarning} =
      useMemoryCheck(model.size, model.supportsMultimodal);
    const {isOk: storageOk, message: storageNOkMessage} = useStorageCheck(
      model,
      {enablePeriodicCheck: true, checkInterval: 10000},
    );

    const isActiveModel = activeModelId === model.id;
    const isDownloaded = model.isDownloaded;
    const isDownloading = modelStore.isDownloading(model.id);
    const isHfModel = model.origin === ModelOrigin.HF;

    // Check projection model status for downloaded vision models
    const projectionModelStatus = modelStore.getProjectionModelStatus(model);
    const hasProjectionModelWarning =
      isDownloaded &&
      model.supportsMultimodal &&
      modelStore.getModelVisionPreference(model) && // Only show warning when vision is enabled
      projectionModelStatus.state === 'missing';

    // Check integrity when model is downloaded
    useEffect(() => {
      if (isDownloaded) {
        checkModelFileIntegrity(model).then(({errorMessage}) => {
          setIntegrityError(errorMessage);
        });
      } else {
        setIntegrityError(null);
      }
    }, [isDownloaded, model]);

    const handleDelete = useCallback(() => {
      if (model.isDownloaded) {
        // Special handling for projection models
        if (model.modelType === ModelType.PROJECTION) {
          const canDeleteResult = modelStore.canDeleteProjectionModel(model.id);

          if (!canDeleteResult.canDelete) {
            // Show error dialog with specific reason
            let message =
              canDeleteResult.reason ||
              l10n.models.multimodal.cannotDeleteTitle;

            if (
              canDeleteResult.reason === 'Projection model is currently active'
            ) {
              message = l10n.models.multimodal.cannotDeleteActive;
            } else if (
              canDeleteResult.dependentModels &&
              canDeleteResult.dependentModels.length > 0
            ) {
              const modelNames = canDeleteResult.dependentModels
                .map(m => m.name)
                .join(', ');
              message = `${l10n.models.multimodal.cannotDeleteInUse}\n\n${l10n.models.multimodal.dependentModels} ${modelNames}`;
            }

            Alert.alert(l10n.models.multimodal.cannotDeleteTitle, message, [
              {text: l10n.common.ok, style: 'default'},
            ]);
            return;
          }

          // Show projection-specific confirmation dialog
          Alert.alert(
            l10n.models.multimodal.deleteProjectionTitle,
            l10n.models.multimodal.deleteProjectionMessage,
            [
              {text: l10n.common.cancel, style: 'cancel'},
              {
                text: l10n.common.delete,
                style: 'destructive',
                onPress: async () => {
                  try {
                    await modelStore.deleteModel(model);
                  } catch (error) {
                    console.error('Failed to delete projection model:', error);
                    Alert.alert(
                      l10n.models.multimodal.cannotDeleteTitle,
                      error instanceof Error
                        ? error.message
                        : 'Unknown error occurred',
                      [{text: l10n.common.ok, style: 'default'}],
                    );
                  }
                },
              },
            ],
          );
        } else {
          // Standard model deletion
          Alert.alert(
            l10n.models.modelCard.alerts.deleteTitle,
            l10n.models.modelCard.alerts.deleteMessage,
            [
              {text: l10n.common.cancel, style: 'cancel'},
              {
                text: l10n.common.delete,
                onPress: async () => {
                  await modelStore.deleteModel(model);
                },
              },
            ],
          );
        }
      }
    }, [model, l10n]);

    const openHuggingFaceUrl = useCallback(() => {
      if (model.hfUrl) {
        Linking.openURL(model.hfUrl).catch(err => {
          console.error('Failed to open URL:', err);
          setSnackbarVisible(true);
        });
      }
    }, [model.hfUrl]);

    const handleRemove = useCallback(() => {
      Alert.alert(
        l10n.models.modelCard.alerts.removeTitle,
        l10n.models.modelCard.alerts.removeMessage,
        [
          {text: l10n.common.cancel, style: 'cancel'},
          {
            text: l10n.models.modelCard.buttons.remove,
            style: 'destructive',
            onPress: () => modelStore.removeModelFromList(model),
          },
        ],
      );
    }, [model, l10n]);

    const handleWarningPress = () => {
      setSnackbarVisible(true);
    };

    const handleProjectionWarningPress = useCallback(() => {
      if (model.defaultProjectionModel) {
        // Try to download the missing projection model
        modelStore.checkSpaceAndDownload(model.defaultProjectionModel);
      } else {
        // Show vision control sheet to select projection model
        setShowVisionControlSheet(true);
      }
    }, [model.defaultProjectionModel]);

    const renderDownloadOverlay = () => (
      <View>
        {!storageOk && (
          <HelperText
            testID="storage-error-text"
            type="error"
            visible={!storageOk}
            padding="none"
            style={styles.storageErrorText}>
            {storageNOkMessage}
          </HelperText>
        )}
        <View style={styles.overlayButtons}>
          {isHfModel && (
            <Button
              testID="remove-model-button"
              icon="delete-outline"
              mode="text"
              textColor={theme.colors.error}
              onPress={handleRemove}
              style={styles.removeButton}>
              {l10n.models.modelCard.buttons.remove}
            </Button>
          )}
          {storageOk && (
            <Button
              testID="download-button"
              icon="download"
              mode="text"
              onPress={() => modelStore.checkSpaceAndDownload(model.id)}
              disabled={!storageOk}
              textColor={theme.colors.secondary}
              style={styles.downloadButton}>
              {l10n.models.modelCard.buttons.download}
            </Button>
          )}
        </View>
      </View>
    );

    const renderModelLoadButton = () => {
      if (
        modelStore.isContextLoading &&
        modelStore.loadingModel?.id === model.id
      ) {
        return (
          <View style={styles.loadingContainer}>
            <ActivityIndicator
              testID="loading-indicator"
              animating={true}
              color={theme.colors.primary}
            />
          </View>
        );
      }

      const handlePress = async () => {
        if (isActiveModel) {
          modelStore.manualReleaseContext();
        } else {
          try {
            await modelStore.initContext(model);
            if (uiStore.autoNavigatetoChat) {
              navigation.navigate('Chat');
            }
          } catch (e) {
            console.log(`Error: ${e}`);
          }
        }
      };

      return (
        <Button
          testID={isActiveModel ? 'offload-button' : 'load-button'}
          icon={isActiveModel ? 'eject' : 'play-circle-outline'}
          mode="text"
          onPress={handlePress}
          // disabled={!!integrityError} // for now integrity check is experimental. So won't disable the button
          style={styles.actionButton}>
          {isActiveModel
            ? l10n.models.modelCard.buttons.offload
            : l10n.models.modelCard.buttons.load}
        </Button>
      );
    };

    return (
      <>
        <Card
          elevation={0}
          style={[
            styles.card,
            {backgroundColor: theme.colors.surface},
            isActiveModel && {backgroundColor: theme.colors.tertiaryContainer},
            {borderColor: theme.colors.primary},
          ]}>
          <View style={styles.cardInner}>
            <View style={styles.cardContent}>
              <View style={styles.headerRow}>
                <View style={styles.modelInfoContainer}>
                  <View style={styles.titleRow}>
                    <Text style={[styles.modelName]}>{model.name}</Text>

                    {model.hfUrl && (
                      <IconButton
                        testID="open-huggingface-url"
                        icon="open-in-new"
                        size={14}
                        iconColor={theme.colors.onSurfaceVariant}
                        onPress={openHuggingFaceUrl}
                        style={styles.hfButton}
                      />
                    )}
                  </View>
                  <Text style={styles.modelDescription}>
                    {getModelDescription(model, isActiveModel, l10n)}
                  </Text>
                  <SkillsDisplay
                    model={model}
                    onVisionPress={
                      model.supportsMultimodal
                        ? () => setShowVisionControlSheet(true)
                        : undefined
                    }
                    visionEnabled={modelStore.getModelVisionPreference(model)}
                    visionAvailable={projectionModelStatus.isAvailable}
                    hasProjectionModelWarning={hasProjectionModelWarning}
                    onProjectionWarningPress={handleProjectionWarningPress}
                  />
                </View>
              </View>

              {/* Display warning icon if there's a memory or multimodal warning */}
              {(shortMemoryWarning || multimodalWarning) && isDownloaded && (
                <TouchableRipple
                  testID="memory-warning-button"
                  onPress={handleWarningPress}
                  style={styles.warningContainer}>
                  <View style={styles.warningContent}>
                    <IconButton
                      icon="alert-circle-outline"
                      iconColor={theme.colors.error}
                      size={20}
                      style={styles.warningIcon}
                    />
                    <Text style={styles.warningText}>
                      {shortMemoryWarning || multimodalWarning}
                    </Text>
                  </View>
                </TouchableRipple>
              )}

              {/* Display integrity warning if check fails */}
              {integrityError && (
                <TouchableRipple
                  testID="integrity-warning-button"
                  //onPress={handleWarningPress}
                  style={styles.warningContainer}>
                  <View style={styles.warningContent}>
                    <IconButton
                      icon="alert-circle-outline"
                      iconColor={theme.colors.error}
                      size={20}
                      style={styles.warningIcon}
                    />
                    <Text style={styles.warningText}>{integrityError}</Text>
                  </View>
                </TouchableRipple>
              )}

              {isDownloading && (
                <>
                  <ProgressBar
                    testID="download-progress-bar"
                    progress={model.progress / 100}
                    color={theme.colors.tertiary}
                    style={styles.progressBar}
                  />
                  {model.downloadSpeed && (
                    <Text style={styles.downloadSpeed}>
                      {model.downloadSpeed}
                    </Text>
                  )}
                </>
              )}
            </View>

            <Divider style={styles.divider} />

            {isDownloaded ? (
              <Card.Actions style={styles.actions}>
                <Button
                  testID="delete-button"
                  icon="delete"
                  mode="text"
                  compact
                  textColor={theme.colors.error}
                  onPress={() => handleDelete()}
                  style={styles.actionButton}>
                  {l10n.common.delete}
                </Button>
                <View style={styles.settingsContainer}>
                  <Button
                    testID="settings-button"
                    icon="tune"
                    mode="text"
                    compact
                    onPress={onOpenSettings}>
                    {l10n.models.modelCard.buttons.settings}
                  </Button>
                  <IconButton
                    icon="chevron-down"
                    size={14}
                    style={styles.settingsChevron}
                  />
                </View>
                {renderModelLoadButton()}
              </Card.Actions>
            ) : isDownloading ? (
              <Card.Actions style={styles.actions}>
                <View style={styles.overlayButtons}>
                  <Button
                    testID="cancel-button"
                    icon="close"
                    mode="text"
                    textColor={theme.colors.error}
                    onPress={() => modelStore.cancelDownload(model.id)}>
                    {l10n.common.cancel}
                  </Button>
                </View>
              </Card.Actions>
            ) : (
              renderDownloadOverlay()
            )}
          </View>
        </Card>
        {/* Snackbar to show full memory warning */}
        <Snackbar
          testID="memory-warning-snackbar"
          visible={snackbarVisible}
          onDismiss={() => setSnackbarVisible(false)}
          duration={Snackbar.DURATION_MEDIUM}
          action={{
            label: l10n.common.dismiss,
            onPress: () => {
              setSnackbarVisible(false);
            },
          }}>
          {memoryWarning ||
            multimodalWarning ||
            (hasProjectionModelWarning &&
              l10n.models.multimodal.projectionMissingWarning)}
        </Snackbar>

        {/* Vision Control Sheet */}
        <VisionControlSheet
          isVisible={showVisionControlSheet}
          onClose={() => setShowVisionControlSheet(false)}
          model={model}
        />
      </>
    );
  },
);



================================================
FILE: src/screens/ModelsScreen/ModelCard/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {Theme} from '../../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    card: {
      borderRadius: 15,
      margin: 6,
      overflow: 'visible', // This ensures the badge can overflow the card
      position: 'relative',
      padding: 0,
    },
    hfBadge: {
      position: 'absolute',
      top: -11,
      right: -5,
      width: 24,
      height: 24,
      zIndex: 1,
      resizeMode: 'contain',
    },
    touchableRipple: {
      zIndex: 1,
    },
    cardInner: {},
    cardContent: {
      paddingTop: 8,
      paddingHorizontal: 15,
    },
    progressBar: {
      height: 8,
      borderRadius: 5,
      marginTop: 8,
    },
    actions: {
      paddingHorizontal: 8,
      paddingVertical: 2,
    },
    actionButton: {
      margin: 0,
    },
    settingsContainer: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
    },
    settingsButton: {
      flex: 1,
    },
    settingsChevron: {
      margin: 0,
      marginLeft: -12,
    },
    errorText: {
      textAlign: 'center',
      marginBottom: 8,
    },
    downloadSpeed: {
      textAlign: 'right',
      fontSize: 12,
      marginTop: 5,
    },
    headerRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'flex-start',
    },
    modelInfoContainer: {
      flex: 1,
      marginRight: 8,
    },
    modelName: {
      fontSize: 16,
      fontWeight: 'bold',
      flexDirection: 'row',
      alignItems: 'center',
    },
    titleRow: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    modelDescription: {
      fontSize: 12,
      marginVertical: 4,
      color: theme.colors.onSurfaceVariant,
    },
    hfButton: {
      margin: 0,
      padding: 0,
      zIndex: 2,
    },
    settings: {
      //paddingHorizontal: 15,
    },
    warningContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      margin: 0,
      marginTop: 8,
    },
    warningContent: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
    },
    warningIcon: {
      marginLeft: 0,
      marginRight: 2,
    },
    warningText: {
      color: theme.colors.error,
      fontSize: 12,
      flex: 1,
      flexWrap: 'wrap',
    },
    overlayButtons: {
      flex: 1,
      flexDirection: 'row',
      justifyContent: 'space-around',
    },
    downloadButton: {
      minWidth: 100,
      color: theme.colors.secondary,
    },
    removeButton: {
      minWidth: 100,
    },
    storageErrorText: {
      fontWeight: 'bold',
      marginHorizontal: 8,
    },
    loadingContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      padding: 10,
      width: 100,
    },
    divider: {
      marginTop: 8,
    },
    sheetScrollViewContainer: {
      padding: 16,
    },
    visionToggleContainer: {
      paddingHorizontal: 15,
      paddingVertical: 8,
    },
    visionToggle: {
      marginVertical: 4,
    },
  });



================================================
FILE: src/screens/ModelsScreen/ModelCard/__tests__/ModelCard.test.tsx
================================================
import React from 'react';
import {Linking, Alert} from 'react-native';

import {render, fireEvent, waitFor, act} from '../../../../../jest/test-utils';
import {
  basicModel,
  downloadedModel,
  downloadingModel,
  largeMemoryModel,
} from '../../../../../jest/fixtures/models';

// Unmock useMemoryCheck for memory warning tests
jest.unmock('../../../../hooks/useMemoryCheck');

import {ModelCard} from '../ModelCard';

import {downloadManager} from '../../../../services/downloads';

import {modelStore, uiStore} from '../../../../store';
import {ModelType} from '../../../../utils/types';

import {l10n} from '../../../../utils/l10n';

jest.useFakeTimers(); // Mock all timers

jest.mock('react-native/Libraries/Linking/Linking', () => ({
  openURL: jest.fn().mockImplementation(() => Promise.resolve()),
  addEventListener: jest.fn(),
  removeEventListener: jest.fn(),
  canOpenURL: jest.fn().mockImplementation(() => Promise.resolve(true)),
  getInitialURL: jest.fn().mockImplementation(() => Promise.resolve(null)),
}));

const mockNavigate = jest.fn();
jest.mock('@react-navigation/native', () => ({
  ...jest.requireActual('@react-navigation/native'),
  useNavigation: () => ({
    navigate: mockNavigate,
  }),
}));

const customRender = (ui, {...renderOptions} = {}) => {
  return render(ui, {...renderOptions, withNavigation: true});
};

describe('ModelCard', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders model details correctly', async () => {
    const {getByText} = customRender(<ModelCard model={basicModel} />);
    await waitFor(() => {
      expect(getByText(basicModel.name)).toBeTruthy();
    });
  });

  it('handles memory warning correctly', async () => {
    const {getByText, getByTestId, queryByText, queryByTestId} = customRender(
      <ModelCard model={largeMemoryModel} />,
    );

    // If the model is downloaded and the device is low on memory, the warning should be displayed.
    await waitFor(() => {
      expect(getByText(l10n.en.memory.shortWarning)).toBeTruthy();
      expect(queryByTestId('memory-warning-snackbar')).toBeNull();
    });

    // Snackbar
    act(() => {
      fireEvent.press(getByTestId('memory-warning-button'));
    });
    await waitFor(() => {
      expect(getByText(l10n.en.common.dismiss)).toBeTruthy();
      expect(queryByTestId('memory-warning-snackbar')).toBeTruthy();
    });
    act(() => {
      fireEvent.press(getByText(l10n.en.common.dismiss));
    });
    await waitFor(() => {
      expect(queryByText(l10n.en.common.dismiss)).toBeNull();
      expect(queryByTestId('memory-warning-snackbar')).toBeNull();
    });
  }, 10000);

  it('handles download overlay and download button correctly', async () => {
    if (!jest.isMockFunction(modelStore.checkSpaceAndDownload)) {
      jest.spyOn(modelStore, 'checkSpaceAndDownload');
    }

    const {getByTestId, queryByTestId} = customRender(
      <ModelCard model={basicModel} />,
    );

    await waitFor(() => {
      expect(getByTestId('download-button')).toBeTruthy();
      expect(queryByTestId('download-progress-bar')).toBeNull();
    });
    const downloadButton = getByTestId('download-button');

    act(() => {
      fireEvent.press(downloadButton);
    });

    expect(modelStore.checkSpaceAndDownload).toHaveBeenCalledWith(
      basicModel.id,
    );
  });

  it('progress bar is shown when downloading', async () => {
    // Mock the isDownloading method to return true for the downloadingModel
    (downloadManager.isDownloading as jest.Mock).mockImplementation(modelId => {
      return modelId === downloadingModel.id;
    });

    // Mock the getDownloadProgress method to return a progress value
    (downloadManager.getDownloadProgress as jest.Mock).mockImplementation(
      modelId => {
        return modelId === downloadingModel.id ? 50 : 0; // 50% progress
      },
    );

    const {getByTestId, queryByTestId, rerender} = render(
      <ModelCard model={basicModel} />,
    );

    await waitFor(() => {
      expect(getByTestId('download-button')).toBeTruthy();
      expect(queryByTestId('download-progress-bar')).toBeNull();
    });

    rerender(<ModelCard model={downloadingModel} />);

    await waitFor(() => {
      expect(getByTestId('download-progress-bar')).toBeTruthy();
    });
  });

  it('opens the HuggingFace URL when the icon button is pressed', () => {
    const {getByTestId} = customRender(<ModelCard model={basicModel} />);

    const openButton = getByTestId('open-huggingface-url');
    fireEvent.press(openButton);

    expect(Linking.openURL).toHaveBeenCalledWith(basicModel.hfUrl);
  });

  it('handles model load correctly', async () => {
    const {getByTestId} = customRender(<ModelCard model={downloadedModel} />);

    expect(getByTestId('load-button')).toBeTruthy();

    act(() => {
      fireEvent.press(getByTestId('load-button'));
    });

    expect(modelStore.initContext).toHaveBeenCalledWith(downloadedModel);
    expect(mockNavigate).not.toHaveBeenCalled();

    uiStore.autoNavigatetoChat = true;
    act(() => {
      fireEvent.press(getByTestId('load-button'));
    });
    await waitFor(() => {
      expect(mockNavigate).toHaveBeenCalledWith('Chat');
    });
  });

  it('handles model offload', async () => {
    const {getByTestId} = customRender(
      <ModelCard model={downloadedModel} activeModelId={downloadedModel.id} />,
    );

    expect(getByTestId('offload-button')).toBeTruthy();

    act(() => {
      fireEvent.press(getByTestId('offload-button'));
    });

    expect(modelStore.manualReleaseContext).toHaveBeenCalled();
  });

  // Add tests for delete functionality
  describe('Delete functionality', () => {
    beforeEach(() => {
      jest.clearAllMocks();
      jest.spyOn(Alert, 'alert').mockImplementation();
    });

    it('shows delete confirmation for regular models', async () => {
      const {getByTestId} = customRender(<ModelCard model={downloadedModel} />);

      const deleteButton = getByTestId('delete-button');
      fireEvent.press(deleteButton);

      expect(Alert.alert).toHaveBeenCalledWith(
        expect.stringContaining('Delete'),
        expect.stringContaining('delete'),
        expect.arrayContaining([
          expect.objectContaining({text: 'Cancel'}),
          expect.objectContaining({text: 'Delete'}),
        ]),
      );
    });

    it('handles delete confirmation for regular models', async () => {
      (Alert.alert as jest.Mock).mockImplementation(
        (title, message, buttons) => {
          // Simulate pressing "Delete" button
          buttons[1].onPress();
        },
      );

      const {getByTestId} = customRender(<ModelCard model={downloadedModel} />);

      const deleteButton = getByTestId('delete-button');
      fireEvent.press(deleteButton);

      expect(modelStore.deleteModel).toHaveBeenCalledWith(downloadedModel);
    });

    it('shows special confirmation for projection models', async () => {
      const projectionModel = {
        ...downloadedModel,
        modelType: ModelType.PROJECTION,
      };

      const {getByTestId} = customRender(<ModelCard model={projectionModel} />);

      const deleteButton = getByTestId('delete-button');
      fireEvent.press(deleteButton);

      expect(Alert.alert).toHaveBeenCalledWith(
        expect.stringContaining('Delete'),
        expect.stringContaining('projection'),
        expect.arrayContaining([
          expect.objectContaining({text: 'Cancel'}),
          expect.objectContaining({text: 'Delete'}),
        ]),
      );
    });
  });

  // Add tests for download cancellation
  describe('Download cancellation', () => {
    beforeEach(() => {
      jest.clearAllMocks();
    });

    it('shows cancel button when downloading', async () => {
      (downloadManager.isDownloading as jest.Mock).mockReturnValue(true);

      const {getByTestId} = customRender(
        <ModelCard model={downloadingModel} />,
      );

      await waitFor(() => {
        expect(getByTestId('cancel-button')).toBeTruthy();
      });
    });

    it('handles download cancellation', async () => {
      (downloadManager.isDownloading as jest.Mock).mockReturnValue(true);

      const {getByTestId} = customRender(
        <ModelCard model={downloadingModel} />,
      );

      const cancelButton = getByTestId('cancel-button');
      fireEvent.press(cancelButton);

      expect(modelStore.cancelDownload).toHaveBeenCalledWith(
        downloadingModel.id,
      );
    });
  });

  // Add tests for settings functionality
  describe('Settings functionality', () => {
    const mockOnOpenSettings = jest.fn();

    beforeEach(() => {
      jest.clearAllMocks();
    });

    it('calls onOpenSettings when settings button is pressed', async () => {
      const {getByTestId} = customRender(
        <ModelCard
          model={downloadedModel}
          onOpenSettings={mockOnOpenSettings}
        />,
      );

      const settingsButton = getByTestId('settings-button');
      fireEvent.press(settingsButton);

      expect(mockOnOpenSettings).toHaveBeenCalled();
    });
  });

  // Add tests for loading states
  describe('Loading states', () => {
    beforeEach(() => {
      jest.clearAllMocks();

      // Reset modelStore to a clean state
      modelStore.isContextLoading = false;
      modelStore.loadingModel = undefined;
      modelStore.initContext = jest.fn(); // optional: re-mock if necessary
    });

    it('shows loading indicator when model is being loaded', async () => {
      modelStore.isContextLoading = true;
      modelStore.loadingModel = downloadedModel;

      const {getByTestId} = customRender(<ModelCard model={downloadedModel} />);

      await waitFor(() => {
        expect(getByTestId('loading-indicator')).toBeTruthy();
      });
    });

    it('handles model loading errors', async () => {
      const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();
      (modelStore.initContext as jest.Mock).mockRejectedValue(
        new Error('Loading failed'),
      );

      const {getByTestId} = customRender(<ModelCard model={downloadedModel} />);

      const loadButton = getByTestId('load-button');
      fireEvent.press(loadButton);

      await waitFor(() => {
        expect(consoleLogSpy).toHaveBeenCalledWith(
          'Error: Error: Loading failed',
        );
      });

      consoleLogSpy.mockRestore();
    });
  });

  // Add tests for projection model functionality
  describe('Projection model functionality', () => {
    const projectionModel = {
      ...downloadedModel,
      modelType: ModelType.PROJECTION,
      id: 'test/projection-model',
    };

    const visionModel = {
      ...downloadedModel,
      supportsMultimodal: true,
      defaultProjectionModel: projectionModel.id,
    };

    beforeEach(() => {
      jest.clearAllMocks();
    });

    it('shows vision control sheet for vision models', async () => {
      const {getByTestId, getByText} = customRender(
        <ModelCard model={visionModel} />,
      );

      await waitFor(() => {
        expect(getByText('Vision')).toBeTruthy();
      });
      const visionTag = getByTestId('vision-skill-touchable');
      fireEvent.press(visionTag);

      // Should open vision control sheet with projection selector inside
      await waitFor(() => {
        expect(getByTestId('projection-model-selector')).toBeTruthy();
      });
    });

    it('handles projection model selection', async () => {
      const {getByTestId} = customRender(<ModelCard model={visionModel} />);
      (modelStore.getCompatibleProjectionModels as jest.Mock) = jest
        .fn()
        .mockReturnValue([projectionModel]);

      const visionTag = getByTestId('vision-skill-touchable');
      fireEvent.press(visionTag);

      await waitFor(() => {
        expect(getByTestId('projection-model-selector')).toBeTruthy();
      });

      const projectionModelButton = getByTestId(
        'select-projection-model-button',
      );
      fireEvent.press(projectionModelButton);

      expect(modelStore.setDefaultProjectionModel).toHaveBeenCalledWith(
        visionModel.id,
        expect.any(String),
      );
    });

    it('shows projection model warning badge when projection model is missing', async () => {
      const visionModelWithMissingProjection = {
        ...downloadedModel,
        supportsMultimodal: true,
        defaultProjectionModel: 'missing/projection-model',
      };

      // Mock getProjectionModelStatus to return false
      (modelStore.getProjectionModelStatus as jest.Mock) = jest
        .fn()
        .mockReturnValue({isAvailable: false, state: 'missing'});

      const {getByTestId} = customRender(
        <ModelCard model={visionModelWithMissingProjection} />,
      );

      await waitFor(() => {
        expect(getByTestId('projection-warning-badge')).toBeTruthy();
      });
    });

    it('handles projection warning badge press to download missing projection model', async () => {
      const visionModelWithMissingProjection = {
        ...downloadedModel,
        supportsMultimodal: true,
        defaultProjectionModel: 'missing/projection-model',
      };

      // Mock getProjectionModelStatus to return false
      (modelStore.getProjectionModelStatus as jest.Mock) = jest
        .fn()
        .mockReturnValue({isAvailable: false, state: 'missing'});

      const {getByTestId} = customRender(
        <ModelCard model={visionModelWithMissingProjection} />,
      );

      const warningBadge = getByTestId('projection-warning-badge');
      fireEvent.press(warningBadge);

      expect(modelStore.checkSpaceAndDownload).toHaveBeenCalledWith(
        'missing/projection-model',
      );
    });
  });
});



================================================
FILE: src/screens/ModelsScreen/ModelSettings/index.ts
================================================
export * from './ModelSettings';



================================================
FILE: src/screens/ModelsScreen/ModelSettings/ModelSettings.tsx
================================================
import React, {useEffect, useRef, useState, useContext} from 'react';
import {TextInput as RNTextInput} from 'react-native';
import {View, Keyboard} from 'react-native';

import {Button, Text, Switch, Chip} from 'react-native-paper';
import LinearGradient from 'react-native-linear-gradient';
import MaskedView from '@react-native-masked-view/masked-view';

import {Divider, TextInput} from '../../../components';

import {useTheme} from '../../../hooks';

import {createStyles} from './styles';
import {ChatTemplatePicker} from '../ChatTemplatePicker';

import {ChatTemplateConfig} from '../../../utils/types';
import {Sheet} from '../../../components/Sheet';
import {L10nContext} from '../../../utils';
import {CompletionParams} from '../../../utils/completionTypes';

interface ModelSettingsProps {
  chatTemplate: ChatTemplateConfig;
  stopWords: CompletionParams['stop'];
  onChange: (name: string, value: any) => void;
  onStopWordsChange: (stopWords: CompletionParams['stop']) => void;
}

export const ModelSettings: React.FC<ModelSettingsProps> = ({
  chatTemplate,
  stopWords,
  onChange,
  onStopWordsChange,
}) => {
  const l10n = useContext(L10nContext);
  const [isDialogVisible, setDialogVisible] = useState<boolean>(false);
  const [localChatTemplate, setLocalChatTemplate] = useState(
    chatTemplate.chatTemplate,
  );
  const [newStopWord, setNewStopWord] = useState('');

  const [selectedTemplateName, setSelectedTemplateName] = useState(
    chatTemplate.name,
  );

  const theme = useTheme();
  const styles = createStyles(theme);

  const textInputRef = useRef<RNTextInput>(null);

  useEffect(() => {
    setLocalChatTemplate(chatTemplate.chatTemplate);
    setSelectedTemplateName(chatTemplate.name);
  }, [chatTemplate]);

  useEffect(() => {
    if (textInputRef.current) {
      textInputRef.current.setNativeProps({text: localChatTemplate});
    }
  }, [localChatTemplate, isDialogVisible]);

  useEffect(() => {
    if (selectedTemplateName !== chatTemplate.name) {
      if (
        chatTemplate.chatTemplate !== undefined &&
        chatTemplate.chatTemplate !== null
      ) {
        setLocalChatTemplate(chatTemplate.chatTemplate);
      }
    }
  }, [chatTemplate.name, selectedTemplateName, chatTemplate.chatTemplate]);

  const handleSave = () => {
    onChange('chatTemplate', localChatTemplate);
    setDialogVisible(false);
  };

  const handleChatTemplateNameChange = (chatTemplateName: string) => {
    setSelectedTemplateName(chatTemplateName);
    onChange('name', chatTemplateName);
  };

  const dismissKeyboard = () => {
    Keyboard.dismiss();
  };

  const renderTokenSetting = (
    testID: string,
    label: string,
    isEnabled: boolean,
    token: string | undefined,
    toggleName: string,
    tokenName?: string,
  ) => (
    <View>
      <View style={styles.switchContainer}>
        <Text>{label}</Text>
        <Switch
          testID={`${testID}-switch`}
          value={isEnabled}
          onValueChange={value => onChange(toggleName, value)}
        />
      </View>
      {isEnabled && tokenName && (
        <TextInput
          placeholder={`${label} Token`}
          value={token}
          onChangeText={text => onChange(tokenName, text)}
          testID={`${testID}-input`}
        />
      )}
    </View>
  );

  const renderTemplateSection = () => (
    <View style={styles.settingsSection}>
      <View style={styles.chatTemplateRow}>
        <Text style={styles.chatTemplateLabel} variant="labelLarge">
          {l10n.models.modelSettings.template.label}
        </Text>
        <MaskedView
          style={styles.chatTemplateContainer}
          maskElement={
            <View style={styles.chatTemplateMaskContainer}>
              <Text variant="labelSmall">
                {chatTemplate.chatTemplate.trim().slice(0, 30)}
              </Text>
            </View>
          }>
          <LinearGradient
            colors={[theme.colors.onSurface, 'transparent']}
            style={styles.chatTemplatePreviewGradient}
            start={{x: 0.7, y: 0}}
            end={{x: 1, y: 0}}
          />
        </MaskedView>
        <Button
          onPress={() => {
            setLocalChatTemplate(chatTemplate.chatTemplate);
            setDialogVisible(true);
          }}>
          {l10n.models.modelSettings.template.editButton}
        </Button>
      </View>
    </View>
  );

  const renderStopWords = () => (
    <View style={styles.settingItem}>
      <View style={styles.stopLabel}>
        <Text variant="labelSmall" style={styles.settingLabel}>
          {l10n.models.modelSettings.stopWords.label}
        </Text>
      </View>

      {/* Display existing stop words as chips */}
      <View style={styles.stopWordsContainer}>
        {(stopWords ?? []).map((word, index) => (
          <Chip
            key={index}
            onClose={() => {
              const newStops = (stopWords ?? []).filter((_, i) => i !== index);
              onStopWordsChange(newStops);
            }}
            compact
            textStyle={styles.stopChipText}
            style={styles.stopChip}>
            {word}
          </Chip>
        ))}
      </View>

      {/* Input for new stop words */}
      <TextInput
        value={newStopWord}
        placeholder={l10n.models.modelSettings.stopWords.placeholder}
        onChangeText={setNewStopWord}
        onSubmitEditing={() => {
          if (newStopWord.trim()) {
            onStopWordsChange([...(stopWords ?? []), newStopWord.trim()]);
            setNewStopWord('');
          }
        }}
        testID="stop-input"
      />
    </View>
  );

  const onCloseSheet = () => {
    dismissKeyboard();
    setDialogVisible(false);
  };

  return (
    <View style={styles.container} testID="settings-container">
      {/* Token Settings Section */}
      <View style={styles.settingsSection}>
        {renderTokenSetting(
          'BOS',
          l10n.models.modelSettings.tokenSettings.bos,
          chatTemplate.addBosToken ?? false,
          chatTemplate.bosToken,
          'addBosToken',
          'bosToken',
        )}

        <Divider style={styles.divider} />

        {renderTokenSetting(
          'EOS',
          l10n.models.modelSettings.tokenSettings.eos,
          chatTemplate.addEosToken ?? false,
          chatTemplate.eosToken,
          'addEosToken',
          'eosToken',
        )}

        <Divider style={styles.divider} />

        {renderTokenSetting(
          'add-generation-prompt',
          l10n.models.modelSettings.tokenSettings.addGenerationPrompt,
          chatTemplate.addGenerationPrompt ?? false,
          undefined,
          'addGenerationPrompt',
        )}

        <Divider style={styles.divider} />

        {/* System Prompt Section */}
        <View style={styles.settingsSection}>
          <TextInput
            testID="system-prompt-input"
            defaultValue={chatTemplate.systemPrompt ?? ''}
            onChangeText={text => {
              onChange('systemPrompt', text);
            }}
            multiline
            numberOfLines={3}
            style={styles.textArea}
            label={l10n.models.modelSettings.tokenSettings.systemPrompt}
          />
        </View>

        <Divider style={styles.divider} />

        {renderTemplateSection()}
      </View>

      <Divider style={styles.divider} />
      {renderStopWords()}
      {/** Chat Template Dialog */}
      <Sheet
        isVisible={isDialogVisible}
        onClose={onCloseSheet}
        title={l10n.models.modelSettings.template.dialogTitle}
        enableContentPanningGesture={false}
        displayFullHeight>
        <Sheet.ScrollView
          bottomOffset={16}
          contentContainerStyle={styles.sheetContainer}>
          <View>
            <ChatTemplatePicker
              selectedTemplateName={selectedTemplateName}
              handleChatTemplateNameChange={handleChatTemplateNameChange}
            />
            <Text variant="labelSmall" style={styles.templateNote}>
              {l10n.models.modelSettings.template.note1}
            </Text>
            <Text variant="labelSmall" style={styles.templateNote}>
              {l10n.models.modelSettings.template.note2}
            </Text>
          </View>
          <TextInput
            ref={textInputRef}
            placeholder={l10n.models.modelSettings.template.placeholder}
            defaultValue={localChatTemplate}
            onChangeText={text => setLocalChatTemplate(text)}
            multiline
            numberOfLines={10}
            style={styles.textArea}
          />
        </Sheet.ScrollView>
        <Sheet.Actions style={styles.actionsContainer}>
          <Button
            testID="template-close-button"
            mode="contained"
            onPress={handleSave}>
            {l10n.models.modelSettings.template.closeButton}
          </Button>
        </Sheet.Actions>
      </Sheet>
    </View>
  );
};



================================================
FILE: src/screens/ModelsScreen/ModelSettings/styles.ts
================================================
import {Dimensions, StyleSheet} from 'react-native';

import {Theme} from '../../../utils/types';

const screenHeight = Dimensions.get('window').height;

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    container: {
      padding: 16,
      backgroundColor: theme.colors.surface,
      borderRadius: theme.borders.default,
    },
    chatTemplateRow: {
      flexDirection: 'row',
      alignItems: 'center',
      paddingHorizontal: 2,
    },
    chatTemplateLabel: {
      flex: 1,
    },
    chatTemplateContainer: {
      flex: 2,
      height: 20,
      overflow: 'hidden',
    },
    chatTemplateMaskContainer: {
      flex: 1,
      flexDirection: 'row',
    },
    chatTemplatePreviewGradient: {
      flex: 1,
    },
    textArea: {
      fontSize: 12,
      lineHeight: 16,
      borderRadius: 8,
      maxHeight: screenHeight * 0.4,
    },
    completionSettingsContainer: {
      marginTop: 12,
      paddingHorizontal: 2,
    },
    switchContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginVertical: 4,
    },
    settingsSection: {
      paddingVertical: 8,
    },
    divider: {
      marginVertical: 4,
    },
    templateNote: {
      color: theme.colors.textSecondary,
      marginVertical: 8,
    },
    stopLabel: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    settingItem: {
      marginBottom: 24,
      paddingHorizontal: 4,
    },
    settingLabel: {
      marginBottom: 2,
    },
    settingValue: {
      textAlign: 'right',
    },
    stopWordsContainer: {
      flexDirection: 'row',
      flexWrap: 'wrap',
      gap: 8,
      marginBottom: 8,
    },
    stopChip: {
      marginRight: 4,
      marginVertical: 4,
    },
    stopChipText: {
      fontSize: 12,
    },
    sheetContainer: {
      padding: 16,
    },
    actionsContainer: {
      alignItems: 'center',
      justifyContent: 'center',
    },
  });



================================================
FILE: src/screens/ModelsScreen/ModelSettings/__tests__/ModelSettings.test.tsx
================================================
import React from 'react';
import {Keyboard} from 'react-native';

import {render, fireEvent, act, waitFor} from '../../../../../jest/test-utils';

import {ModelSettings} from '../ModelSettings';

jest.useFakeTimers(); // Mock all timers

// Mock Sheet component
jest.mock('../../../../components/Sheet', () => {
  const {View, TextInput, Button} = require('react-native');
  const MockSheet = ({children, isVisible, onClose}) => {
    if (!isVisible) {
      return null;
    }
    return (
      <View testID="sheet">
        <Button title="Close" onPress={onClose} testID="sheet-close-button" />
        {children}
      </View>
    );
  };
  MockSheet.ScrollView = View;
  MockSheet.View = View;
  MockSheet.TextInput = TextInput;
  MockSheet.Actions = View;
  return {Sheet: MockSheet};
});

describe('ModelSettings', () => {
  const defaultTemplate = {
    name: 'Default Template',
    addBosToken: true,
    addEosToken: true,
    addGenerationPrompt: true,
    bosToken: '<|START|>',
    eosToken: '<|END|>',
    chatTemplate: 'User: {{prompt}}\nAssistant:',
    systemPrompt: 'You are a helpful assistant',
  };

  const mockProps = {
    chatTemplate: defaultTemplate,
    stopWords: [] as string[],
    onChange: jest.fn(),
    onStopWordsChange: jest.fn(),
    onCompletionSettingsChange: jest.fn(),
    isActive: false,
    onFocus: jest.fn(),
  };

  beforeEach(() => {
    // Reset all properties to initial values
    mockProps.chatTemplate = {...defaultTemplate};
    mockProps.stopWords = [];
    mockProps.isActive = false;

    // Create fresh mocks for all function props
    mockProps.onChange = jest.fn();
    mockProps.onStopWordsChange = jest.fn();

    jest.clearAllMocks();
    jest.spyOn(Keyboard, 'dismiss');
  });

  it('renders correctly with initial props', () => {
    const {getByText, getByPlaceholderText} = render(
      <ModelSettings {...mockProps} />,
    );

    expect(getByText('BOS')).toBeTruthy();
    expect(getByText('EOS')).toBeTruthy();
    expect(getByText('Add Generation Prompt')).toBeTruthy();
    expect(getByPlaceholderText('BOS Token')).toBeTruthy();
    expect(getByPlaceholderText('EOS Token')).toBeTruthy();
  });

  it('handles BOS token changes', async () => {
    const {getByPlaceholderText} = render(<ModelSettings {...mockProps} />);

    const bosInput = getByPlaceholderText('BOS Token');
    await act(async () => {
      fireEvent.changeText(bosInput, '<|NEW_START|>');
    });

    expect(mockProps.onChange).toHaveBeenCalledWith(
      'bosToken',
      '<|NEW_START|>',
    );
  });

  it('handles EOS token changes', async () => {
    const {getByPlaceholderText} = render(<ModelSettings {...mockProps} />);

    const eosInput = getByPlaceholderText('EOS Token');
    await act(async () => {
      fireEvent.changeText(eosInput, '<|NEW_END|>');
    });

    expect(mockProps.onChange).toHaveBeenCalledWith('eosToken', '<|NEW_END|>');
  });

  it('toggles BOS switch correctly', async () => {
    const {getByTestId} = render(<ModelSettings {...mockProps} />);

    const bosSwitch = getByTestId('BOS-switch');

    await act(async () => {
      fireEvent(bosSwitch, 'valueChange', false);
    });

    expect(mockProps.onChange).toHaveBeenCalledWith('addBosToken', false);
  });

  // eslint-disable-next-line jest/no-disabled-tests
  it.skip('opens and closes the template dialog', async () => {
    const {getByText, queryByText} = render(<ModelSettings {...mockProps} />);

    // Open dialog
    await act(() => {
      fireEvent.press(getByText('Edit'));
    });

    // Wait for dialog to be visible
    await waitFor(() => {
      expect(getByText('Close')).toBeTruthy();
    });

    // Press Close button
    await act(() => {
      fireEvent.press(getByText('Close'));
    });

    // Wait for dialog to be hidden
    await waitFor(() => {
      expect(queryByText('Close')).toBeNull();
    });
  });

  it('saves template changes', async () => {
    const {getByText, getByPlaceholderText, getByTestId} = render(
      <ModelSettings {...mockProps} />,
    );

    // Open dialog
    await act(async () => {
      fireEvent.press(getByText('Edit'));
    });

    const templateInput = getByPlaceholderText(
      'Enter your chat template here...',
    );
    const newTemplate = 'New Template Content';
    await act(async () => {
      fireEvent.changeText(templateInput, newTemplate);
    });

    await act(async () => {
      fireEvent.press(getByTestId('template-close-button'));
    });

    expect(mockProps.onChange).toHaveBeenCalledWith(
      'chatTemplate',
      newTemplate,
    );
  });

  it('handles system prompt changes', async () => {
    const {getByTestId} = render(<ModelSettings {...mockProps} />);

    const systemPromptInput = getByTestId('system-prompt-input');
    const newPrompt = 'New system prompt';
    await act(async () => {
      fireEvent.changeText(systemPromptInput, newPrompt);
    });
    await act(async () => {
      fireEvent(systemPromptInput, 'blur');
    });

    expect(mockProps.onChange).toHaveBeenCalledWith('systemPrompt', newPrompt);
  });

  it('dismisses keyboard when the template sheet is closed', async () => {
    const {getByTestId, getByText, getByPlaceholderText} = render(
      <ModelSettings {...mockProps} />,
    );
    const editButton = getByText('Edit');
    await act(async () => {
      fireEvent.press(editButton);
    });

    const input = getByPlaceholderText('Enter your chat template here...');
    await act(async () => {
      fireEvent.changeText(input, 'New Template Content');
    });

    const sheetCloseButton = getByTestId('sheet-close-button');
    await act(async () => {
      fireEvent.press(sheetCloseButton);
    });

    expect(Keyboard.dismiss).toHaveBeenCalled();
  });

  it('handles stop words additions and removals', () => {
    const {getByTestId} = render(<ModelSettings {...mockProps} />);

    // Test adding new stop word
    const stopInput = getByTestId('stop-input');
    fireEvent.changeText(stopInput, 'newstop');
    fireEvent(stopInput, 'submitEditing');

    expect(mockProps.onStopWordsChange).toHaveBeenCalledWith(['newstop']);

    // Mock existing stop words
    mockProps.stopWords = ['<stop1>'];
    const {getAllByRole} = render(<ModelSettings {...mockProps} />);

    // Test removing stop word using chip close button
    const closeButtons = getAllByRole('button', {name: /close/i});
    fireEvent.press(closeButtons[0]);

    expect(mockProps.onStopWordsChange).toHaveBeenCalledWith([]);
  });
});



================================================
FILE: src/screens/PalsScreen/index.ts
================================================
export * from './PalsScreen';



================================================
FILE: src/screens/PalsScreen/PalsScreen.tsx
================================================
import React, {useState, useContext} from 'react';
import {View, ScrollView, Pressable, Alert} from 'react-native';
import {useSafeAreaInsets} from 'react-native-safe-area-context';
import {Text, Divider, IconButton} from 'react-native-paper';
import {observer} from 'mobx-react-lite';

import {useTheme} from '../../hooks';
import {createStyles} from './styles';
import {
  ChevronRightIcon,
  ChevronDownIcon,
  PlusIcon,
  PencilLineIcon,
  TrashIcon,
  AlertIcon,
  ShareIcon,
} from '../../assets/icons';
import {
  AssistantPalSheet,
  RoleplayPalSheet,
  VideoPalSheet,
  PalType,
} from '../../components/PalsSheets';
import {palStore, Pal} from '../../store/PalStore';
import {modelStore} from '../../store/ModelStore';
import {L10nContext} from '../../utils';
import {exportPal} from '../../utils/exportUtils';

const PalDetails = ({pal}: {pal: Pal}) => {
  const theme = useTheme();
  const insets = useSafeAreaInsets();
  const styles = createStyles(theme, insets);
  const l10n = useContext(L10nContext);

  if (pal.palType === PalType.ASSISTANT) {
    return (
      <View style={styles.infoContainer}>
        <View style={styles.infoColumn}>
          <Text style={theme.fonts.titleMediumLight}>
            {l10n.palsScreen.systemPrompt}
          </Text>
          <Text style={styles.itemDescription}>{pal.systemPrompt}</Text>
        </View>
      </View>
    );
  }

  if (pal.palType === PalType.VIDEO) {
    return (
      <View style={styles.infoContainer}>
        <View style={styles.infoColumn}>
          <Text style={theme.fonts.titleMediumLight}>
            {l10n.palsScreen.videoAnalysis}
          </Text>
          <Text style={styles.itemDescription}>
            {l10n.palsScreen.videoAnalysisDescription}
          </Text>
        </View>
        <View style={styles.infoColumn}>
          <Text style={theme.fonts.titleMediumLight}>
            {l10n.palsScreen.captureInterval}
          </Text>
          <Text style={styles.itemDescription}>
            {(pal as any).captureInterval} {l10n.palsScreen.captureIntervalUnit}
          </Text>
        </View>
        <View style={styles.infoColumn}>
          <Text style={theme.fonts.titleMediumLight}>
            {l10n.palsScreen.systemPrompt}
          </Text>
          <Text style={styles.itemDescription}>{pal.systemPrompt}</Text>
        </View>
      </View>
    );
  }

  return (
    <View style={styles.infoContainer}>
      <View style={styles.infoColumn}>
        <Text style={theme.fonts.titleMediumLight}>
          {l10n.palsScreen.world}
        </Text>
        <Text style={styles.itemDescription}>{pal.world}</Text>
      </View>

      <View style={styles.infoColumn}>
        <Text style={theme.fonts.titleMediumLight}>
          {l10n.palsScreen.toneStyle}
        </Text>
        <Text style={styles.itemDescription}>{pal.toneStyle}</Text>
      </View>

      <View style={styles.infoColumn}>
        <Text style={theme.fonts.titleMediumLight}>
          {l10n.palsScreen.aiRole}
        </Text>
        <Text style={styles.itemDescription}>{pal.aiRole}</Text>
      </View>

      <View style={styles.infoColumn}>
        <Text style={theme.fonts.titleMediumLight}>
          {l10n.palsScreen.userRole}
        </Text>
        <Text style={styles.itemDescription}>{pal.userRole}</Text>
      </View>

      <View style={styles.infoColumn}>
        <Text style={theme.fonts.titleMediumLight}>
          {l10n.palsScreen.prompt}
        </Text>
        <Text style={styles.itemDescription}>{pal.systemPrompt}</Text>
      </View>
    </View>
  );
};

const PalCard = ({pal, onEdit}: {pal: Pal; onEdit: (pal: Pal) => void}) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const theme = useTheme();
  const insets = useSafeAreaInsets();
  const styles = createStyles(theme, insets);
  const l10n = useContext(L10nContext);
  const isDefaultModelMissing =
    pal.defaultModel && !modelStore.isModelAvailable(pal.defaultModel?.id);

  const handleDelete = () => {
    Alert.alert(l10n.palsScreen.deletePal, l10n.palsScreen.deletePalMessage, [
      {
        text: l10n.common.cancel,
        style: 'cancel',
      },
      {
        text: l10n.common.delete,
        onPress: () => palStore.deletePal(pal.id),
        style: 'destructive',
      },
    ]);
  };

  const handleExport = async () => {
    await exportPal(pal.id);
  };

  const handleWarningPress = () => {
    Alert.alert(
      l10n.palsScreen.missingModel,
      l10n.palsScreen.missingModelMessage.replace(
        '{{modelName}}',
        pal.defaultModel?.name || '',
      ),
    );
  };

  const renderWarningIcon = () => (
    <AlertIcon stroke={theme.colors.error} width={20} height={20} />
  );

  const renderTrashIcon = () => (
    <TrashIcon stroke={theme.colors.onSurface} width={20} height={20} />
  );

  const renderPencilIcon = () => (
    <PencilLineIcon stroke={theme.colors.onSurface} width={20} height={20} />
  );

  const renderShareIcon = () => (
    <ShareIcon stroke={theme.colors.onSurface} width={20} height={20} />
  );

  return (
    <View style={styles.palCard}>
      <Pressable
        onPress={() => setIsExpanded(!isExpanded)}
        style={[styles.itemContainer, isExpanded && styles.expandedItem]}>
        <View style={styles.nameContainer}>
          {isDefaultModelMissing && (
            <IconButton
              icon={renderWarningIcon}
              onPress={handleWarningPress}
              style={styles.warningIcon}
            />
          )}
          <Text style={theme.fonts.titleMediumLight}>{pal.name}</Text>
        </View>
        <View style={styles.itemRight}>
          <IconButton
            icon={renderShareIcon}
            onPress={handleExport}
            style={styles.iconBtn}
          />
          <IconButton
            icon={renderTrashIcon}
            onPress={handleDelete}
            style={styles.iconBtn}
          />
          <IconButton
            icon={renderPencilIcon}
            onPress={() => onEdit(pal)}
            style={styles.iconBtn}
          />
          {isExpanded ? (
            <ChevronDownIcon stroke={theme.colors.onSurface} />
          ) : (
            <ChevronRightIcon stroke={theme.colors.onSurface} />
          )}
        </View>
      </Pressable>

      {isExpanded && <PalDetails pal={pal} />}
    </View>
  );
};

export const PalsScreen: React.FC = observer(() => {
  const insets = useSafeAreaInsets();
  const theme = useTheme();
  const styles = createStyles(theme, insets);
  const l10n = useContext(L10nContext);

  const [showAssistantSheet, setShowAssistantSheet] = useState(false);
  const [showRoleplaySheet, setShowRoleplaySheet] = useState(false);

  const [showVideoSheet, setShowVideoSheet] = useState(false);
  const [editPal, setEditPal] = useState<Pal | undefined>();

  const handleCreatePal = (type: PalType) => {
    setEditPal(undefined);
    if (type === PalType.ASSISTANT) {
      setShowAssistantSheet(true);
    } else if (type === PalType.ROLEPLAY) {
      setShowRoleplaySheet(true);
    } else if (type === PalType.VIDEO) {
      setShowVideoSheet(true);
    }
  };

  const handleEditPal = (pal: Pal) => {
    setEditPal(pal);
    if (pal.palType === PalType.ASSISTANT) {
      setShowAssistantSheet(true);
    } else if (pal.palType === PalType.ROLEPLAY) {
      setShowRoleplaySheet(true);
    } else if (pal.palType === PalType.VIDEO) {
      setShowVideoSheet(true);
    }
  };

  const pals = palStore.getPals();

  return (
    <ScrollView
      style={styles.scrollview}
      contentContainerStyle={styles.scrollviewContent}>
      <View style={styles.createBtnsContainer}>
        <Pressable
          style={styles.itemContainer}
          onPress={() => handleCreatePal(PalType.ASSISTANT)}>
          <Text style={theme.fonts.titleMediumLight}>
            {l10n.palsScreen.assistant}
          </Text>
          <PlusIcon stroke={theme.colors.onSurface} />
        </Pressable>
        <Pressable
          style={styles.itemContainer}
          onPress={() => handleCreatePal(PalType.ROLEPLAY)}>
          <Text style={theme.fonts.titleMediumLight}>
            {l10n.palsScreen.roleplay}
          </Text>
          <PlusIcon stroke={theme.colors.onSurface} />
        </Pressable>

        <Pressable
          style={styles.itemContainer}
          onPress={() => handleCreatePal(PalType.VIDEO)}>
          <Text style={theme.fonts.titleMediumLight}>
            {l10n.palsScreen.video}
          </Text>
          <PlusIcon stroke={theme.colors.onSurface} />
        </Pressable>
      </View>

      <Divider style={styles.divider} />

      <View style={styles.palContainer}>
        {pals.map(pal => (
          <PalCard key={pal.id} pal={pal} onEdit={handleEditPal} />
        ))}
      </View>

      <AssistantPalSheet
        isVisible={showAssistantSheet}
        onClose={() => setShowAssistantSheet(false)}
        editPal={editPal?.palType === PalType.ASSISTANT ? editPal : undefined}
      />

      <RoleplayPalSheet
        isVisible={showRoleplaySheet}
        onClose={() => setShowRoleplaySheet(false)}
        editPal={editPal?.palType === PalType.ROLEPLAY ? editPal : undefined}
      />

      <VideoPalSheet
        isVisible={showVideoSheet}
        onClose={() => setShowVideoSheet(false)}
        editPal={editPal?.palType === PalType.VIDEO ? editPal : undefined}
      />
    </ScrollView>
  );
});



================================================
FILE: src/screens/PalsScreen/styles.ts
================================================
import {StyleSheet} from 'react-native';
import {Theme} from '../../utils/types';
import {EdgeInsets} from 'react-native-safe-area-context';

export const createStyles = (theme: Theme, insets: EdgeInsets) =>
  StyleSheet.create({
    scrollview: {
      backgroundColor: theme.colors.background,
    },
    palContainer: {
      gap: theme.spacing.default,
    },
    scrollviewContent: {
      padding: theme.spacing.default,
      paddingBottom: theme.spacing.default + insets.bottom,
    },
    createBtnsContainer: {
      gap: theme.spacing.default,
    },
    sectionTitle: {
      fontSize: 20,
      color: theme.colors.onSurface,
      marginBottom: 8,
    },
    itemContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      height: 54,
      paddingHorizontal: theme.spacing.default,
      backgroundColor: theme.colors.surface,
      borderRadius: theme.borders.default,
    },
    infoColumn: {
      flexDirection: 'column',
      paddingVertical: 10,
      minHeight: 40,
    },
    itemRight: {
      flexDirection: 'row',
      alignItems: 'center',
    },
    itemDescription: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    divider: {
      marginVertical: theme.spacing.default,
      height: 1,
      backgroundColor: theme.colors.surface,
    },
    switch: {
      marginLeft: 8,
    },
    expandIcon: {
      marginLeft: 8,
    },
    expandedItem: {
      borderBottomStartRadius: 0,
      borderBottomEndRadius: 0,
    },
    row: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
    },
    infoContainer: {
      backgroundColor: theme.colors.surface,
      padding: theme.spacing.default,
      borderTopWidth: 1,
      borderTopColor: theme.colors.onPrimary,
    },
    palCard: {},
    iconBtn: {
      marginHorizontal: 0,
    },
    nameContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 4,
    },
    warningIcon: {
      margin: 0,
      padding: 0,
    },
  });



================================================
FILE: src/screens/PalsScreen/__tests__/PalsScreen.test.tsx
================================================
import React from 'react';
import {fireEvent} from '@testing-library/react-native';
import {render} from '../../../../jest/test-utils';
import {PalsScreen} from '../PalsScreen';
import {PalType} from '../../../components/PalsSheets';
import {palStore} from '../../../store/PalStore';
import {L10nContext} from '../../../utils';
import {l10n} from '../../../utils/l10n';

// Mock the store
jest.mock('../../../store/PalStore', () => ({
  palStore: {
    getPals: jest.fn(),
  },
}));

// Mock the sheets
const mockAssistantSheet = jest.fn();
const mockRoleplaySheet = jest.fn();
const mockVideoPalSheet = jest.fn();

jest.mock('../../../components/PalsSheets', () => ({
  PalType: {
    ASSISTANT: 'ASSISTANT',
    ROLEPLAY: 'ROLEPLAY',
    VIDEO: 'VIDEO',
  },
  AssistantPalSheet: (props: any) => {
    mockAssistantSheet(props);
    return null;
  },
  RoleplayPalSheet: (props: any) => {
    mockRoleplaySheet(props);
    return null;
  },
  VideoPalSheet: (props: any) => {
    mockVideoPalSheet(props);
    return null;
  },
}));

// Mock the icons
jest.mock('../../../assets/icons', () => {
  const {View} = require('react-native');
  return {
    ChevronRightIcon: ({testID = 'chevron-right-icon', ...props}) => (
      <View testID={testID} {...props} />
    ),
    ChevronDownIcon: ({testID = 'chevron-down-icon', ...props}) => (
      <View testID={testID} {...props} />
    ),
    PlusIcon: ({testID = 'plus-icon', ...props}) => (
      <View testID={testID} {...props} />
    ),
    PencilLineIcon: ({testID = 'pencil-icon', ...props}) => (
      <View testID={testID} {...props} />
    ),
    TrashIcon: ({testID = 'trash-icon', ...props}) => (
      <View testID={testID} {...props} />
    ),
    ShareIcon: ({testID = 'share-icon', ...props}) => (
      <View testID={testID} {...props} />
    ),
  };
});

const renderWithL10n = (ui: React.ReactElement, options?: any) => {
  return render(
    <L10nContext.Provider value={l10n.en as any}>{ui}</L10nContext.Provider>,
    options,
  );
};

describe('PalsScreen', () => {
  const mockPals = [
    {
      id: '1',
      name: 'Assistant Pal',
      palType: PalType.ASSISTANT,
      systemPrompt: 'Test system prompt',
    },
    {
      id: '2',
      name: 'Roleplay Pal',
      palType: PalType.ROLEPLAY,
      world: 'Test world',
      toneStyle: 'Test tone',
      aiRole: 'Test AI role',
      userRole: 'Test user role',
      systemPrompt: 'Test system prompt',
    },
  ];

  beforeEach(() => {
    jest.clearAllMocks();
    (palStore.getPals as jest.Mock).mockReturnValue(mockPals);
  });

  it('renders create buttons', () => {
    const {getByText, getAllByTestId} = renderWithL10n(<PalsScreen />, {
      withSafeArea: true,
    });

    expect(getByText('Assistant')).toBeDefined();
    expect(getByText('Roleplay')).toBeDefined();
    expect(getAllByTestId('plus-icon')).toHaveLength(3); // Updated to 3 for Video
  });

  it('renders list of pals', () => {
    const {getByText, getAllByTestId} = renderWithL10n(<PalsScreen />);

    expect(getByText('Assistant Pal')).toBeDefined();
    expect(getByText('Roleplay Pal')).toBeDefined();
    expect(getAllByTestId('chevron-right-icon')).toHaveLength(2);
  });

  it('shows assistant details when expanded', () => {
    const {getByText, getByTestId} = renderWithL10n(<PalsScreen />);

    fireEvent.press(getByText('Assistant Pal'));

    expect(getByTestId('chevron-down-icon')).toBeDefined();
    expect(getByText('System Prompt')).toBeDefined();
    expect(getByText('Test system prompt')).toBeDefined();
  });

  it('shows roleplay details when expanded', () => {
    const {getByText, getByTestId} = renderWithL10n(<PalsScreen />);

    fireEvent.press(getByText('Roleplay Pal'));

    expect(getByTestId('chevron-down-icon')).toBeDefined();
    expect(getByText('World')).toBeDefined();
    expect(getByText('Test world')).toBeDefined();
    expect(getByText('Tone/Style')).toBeDefined();
    expect(getByText('Test tone')).toBeDefined();
    expect(getByText("AI's Role")).toBeDefined();
    expect(getByText('Test AI role')).toBeDefined();
    expect(getByText('My Role')).toBeDefined();
    expect(getByText('Test user role')).toBeDefined();
    expect(getByText('Prompt')).toBeDefined();
    expect(getByText('Test system prompt')).toBeDefined();
  });

  it('opens AssistantPalSheet when creating new assistant', () => {
    const {getByText} = renderWithL10n(<PalsScreen />);

    fireEvent.press(getByText('Assistant'));

    expect(mockAssistantSheet).toHaveBeenLastCalledWith(
      expect.objectContaining({
        isVisible: true,
        editPal: undefined,
      }),
    );
  });

  it('opens RoleplayPalSheet when creating new roleplay', () => {
    const {getByText} = renderWithL10n(<PalsScreen />);

    fireEvent.press(getByText('Roleplay'));

    expect(mockRoleplaySheet).toHaveBeenLastCalledWith(
      expect.objectContaining({
        isVisible: true,
        editPal: undefined,
      }),
    );
  });

  it('opens AssistantPalSheet with pal data when editing assistant', () => {
    const {getAllByTestId} = renderWithL10n(<PalsScreen />);

    const pencilIcons = getAllByTestId('pencil-icon');
    fireEvent.press(pencilIcons[0]); // First pencil icon is for assistant pal

    expect(mockAssistantSheet).toHaveBeenLastCalledWith(
      expect.objectContaining({
        isVisible: true,
        editPal: mockPals[0],
      }),
    );
  });

  it('opens RoleplayPalSheet with pal data when editing roleplay', () => {
    const {getAllByTestId} = renderWithL10n(<PalsScreen />);

    const pencilIcons = getAllByTestId('pencil-icon');
    fireEvent.press(pencilIcons[1]); // Second pencil icon is for roleplay pal

    expect(mockRoleplaySheet).toHaveBeenLastCalledWith(
      expect.objectContaining({
        isVisible: true,
        editPal: mockPals[1],
      }),
    );
  });

  it('closes sheets when onClose is called', () => {
    const {getByText} = renderWithL10n(<PalsScreen />);

    // Open and close assistant sheet
    fireEvent.press(getByText('Assistant'));
    expect(mockAssistantSheet).toHaveBeenLastCalledWith(
      expect.objectContaining({
        isVisible: true,
      }),
    );

    // Get the last call's props and call onClose
    const assistantProps =
      mockAssistantSheet.mock.calls[
        mockAssistantSheet.mock.calls.length - 1
      ][0];
    assistantProps.onClose();

    expect(mockAssistantSheet).toHaveBeenLastCalledWith(
      expect.objectContaining({
        isVisible: false,
      }),
    );

    // Open and close roleplay sheet
    fireEvent.press(getByText('Roleplay'));
    expect(mockRoleplaySheet).toHaveBeenLastCalledWith(
      expect.objectContaining({
        isVisible: true,
      }),
    );

    // Get the last call's props and call onClose
    const roleplayProps =
      mockRoleplaySheet.mock.calls[mockRoleplaySheet.mock.calls.length - 1][0];
    roleplayProps.onClose();

    expect(mockRoleplaySheet).toHaveBeenLastCalledWith(
      expect.objectContaining({
        isVisible: false,
      }),
    );
  });
});



================================================
FILE: src/screens/SettingsScreen/index.ts
================================================
export * from './SettingsScreen';



================================================
FILE: src/screens/SettingsScreen/SettingsScreen.tsx
================================================
import React, {useState, useEffect, useRef, useContext} from 'react';
import {
  View,
  Platform,
  TouchableWithoutFeedback,
  Keyboard,
  ScrollView,
  TextInput as RNTextInput,
  Alert,
} from 'react-native';

import {debounce} from 'lodash';
import {observer} from 'mobx-react-lite';
import Slider from '@react-native-community/slider';
import {SafeAreaView} from 'react-native-safe-area-context';
import {Switch, Text, Card, Button, Icon, List} from 'react-native-paper';

import {GlobeIcon, MoonIcon, CpuChipIcon, ShareIcon} from '../../assets/icons';
import {TextInput, Menu, Divider, HFTokenSheet} from '../../components';

import {useTheme} from '../../hooks';

import {createStyles} from './styles';

import {modelStore, uiStore, hfStore} from '../../store';
import {AvailableLanguage} from '../../store/UIStore';

import {L10nContext} from '../../utils';
import {CacheType} from '../../utils/types';
import {exportLegacyChatSessions} from '../../utils/exportUtils';

// Language display names in their native form
const languageNames: Record<AvailableLanguage, string> = {
  en: 'English (EN)',
  //es: 'Espa√±ol (ES)',
  //de: 'Deutsch (DE)',
  ja: 'Êó•Êú¨Ë™û (JA)',
  //ko: 'ÌïúÍµ≠Ïñ¥ (KO)',
  //pl: 'Polski (PL)',
  //pt: 'Portugu√™s (PT)',
  //ru: '–†—É—Å—Å–∫–∏–π (RU)',
  //tr: 'T√ºrk√ße (TR)',
  //uk: '–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞ (UK)',
  //ca: 'Catal√† (CA)',
  zh: '‰∏≠Êñá (ZH)',
};

export const SettingsScreen: React.FC = observer(() => {
  const l10n = useContext(L10nContext);
  const theme = useTheme();
  const styles = createStyles(theme);
  const [contextSize, setContextSize] = useState(
    modelStore.n_context.toString(),
  );
  const [isValidInput, setIsValidInput] = useState(true);
  const [showAdvancedSettings, setShowAdvancedSettings] = useState(false);
  const inputRef = useRef<RNTextInput>(null);
  const [showKeyCacheMenu, setShowKeyCacheMenu] = useState(false);
  const [showValueCacheMenu, setShowValueCacheMenu] = useState(false);
  const [showLanguageMenu, setShowLanguageMenu] = useState(false);
  const [showMmapMenu, setShowMmapMenu] = useState(false);
  const [showHfTokenDialog, setShowHfTokenDialog] = useState(false);
  const [keyCacheAnchor, setKeyCacheAnchor] = useState<{x: number; y: number}>({
    x: 0,
    y: 0,
  });
  const [valueCacheAnchor, setValueCacheAnchor] = useState<{
    x: number;
    y: number;
  }>({x: 0, y: 0});
  const [languageAnchor, setLanguageAnchor] = useState<{x: number; y: number}>({
    x: 0.0,
    y: 0.0,
  });
  const [mmapAnchor, setMmapAnchor] = useState<{x: number; y: number}>({
    x: 0.0,
    y: 0.0,
  });
  const keyCacheButtonRef = useRef<View>(null);
  const valueCacheButtonRef = useRef<View>(null);
  const languageButtonRef = useRef<View>(null);
  const mmapButtonRef = useRef<View>(null);

  const debouncedUpdateStore = useRef(
    debounce((value: number) => {
      modelStore.setNContext(value);
    }, 500),
  ).current;

  useEffect(() => {
    setContextSize(modelStore.n_context.toString());
  }, []);

  useEffect(() => {
    return () => {
      debouncedUpdateStore.cancel();
    };
  }, [debouncedUpdateStore]);

  const handleOutsidePress = () => {
    Keyboard.dismiss();
    inputRef.current?.blur();
    setContextSize(modelStore.n_context.toString());
    setIsValidInput(true);
    setShowKeyCacheMenu(false);
    setShowValueCacheMenu(false);
    setShowLanguageMenu(false);
    setShowMmapMenu(false);
  };

  const handleContextSizeChange = (text: string) => {
    setContextSize(text);
    const value = parseInt(text, 10);
    if (!isNaN(value) && value >= modelStore.MIN_CONTEXT_SIZE) {
      setIsValidInput(true);
      debouncedUpdateStore(value);
    } else {
      setIsValidInput(false);
    }
  };

  const cacheTypeOptions = [
    {label: 'F32', value: CacheType.F32},
    {label: 'F16', value: CacheType.F16},
    {label: 'Q8_0', value: CacheType.Q8_0},
    {label: 'Q5_1', value: CacheType.Q5_1},
    {label: 'Q5_0', value: CacheType.Q5_0},
    {label: 'Q4_1', value: CacheType.Q4_1},
    {label: 'Q4_0', value: CacheType.Q4_0},
    {label: 'IQ4_NL', value: CacheType.IQ4_NL},
  ];

  const mmapOptions = [
    {label: l10n.settings.useMmapTrue, value: 'true' as const},
    {label: l10n.settings.useMmapFalse, value: 'false' as const},
    ...(Platform.OS === 'android'
      ? [{label: l10n.settings.useMmapSmart, value: 'smart' as const}]
      : []),
  ];

  const getCacheTypeLabel = (value: CacheType) => {
    return (
      cacheTypeOptions.find(option => option.value === value)?.label || value
    );
  };

  const getMmapLabel = (value: 'true' | 'false' | 'smart') => {
    return mmapOptions.find(option => option.value === value)?.label || '';
  };

  const handleMmapPress = () => {
    mmapButtonRef.current?.measure((x, y, width, height, pageX, pageY) => {
      setMmapAnchor({x: pageX, y: pageY + height});
      setShowMmapMenu(true);
    });
  };

  const handleKeyCachePress = () => {
    keyCacheButtonRef.current?.measure((x, y, width, height, pageX, pageY) => {
      setKeyCacheAnchor({x: pageX, y: pageY + height});
      setShowKeyCacheMenu(true);
    });
  };

  const handleValueCachePress = () => {
    valueCacheButtonRef.current?.measure(
      (x, y, width, height, pageX, pageY) => {
        setValueCacheAnchor({x: pageX, y: pageY + height});
        setShowValueCacheMenu(true);
      },
    );
  };

  const handleLanguagePress = () => {
    languageButtonRef.current?.measure((x, y, width, height, pageX, pageY) => {
      setLanguageAnchor({x: pageX, y: pageY + height});
      setShowLanguageMenu(true);
    });
  };

  const isIOS18OrHigher =
    Platform.OS === 'ios' && parseInt(Platform.Version as string, 10) >= 18;

  return (
    <SafeAreaView style={styles.safeArea} edges={['bottom']}>
      <TouchableWithoutFeedback onPress={handleOutsidePress}>
        <ScrollView contentContainerStyle={styles.container}>
          {/* Model Initialization Settings */}
          <Card elevation={0} style={styles.card}>
            <Card.Title title={l10n.settings.modelInitializationSettings} />
            <Card.Content>
              {/* Metal Settings (iOS only) */}
              {Platform.OS === 'ios' && (
                <>
                  <View style={styles.settingItemContainer}>
                    <View style={styles.switchContainer}>
                      <View style={styles.textContainer}>
                        <Text variant="titleMedium" style={styles.textLabel}>
                          {l10n.settings.metal}
                        </Text>
                        <Text
                          variant="labelSmall"
                          style={styles.textDescription}>
                          {isIOS18OrHigher
                            ? l10n.settings.metalDescription
                            : l10n.settings.metalRequiresNewerIOS}
                        </Text>
                      </View>
                      <Switch
                        testID="metal-switch"
                        value={modelStore.useMetal}
                        onValueChange={value =>
                          modelStore.updateUseMetal(value)
                        }
                        // disabled={!isIOS18OrHigher}
                        // We don't disable for cases where the users has has set to true in the past.
                      />
                    </View>
                    <Slider
                      testID="gpu-layers-slider"
                      disabled={!modelStore.useMetal}
                      value={modelStore.n_gpu_layers}
                      onValueChange={value =>
                        modelStore.setNGPULayers(Math.round(value))
                      }
                      minimumValue={1}
                      maximumValue={100}
                      step={1}
                      style={styles.slider}
                      thumbTintColor={theme.colors.primary}
                      minimumTrackTintColor={theme.colors.primary}
                    />
                    <Text variant="labelSmall" style={styles.textDescription}>
                      {l10n.settings.layersOnGPU.replace(
                        '{{gpuLayers}}',
                        modelStore.n_gpu_layers.toString(),
                      )}
                    </Text>
                  </View>
                  <Divider />
                </>
              )}

              {/* Context Size */}
              <View style={styles.settingItemContainer}>
                <Text variant="titleMedium" style={styles.textLabel}>
                  {l10n.settings.contextSize}
                </Text>
                <TextInput
                  ref={inputRef}
                  testID="context-size-input"
                  style={[
                    styles.textInput,
                    !isValidInput && styles.invalidInput,
                  ]}
                  keyboardType="numeric"
                  value={contextSize}
                  onChangeText={handleContextSizeChange}
                  placeholder={l10n.settings.contextSizePlaceholder.replace(
                    '{{minContextSize}}',
                    modelStore.MIN_CONTEXT_SIZE.toString(),
                  )}
                />
                {!isValidInput && (
                  <Text style={styles.errorText}>
                    {l10n.settings.invalidContextSizeError.replace(
                      '{{minContextSize}}',
                      modelStore.MIN_CONTEXT_SIZE.toString(),
                    )}
                  </Text>
                )}
                <Text variant="labelSmall" style={styles.textDescription}>
                  {l10n.settings.modelReloadNotice}
                </Text>
              </View>

              {/* Advanced Settings */}
              <List.Accordion
                title={l10n.settings.advancedSettings}
                titleStyle={styles.accordionTitle}
                style={styles.advancedAccordion}
                expanded={showAdvancedSettings}
                onPress={() => setShowAdvancedSettings(!showAdvancedSettings)}>
                <View style={styles.advancedSettingsContent}>
                  {/* Batch Size Slider */}
                  <View style={styles.settingItemContainer}>
                    <Text variant="titleMedium" style={styles.textLabel}>
                      {l10n.settings.batchSize}
                    </Text>
                    <Slider
                      testID="batch-size-slider"
                      value={modelStore.n_batch}
                      onValueChange={value =>
                        modelStore.setNBatch(Math.round(value))
                      }
                      minimumValue={1}
                      maximumValue={4096}
                      step={1}
                      style={styles.slider}
                      thumbTintColor={theme.colors.primary}
                      minimumTrackTintColor={theme.colors.primary}
                    />
                    <Text variant="labelSmall" style={styles.textDescription}>
                      {l10n.settings.batchSizeDescription
                        .replace('{{batchSize}}', modelStore.n_batch.toString())
                        .replace(
                          '{{effectiveBatch}}',
                          modelStore.n_batch > modelStore.n_context
                            ? ` (${l10n.settings.effectiveLabel}: ${modelStore.n_context})`
                            : '',
                        )}
                    </Text>
                  </View>
                  <Divider />

                  {/* Physical Batch Size Slider */}
                  <View style={styles.settingItemContainer}>
                    <Text variant="titleMedium" style={styles.textLabel}>
                      {l10n.settings.physicalBatchSize}
                    </Text>
                    <Slider
                      testID="ubatch-size-slider"
                      value={modelStore.n_ubatch}
                      onValueChange={value =>
                        modelStore.setNUBatch(Math.round(value))
                      }
                      minimumValue={1}
                      maximumValue={4096}
                      step={1}
                      style={styles.slider}
                      thumbTintColor={theme.colors.primary}
                      minimumTrackTintColor={theme.colors.primary}
                    />
                    <Text variant="labelSmall" style={styles.textDescription}>
                      {l10n.settings.physicalBatchSizeDescription
                        .replace(
                          '{{physicalBatchSize}}',
                          modelStore.n_ubatch.toString(),
                        )
                        .replace(
                          '{{effectivePhysicalBatch}}',
                          modelStore.n_ubatch >
                            Math.min(modelStore.n_batch, modelStore.n_context)
                            ? ` (${l10n.settings.effectiveLabel}: ${Math.min(
                                modelStore.n_batch,
                                modelStore.n_context,
                              )})`
                            : '',
                        )}
                    </Text>
                  </View>
                  <Divider />

                  {/* Thread Count Slider */}
                  <View style={styles.settingItemContainer}>
                    <Text variant="titleMedium" style={styles.textLabel}>
                      {l10n.settings.cpuThreads}
                    </Text>
                    <Slider
                      testID="thread-count-slider"
                      value={modelStore.n_threads}
                      onValueChange={value =>
                        modelStore.setNThreads(Math.round(value))
                      }
                      minimumValue={1}
                      maximumValue={modelStore.max_threads}
                      step={1}
                      style={styles.slider}
                      thumbTintColor={theme.colors.primary}
                      minimumTrackTintColor={theme.colors.primary}
                    />
                    <Text variant="labelSmall" style={styles.textDescription}>
                      {l10n.settings.cpuThreadsDescription
                        .replace('{{threads}}', modelStore.n_threads.toString())
                        .replace(
                          '{{maxThreads}}',
                          modelStore.max_threads.toString(),
                        )}
                    </Text>
                  </View>
                  <Divider />

                  {/* Flash Attention and Cache Types */}
                  <View style={styles.settingItemContainer}>
                    <View style={styles.switchContainer}>
                      <View style={styles.textContainer}>
                        <Text variant="titleMedium" style={styles.textLabel}>
                          {l10n.settings.flashAttention}
                        </Text>
                        <Text
                          variant="labelSmall"
                          style={styles.textDescription}>
                          {l10n.settings.flashAttentionDescription}
                        </Text>
                      </View>
                      <Switch
                        testID="flash-attention-switch"
                        value={modelStore.flash_attn}
                        onValueChange={value => modelStore.setFlashAttn(value)}
                      />
                    </View>
                  </View>
                  <Divider />

                  {/* Cache Type K Selection */}
                  <View style={styles.settingItemContainer}>
                    <View style={styles.switchContainer}>
                      <View style={styles.textContainer}>
                        <Text variant="titleMedium" style={styles.textLabel}>
                          {l10n.settings.keyCacheType}
                        </Text>
                        <Text
                          variant="labelSmall"
                          style={styles.textDescription}>
                          {modelStore.flash_attn
                            ? l10n.settings.keyCacheTypeDescription
                            : l10n.settings.keyCacheTypeDisabledDescription}
                        </Text>
                      </View>
                      <View style={styles.menuContainer}>
                        <Button
                          ref={keyCacheButtonRef}
                          mode="outlined"
                          onPress={handleKeyCachePress}
                          style={styles.menuButton}
                          contentStyle={styles.buttonContent}
                          disabled={!modelStore.flash_attn}
                          icon={({size, color}) => (
                            <Icon
                              source="chevron-down"
                              size={size}
                              color={color}
                            />
                          )}>
                          {getCacheTypeLabel(modelStore.cache_type_k)}
                        </Button>
                        <Menu
                          visible={showKeyCacheMenu}
                          onDismiss={() => setShowKeyCacheMenu(false)}
                          anchor={keyCacheAnchor}
                          selectable>
                          {cacheTypeOptions.map(option => (
                            <Menu.Item
                              key={option.value}
                              style={styles.menu}
                              label={option.label}
                              selected={
                                option.value === modelStore.cache_type_k
                              }
                              onPress={() => {
                                modelStore.setCacheTypeK(option.value);
                                setShowKeyCacheMenu(false);
                              }}
                            />
                          ))}
                        </Menu>
                      </View>
                    </View>
                  </View>
                  <Divider />

                  {/* Cache Type V Selection */}
                  <View style={styles.settingItemContainer}>
                    <View style={styles.switchContainer}>
                      <View style={styles.textContainer}>
                        <Text variant="titleMedium" style={styles.textLabel}>
                          {l10n.settings.valueCacheType}
                        </Text>
                        <Text
                          variant="labelSmall"
                          style={styles.textDescription}>
                          {modelStore.flash_attn
                            ? l10n.settings.valueCacheTypeDescription
                            : l10n.settings.valueCacheTypeDisabledDescription}
                        </Text>
                      </View>
                      <View style={styles.menuContainer}>
                        <Button
                          ref={valueCacheButtonRef}
                          mode="outlined"
                          onPress={handleValueCachePress}
                          style={styles.menuButton}
                          contentStyle={styles.buttonContent}
                          disabled={!modelStore.flash_attn}
                          icon={({size, color}) => (
                            <Icon
                              source="chevron-down"
                              size={size}
                              color={color}
                            />
                          )}>
                          {getCacheTypeLabel(modelStore.cache_type_v)}
                        </Button>
                        <Menu
                          visible={showValueCacheMenu}
                          onDismiss={() => setShowValueCacheMenu(false)}
                          anchor={valueCacheAnchor}
                          selectable>
                          {cacheTypeOptions.map(option => (
                            <Menu.Item
                              key={option.value}
                              label={option.label}
                              style={styles.menu}
                              selected={
                                option.value === modelStore.cache_type_v
                              }
                              onPress={() => {
                                modelStore.setCacheTypeV(option.value);
                                setShowValueCacheMenu(false);
                              }}
                            />
                          ))}
                        </Menu>
                      </View>
                    </View>
                  </View>
                </View>
              </List.Accordion>
            </Card.Content>
          </Card>

          {/* Memory Settings */}
          <Card elevation={0} style={styles.card}>
            <Card.Title title={l10n.settings.memorySettings} />
            <Card.Content>
              <View style={styles.settingItemContainer}>
                {/* Use Memory Lock */}
                <View style={styles.switchContainer}>
                  <View style={styles.textContainer}>
                    <Text variant="titleMedium" style={styles.textLabel}>
                      {l10n.settings.useMlock}
                    </Text>
                    <Text variant="labelSmall" style={styles.textDescription}>
                      {l10n.settings.useMlockDescription}
                    </Text>
                  </View>
                  <Switch
                    testID="use-mlock-switch"
                    value={modelStore.use_mlock}
                    onValueChange={value => modelStore.setUseMlock(value)}
                  />
                </View>
              </View>
              <Divider />

              {/* Memory Mapping */}
              <View style={styles.settingItemContainer}>
                <View style={styles.switchContainer}>
                  <View style={styles.textContainer}>
                    <Text variant="titleMedium" style={styles.textLabel}>
                      {l10n.settings.useMmap}
                    </Text>
                    <Text variant="labelSmall" style={styles.textDescription}>
                      {l10n.settings.useMmapDescription}
                    </Text>
                  </View>
                  <View style={styles.menuContainer}>
                    <Button
                      ref={mmapButtonRef}
                      mode="outlined"
                      onPress={handleMmapPress}
                      style={styles.menuButton}
                      contentStyle={styles.buttonContent}
                      icon={({size, color}) => (
                        <Icon source="chevron-down" size={size} color={color} />
                      )}>
                      {getMmapLabel(modelStore.use_mmap)}
                    </Button>
                    <Menu
                      visible={showMmapMenu}
                      onDismiss={() => setShowMmapMenu(false)}
                      anchor={mmapAnchor}
                      selectable>
                      {mmapOptions.map(option => (
                        <Menu.Item
                          key={option.value}
                          style={styles.menu}
                          label={option.label}
                          selected={option.value === modelStore.use_mmap}
                          onPress={() => {
                            modelStore.setUseMmap(option.value);
                            setShowMmapMenu(false);
                          }}
                        />
                      ))}
                    </Menu>
                  </View>
                </View>
              </View>
              <Text variant="labelSmall" style={styles.textDescription}>
                {l10n.settings.modelReloadNotice}
              </Text>
            </Card.Content>
          </Card>

          {/* Model Loading Settings */}
          <Card elevation={0} style={styles.card}>
            <Card.Title title={l10n.settings.modelLoadingSettings} />
            <Card.Content>
              <View style={styles.settingItemContainer}>
                {/* Auto Offload/Load */}
                <View style={styles.switchContainer}>
                  <View style={styles.textContainer}>
                    <Text variant="titleMedium" style={styles.textLabel}>
                      {l10n.settings.autoOffloadLoad}
                    </Text>
                    <Text variant="labelSmall" style={styles.textDescription}>
                      {l10n.settings.autoOffloadLoadDescription}
                    </Text>
                  </View>
                  <Switch
                    testID="auto-offload-load-switch"
                    value={modelStore.useAutoRelease}
                    onValueChange={value =>
                      modelStore.updateUseAutoRelease(value)
                    }
                  />
                </View>
                <Divider />

                {/* Auto Navigate to Chat */}
                <View style={styles.switchContainer}>
                  <View style={styles.textContainer}>
                    <Text variant="titleMedium" style={styles.textLabel}>
                      {l10n.settings.autoNavigateToChat}
                    </Text>
                    <Text variant="labelSmall" style={styles.textDescription}>
                      {l10n.settings.autoNavigateToChatDescription}
                    </Text>
                  </View>
                  <Switch
                    testID="auto-navigate-to-chat-switch"
                    value={uiStore.autoNavigatetoChat}
                    onValueChange={value =>
                      uiStore.setAutoNavigateToChat(value)
                    }
                  />
                </View>
              </View>
            </Card.Content>
          </Card>

          {/* UI Settings */}
          <Card elevation={0} style={styles.card}>
            <Card.Title title={l10n.settings.appSettings} />
            <Card.Content>
              <View style={styles.settingItemContainer}>
                {/* Language Selection */}
                <View style={styles.switchContainer}>
                  <View style={styles.textContainer}>
                    <View style={styles.labelWithIconContainer}>
                      <GlobeIcon
                        width={20}
                        height={20}
                        style={styles.settingIcon}
                        stroke={theme.colors.onSurface}
                      />
                      <Text variant="titleMedium" style={styles.textLabel}>
                        {l10n.settings.language}
                      </Text>
                    </View>
                  </View>
                  <View style={styles.menuContainer}>
                    <Button
                      ref={languageButtonRef}
                      mode="outlined"
                      onPress={handleLanguagePress}
                      style={styles.menuButton}
                      contentStyle={styles.buttonContent}
                      icon={({size, color}) => (
                        <Icon source="chevron-down" size={size} color={color} />
                      )}>
                      {languageNames[uiStore.language]}
                    </Button>
                    <Menu
                      visible={showLanguageMenu}
                      onDismiss={() => setShowLanguageMenu(false)}
                      anchor={languageAnchor}
                      selectable>
                      {uiStore.supportedLanguages.map(lang => (
                        <Menu.Item
                          key={lang}
                          style={styles.menu}
                          label={languageNames[lang]}
                          selected={lang === uiStore.language}
                          onPress={() => {
                            uiStore.setLanguage(lang);
                            setShowLanguageMenu(false);
                          }}
                        />
                      ))}
                    </Menu>
                  </View>
                </View>
                <Divider />

                {/* Dark Mode */}
                <View style={styles.switchContainer}>
                  <View style={styles.textContainer}>
                    <View style={styles.labelWithIconContainer}>
                      <MoonIcon
                        width={20}
                        height={20}
                        style={styles.settingIcon}
                        stroke={theme.colors.onSurface}
                      />
                      <Text variant="titleMedium" style={styles.textLabel}>
                        {l10n.settings.darkMode}
                      </Text>
                    </View>
                  </View>
                  <Switch
                    testID="dark-mode-switch"
                    value={uiStore.colorScheme === 'dark'}
                    onValueChange={value =>
                      uiStore.setColorScheme(value ? 'dark' : 'light')
                    }
                  />
                </View>

                {/* Display Memory Usage (iOS only) */}
                {Platform.OS === 'ios' && (
                  <>
                    <Divider />
                    <View style={styles.switchContainer}>
                      <View style={styles.textContainer}>
                        <View style={styles.labelWithIconContainer}>
                          <CpuChipIcon
                            width={20}
                            height={20}
                            style={styles.settingIcon}
                            stroke={theme.colors.onSurface}
                          />
                          <Text variant="titleMedium" style={styles.textLabel}>
                            {l10n.settings.displayMemoryUsage}
                          </Text>
                        </View>
                        <Text
                          variant="labelSmall"
                          style={styles.textDescription}>
                          {l10n.settings.displayMemoryUsageDescription}
                        </Text>
                      </View>
                      <Switch
                        testID="display-memory-usage-switch"
                        value={uiStore.displayMemUsage}
                        onValueChange={value =>
                          uiStore.setDisplayMemUsage(value)
                        }
                      />
                    </View>
                  </>
                )}
              </View>
            </Card.Content>
          </Card>

          {/* API Settings */}
          <Card elevation={0} style={styles.card}>
            <Card.Title title={l10n.settings.apiSettingsTitle} />
            <Card.Content>
              <View style={styles.settingItemContainer}>
                {/* Hugging Face Token */}
                <View style={styles.switchContainer}>
                  <View style={styles.textContainer}>
                    <Text variant="titleMedium" style={styles.textLabel}>
                      {l10n.settings.huggingFaceTokenLabel}
                    </Text>
                    <Text variant="labelSmall" style={styles.textDescription}>
                      {hfStore.isTokenPresent
                        ? l10n.settings.tokenIsSetDescription
                        : l10n.settings.setTokenDescription}
                    </Text>
                  </View>
                  <Button
                    mode="outlined"
                    onPress={() => setShowHfTokenDialog(true)}
                    style={styles.menuButton}>
                    {hfStore.isTokenPresent
                      ? l10n.common.update
                      : l10n.settings.setTokenButton}
                  </Button>
                </View>

                {/* Use HF Token Switch */}
                <Divider style={styles.divider} />
                <View style={styles.switchContainer}>
                  <View style={styles.textContainer}>
                    <Text variant="titleMedium" style={styles.textLabel}>
                      {l10n.settings.useHfTokenLabel}
                    </Text>
                    <Text variant="labelSmall" style={styles.textDescription}>
                      {l10n.settings.useHfTokenDescription}
                    </Text>
                  </View>
                  <Switch
                    testID="use-hf-token-switch"
                    value={hfStore.useHfToken}
                    disabled={!hfStore.isTokenPresent}
                    onValueChange={value => hfStore.setUseHfToken(value)}
                  />
                </View>
              </View>
            </Card.Content>
          </Card>

          {/* Export Options */}
          <Card elevation={0} style={styles.card}>
            <Card.Title title={l10n.settings.exportOptions} />
            <Card.Content>
              <View style={styles.settingItemContainer}>
                {/* Legacy Export */}
                <View style={styles.switchContainer}>
                  <View style={styles.textContainer}>
                    <View style={styles.labelWithIconContainer}>
                      <ShareIcon
                        width={20}
                        height={20}
                        style={styles.settingIcon}
                        stroke={theme.colors.onSurface}
                      />
                      <Text variant="titleMedium" style={styles.textLabel}>
                        {l10n.settings.exportLegacyChats}
                      </Text>
                    </View>
                    <Text variant="labelSmall" style={styles.textDescription}>
                      {l10n.settings.exportLegacyChatsDescription}
                    </Text>
                  </View>
                  <Button
                    mode="outlined"
                    onPress={async () => {
                      try {
                        await exportLegacyChatSessions();
                      } catch (error) {
                        Alert.alert(
                          'Export Error',
                          'Failed to export legacy chat sessions. The file may not exist.',
                        );
                      }
                    }}
                    style={styles.menuButton}>
                    {l10n.settings.exportButton}
                  </Button>
                </View>
              </View>
            </Card.Content>
          </Card>
        </ScrollView>
      </TouchableWithoutFeedback>
      <HFTokenSheet
        isVisible={showHfTokenDialog}
        onDismiss={() => setShowHfTokenDialog(false)}
        onSave={() => setShowHfTokenDialog(false)}
      />
    </SafeAreaView>
  );
});



================================================
FILE: src/screens/SettingsScreen/styles.ts
================================================
import {StyleSheet} from 'react-native';

import {Theme} from '../../utils/types';

export const createStyles = (theme: Theme) =>
  StyleSheet.create({
    safeArea: {
      flex: 1,
      backgroundColor: theme.colors.surface,
    },
    container: {
      padding: 16,
    },
    scrollViewContent: {
      paddingVertical: 16,
      paddingHorizontal: 16,
    },
    card: {
      marginVertical: 8,
      borderRadius: 12,
      backgroundColor: theme.colors.background,
    },
    settingItemContainer: {
      marginVertical: 16,
    },
    switchContainer: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginVertical: 8,
    },
    textContainer: {
      flex: 1,
      marginRight: 16,
    },
    labelWithIconContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginBottom: 4,
    },
    settingIcon: {
      marginRight: 8,
    },
    textLabel: {
      color: theme.colors.onSurface,
    },
    textDescription: {
      color: theme.colors.onSurfaceVariant,
      //marginTop: 4,
    },
    divider: {
      marginVertical: 12,
    },
    slider: {
      //marginVertical: 8,
      //height: 40,
    },
    textInput: {
      marginVertical: 8,
    },
    invalidInput: {
      borderColor: theme.colors.error,
      borderWidth: 1,
    },
    errorText: {
      color: theme.colors.error,
      marginTop: 4,
    },
    menuContainer: {
      position: 'relative',
    },
    menuButton: {
      minWidth: 100,
    },
    buttonContent: {
      flexDirection: 'row-reverse',
      justifyContent: 'space-between',
    },
    advancedSettingsButton: {
      marginVertical: 8,
    },
    advancedSettingsContent: {
      marginTop: 8,
    },
    advancedAccordion: {
      height: 55,
      //backgroundColor: theme.colors.surface,
    },
    accordionTitle: {
      fontSize: 14,
      color: theme.colors.secondary,
    },
    menu: {
      width: 170,
    },
  });



================================================
FILE: src/screens/SettingsScreen/__tests__/SettingsScreen.test.tsx
================================================
import React from 'react';
import {Platform, Keyboard} from 'react-native';

import {fireEvent, render, waitFor, act} from '../../../../jest/test-utils';

import {SettingsScreen} from '../SettingsScreen';

import {modelStore, uiStore} from '../../../store';

jest.useFakeTimers();

describe('SettingsScreen', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    jest.spyOn(Keyboard, 'dismiss');
  });

  it('renders settings screen correctly', async () => {
    const {getByText, getByDisplayValue} = render(<SettingsScreen />, {
      withSafeArea: true,
      withNavigation: true,
    });

    expect(getByText('Model Initialization Settings')).toBeTruthy();
    expect(getByText('Model Loading Settings')).toBeTruthy();
    expect(getByText('App Settings')).toBeTruthy();
    expect(getByDisplayValue('1024')).toBeTruthy(); // Context size
  });

  it('updates context size correctly', async () => {
    jest.useFakeTimers();
    const {getByDisplayValue} = render(<SettingsScreen />, {
      withSafeArea: true,
      withNavigation: true,
    });
    const contextSizeInput = getByDisplayValue('1024');

    await act(async () => {
      fireEvent.changeText(contextSizeInput, '512');
    });
    await act(async () => {
      fireEvent(contextSizeInput, 'blur');
    });

    jest.advanceTimersByTime(501); // Wait for debounce

    await waitFor(() => {
      expect(modelStore.setNContext).toHaveBeenCalledWith(512);
    });
    jest.useRealTimers();
  });

  it('displays error for invalid context size input', async () => {
    const {getByDisplayValue, getByText} = render(<SettingsScreen />, {
      withSafeArea: true,
      withNavigation: true,
    });
    const contextSizeInput = getByDisplayValue('1024');

    await act(async () => {
      fireEvent.changeText(contextSizeInput, '100'); // Below minimum size
    });

    expect(getByText('Please enter a valid number (minimum 200)')).toBeTruthy();
  });

  it('handles outside press correctly and resets input', async () => {
    const {getByDisplayValue, getByText} = render(<SettingsScreen />, {
      withSafeArea: true,
      withNavigation: true,
    });
    const contextSizeInput = getByDisplayValue('1024');

    fireEvent.changeText(contextSizeInput, '512');
    fireEvent.press(getByText('Model Initialization Settings'));

    await waitFor(() => {
      expect(Keyboard.dismiss).toHaveBeenCalled();
      expect(getByDisplayValue('1024')).toBeTruthy(); // Reset back to original size
    });
  });

  it('toggles Auto Offload/Load switch', async () => {
    const {getByTestId} = render(<SettingsScreen />, {
      withSafeArea: true,
      withNavigation: true,
    });
    const autoOffloadSwitch = getByTestId('auto-offload-load-switch');

    await act(async () => {
      fireEvent(autoOffloadSwitch, 'valueChange', false);
    });

    expect(modelStore.updateUseAutoRelease).toHaveBeenCalledWith(false);
  });

  it('toggles Auto-Navigate to Chat switch', async () => {
    const {getByTestId} = render(<SettingsScreen />, {
      withSafeArea: true,
      withNavigation: true,
    });
    const autoNavigateSwitch = getByTestId('auto-navigate-to-chat-switch');

    await act(async () => {
      fireEvent(autoNavigateSwitch, 'valueChange', false);
    });

    expect(uiStore.setAutoNavigateToChat).toHaveBeenCalledWith(false);
  });

  it('toggles Dark Mode switch', async () => {
    const {getByTestId} = render(<SettingsScreen />, {
      withSafeArea: true,
      withNavigation: true,
    });
    const darkModeSwitch = getByTestId('dark-mode-switch');

    await act(async () => {
      fireEvent(darkModeSwitch, 'valueChange', true);
    });

    expect(uiStore.setColorScheme).toHaveBeenCalledWith('dark');
  });

  it('toggles Metal switch on iOS and adjusts GPU layers', async () => {
    Platform.OS = 'ios';

    const {getByTestId} = render(<SettingsScreen />, {
      withSafeArea: true,
      withNavigation: true,
    });
    const metalSwitch = getByTestId('metal-switch');

    await act(async () => {
      fireEvent(metalSwitch, 'valueChange', true);
    });

    expect(modelStore.updateUseMetal).toHaveBeenCalledWith(true);

    const gpuSlider = getByTestId('gpu-layers-slider');

    await act(async () => {
      fireEvent(gpuSlider, 'valueChange', 60);
    });

    expect(modelStore.setNGPULayers).toHaveBeenCalledWith(60);
  });

  it('toggles Display Memory Usage switch', async () => {
    const {getByTestId} = render(<SettingsScreen />, {
      withSafeArea: true,
      withNavigation: true,
    });
    const memoryUsageSwitch = getByTestId('display-memory-usage-switch');

    await act(async () => {
      fireEvent(memoryUsageSwitch, 'valueChange', true);
    });

    expect(uiStore.setDisplayMemUsage).toHaveBeenCalledWith(true);
  });
});



================================================
FILE: src/services/downloads/DownloadManager.ts
================================================
import * as RNFS from '@dr.pogodin/react-native-fs';
import {makeAutoObservable, observable} from 'mobx';
import {NativeEventEmitter, NativeModules, Platform} from 'react-native';

import {
  DownloadEventCallbacks,
  DownloadJob,
  DownloadMap,
  DownloadProgress,
} from './types';

import {Model} from '../../utils/types';
import {formatBytes, hasEnoughSpace} from '../../utils';
import {uiStore} from '../../store';

const {DownloadModule} = NativeModules;
const TAG = 'DownloadManager';

export class DownloadManager {
  private downloadJobs: DownloadMap;
  private callbacks: DownloadEventCallbacks = {};
  private eventEmitter: NativeEventEmitter | null = null;

  constructor() {
    console.log(`${TAG}: Initializing DownloadManager`);
    this.downloadJobs = observable.map(new Map());
    makeAutoObservable(this);

    if (Platform.OS === 'android') {
      this.setupAndroidEventListener();
    }
  }

  private setupAndroidEventListener() {
    if (DownloadModule) {
      console.log(`${TAG}: Setting up Android event listeners`);
      this.eventEmitter = new NativeEventEmitter(DownloadModule);

      this.eventEmitter.addListener('onDownloadProgress', event => {
        // console.log(
        //   `${TAG}: Progress event received for ID ${event.downloadId}:`,
        //   {
        //     bytesWritten: event.bytesWritten,
        //     totalBytes: event.totalBytes,
        //     progress: event.progress,
        //   },
        // );

        // Find the job by download ID
        const job = Array.from(this.downloadJobs.values()).find(
          _job => _job.downloadId === event.downloadId,
        );

        if (!job) {
          console.warn(
            `${TAG}: No job found for download ID: ${event.downloadId}. This may indicate the job was completed or cancelled.`,
          );
          return;
        }

        // Calculate speed
        const currentTime = Date.now();
        const timeDiff = (currentTime - job.lastUpdateTime) / 1000 || 1;
        const bytesDiff = event.bytesWritten - job.lastBytesWritten;
        const speedBps = bytesDiff / timeDiff;
        const speedMBps = (speedBps / (1024 * 1024)).toFixed(2);

        // Calculate ETA
        const remainingBytes = event.totalBytes - event.bytesWritten;
        const etaSeconds = speedBps > 0 ? remainingBytes / speedBps : 0;
        const etaMinutes = Math.ceil(etaSeconds / 60);
        const l10nData = uiStore.l10n;
        const etaText =
          etaSeconds >= 60
            ? `${etaMinutes} ${l10nData.common.minutes}`
            : `${Math.ceil(etaSeconds)} ${l10nData.common.seconds}`;

        const progress: DownloadProgress = {
          bytesDownloaded: event.bytesWritten,
          bytesTotal: event.totalBytes,
          progress: event.progress,
          speed: `${formatBytes(event.bytesWritten)} (${speedMBps} MB/s)`,
          eta: etaText,
          rawSpeed: speedBps,
          rawEta: etaSeconds,
        };

        // console.log(
        //   `${TAG}: Updating progress for model ${job.model.id}:`,
        //   progress,
        // );

        // Update job state
        job.state.progress = progress;
        job.lastBytesWritten = event.bytesWritten;
        job.lastUpdateTime = currentTime;

        this.callbacks.onProgress?.(job.model.id, progress);
      });

      this.eventEmitter.addListener('onDownloadComplete', event => {
        console.log(`${TAG}: Download completed for ID: ${event.downloadId}`);
        // Find the job by download ID
        const job = Array.from(this.downloadJobs.values()).find(
          _job => _job.downloadId === event.downloadId,
        );

        if (job) {
          // Set final state before removing
          job.state.isDownloading = false;
          job.state.progress = {
            bytesDownloaded: job.state.progress?.bytesTotal || 0,
            bytesTotal: job.state.progress?.bytesTotal || 0,
            progress: 100,
            speed: '0 B/s',
            eta: '0 sec',
            rawSpeed: 0,
            rawEta: 0,
          };
          // Ensure callback is called before removing the job
          this.callbacks.onComplete?.(job.model.id);
          this.downloadJobs.delete(job.model.id);
          console.log(`${TAG}: Removed completed job: ${job.model.id}`);
        } else {
          console.warn(
            `${TAG}: Completion event received for non-existent job: ${event.downloadId}`,
          );
        }
      });

      this.eventEmitter.addListener('onDownloadFailed', event => {
        console.error(
          `${TAG}: (js) Download failed for ID: ${event.downloadId}`,
          event.error,
        );
        // Find the job by download ID
        const job = Array.from(this.downloadJobs.values()).find(
          _job => _job.downloadId === event.downloadId,
        );

        if (job) {
          job.state.error = new Error(event.error);
          job.state.isDownloading = false;
          // Ensure callback is called before removing the job
          this.callbacks.onError?.(job.model.id, new Error(event.error));
          this.downloadJobs.delete(job.model.id);
          console.log(`${TAG}: Removed failed job: ${job.model.id}`);
        } else {
          console.warn(
            `${TAG}: Failure event received for non-existent job: ${event.downloadId}`,
          );
        }
      });
    } else {
      console.error(`${TAG}: DownloadModule is not available`);
    }
  }

  private calculateEta(
    bytesDownloaded: number,
    totalBytes: number,
    speedBps: number,
  ): string {
    const l10nData = uiStore.l10n;
    if (speedBps <= 0) {
      return l10nData.common.calculating;
    }

    const remainingBytes = totalBytes - bytesDownloaded;
    const etaSeconds = remainingBytes / speedBps;
    const etaMinutes = Math.ceil(etaSeconds / 60);

    const eta =
      etaSeconds >= 60
        ? `${etaMinutes} ${l10nData.common.minutes}`
        : `${Math.ceil(etaSeconds)} ${l10nData.common.seconds}`;
    console.log(`${TAG}: Calculated ETA:`, {
      remainingBytes,
      speedBps,
      eta,
    });
    return eta;
  }

  setCallbacks(callbacks: DownloadEventCallbacks) {
    console.log(`${TAG}: Setting callbacks`);
    this.callbacks = callbacks;
  }

  isDownloading(modelId: string): boolean {
    const isDownloading = this.downloadJobs.has(modelId);
    return isDownloading;
  }

  getDownloadProgress(modelId: string): number {
    const progress =
      this.downloadJobs.get(modelId)?.state.progress?.progress || 0;
    console.log(`${TAG}: Getting progress for model ${modelId}:`, progress);
    return progress;
  }

  async startDownload(
    model: Model,
    destinationPath: string,
    authToken?: string | null,
  ): Promise<void> {
    console.log(`${TAG}: Starting download for model:`, {
      modelId: model.id,
      destination: destinationPath,
      url: model.downloadUrl,
    });

    if (this.isDownloading(model.id)) {
      console.log(`${TAG}: Download already in progress for model:`, model.id);
      return;
    }

    if (!model.downloadUrl) {
      console.error(`${TAG}: Model has no download URL`);
      throw new Error('Model has no download URL');
    }

    const isEnoughSpace = await hasEnoughSpace(model);
    if (!isEnoughSpace) {
      console.error(`${TAG}: Not enough storage space for model:`, {
        modelId: model.id,
        size: model.size,
      });
      throw new Error('Not enough storage space to download the model');
    }

    const dirPath = destinationPath.substring(
      0,
      destinationPath.lastIndexOf('/'),
    );
    try {
      console.log(`${TAG}: Creating directory:`, dirPath);
      await RNFS.mkdir(dirPath);
    } catch (err) {
      console.error(`${TAG}: Failed to create directory:`, err);
      throw err;
    }

    if (Platform.OS === 'ios') {
      await this.startIOSDownload(model, destinationPath, authToken);
    } else {
      await this.startAndroidDownload(model, destinationPath, authToken);
    }
  }

  private async startIOSDownload(
    model: Model,
    destinationPath: string,
    authToken?: string | null,
  ): Promise<void> {
    try {
      const downloadJob: DownloadJob = {
        model,
        state: {
          isDownloading: true,
          progress: null,
          error: null,
        },
        destination: destinationPath,
        lastBytesWritten: 0,
        lastUpdateTime: Date.now(),
      };

      this.downloadJobs.set(model.id, downloadJob);
      this.callbacks.onStart?.(model.id);

      // Create the download task
      const downloadResult = RNFS.downloadFile({
        fromUrl: model.downloadUrl!,
        toFile: destinationPath,
        background: uiStore.iOSBackgroundDownloading,
        discretionary: false,
        progressInterval: 800,
        headers: {
          ...(authToken ? {Authorization: `Bearer ${authToken}`} : {}),
        },
        begin: res => {
          console.log(`${TAG}: Download started for ID: ${model.id}`, {
            statusCode: res.statusCode,
            contentLength: res.contentLength,
            headers: res.headers,
            jobId: downloadResult.jobId,
          });

          // Initialize progress
          const progress: DownloadProgress = {
            bytesDownloaded: 0,
            bytesTotal: res.contentLength,
            progress: 0,
            speed: '0 B/s',
            eta: uiStore.l10n.common.calculating,
            rawSpeed: 0,
            rawEta: 0,
          };

          downloadJob.state.progress = progress;
          this.callbacks.onProgress?.(model.id, progress);
        },
        progress: res => {
          if (!this.downloadJobs.has(model.id)) {
            return;
          }

          const job = this.downloadJobs.get(model.id)!;
          const currentTime = Date.now();
          const timeDiff = (currentTime - job.lastUpdateTime) / 1000 || 1;
          const bytesDiff = res.bytesWritten - job.lastBytesWritten;
          const speedBps = bytesDiff / timeDiff;
          const speedMBps = (speedBps / (1024 * 1024)).toFixed(2);

          const remainingBytes = res.contentLength - res.bytesWritten;
          const etaSeconds = speedBps > 0 ? remainingBytes / speedBps : 0;
          const etaMinutes = Math.ceil(etaSeconds / 60);
          const l10nData = uiStore.l10n;
          const etaText =
            etaSeconds >= 60
              ? `${etaMinutes} ${l10nData.common.minutes}`
              : `${Math.ceil(etaSeconds)} ${l10nData.common.seconds}`;

          const progress: DownloadProgress = {
            bytesDownloaded: res.bytesWritten,
            bytesTotal: res.contentLength,
            progress: (res.bytesWritten / res.contentLength) * 100,
            speed: `${formatBytes(res.bytesWritten)} (${speedMBps} MB/s)`,
            eta: etaText,
            rawSpeed: speedBps,
            rawEta: etaSeconds,
          };

          job.state.progress = progress;
          job.lastBytesWritten = res.bytesWritten;
          job.lastUpdateTime = currentTime;

          this.callbacks.onProgress?.(model.id, progress);
        },
      });

      // Store the jobId immediately for cancellation
      downloadJob.jobId = downloadResult.jobId;
      console.log(
        `${TAG}: Created download with jobId: ${downloadResult.jobId}`,
      );

      // Add job to map after setting jobId
      this.downloadJobs.set(model.id, downloadJob);

      // Wait for the download to complete
      const result = await downloadResult.promise;

      if (result.statusCode === 200) {
        console.log(
          `${TAG}: Download completed successfully for ID: ${model.id}`,
        );
        this.callbacks.onComplete?.(model.id);
        this.downloadJobs.delete(model.id);
      } else {
        console.error(
          `${TAG}: Download failed with status: ${result.statusCode} for ID: ${model.id}`,
        );
        throw new Error(`Download failed with status: ${result.statusCode}`);
      }
    } catch (error) {
      console.error(`${TAG}: Download failed for ID: ${model.id}:`, error);
      const job = this.downloadJobs.get(model.id);
      if (job) {
        job.state.error =
          error instanceof Error ? error : new Error(String(error));
        job.state.isDownloading = false;
      }
      this.downloadJobs.delete(model.id);
      this.callbacks.onError?.(
        model.id,
        error instanceof Error ? error : new Error(String(error)),
      );
      throw error;
    }
  }

  private async startAndroidDownload(
    model: Model,
    destinationPath: string,
    authToken?: string | null,
  ): Promise<void> {
    try {
      console.log(`${TAG}: Starting Android download for model:`, {
        modelId: model.id,
        destination: destinationPath,
      });

      const downloadJob: DownloadJob = {
        model,
        state: {
          isDownloading: true,
          progress: null,
          error: null,
        },
        destination: destinationPath,
        lastBytesWritten: 0,
        lastUpdateTime: Date.now(),
      };

      // Start the download first to get the download ID
      const response = await DownloadModule.startDownload(model.downloadUrl!, {
        destination: destinationPath,
        networkType: 'ANY',
        priority: 1,
        progressInterval: 1000,
        ...(authToken ? {authToken} : {}),
      });

      // Store the download ID
      downloadJob.downloadId = response.downloadId;
      console.log(`${TAG}: Download started with ID: ${response.downloadId}`);

      // Add job to map after getting download ID
      this.downloadJobs.set(model.id, downloadJob);
      this.callbacks.onStart?.(model.id);
    } catch (error) {
      console.error(`${TAG}: Failed to start Android download:`, {
        modelId: model.id,
        error: error instanceof Error ? error.message : String(error),
      });

      const job = this.downloadJobs.get(model.id);
      if (job) {
        job.state.error =
          error instanceof Error ? error : new Error(String(error));
        job.state.isDownloading = false;
      }
      this.downloadJobs.delete(model.id);
      this.callbacks.onError?.(
        model.id,
        error instanceof Error ? error : new Error(String(error)),
      );
      throw error;
    }
  }

  async cancelDownload(modelId: string): Promise<void> {
    console.log(`${TAG}: Attempting to cancel download:`, modelId);
    const job = this.downloadJobs.get(modelId);
    if (job) {
      try {
        if (Platform.OS === 'ios') {
          console.log(
            `${TAG}: Cancelling iOS download for ID: ${modelId}, jobId: ${job.jobId}`,
          );
          if (job.jobId) {
            RNFS.stopDownload(job.jobId); // job.jobId is now correctly typed as number
          }
        } else if (Platform.OS === 'android' && DownloadModule) {
          console.log(`${TAG}: Cancelling Android download:`, modelId);
          await DownloadModule.cancelDownload(job.downloadId);
        }

        // Clean up the partial download file
        const destinationPath = job.destination;
        if (destinationPath) {
          console.log(
            `${TAG}: Cleaning up partial download file:`,
            destinationPath,
          );
          try {
            const exists = await RNFS.exists(destinationPath);
            if (exists) {
              await RNFS.unlink(destinationPath);
              console.log(
                `${TAG}: Successfully deleted partial download file:`,
                destinationPath,
              );
            }
          } catch (fileError) {
            if ((fileError as any)?.code !== 'ENOENT') {
              console.error(`${TAG}: Error deleting partial download file:`, {
                path: destinationPath,
                error:
                  fileError instanceof Error
                    ? fileError.message
                    : String(fileError),
              });
            }
          }
        }

        // Update state and remove job
        job.state.isDownloading = false;
        this.downloadJobs.delete(modelId);
        console.log(`${TAG}: Removed cancelled job:`, modelId);
      } catch (err) {
        console.error(`${TAG}: Error cancelling download:`, {
          modelId,
          error: err instanceof Error ? err.message : String(err),
        });
      }
    } else {
      console.warn(`${TAG}: No download job found to cancel:`, modelId);
    }
  }

  cleanup() {
    console.log(`${TAG}: Cleaning up download manager`);
    if (Platform.OS === 'android' && this.eventEmitter) {
      console.log(`${TAG}: Removing Android event listeners`);
      this.eventEmitter.removeAllListeners('onDownloadProgress');
      this.eventEmitter.removeAllListeners('onDownloadComplete');
      this.eventEmitter.removeAllListeners('onDownloadFailed');
    }
    this.downloadJobs.clear();
    console.log(`${TAG}: Download jobs cleared`);
  }

  /**
   * Synchronizes the downloadJobs map with active downloads in the native layer.
   * This should be called after the model store is initialized.
   */
  syncWithActiveDownloads = async (models: Model[]): Promise<void> => {
    if (Platform.OS !== 'android' || !DownloadModule) {
      return;
    }

    try {
      console.log(`${TAG}: Syncing download jobs with native layer`);

      // Get active downloads from native module
      const activeDownloads = await DownloadModule.getActiveDownloads();
      console.log(
        `${TAG}: Found ${activeDownloads.length} active downloads in native layer`,
      );

      if (activeDownloads.length === 0) {
        return;
      }

      // For each active download, find the corresponding model and create a download job
      for (const download of activeDownloads) {
        const model = models.find(m => {
          return m.downloadUrl && download.url === m.downloadUrl;
        });

        if (!model) {
          console.warn(
            `${TAG}: Could not find model for download: ${download.destination}`,
          );
          continue;
        }

        // Parse numeric values safely
        const bytesWritten =
          typeof download.bytesWritten === 'string'
            ? parseInt(download.bytesWritten, 10)
            : download.bytesWritten || 0;

        const totalBytes =
          typeof download.totalBytes === 'string'
            ? parseInt(download.totalBytes, 10)
            : download.totalBytes || 0;

        const progress =
          typeof download.progress === 'string'
            ? parseFloat(download.progress)
            : download.progress || 0;

        // Create a download job for this model
        const downloadJob: DownloadJob = {
          model,
          downloadId: download.id,
          state: {
            isDownloading: true,
            progress: {
              bytesDownloaded: bytesWritten,
              bytesTotal: totalBytes,
              progress: progress,
              speed: '0 B/s',
              eta: uiStore.l10n.common.calculating,
              rawSpeed: 0,
              rawEta: 0,
            },
            error: null,
          },
          destination: download.destination,
          lastBytesWritten: bytesWritten,
          lastUpdateTime: Date.now(),
        };

        // Add to downloadJobs map
        this.downloadJobs.set(model.id, downloadJob);
        console.log(
          `${TAG}: Restored download job for model: ${model.id}, progress: ${progress}%`,
        );

        // Notify listeners that download is in progress
        this.callbacks.onStart?.(model.id);

        // Re-register for progress updates by calling the native module
        try {
          // We need to tell the native module to re-register the observer for this download
          if (DownloadModule.reattachDownloadObserver) {
            await DownloadModule.reattachDownloadObserver(download.id);
            console.log(
              `${TAG}: Re-attached observer for download ID: ${download.id}`,
            );
          } else {
            console.warn(
              `${TAG}: reattachDownloadObserver method not available in DownloadModule`,
            );
          }
        } catch (error) {
          console.error(`${TAG}: Error re-attaching observer:`, error);
        }
      }
    } catch (error) {
      console.error(`${TAG}: Error syncing download jobs:`, error);
    }
  };
}



================================================
FILE: src/services/downloads/index.ts
================================================
// Create a singleton instance
import {DownloadManager} from './DownloadManager';

export * from './types';
export * from './DownloadManager';

export const downloadManager = new DownloadManager();



================================================
FILE: src/services/downloads/types.ts
================================================
import {Model} from '../../utils/types';

export interface DownloadProgress {
  bytesDownloaded: number;
  bytesTotal: number;
  progress: number; // percentage (0-100)
  speed: string; // formatted string like "1.5 MB/s"
  eta: string; // formatted string like "2 min" or "30 sec"
  rawSpeed?: number; // raw speed in bytes per second
  rawEta?: number; // raw eta in seconds
}

export interface DownloadState {
  isDownloading: boolean;
  progress: DownloadProgress | null;
  error: Error | null;
}

export interface DownloadJob {
  model: Model;
  jobId?: number; // For iOS downloads - RNFS uses number for jobId
  downloadId?: string; // For Android downloads - UUID returned by WorkManager
  state: {
    isDownloading: boolean;
    progress: DownloadProgress | null;
    error: Error | null;
  };
  destination: string;
  lastBytesWritten: number;
  lastUpdateTime: number;
}

export type DownloadMap = Map<string, DownloadJob>;

export interface DownloadEventCallbacks {
  onStart?: (modelId: string) => void;
  onProgress?: (modelId: string, progress: DownloadProgress) => void;
  onComplete?: (modelId: string) => void;
  onError?: (modelId: string, error: Error) => void;
}



================================================
FILE: src/services/downloads/__tests__/DownloadManager.test.ts
================================================
import {NativeModules, Platform, NativeEventEmitter} from 'react-native';

import * as RNFS from '@dr.pogodin/react-native-fs';

import {basicModel} from '../../../../jest/fixtures/models';

import {DownloadManager} from '../DownloadManager';

jest.mock('react-native', () => ({
  NativeModules: {
    DownloadModule: {
      startDownload: jest.fn(),
      cancelDownload: jest.fn(),
      getActiveDownloads: jest.fn(),
      reattachDownloadObserver: jest.fn(),
    },
  },
  NativeEventEmitter: jest.fn(),
  Platform: {
    OS: 'android',
  },
  Appearance: {
    getColorScheme: jest.fn(() => 'light'),
  },
}));

describe('DownloadManager', () => {
  let downloadManager: DownloadManager;
  let mockEventEmitter: any;

  beforeEach(() => {
    jest.clearAllMocks();

    // Setup mock event emitter
    mockEventEmitter = {
      addListener: jest.fn(),
      removeAllListeners: jest.fn(),
    };
    (NativeEventEmitter as jest.Mock).mockReturnValue(mockEventEmitter);

    // Reset platform to Android by default
    (Platform as any).OS = 'android';

    downloadManager = new DownloadManager();
  });

  it('initializes correctly', () => {
    expect(downloadManager).toBeDefined();
    expect(NativeEventEmitter).toHaveBeenCalled();
    expect(mockEventEmitter.addListener).toHaveBeenCalledWith(
      'onDownloadProgress',
      expect.any(Function),
    );
    expect(mockEventEmitter.addListener).toHaveBeenCalledWith(
      'onDownloadComplete',
      expect.any(Function),
    );
    expect(mockEventEmitter.addListener).toHaveBeenCalledWith(
      'onDownloadFailed',
      expect.any(Function),
    );
  });

  it('starts a download on Android', async () => {
    NativeModules.DownloadModule.startDownload.mockResolvedValue({
      downloadId: 'download123',
    });

    const callbacks = {
      onStart: jest.fn(),
      onProgress: jest.fn(),
      onComplete: jest.fn(),
      onError: jest.fn(),
    };

    downloadManager.setCallbacks(callbacks);

    await downloadManager.startDownload(basicModel, '/path/to/model.bin');

    expect(RNFS.mkdir).toHaveBeenCalledWith('/path/to');
    expect(NativeModules.DownloadModule.startDownload).toHaveBeenCalledWith(
      basicModel.downloadUrl,
      expect.objectContaining({
        destination: '/path/to/model.bin',
      }),
    );
    expect(callbacks.onStart).toHaveBeenCalledWith('model-1');
    expect(downloadManager.isDownloading('model-1')).toBe(true);
  });

  it('starts a download on iOS', async () => {
    (Platform as any).OS = 'ios';

    const mockDownloadResult = {
      jobId: 123,
      promise: Promise.resolve({statusCode: 200}),
    };

    (RNFS.downloadFile as jest.Mock).mockReturnValue(mockDownloadResult);

    const callbacks = {
      onStart: jest.fn(),
      onProgress: jest.fn(),
      onComplete: jest.fn(),
      onError: jest.fn(),
    };

    downloadManager.setCallbacks(callbacks);

    await downloadManager.startDownload(basicModel, '/path/to/model.bin');

    expect(RNFS.mkdir).toHaveBeenCalledWith('/path/to');
    expect(RNFS.downloadFile).toHaveBeenCalledWith(
      expect.objectContaining({
        fromUrl: basicModel.downloadUrl,
        toFile: '/path/to/model.bin',
      }),
    );

    expect(callbacks.onComplete).toHaveBeenCalledWith('model-1');
    expect(downloadManager.isDownloading('model-1')).toBe(false);
  });

  it('cancels a download', async () => {
    // Setup a download first
    NativeModules.DownloadModule.startDownload.mockResolvedValue({
      downloadId: 'download123',
    });

    await downloadManager.startDownload(basicModel, '/path/to/model.bin');
    expect(downloadManager.isDownloading('model-1')).toBe(true);

    // Now cancel it
    await downloadManager.cancelDownload('model-1');

    expect(NativeModules.DownloadModule.cancelDownload).toHaveBeenCalledWith(
      'download123',
    );
    expect(downloadManager.isDownloading('model1')).toBe(false);
  });

  it('syncs with active downloads', async () => {
    NativeModules.DownloadModule.getActiveDownloads.mockResolvedValue([
      {
        id: 'download123',
        url: basicModel.downloadUrl,
        destination: '/path/to/model.bin',
        bytesWritten: 500000,
        totalBytes: 1000000,
        progress: 50,
      },
    ]);

    const callbacks = {
      onStart: jest.fn(),
    };

    downloadManager.setCallbacks(callbacks);

    await downloadManager.syncWithActiveDownloads([basicModel]);

    expect(NativeModules.DownloadModule.getActiveDownloads).toHaveBeenCalled();
    expect(downloadManager.isDownloading('model-1')).toBe(true);
    expect(downloadManager.getDownloadProgress('model-1')).toBe(50);
    expect(callbacks.onStart).toHaveBeenCalledWith('model-1');
  });

  it('handles download progress events', async () => {
    // Setup a download first
    NativeModules.DownloadModule.startDownload.mockResolvedValue({
      downloadId: 'download123',
    });

    const callbacks = {
      onStart: jest.fn(),
      onProgress: jest.fn(),
    };

    downloadManager.setCallbacks(callbacks);

    // Start download and wait for it to complete
    await downloadManager.startDownload(basicModel, '/path/to/model.bin');

    // Verify the download job was created
    expect(downloadManager.isDownloading('model-1')).toBe(true);

    // Get the progress listener directly from the mock
    const progressListener = mockEventEmitter.addListener.mock.calls.find(
      call => call[0] === 'onDownloadProgress',
    )[1];

    // Call the progress listener with a mock event that matches model ID
    progressListener({
      downloadId: 'download123',
      bytesWritten: 500000,
      totalBytes: 1000000,
      progress: 50,
    });

    // Now check if onProgress was called
    expect(callbacks.onProgress).toHaveBeenCalledWith(
      'model-1', // Make sure this matches model ID
      expect.objectContaining({
        bytesDownloaded: 500000,
        bytesTotal: 1000000,
        progress: 50,
      }),
    );
  });

  it('starts and manages a download on iOS', async () => {
    // Set platform to iOS
    (Platform as any).OS = 'ios';

    // Create a new instance for iOS testing
    const iosDownloadManager = new DownloadManager();

    const callbacks = {
      onStart: jest.fn(),
      onProgress: jest.fn(),
      onComplete: jest.fn(),
      onError: jest.fn(),
    };

    iosDownloadManager.setCallbacks(callbacks);

    let beginCallback: any;
    let progressCallback: any;

    const mockDownloadResult = {
      jobId: 456,
      promise: Promise.resolve({statusCode: 200}),
    };

    (RNFS.downloadFile as jest.Mock).mockImplementation(options => {
      // Save the callbacks so we can call them manually
      beginCallback = options.begin;
      progressCallback = options.progress;
      return mockDownloadResult;
    });

    // Start the download
    const downloadPromise = iosDownloadManager.startDownload(
      basicModel,
      '/path/to/model.bin',
    );

    await jest.runAllTimersAsync();

    expect(RNFS.mkdir).toHaveBeenCalledWith('/path/to');

    expect(RNFS.downloadFile).toHaveBeenCalledWith(
      expect.objectContaining({
        fromUrl: basicModel.downloadUrl,
        toFile: '/path/to/model.bin',
        discretionary: false,
      }),
    );

    expect(iosDownloadManager.isDownloading('model-1')).toBe(true);

    // Simulate begin callback
    beginCallback({
      statusCode: 200,
      contentLength: 1000000,
      headers: {},
    });

    expect(callbacks.onStart).toHaveBeenCalledWith('model-1');
    expect(callbacks.onProgress).toHaveBeenCalledWith(
      'model-1',
      expect.objectContaining({
        bytesDownloaded: 0,
        bytesTotal: 1000000,
        progress: 0,
      }),
    );

    // Reset mock to check next call
    callbacks.onProgress.mockClear();

    // Simulate progress callback (50%)
    progressCallback({
      bytesWritten: 500000,
      contentLength: 1000000,
    });

    expect(callbacks.onProgress).toHaveBeenCalledWith(
      'model-1',
      expect.objectContaining({
        bytesDownloaded: 500000,
        bytesTotal: 1000000,
        progress: 50,
      }),
    );

    // Wait for the download promise to resolve
    await downloadPromise;

    expect(callbacks.onComplete).toHaveBeenCalledWith('model-1');
    expect(iosDownloadManager.isDownloading('model-1')).toBe(false);
  });

  it('handles download failure on iOS', async () => {
    // Set platform to iOS
    (Platform as any).OS = 'ios';

    const iosDownloadManager = new DownloadManager();

    const callbacks = {
      onStart: jest.fn(),
      onProgress: jest.fn(),
      onComplete: jest.fn(),
      onError: jest.fn(),
    };

    iosDownloadManager.setCallbacks(callbacks);

    const mockDownloadResult = {
      jobId: 789,
      promise: Promise.resolve({statusCode: 404}), // Error status
    };

    (RNFS.downloadFile as jest.Mock).mockReturnValue(mockDownloadResult);

    await expect(
      iosDownloadManager.startDownload(basicModel, '/path/to/model.bin'),
    ).rejects.toThrow('Download failed with status: 404');

    expect(callbacks.onError).toHaveBeenCalledWith(
      'model-1',
      expect.any(Error),
    );

    expect(iosDownloadManager.isDownloading('model-1')).toBe(false);
  });
});



================================================
FILE: src/store/BenchmarkStore.ts
================================================
import {makeAutoObservable, runInAction} from 'mobx';
import {makePersistable} from 'mobx-persist-store';
import AsyncStorage from '@react-native-async-storage/async-storage';
import {BenchmarkResult} from '../utils/types';

export class BenchmarkStore {
  results: BenchmarkResult[] = [];

  constructor() {
    makeAutoObservable(this);
    makePersistable(this, {
      name: 'BenchmarkStore',
      properties: ['results'],
      storage: AsyncStorage,
    });
  }

  addResult(result: BenchmarkResult) {
    runInAction(() => {
      this.results.unshift(result); // Add new result at the beginning
    });
  }

  removeResult(timestamp: string) {
    runInAction(() => {
      this.results = this.results.filter(
        result => result.timestamp !== timestamp,
      );
    });
  }

  clearResults() {
    runInAction(() => {
      this.results = [];
    });
  }

  getResultsByModel(modelId: string): BenchmarkResult[] {
    return this.results.filter(result => result.modelId === modelId);
  }

  get latestResult(): BenchmarkResult | undefined {
    return this.results[0];
  }

  markAsSubmitted(uuid: string) {
    runInAction(() => {
      const result = this.results.find(r => r.uuid === uuid);
      if (result) {
        result.submitted = true;
      }
    });
  }
}

export const benchmarkStore = new BenchmarkStore();



================================================
FILE: src/store/ChatSessionStore.ts
================================================
import {LlamaContext} from '@pocketpalai/llama.rn';
import {makeAutoObservable, runInAction} from 'mobx';
import {format, isToday, isYesterday} from 'date-fns';
import * as RNFS from '@dr.pogodin/react-native-fs';

import {assistant} from '../utils/chat';
import {MessageType} from '../utils/types';
import {CompletionParams} from '../utils/completionTypes';
import {chatSessionRepository} from '../repositories/ChatSessionRepository';
import {defaultCompletionParams} from '../utils/completionSettingsVersions';

const NEW_SESSION_TITLE = 'New Session';
const TITLE_LIMIT = 40;

export interface SessionMetaData {
  id: string;
  title: string;
  date: string;
  messages: MessageType.Any[];
  completionSettings: CompletionParams;
  activePalId?: string;
}

interface SessionGroup {
  [key: string]: SessionMetaData[];
}

// Default group names in English as fallback
const DEFAULT_GROUP_NAMES = {
  today: 'Today',
  yesterday: 'Yesterday',
  thisWeek: 'This week',
  lastWeek: 'Last week',
  twoWeeksAgo: '2 weeks ago',
  threeWeeksAgo: '3 weeks ago',
  fourWeeksAgo: '4 weeks ago',
  lastMonth: 'Last month',
  older: 'Older',
};

export const defaultCompletionSettings = {...defaultCompletionParams};
delete defaultCompletionSettings.prompt;
delete defaultCompletionSettings.stop;

class ChatSessionStore {
  sessions: SessionMetaData[] = [];
  activeSessionId: string | null = null;
  isEditMode: boolean = false;
  editingMessageId: string | null = null;
  isGenerating: boolean = false;
  newChatCompletionSettings: CompletionParams = defaultCompletionSettings;
  newChatPalId: string | undefined = undefined;
  // Store localized date group names
  dateGroupNames: typeof DEFAULT_GROUP_NAMES = DEFAULT_GROUP_NAMES;
  // Migration status
  isMigrating: boolean = false;
  migrationComplete: boolean = false;

  constructor() {
    makeAutoObservable(this);
    this.initialize();
  }

  async initialize() {
    try {
      // First check if migration is needed without setting isMigrating flag
      // This is a quick check that just looks for the flag file
      const migrationNeeded = await this.isMigrationNeeded();

      if (migrationNeeded) {
        // Only set isMigrating to true if migration is actually needed
        runInAction(() => {
          this.isMigrating = true;
        });

        // Perform the actual migration
        await chatSessionRepository.checkAndMigrateFromJSON();

        runInAction(() => {
          this.isMigrating = false;
          this.migrationComplete = true;
        });
      } else {
        // Migration not needed, just mark as complete
        runInAction(() => {
          this.migrationComplete = true;
        });
      }

      // Load data from database (whether migration happened or not)
      await this.loadSessionList();
      await this.loadGlobalSettings();
    } catch (error) {
      console.error('Failed to initialize ChatSessionStore:', error);
      runInAction(() => {
        this.isMigrating = false;
        this.migrationComplete = false;
      });
    }
  }

  // Helper method to check if migration is needed without setting isMigrating flag
  private async isMigrationNeeded(): Promise<boolean> {
    try {
      // Check if migration flag file exists
      const migrationFlagPath = `${RNFS.DocumentDirectoryPath}/db-migration-complete.flag`;
      const migrationComplete = await RNFS.exists(migrationFlagPath);

      return !migrationComplete;
    } catch (error) {
      console.error('Error checking migration status:', error);
      return false; // Assume no migration needed if we can't check
    }
  }

  // Method to set localized date group names from React components
  setDateGroupNames(l10nDateGroups: typeof DEFAULT_GROUP_NAMES) {
    this.dateGroupNames = l10nDateGroups;
  }

  get shouldShowHeaderDivider(): boolean {
    return (
      !this.activeSessionId ||
      (this.currentSessionMessages.length === 0 &&
        !this.isGenerating &&
        !this.isEditMode)
    );
  }

  setIsGenerating(value: boolean) {
    this.isGenerating = value;
  }

  async loadSessionList(): Promise<void> {
    try {
      const sessions = await chatSessionRepository.getAllSessions();

      // Convert to SessionMetaData format
      const sessionMetadata: SessionMetaData[] = [];

      for (const session of sessions) {
        const sessionData = await chatSessionRepository.getSessionById(
          session.id,
        );
        if (!sessionData) {
          continue;
        }

        const messages = sessionData.messages.map(msg => msg.toMessageObject());

        // Handle case where completionSettings might be null
        let completionSettings = defaultCompletionSettings;
        if (sessionData.completionSettings) {
          completionSettings = sessionData.completionSettings.getSettings();
        } else {
          console.warn(
            `No completion settings found for session ${session.id}, using defaults`,
          );
        }

        sessionMetadata.push({
          id: session.id,
          title: session.title,
          date: session.date,
          messages,
          completionSettings,
          activePalId: session.activePalId,
        });
      }

      runInAction(() => {
        this.sessions = sessionMetadata;
      });
    } catch (error) {
      console.error('Failed to load session list:', error);
    }
  }

  async loadGlobalSettings(): Promise<void> {
    try {
      const settings =
        await chatSessionRepository.getGlobalCompletionSettings();

      runInAction(() => {
        this.newChatCompletionSettings = settings;
      });
    } catch (error) {
      console.error('Failed to load global settings:', error);
    }
  }

  async deleteSession(id: string): Promise<void> {
    try {
      await chatSessionRepository.deleteSession(id);

      if (id === this.activeSessionId) {
        this.resetActiveSession();
      }

      runInAction(() => {
        this.sessions = this.sessions.filter(session => session.id !== id);
      });
    } catch (error) {
      console.error('Failed to delete session:', error);
    }
  }

  async duplicateSession(id: string) {
    const session = this.sessions.find(s => s.id === id);
    if (session) {
      await this.createNewSession(
        `${session.title} - Copy`,
        session.messages,
        session.completionSettings,
      );
    }
  }

  resetActiveSession() {
    runInAction(() => {
      this.newChatPalId = this.activePalId;
      // Do not copy completion settings from session to global settings
      // Instead, preserve global settings as they are
      this.exitEditMode();
      this.activeSessionId = null;
    });
  }

  setActiveSession(sessionId: string) {
    runInAction(() => {
      this.exitEditMode();
      this.activeSessionId = sessionId;
      // Don't modify global settings when changing sessions
      this.newChatPalId = undefined;
    });
  }

  // Update session title by session ID
  async updateSessionTitleBySessionId(
    sessionId: string,
    newTitle: string,
  ): Promise<void> {
    try {
      await chatSessionRepository.updateSessionTitle(sessionId, newTitle);

      const session = this.sessions.find(s => s.id === sessionId);
      if (session) {
        runInAction(() => {
          session.title = newTitle;
        });
      }
    } catch (error) {
      console.error('Failed to update session title:', error);
    }
  }

  async updateSessionTitle(session: SessionMetaData) {
    if (session.messages.length > 0) {
      const message = session.messages[session.messages.length - 1];
      if (session.title === NEW_SESSION_TITLE && message.type === 'text') {
        runInAction(() => {
          session.title =
            message.text.length > TITLE_LIMIT
              ? `${message.text.substring(0, TITLE_LIMIT)}...`
              : message.text;
        });

        // Update in database - await the async call
        await chatSessionRepository.updateSessionTitle(
          session.id,
          session.title,
        );
      }
    }
  }

  async addMessageToCurrentSession(message: MessageType.Any): Promise<void> {
    if (this.activeSessionId) {
      const session = this.sessions.find(s => s.id === this.activeSessionId);
      if (session) {
        // Add to database
        const newMessage = await chatSessionRepository.addMessageToSession(
          this.activeSessionId,
          message,
        );
        message.id = newMessage.id;

        // Update local state
        await this.updateSessionTitle(session);
        runInAction(() => {
          session.messages.unshift(message);
        });
      }
    } else {
      // Always use the global settings for new sessions
      const settings = {...this.newChatCompletionSettings};
      await this.createNewSession(NEW_SESSION_TITLE, [message], settings);
    }
  }

  get currentSessionMessages(): MessageType.Any[] {
    if (this.activeSessionId) {
      const session = this.sessions.find(s => s.id === this.activeSessionId);
      if (session) {
        if (this.isEditMode && this.editingMessageId) {
          const messageIndex = session.messages.findIndex(
            msg => msg.id === this.editingMessageId,
          );
          if (messageIndex >= 0) {
            return session.messages.slice(messageIndex + 1);
          }
        }
        return session.messages;
      }
    }
    return [];
  }

  async setNewChatCompletionSettings(settings: CompletionParams) {
    this.newChatCompletionSettings = settings;
    await chatSessionRepository.saveGlobalCompletionSettings(settings);
  }

  async resetNewChatCompletionSettings() {
    this.newChatCompletionSettings = {...defaultCompletionSettings};
    await chatSessionRepository.saveGlobalCompletionSettings(
      this.newChatCompletionSettings,
    );
  }

  async createNewSession(
    title: string,
    initialMessages: MessageType.Any[] = [],
    completionSettings: CompletionParams = defaultCompletionSettings,
  ): Promise<void> {
    try {
      // Create in database
      const newSession = await chatSessionRepository.createSession(
        title,
        initialMessages,
        completionSettings,
        this.newChatPalId,
      );

      // Get the full session data
      const sessionData = await chatSessionRepository.getSessionById(
        newSession.id,
      );
      if (!sessionData) {
        return;
      }

      const messages = sessionData.messages.map(msg => msg.toMessageObject());

      // Handle case where completionSettings might be null
      let settings = completionSettings; // Use the settings passed to createNewSession as fallback
      if (sessionData.completionSettings) {
        settings = sessionData.completionSettings.getSettings();
      } else {
        console.warn(
          `No completion settings found for new session ${newSession.id}, using provided settings`,
        );
      }

      // Create metadata object
      const metaData: SessionMetaData = {
        id: newSession.id,
        title,
        date: newSession.date,
        messages,
        completionSettings: settings,
      };

      if (this.newChatPalId) {
        metaData.activePalId = this.newChatPalId;
        this.newChatPalId = undefined;
      }

      await this.updateSessionTitle(metaData);

      runInAction(() => {
        this.sessions.push(metaData);
        this.activeSessionId = newSession.id;
      });
    } catch (error) {
      console.error('Failed to create new session:', error);
    }
  }

  async updateMessage(
    id: string,
    sessionId: string,
    update: Partial<MessageType.Text>,
  ): Promise<void> {
    try {
      // Update in database
      await chatSessionRepository.updateMessage(id, update);

      // Determine which session to update
      const targetSessionId = sessionId || this.activeSessionId;
      if (targetSessionId) {
        const session = this.sessions.find(s => s.id === targetSessionId);
        if (session) {
          const index = session.messages.findIndex(msg => msg.id === id);
          if (index >= 0 && session.messages[index].type === 'text') {
            // Update local state - only update the specific message
            runInAction(() => {
              session.messages[index] = {
                ...session.messages[index],
                ...update,
              } as MessageType.Text;
            });
          }
        }
      }
    } catch (error) {
      console.error('Failed to update message:', error);
    }
  }

  async updateSessionCompletionSettings(settings: CompletionParams) {
    if (this.activeSessionId) {
      const session = this.sessions.find(s => s.id === this.activeSessionId);
      if (session) {
        try {
          // Update in database
          await chatSessionRepository.updateSessionCompletionSettings(
            this.activeSessionId,
            settings,
          );

          // Update local state directly - no need to reload from database
          runInAction(() => {
            session.completionSettings = settings;
          });
        } catch (error) {
          console.error('Failed to update session completion settings:', error);
        }
      }
    }
  }

  // Apply current session settings to global settings
  async applySessionSettingsToGlobal() {
    if (this.activeSessionId) {
      const session = this.sessions.find(s => s.id === this.activeSessionId);
      if (session) {
        await this.setNewChatCompletionSettings({
          ...session.completionSettings,
        });
      }
    }
  }

  // Reset current session settings to match global settings
  async resetSessionSettingsToGlobal() {
    if (this.activeSessionId) {
      const session = this.sessions.find(s => s.id === this.activeSessionId);
      if (session) {
        await this.updateSessionCompletionSettings({
          ...this.newChatCompletionSettings,
        });
      }
    }
  }

  async updateMessageToken(
    data: any,
    createdAt: number,
    id: string,
    sessionId: string | undefined,
    context: LlamaContext,
  ): Promise<void> {
    const {token} = data;

    if (this.activeSessionId) {
      const session = sessionId
        ? this.sessions.find(s => s.id === sessionId)
        : this.sessions.find(s => s.id === this.activeSessionId);
      if (session) {
        const index = session.messages.findIndex(msg => msg.id === id);
        if (index >= 0) {
          // Update existing message
          runInAction(() => {
            session.messages = session.messages.map((msg, i) => {
              if (msg.type === 'text' && i === index) {
                return {
                  ...msg,
                  text: (msg.text + token).replace(/^\s+/, ''),
                };
              }
              return msg;
            });
          });

          // Update the database with each token to ensure it's saved
          // Since we throttle the calls, this shouldn't be too much of a performance hit
          try {
            const updatedMessage = session.messages[index];
            if (updatedMessage.type === 'text') {
              // Use the repository to update the message
              await chatSessionRepository.updateMessage(id, {
                text: updatedMessage.text,
              });
            }
          } catch (error) {
            console.error('Failed to update message in database:', error);
          }
        } else {
          // Create new message
          const newMessage = {
            author: assistant,
            createdAt,
            id,
            text: token,
            type: 'text',
            metadata: {contextId: context?.id, copyable: true},
          } as MessageType.Text;

          // we can simply update the message in the database,
          // since we create an empty message before calling update
          try {
            await chatSessionRepository.updateMessage(id, {
              text: newMessage.text,
            });

            // Then update UI
            runInAction(() => {
              session.messages.unshift(newMessage);
            });
          } catch (error) {
            console.error('Failed to add message to session:', error);
          }
        }
      }
    }
  }

  get groupedSessions(): SessionGroup {
    const groups: SessionGroup = this.sessions.reduce(
      (acc: SessionGroup, session) => {
        const date = new Date(session.date);
        let dateKey: string = format(date, 'MMMM dd, yyyy');
        const today = new Date();
        const daysAgo = Math.ceil(
          (today.getTime() - date.getTime()) / (1000 * 3600 * 24),
        );

        if (isToday(date)) {
          dateKey = this.dateGroupNames.today;
        } else if (isYesterday(date)) {
          dateKey = this.dateGroupNames.yesterday;
        } else if (daysAgo <= 6) {
          dateKey = this.dateGroupNames.thisWeek;
        } else if (daysAgo <= 13) {
          dateKey = this.dateGroupNames.lastWeek;
        } else if (daysAgo <= 20) {
          dateKey = this.dateGroupNames.twoWeeksAgo;
        } else if (daysAgo <= 27) {
          dateKey = this.dateGroupNames.threeWeeksAgo;
        } else if (daysAgo <= 34) {
          dateKey = this.dateGroupNames.fourWeeksAgo;
        } else if (daysAgo <= 60) {
          dateKey = this.dateGroupNames.lastMonth;
        } else {
          dateKey = this.dateGroupNames.older;
        }

        if (!acc[dateKey]) {
          acc[dateKey] = [];
        }
        acc[dateKey].push(session);
        return acc;
      },
      {},
    );

    // Define the order of keys using the localized group names
    const orderedKeys = [
      this.dateGroupNames.today,
      this.dateGroupNames.yesterday,
      this.dateGroupNames.thisWeek,
      this.dateGroupNames.lastWeek,
      this.dateGroupNames.twoWeeksAgo,
      this.dateGroupNames.threeWeeksAgo,
      this.dateGroupNames.fourWeeksAgo,
      this.dateGroupNames.lastMonth,
      this.dateGroupNames.older,
    ];

    // Create a new object with keys in the desired order
    const orderedGroups: SessionGroup = {};
    orderedKeys.forEach(key => {
      if (groups[key]) {
        orderedGroups[key] = groups[key].sort(
          (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime(),
        );
      }
    });

    // Add any remaining keys that weren't in our predefined list
    Object.keys(groups).forEach(key => {
      if (!orderedGroups[key]) {
        orderedGroups[key] = groups[key].sort(
          (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime(),
        );
      }
    });

    return orderedGroups;
  }

  /**
   * Enters edit mode for a specific message
   */
  enterEditMode(messageId: string): void {
    if (this.activeSessionId) {
      const session = this.sessions.find(s => s.id === this.activeSessionId);
      if (session) {
        const messageIndex = session.messages.findIndex(
          msg => msg.id === messageId,
        );
        if (messageIndex >= 0) {
          runInAction(() => {
            this.isEditMode = true;
            this.editingMessageId = messageId;
          });
        }
      }
    }
  }

  /**
   * Exits edit mode without making changes
   */
  exitEditMode(): void {
    runInAction(() => {
      this.isEditMode = false;
      this.editingMessageId = null;
    });
  }

  /**
   * Commits the edit by actually removing messages after the edited message
   */
  async commitEdit(): Promise<void> {
    if (this.editingMessageId) {
      // Remove messages after the edited message including the edited message as well.
      await this.removeMessagesFromId(this.editingMessageId, true);
      runInAction(() => {
        this.isEditMode = false;
        this.editingMessageId = null;
      });
    }
  }

  /**
   * Removes messages from the current active session starting from a specific message ID.
   * If includeMessage is true, the message with the given ID is also removed.
   *
   * @param messageId - The ID of the message to start removal from.
   * @param includeMessage - Whether to include the message with the given ID in the removal.
   */
  async removeMessagesFromId(
    messageId: string,
    includeMessage: boolean = true,
  ): Promise<void> {
    if (this.activeSessionId) {
      const session = this.sessions.find(s => s.id === this.activeSessionId);
      if (session) {
        const messageIndex = session.messages.findIndex(
          msg => msg.id === messageId,
        );
        if (messageIndex >= 0) {
          // Get messages to remove
          const endIndex = includeMessage ? messageIndex + 1 : messageIndex;
          // Slice from the start to the end index, since messages are in reverse order, ie 0 is the latest.
          const messagesToRemove = session.messages.slice(0, endIndex);

          // Remove from database
          for (const msg of messagesToRemove) {
            await chatSessionRepository.deleteMessage(msg.id);
          }

          const updatedSession = await chatSessionRepository.getSessionById(
            this.activeSessionId,
          );

          // Update local state
          runInAction(() => {
            session.messages =
              updatedSession?.messages?.map(msg => msg.toMessageObject()) || [];
          });
        }
      }
    }
  }

  get activePalId(): string | undefined {
    if (this.activeSessionId) {
      const session = this.sessions.find(s => s.id === this.activeSessionId);
      return session?.activePalId;
    }
    return this.newChatPalId;
  }

  async setActivePal(palId: string | undefined): Promise<void> {
    if (this.activeSessionId) {
      const session = this.sessions.find(s => s.id === this.activeSessionId);
      if (session) {
        // Update in database
        await chatSessionRepository.setSessionActivePal(
          this.activeSessionId,
          palId,
        );

        // Update local state
        runInAction(() => {
          session.activePalId = palId;
        });
      }
    } else {
      this.newChatPalId = palId;
    }
  }
}

export const chatSessionStore = new ChatSessionStore();



================================================
FILE: src/store/defaultModels.ts
================================================
import {Model, ModelOrigin, ModelType} from '../utils/types';
import {chatTemplates} from '../utils/chat';
import {defaultCompletionParams} from '../utils/completionSettingsVersions';
import {Platform} from 'react-native';

export const MODEL_LIST_VERSION = 13;

const iosOnlyModels: Model[] = [];

const androidOnlyModels: Model[] = [];

const crossPlatformModels: Model[] = [
  // -------- Gemma --------
  {
    id: 'bartowski/gemma-2-2b-it-GGUF/gemma-2-2b-it-Q6_K.gguf',
    author: 'bartowski',
    name: 'Gemma-2-2b-it (Q6_K)',
    type: 'Gemma',
    capabilities: ['questionAnswering', 'summarization', 'reasoning'],
    size: 2151393120,
    params: 2614341888,
    isDownloaded: false,
    downloadUrl:
      'https://huggingface.co/bartowski/gemma-2-2b-it-GGUF/resolve/main/gemma-2-2b-it-Q6_K.gguf',
    hfUrl: 'https://huggingface.co/bartowski/gemma-2-2b-it-GGUF',
    progress: 0,
    filename: 'gemma-2-2b-it-Q6_K.gguf',
    isLocal: false,
    origin: ModelOrigin.PRESET,
    defaultChatTemplate: {...chatTemplates.gemmaIt},
    chatTemplate: chatTemplates.gemmaIt,
    defaultCompletionSettings: {
      ...defaultCompletionParams,
      n_predict: 500,
      temperature: 0.0,
      penalty_repeat: 1.0,
    },
    completionSettings: {
      // https://huggingface.co/google/gemma-7b-it/discussions/38#65d7b14adb51f7c160769fa1
      ...defaultCompletionParams,
      n_predict: 500,
      temperature: 0.0,
      penalty_repeat: 1.0,
    },
    defaultStopWords: ['<end_of_turn>'],
    stopWords: ['<end_of_turn>'],
    hfModelFile: {
      rfilename: 'gemma-2-2b-it-Q6_K.gguf',
      url: 'https://huggingface.co/bartowski/gemma-2-2b-it-GGUF/resolve/main/gemma-2-2b-it-Q6_K.gguf',
      size: 2151393120,
      oid: '72f2510b5868d1141617aa16cfc4c4a61ec77262',
      lfs: {
        oid: 'f82c5c2230a8b452221706461eb93203443373625d96a05912d4f96c845c2775',
        size: 2151393120,
        pointerSize: 135,
      },
      canFitInStorage: true,
    },
  },
  {
    id: 'TheDrummer/Gemmasutra-Mini-2B-v1-GGUF/Gemmasutra-Mini-2B-v1-Q6_K.gguf',
    author: 'TheDrummer',
    name: 'Gemmasutra-Mini-2B-v1 (Q6_K)',
    type: 'Gemma',
    capabilities: ['roleplay'],
    size: 2151393152,
    params: 2614341888,
    isDownloaded: false,
    downloadUrl:
      'https://huggingface.co/TheDrummer/Gemmasutra-Mini-2B-v1-GGUF/resolve/main/Gemmasutra-Mini-2B-v1-Q6_K.gguf',
    hfUrl: 'https://huggingface.co/TheDrummer/Gemmasutra-Mini-2B-v1-GGUF',
    progress: 0,
    filename: 'Gemmasutra-Mini-2B-v1-Q6_K.gguf',
    isLocal: false,
    origin: ModelOrigin.PRESET,
    defaultChatTemplate: {...chatTemplates.gemmasutra},
    chatTemplate: chatTemplates.gemmasutra,
    defaultCompletionSettings: {
      ...defaultCompletionParams,
      n_predict: 500,
      temperature: 0.7,
      penalty_repeat: 1.0,
    },
    completionSettings: {
      ...defaultCompletionParams,
      n_predict: 500,
      temperature: 0.7,
      penalty_repeat: 1.0,
    },
    defaultStopWords: ['<end_of_turn>'],
    stopWords: ['<end_of_turn>'],
    hfModelFile: {
      rfilename: 'Gemmasutra-Mini-2B-v1-Q6_K.gguf',
      url: 'https://huggingface.co/TheDrummer/Gemmasutra-Mini-2B-v1-GGUF/resolve/main/Gemmasutra-Mini-2B-v1-Q6_K.gguf',
      size: 2151393152,
      oid: '05521bb238e46ebd8fb5dacf044ba14f7c15f73e',
      lfs: {
        oid: '34bdca7d62ae0b15366a6f3d7f457d6d8ef96343e72c5e4555b6475c4a78e839',
        size: 2151393152,
        pointerSize: 135,
      },
      canFitInStorage: true,
    },
  },
  // -------- Phi --------
  {
    id: 'MaziyarPanahi/Phi-3.5-mini-instruct-GGUF/Phi-3.5-mini-instruct.Q4_K_M.gguf',
    author: 'MaziyarPanahi',
    name: 'Phi-3.5 mini 4k instruct (Q4_K_M)',
    type: 'Phi',
    capabilities: ['reasoning', 'code', 'math', 'multilingual'],
    size: 2393232608,
    params: 3821079648,
    isDownloaded: false,
    downloadUrl:
      'https://huggingface.co/MaziyarPanahi/Phi-3.5-mini-instruct-GGUF/resolve/main/Phi-3.5-mini-instruct.Q4_K_M.gguf',
    hfUrl: 'https://huggingface.co/MaziyarPanahi/Phi-3.5-mini-instruct-GGUF',
    progress: 0,
    filename: 'Phi-3.5-mini-instruct.Q4_K_M.gguf',
    isLocal: false,
    origin: ModelOrigin.PRESET,
    defaultChatTemplate: {...chatTemplates.phi3},
    chatTemplate: chatTemplates.phi3,
    defaultCompletionSettings: {
      ...defaultCompletionParams,
      n_predict: 500,
      temperature: 0.1,
    },
    completionSettings: {
      ...defaultCompletionParams,
      n_predict: 500,
      temperature: 0.1,
    },
    defaultStopWords: ['<|end|>'],
    stopWords: ['<|end|>'],
    hfModelFile: {
      rfilename: 'Phi-3.5-mini-instruct.Q4_K_M.gguf',
      url: 'https://huggingface.co/MaziyarPanahi/Phi-3.5-mini-instruct-GGUF/resolve/main/Phi-3.5-mini-instruct.Q4_K_M.gguf',
      size: 2393232608,
      oid: 'a2b0f35b7504ba395e886fadd5ebc61236b9f5ec',
      lfs: {
        oid: '3f68916e850b107d8641d18bcd5548f0d66beef9e0a9077fe84ef28943eb7e88',
        size: 2393232608,
        pointerSize: 135,
      },
      canFitInStorage: true,
    },
  },
  // -------- Qwen --------
  {
    id: 'Qwen/Qwen2.5-1.5B-Instruct-GGUF/qwen2.5-1.5b-instruct-q8_0.gguf',
    author: 'Qwen',
    name: 'Qwen2.5-1.5B-Instruct (Q8_0)',
    type: 'Qwen',
    capabilities: ['instructions', 'roleplay', 'multilingual'],
    size: 1894532128,
    params: 1777088000,
    isDownloaded: false,
    downloadUrl:
      'https://huggingface.co/Qwen/Qwen2.5-1.5B-Instruct-GGUF/resolve/main/qwen2.5-1.5b-instruct-q8_0.gguf',
    hfUrl: 'https://huggingface.co/Qwen/Qwen2.5-1.5B-Instruct-GGUF',
    progress: 0,
    filename: 'qwen2.5-1.5b-instruct-q8_0.gguf',
    isLocal: false,
    origin: ModelOrigin.PRESET,
    defaultChatTemplate: {...chatTemplates.qwen25},
    chatTemplate: chatTemplates.qwen25,
    defaultCompletionSettings: {
      ...defaultCompletionParams,
      n_predict: 500,
      temperature: 0.5,
    },
    completionSettings: {
      ...defaultCompletionParams,
      n_predict: 500,
      temperature: 0.5,
    },
    defaultStopWords: ['<|im_end|>'],
    stopWords: ['<|im_end|>'],
    supportsThinking: false, // Qwen2.5 doesn't support thinking (Qwen3+ does)
    hfModelFile: {
      rfilename: 'qwen2.5-1.5b-instruct-q8_0.gguf',
      url: 'https://huggingface.co/Qwen/Qwen2.5-1.5B-Instruct-GGUF/resolve/main/qwen2.5-1.5b-instruct-q8_0.gguf',
      size: 1894532128,
      oid: '1ec6832f8c80d58e2efa88832420ec7856e8e7c6',
      lfs: {
        oid: 'd7efb072e7724d25048a4fda0a3e10b04bdef5d06b1403a1c93bd9f1240a63c8',
        size: 1894532128,
        pointerSize: 135,
      },
      canFitInStorage: true,
    },
  },
  {
    id: 'Qwen/Qwen2.5-3B-Instruct-GGUF/qwen2.5-3b-instruct-q5_k_m.gguf',
    author: 'Qwen',
    name: 'Qwen2.5-3B-Instruct (Q5_K_M)',
    type: 'Qwen',
    capabilities: ['instructions', 'roleplay', 'multilingual'],
    size: 2438740384,
    params: 3397103616,
    isDownloaded: false,
    downloadUrl:
      'https://huggingface.co/Qwen/Qwen2.5-3B-Instruct-GGUF/resolve/main/qwen2.5-3b-instruct-q5_k_m.gguf',
    hfUrl: 'https://huggingface.co/Qwen/Qwen2.5-3B-Instruct-GGUF',
    progress: 0,
    filename: 'qwen2.5-3b-instruct-q5_k_m.gguf',
    isLocal: false,
    origin: ModelOrigin.PRESET,
    defaultChatTemplate: {...chatTemplates.qwen25},
    chatTemplate: chatTemplates.qwen25,
    defaultCompletionSettings: {
      ...defaultCompletionParams,
      n_predict: 500,
      temperature: 0.5,
    },
    completionSettings: {
      ...defaultCompletionParams,
      n_predict: 500,
      temperature: 0.5,
    },
    defaultStopWords: ['<|im_end|>'],
    stopWords: ['<|im_end|>'],
    supportsThinking: false, // Qwen2.5 doesn't support thinking (Qwen3+ does)
    hfModelFile: {
      rfilename: 'qwen2.5-3b-instruct-q5_k_m.gguf',
      url: 'https://huggingface.co/Qwen/Qwen2.5-3B-Instruct-GGUF/resolve/main/qwen2.5-3b-instruct-q5_k_m.gguf',
      size: 2438740384,
      oid: 'ffee048cd9cd76e7e4848d17fb96892023e8eca1',
      lfs: {
        oid: '2c63dde5f2c9ab1fd64d47dee2d34dade6ba9ff62442d1d20b5342310c982081',
        size: 2438740384,
        pointerSize: 135,
      },
      canFitInStorage: true,
    },
  },
  // -------- Llama --------
  {
    id: 'hugging-quants/Llama-3.2-1B-Instruct-Q8_0-GGUF/llama-3.2-1b-instruct-q8_0.gguf',
    author: 'hugging-quants',
    name: 'Llama-3.2-1b-instruct (Q8_0)',
    type: 'Llama',
    capabilities: ['instructions', 'summarization', 'rewriting'],
    size: 1321079200,
    params: 1235814432,
    isDownloaded: false,
    downloadUrl:
      'https://huggingface.co/hugging-quants/Llama-3.2-1B-Instruct-Q8_0-GGUF/resolve/main/llama-3.2-1b-instruct-q8_0.gguf',
    hfUrl:
      'https://huggingface.co/hugging-quants/Llama-3.2-1B-Instruct-Q8_0-GGUF',
    progress: 0,
    filename: 'llama-3.2-1b-instruct-q8_0.gguf',
    isLocal: false,
    origin: ModelOrigin.PRESET,
    defaultChatTemplate: {...chatTemplates.llama32},
    chatTemplate: chatTemplates.llama32,
    defaultCompletionSettings: {
      ...defaultCompletionParams,
      n_predict: 500,
      temperature: 0.5,
    },
    completionSettings: {
      ...defaultCompletionParams,
      n_predict: 500,
      temperature: 0.5,
    },
    defaultStopWords: ['<|eot_id|>'],
    stopWords: ['<|eot_id|>'],
    hfModelFile: {
      rfilename: 'llama-3.2-1b-instruct-q8_0.gguf',
      url: 'https://huggingface.co/hugging-quants/Llama-3.2-1B-Instruct-Q8_0-GGUF/resolve/main/llama-3.2-1b-instruct-q8_0.gguf',
      size: 1321079200,
      oid: '4d5402369568f0bd157d8454270821341e833722',
      lfs: {
        oid: 'ba345c83bf5cc679c653b853c46517eea5a34f03ed2205449db77184d9ae62a9',
        size: 1321079200,
        pointerSize: 135,
      },
      canFitInStorage: true,
    },
  },
  {
    id: 'bartowski/Llama-3.2-3B-Instruct-GGUF/Llama-3.2-3B-Instruct-Q6_K.gguf',
    author: 'bartowski',
    name: 'Llama-3.2-3B-Instruct (Q6_K)',
    type: 'Llama',
    capabilities: ['instructions', 'summarization', 'rewriting'],
    size: 2643853856,
    params: 3212749888,
    isDownloaded: false,
    downloadUrl:
      'https://huggingface.co/bartowski/Llama-3.2-3B-Instruct-GGUF/resolve/main/Llama-3.2-3B-Instruct-Q6_K.gguf',
    hfUrl: 'https://huggingface.co/bartowski/Llama-3.2-3B-Instruct-GGUF',
    progress: 0,
    filename: 'Llama-3.2-3B-Instruct-Q6_K.gguf',
    isLocal: false,
    origin: ModelOrigin.PRESET,
    defaultChatTemplate: {...chatTemplates.llama32},
    chatTemplate: chatTemplates.llama32,
    defaultCompletionSettings: {
      ...defaultCompletionParams,
      n_predict: 500,
      temperature: 0.5,
    },
    completionSettings: {
      ...defaultCompletionParams,
      n_predict: 500,
      temperature: 0.5,
    },
    defaultStopWords: ['<|eot_id|>'],
    stopWords: ['<|eot_id|>'],
    hfModelFile: {
      rfilename: 'Llama-3.2-3B-Instruct-Q6_K.gguf',
      url: 'https://huggingface.co/bartowski/Llama-3.2-3B-Instruct-GGUF/resolve/main/Llama-3.2-3B-Instruct-Q6_K.gguf',
      size: 2643853856,
      oid: '47d12cf8883aaa6a6cd0b47975cc026980a3af9d',
      lfs: {
        oid: '1771887c15fc3d327cfee6fd593553b2126e88834bf48eae50e709d3f70dd998',
        size: 2643853856,
        pointerSize: 135,
      },
      canFitInStorage: true,
    },
  },
  // -------- SmolLM --------
  {
    id: 'bartowski/SmolLM2-1.7B-Instruct-GGUF/SmolLM2-1.7B-Instruct-Q8_0.gguf',
    author: 'bartowski',
    name: 'SmolLM2-1.7B-Instruct (Q8_0)',
    type: 'SmolLM',
    size: 1820414944,
    params: 1711376384,
    isDownloaded: false,
    downloadUrl:
      'https://huggingface.co/bartowski/SmolLM2-1.7B-Instruct-GGUF/resolve/main/SmolLM2-1.7B-Instruct-Q8_0.gguf',
    hfUrl: 'https://huggingface.co/bartowski/SmolLM2-1.7B-Instruct-GGUF',
    progress: 0,
    filename: 'SmolLM2-1.7B-Instruct-Q8_0.gguf',
    isLocal: false,
    origin: ModelOrigin.PRESET,
    defaultChatTemplate: chatTemplates.smolLM,
    chatTemplate: chatTemplates.smolLM,
    defaultCompletionSettings: {
      ...defaultCompletionParams,
      n_predict: 500,
      temperature: 0.7,
    },
    completionSettings: {
      ...defaultCompletionParams,
      n_predict: 500,
      temperature: 0.7,
    },
    defaultStopWords: ['<|endoftext|>', '<|im_end|>'],
    stopWords: ['<|endoftext|>', '<|im_end|>'],
    supportsThinking: false, // SmolLM2 doesn't support thinking (SmolLM3+ does)
    hfModelFile: {
      rfilename: 'SmolLM2-1.7B-Instruct-Q8_0.gguf',
      url: 'https://huggingface.co/bartowski/SmolLM2-1.7B-Instruct-GGUF/resolve/main/SmolLM2-1.7B-Instruct-Q8_0.gguf',
      size: 1820414944,
      oid: 'c06316819523138df0346459118248997dac5089',
      lfs: {
        oid: '0c6e8955788b1253f418c354a4bdc4cf507b8cfe49c48bb10c7c58ae713cfa2a',
        size: 1820414944,
        pointerSize: 135,
      },
      canFitInStorage: true,
    },
  },
  // -------- SmolVLM --------
  {
    id: 'ggml-org/SmolVLM-500M-Instruct-GGUF/SmolVLM-500M-Instruct-Q8_0.gguf',
    author: 'ggml-org',
    name: 'SmolVLM2-500M-Instruct (Q8_0)',
    type: 'SmolVLM',
    capabilities: ['vision'],
    size: 436806912,
    params: 409252800, // 500M parameters
    isDownloaded: false,
    downloadUrl:
      'https://huggingface.co/ggml-org/SmolVLM-500M-Instruct-GGUF/resolve/main/SmolVLM-500M-Instruct-Q8_0.gguf',
    hfUrl: 'https://huggingface.co/ggml-org/SmolVLM-500M-Instruct-GGUF',
    progress: 0,
    filename: 'SmolVLM-500M-Instruct-Q8_0.gguf',
    isLocal: false,
    origin: ModelOrigin.PRESET,
    modelType: ModelType.VISION, // Specify that this is a vision model
    defaultChatTemplate: chatTemplates.smolVLM,
    chatTemplate: chatTemplates.smolVLM,
    defaultCompletionSettings: {
      ...defaultCompletionParams,
      n_predict: 500,
      temperature: 0.7,
    },
    completionSettings: {
      ...defaultCompletionParams,
      n_predict: 500,
      temperature: 0.7,
    },
    defaultStopWords: ['<|endoftext|>', '<|im_end|>', '<end_of_utterance>'],
    stopWords: ['<|endoftext|>', '<|im_end|>', '<end_of_utterance>'],
    hfModelFile: {
      rfilename: 'SmolVLM-500M-Instruct-Q8_0.gguf',
      url: 'https://huggingface.co/ggml-org/SmolVLM-500M-Instruct-GGUF/resolve/main/SmolVLM-500M-Instruct-Q8_0.gguf',
      size: 436806912,
      canFitInStorage: true,
    },
    supportsMultimodal: true,
    compatibleProjectionModels: [
      'ggml-org/SmolVLM-500M-Instruct-GGUF/mmproj-SmolVLM-500M-Instruct-Q8_0.gguf',
      'ggml-org/SmolVLM-500M-Instruct-GGUF/mmproj-SmolVLM-500M-Instruct-f16.gguf',
    ],
    defaultProjectionModel:
      'ggml-org/SmolVLM-500M-Instruct-GGUF/mmproj-SmolVLM-500M-Instruct-Q8_0.gguf',
  },
  {
    id: 'ggml-org/SmolVLM-500M-Instruct-GGUF/mmproj-SmolVLM-500M-Instruct-Q8_0.gguf',
    author: 'ggml-org',
    name: 'mmproj-SmolVLM2-500M-Instruct (Q8_0)',
    type: 'SmolVLM',
    capabilities: [],
    size: 108783360,
    params: 409252800,
    isDownloaded: false,
    downloadUrl:
      'https://huggingface.co/ggml-org/SmolVLM-500M-Instruct-GGUF/resolve/main/mmproj-SmolVLM-500M-Instruct-Q8_0.gguf',
    hfUrl: 'https://huggingface.co/ggml-org/SmolVLM-500M-Instruct-GGUF',
    progress: 0,
    filename: 'mmproj-SmolVLM-500M-Instruct-Q8_0.gguf',
    isLocal: false,
    origin: ModelOrigin.PRESET,
    modelType: ModelType.PROJECTION,
    defaultChatTemplate: chatTemplates.smolVLM,
    chatTemplate: chatTemplates.smolVLM,
    defaultCompletionSettings: {
      ...defaultCompletionParams,
      n_predict: 500,
      temperature: 0.7,
    },
    completionSettings: {
      ...defaultCompletionParams,
      n_predict: 500,
      temperature: 0.7,
    },
    defaultStopWords: ['<|endoftext|>', '<|im_end|>', '<end_of_utterance>'],
    stopWords: ['<|endoftext|>', '<|im_end|>', '<end_of_utterance>'],
    hfModelFile: {
      rfilename: 'mmproj-SmolVLM-500M-Instruct-Q8_0.gguf',
      url: 'https://huggingface.co/ggml-org/SmolVLM-500M-Instruct-GGUF/resolve/main/mmproj-SmolVLM-500M-Instruct-Q8_0.gguf',
      size: 108783360,
      canFitInStorage: true,
    },
  },
];

export const defaultModels =
  Platform.OS === 'android'
    ? [...androidOnlyModels, ...crossPlatformModels]
    : [...iosOnlyModels, ...crossPlatformModels];



================================================
FILE: src/store/FeedbackStore.ts
================================================
import {makeAutoObservable} from 'mobx';
import AsyncStorage from '@react-native-async-storage/async-storage';
import {v4 as uuidv4} from 'uuid';

const FEEDBACK_ID_STORAGE_KEY = '@pocketpal_ai/app_feedback_id';

/**
 * Manages a persistent ID for feedback submissions to:
 * - Prevent abuse while maintaining privacy
 * - Avoid using device-specific identifiers for privacy reasons
 */
class FeedbackStore {
  private _feedbackId: string | null = null;

  constructor() {
    makeAutoObservable(this);
    this.initializeFeedbackId();
  }

  /**
   * Initializes the feedback ID by:
   * 1. Checking if an ID already exists in storage
   * 2. If not, generating a new UUID and storing it
   */
  private async initializeFeedbackId() {
    try {
      const storedId = await AsyncStorage.getItem(FEEDBACK_ID_STORAGE_KEY);
      if (storedId) {
        this._feedbackId = storedId;
        return;
      }

      const newId = uuidv4();
      await AsyncStorage.setItem(FEEDBACK_ID_STORAGE_KEY, newId);
      this._feedbackId = newId;
    } catch (error) {
      console.error('Error initializing feedback ID:', error);
      // Generate a new ID if storage fails
      this._feedbackId = uuidv4();
    }
  }

  /**
   * Returns the feedback ID for this app installation.
   * If no ID exists (should never happen after initialization),
   * generates a new one as a fallback.
   */
  get feedbackId(): string {
    if (!this._feedbackId) {
      // If for some reason we don't have an ID, generate a new one
      this._feedbackId = uuidv4();
    }
    return this._feedbackId;
  }
}

export const feedbackStore = new FeedbackStore();



================================================
FILE: src/store/HFStore.ts
================================================
import {makeAutoObservable, runInAction} from 'mobx';
import AsyncStorage from '@react-native-async-storage/async-storage';
import {makePersistable} from 'mobx-persist-store';
import * as Keychain from 'react-native-keychain';

import {fetchGGUFSpecs, fetchModelFilesDetails, fetchModels} from '../api/hf';

import {urls} from '../config';

import {hasEnoughSpace, hfAsModel} from '../utils';
import {ErrorState, createErrorState} from '../utils/errors';

import {HuggingFaceModel} from '../utils/types';

const RE_GGUF_SHARD_FILE =
  /^(?<prefix>.*?)-(?<shard>\d{5})-of-(?<total>\d{5})\.gguf$/;

// Service name for keychain storage
const HF_TOKEN_SERVICE = 'hf_token_service';

class HFStore {
  models: HuggingFaceModel[] = [];
  isLoading = false;
  error: ErrorState | null = null;
  nextPageLink: string | null = null;
  searchQuery = '';
  queryFilter = 'gguf,conversational';
  queryFull = true;
  queryConfig = true;
  hfToken: string | null = null;
  useHfToken: boolean = true; // Only applies when token is set

  constructor() {
    makeAutoObservable(this);

    makePersistable(this, {
      name: 'HFStore',
      properties: ['useHfToken'],
      storage: AsyncStorage,
    });

    // Load token from secure storage on initialization
    this.loadTokenFromSecureStorage();
  }

  // Load token from secure storage
  private async loadTokenFromSecureStorage() {
    try {
      const credentials = await Keychain.getGenericPassword({
        service: HF_TOKEN_SERVICE,
      });

      if (credentials) {
        runInAction(() => {
          this.hfToken = credentials.password;
        });
      }
    } catch (error) {
      console.error('Failed to load token from secure storage:', error);
    }
  }

  get isTokenPresent(): boolean {
    return !!this.hfToken && this.hfToken.trim().length > 0;
  }

  get shouldUseToken(): boolean {
    return this.isTokenPresent && this.useHfToken;
  }

  setUseHfToken(useToken: boolean) {
    runInAction(() => {
      this.useHfToken = useToken;
    });
  }

  async setToken(token: string) {
    try {
      // Save token in secure storage
      await Keychain.setGenericPassword('hf_token', token, {
        service: HF_TOKEN_SERVICE,
      });

      runInAction(() => {
        this.hfToken = token;
      });
      return true;
    } catch (error) {
      console.error('Failed to save HF token:', error);
      return false;
    }
  }

  async clearToken() {
    try {
      // Remove token from secure storage
      await Keychain.resetGenericPassword({
        service: HF_TOKEN_SERVICE,
      });

      runInAction(() => {
        this.hfToken = null;
      });
      return true;
    } catch (error) {
      console.error('Failed to clear HF token:', error);
      return false;
    }
  }

  setSearchQuery(query: string) {
    this.searchQuery = query;
  }

  clearError() {
    this.error = null;
  }

  // Fetch the GGUF specs for a specific model,
  // such as number of parameters, context length, chat template, etc.
  async fetchAndSetGGUFSpecs(modelId: string) {
    try {
      const authToken = this.shouldUseToken ? this.hfToken : null;
      const specs = await fetchGGUFSpecs(modelId, authToken);
      const model = this.models.find(m => m.id === modelId);
      if (model) {
        runInAction(() => {
          model.specs = specs;
        });
      }
    } catch (error) {
      console.error('Failed to fetch GGUF specs:', error);
      runInAction(() => {
        this.error = createErrorState(error, 'modelDetails', 'huggingface');
      });
    }
  }

  private async updateSiblingsWithFileDetails(
    model: HuggingFaceModel,
    fileDetails: any[],
  ) {
    return Promise.all(
      model.siblings.map(async file => {
        const details = fileDetails.find(
          detail => detail.path === file.rfilename,
        );
        if (!details) {
          return {...file};
        }

        const enrichedFile = {
          ...file,
          size: details.size,
          oid: details.oid,
          lfs: details.lfs,
        };

        return {
          ...enrichedFile,
          canFitInStorage: await hasEnoughSpace(hfAsModel(model, enrichedFile)),
        };
      }),
    );
  }

  // Fetch the details (sizes, oid, lfs, ...) of the model files
  async fetchModelFileDetails(modelId: string) {
    try {
      console.log('Fetching model file details for', modelId);
      const authToken = this.shouldUseToken ? this.hfToken : null;
      const fileDetails = await fetchModelFilesDetails(modelId, authToken);
      const model = this.models.find(m => m.id === modelId);

      if (!model) {
        return;
      }

      const updatedSiblings = await this.updateSiblingsWithFileDetails(
        model,
        fileDetails,
      );

      runInAction(() => {
        model.siblings = updatedSiblings;
      });
    } catch (error) {
      console.error('Error fetching model file sizes:', error);
      runInAction(() => {
        this.error = createErrorState(error, 'modelDetails', 'huggingface');
      });
    }
  }

  getModelById(id: string): HuggingFaceModel | null {
    return this.models.find(model => model.id === id) || null;
  }

  async fetchModelData(modelId: string) {
    try {
      await this.fetchAndSetGGUFSpecs(modelId);
      await this.fetchModelFileDetails(modelId);
    } catch (error) {
      console.error('Error fetching model data:', error);
      runInAction(() => {
        this.error = createErrorState(error, 'modelDetails', 'huggingface');
      });
    }
  }

  /** Filters out non-GGUF and sharded GGUF files from model siblings */
  private filterGGUFFiles(siblings: any[]) {
    return (
      siblings?.filter(sibling => {
        const filename = sibling.rfilename.toLowerCase();
        return filename.endsWith('.gguf') && !RE_GGUF_SHARD_FILE.test(filename);
      }) || []
    );
  }

  /** Adds download URLs to model files based on modelId */
  private addDownloadUrls(modelId: string, siblings: any[]) {
    return siblings.map(sibling => ({
      ...sibling,
      url: urls.modelDownloadFile(modelId, sibling.rfilename),
    }));
  }

  // Process the hf search results to:
  // - add the URL
  // - filter out non-gguf files from the siblings
  // - filter out sharded gguf files from the siblings
  private processSearchResults(models: HuggingFaceModel[]) {
    return models.map(model => {
      const filteredSiblings = this.filterGGUFFiles(model.siblings);
      const siblingsWithUrl = this.addDownloadUrls(model.id, filteredSiblings);

      return {
        ...model,
        url: urls.modelWebPage(model.id),
        siblings: siblingsWithUrl,
      };
    });
  }

  get hasMoreResults() {
    return this.nextPageLink !== null;
  }

  // Fetch the models from the Hugging Face API
  async fetchModels() {
    this.isLoading = true;
    this.error = null;

    try {
      const authToken = this.shouldUseToken ? this.hfToken : null;
      const {models, nextLink} = await fetchModels({
        search: this.searchQuery,
        limit: 10,
        sort: 'downloads',
        direction: '-1',
        filter: this.queryFilter,
        full: this.queryFull,
        config: this.queryConfig,
        authToken: authToken,
      });

      const modelsWithUrl = this.processSearchResults(models);

      runInAction(() => {
        this.models = modelsWithUrl;
        this.nextPageLink = nextLink;
      });
    } catch (error) {
      runInAction(() => {
        this.isLoading = false;
        this.nextPageLink = null;
        this.models = [];
      });
      // this need to be in a separate runInAction for the ui to render properly.
      runInAction(() => {
        this.error = createErrorState(error, 'search', 'huggingface');
      });
    } finally {
      runInAction(() => {
        this.isLoading = false;
      });
    }
  }

  // Fetch the next page of models
  async fetchMoreModels() {
    if (!this.nextPageLink || this.isLoading) {
      return;
    }

    this.isLoading = true;
    this.error = null;

    try {
      const authToken = this.shouldUseToken ? this.hfToken : null;
      const {models, nextLink} = await fetchModels({
        nextPageUrl: this.nextPageLink,
        authToken: authToken,
      });

      const modelsWithUrl = this.processSearchResults(models);

      runInAction(() => {
        modelsWithUrl.forEach(model => this.models.push(model));
        this.nextPageLink = nextLink;
      });
    } catch (error) {
      runInAction(() => {
        this.error = createErrorState(error, 'search', 'huggingface');
      });
    } finally {
      runInAction(() => {
        this.isLoading = false;
      });
    }
  }
}

export const hfStore = new HFStore();



================================================
FILE: src/store/index.ts
================================================
export * from './ChatSessionStore';
export * from './ModelStore';
export * from './UIStore';
export * from './HFStore';
export * from './BenchmarkStore';
export * from './PalStore';
export * from './FeedbackStore';



================================================
FILE: src/store/PalStore.ts
================================================
import {v4 as uuidv4} from 'uuid';
import {makeAutoObservable} from 'mobx';
import 'react-native-get-random-values';
import {makePersistable} from 'mobx-persist-store';
import AsyncStorage from '@react-native-async-storage/async-storage';

import {
  AssistantFormData,
  PalType,
  RoleplayFormData,
  VideoPalFormData,
} from '../components/PalsSheets/types';
import {defaultModels} from './defaultModels';

export type Pal = {id: string} & (
  | AssistantFormData
  | RoleplayFormData
  | VideoPalFormData
);
export type AssistantPal = Pal & {palType: PalType.ASSISTANT};
export type RoleplayPal = Pal & {palType: PalType.ROLEPLAY};
export type VideoPal = Pal & {palType: PalType.VIDEO};

class PalStore {
  pals: Pal[] = [];

  constructor() {
    makeAutoObservable(this);
    makePersistable(this, {
      name: 'PalStore',
      properties: ['pals'],
      storage: AsyncStorage,
    });
  }

  addPal = (data: AssistantFormData | RoleplayFormData | VideoPalFormData) => {
    const newPal = {
      id: uuidv4(),
      ...data,
    } as Pal;
    this.pals.push(newPal);
  };

  updatePal = (
    id: string,
    data: Partial<AssistantFormData | RoleplayFormData | VideoPalFormData>,
  ) => {
    const palIndex = this.pals.findIndex(p => p.id === id);
    if (palIndex !== -1) {
      const currentPal = this.pals[palIndex];
      this.pals[palIndex] = {
        ...currentPal,
        ...data,
        palType: currentPal.palType,
      } as Pal;
    }
  };

  deletePal = (id: string) => {
    const palIndex = this.pals.findIndex(p => p.id === id);
    if (palIndex !== -1) {
      this.pals.splice(palIndex, 1);
    }
  };

  getPals = () => {
    return this.pals;
  };
}

export const palStore = new PalStore();

// Create the default "Lookie" VideoPal if it doesn't exist
export const initializeLookiePal = () => {
  // Check if Lookie already exists
  const lookiePal = palStore.pals.find(
    p => p.palType === PalType.VIDEO && p.name === 'Lookie',
  );

  if (!lookiePal) {
    // Find the default SmolVLM model directly from defaultModels
    // This avoids timing issues with ModelStore initialization
    const defaultModelId =
      'ggml-org/SmolVLM-500M-Instruct-GGUF/SmolVLM-500M-Instruct-Q8_0.gguf';
    const defaultModel = defaultModels.find(
      model => model.id === defaultModelId,
    );

    // Create the Lookie pal
    const lookieData: VideoPalFormData = {
      name: 'Lookie',
      palType: PalType.VIDEO,
      defaultModel: defaultModel, // Set the default model so users know what to download
      systemPrompt:
        'You are Lookie, an AI assistant giving real-time, concise descriptions of a video feed. Use few words. If unsure, say so clearly.',
      useAIPrompt: false,
      isSystemPromptChanged: false,
      color: ['#9E204F', '#F6E1EA'],
      captureInterval: 3000, // Default to 1 second
    };

    palStore.addPal(lookieData);
  }
};



================================================
FILE: src/store/UIStore.ts
================================================
import {Appearance} from 'react-native';

import {makePersistable} from 'mobx-persist-store';
import {makeAutoObservable, runInAction} from 'mobx';
import AsyncStorage from '@react-native-async-storage/async-storage';
import {l10n} from '../utils/l10n';
import {ErrorState} from '../utils/errors';

// Define available languages type
export type AvailableLanguage = keyof typeof l10n;

export class UIStore {
  static readonly GROUP_KEYS = {
    READY_TO_USE: 'ready_to_use',
    AVAILABLE_TO_DOWNLOAD: 'available_to_download',
  } as const;

  pageStates = {
    modelsScreen: {
      filters: [] as string[],
      expandedGroups: {
        [UIStore.GROUP_KEYS.READY_TO_USE]: true,
      },
    },
  };

  // This is a flag to auto-navigate to the chat page after loading a model
  autoNavigatetoChat = true;

  //colorScheme = useColorScheme();
  colorScheme: 'light' | 'dark' = Appearance.getColorScheme() ?? 'light';

  // Current selected language (default to English)
  _language: AvailableLanguage = 'en';

  // List of supported languages
  supportedLanguages: AvailableLanguage[] = ['en', 'ja', 'zh'];

  displayMemUsage = false;

  iOSBackgroundDownloading = true;

  benchmarkShareDialog = {
    shouldShow: true,
  };

  // Warning state for chat-related warnings (like multimodal warnings)
  chatWarning: ErrorState | null = null;

  showError(message: string) {
    // TODO: Implement error display logic (e.g., toast, alert, etc.)
    console.error(message);
  }

  setChatWarning(warning: ErrorState | null) {
    runInAction(() => {
      this.chatWarning = warning;
    });
  }

  clearChatWarning() {
    runInAction(() => {
      this.chatWarning = null;
    });
  }

  constructor() {
    makeAutoObservable(this);
    makePersistable(this, {
      name: 'UIStore',
      properties: [
        'pageStates',
        'colorScheme',
        'autoNavigatetoChat',
        'displayMemUsage',
        'benchmarkShareDialog',
        '_language',
      ],
      storage: AsyncStorage,
    });

    // backwards compatibility. Removed this from the ui settings screen.
    this.iOSBackgroundDownloading = true;
  }

  setValue<T extends keyof typeof this.pageStates>(
    page: T,
    key: keyof (typeof this.pageStates)[T],
    value: any,
  ) {
    runInAction(() => {
      if (this.pageStates[page]) {
        this.pageStates[page][key] = value;
      } else {
        console.error(`Page '${page}' does not exist in pageStates`);
      }
    });
  }

  setColorScheme(colorScheme: 'light' | 'dark') {
    runInAction(() => {
      this.colorScheme = colorScheme;
    });
  }

  setLanguage(language: AvailableLanguage) {
    runInAction(() => {
      this._language = language;
    });
  }
  get language() {
    // If the language is not in l10n, return 'en'
    // This can happen when the app removes a language from l10n
    return this._language in l10n ? this._language : 'en';
  }

  get l10n() {
    return l10n[this.language];
  }

  setAutoNavigateToChat(value: boolean) {
    runInAction(() => {
      this.autoNavigatetoChat = value;
    });
  }

  setDisplayMemUsage(value: boolean) {
    runInAction(() => {
      this.displayMemUsage = value;
    });
  }

  setiOSBackgroundDownloading(value: boolean) {
    runInAction(() => {
      this.iOSBackgroundDownloading = value;
    });
  }

  setBenchmarkShareDialogPreference(shouldShow: boolean) {
    runInAction(() => {
      this.benchmarkShareDialog.shouldShow = shouldShow;
    });
  }
}

export const uiStore = new UIStore();



================================================
FILE: src/store/__tests__/BenchmarkStore.test.ts
================================================
import {BenchmarkStore} from '../BenchmarkStore';
import {BenchmarkResult} from '../../utils/types';

describe('BenchmarkStore', () => {
  let store: BenchmarkStore;
  const mockResult: BenchmarkResult = {
    config: {
      pp: 1,
      tg: 1,
      pl: 512,
      nr: 3,
      label: 'Test Config',
    },
    modelDesc: 'Test Model',
    modelSize: 1000000,
    modelNParams: 7000000000,
    ppAvg: 20.5,
    ppStd: 1.2,
    tgAvg: 30.5,
    tgStd: 2.1,
    timestamp: '2024-03-20T10:00:00.000Z',
    modelId: 'test-model-id',
    modelName: 'Test Model',
    filename: 'test-model.gguf',
    uuid: 'test-uuid',
  };

  beforeEach(() => {
    store = new BenchmarkStore();
  });

  it('adds new result to the beginning of results array', () => {
    store.addResult(mockResult);
    expect(store.results[0]).toEqual(mockResult);
  });

  it('removes result by timestamp', () => {
    store.addResult(mockResult);
    store.removeResult(mockResult.timestamp);
    expect(store.results.length).toBe(0);
  });

  it('clears all results', () => {
    store.addResult(mockResult);
    store.addResult({...mockResult, uuid: 'test-uuid-2'});
    store.clearResults();
    expect(store.results.length).toBe(0);
  });

  it('gets results by model ID', () => {
    const differentModelResult = {
      ...mockResult,
      modelId: 'different-model',
      uuid: 'different-uuid',
    };
    store.addResult(mockResult);
    store.addResult(differentModelResult);

    const results = store.getResultsByModel(mockResult.modelId);
    expect(results.length).toBe(1);
    expect(results[0].modelId).toBe(mockResult.modelId);
  });

  it('returns latest result', () => {
    const olderResult = {
      ...mockResult,
      timestamp: '2024-03-19T10:00:00.000Z',
      uuid: 'older-uuid',
    };
    store.addResult(mockResult);
    store.addResult(olderResult);

    expect(store.latestResult).toEqual(olderResult);
  });

  it('marks result as submitted', () => {
    store.addResult(mockResult);
    store.markAsSubmitted(mockResult.uuid);

    const result = store.results.find(r => r.uuid === mockResult.uuid);
    expect(result?.submitted).toBe(true);
  });
});



================================================
FILE: src/store/__tests__/ChatSessionStore.test.ts
================================================
jest.unmock('../ChatSessionStore'); // this is not really needed, as only importing from store is mocked.
import {LlamaContext} from '@pocketpalai/llama.rn';

import {chatSessionStore, defaultCompletionSettings} from '../ChatSessionStore';
import {chatSessionRepository} from '../../repositories/ChatSessionRepository';

import {MessageType} from '../../utils/types';
import {mockContextModel} from '../../../jest/fixtures/models';
import {waitFor} from '@testing-library/react-native';

// Use the mock from __mocks__/repositories/ChatSessionRepository.js
//jest.mock('../../repositories/ChatSessionRepository');

// Make the repository methods mockable
jest.spyOn(chatSessionRepository, 'getAllSessions');
jest.spyOn(chatSessionRepository, 'getSessionById');
jest.spyOn(chatSessionRepository, 'createSession');
jest.spyOn(chatSessionRepository, 'deleteSession');
jest.spyOn(chatSessionRepository, 'addMessageToSession');
jest.spyOn(chatSessionRepository, 'updateMessage');
jest.spyOn(chatSessionRepository, 'updateSessionTitle');
jest.spyOn(chatSessionRepository, 'updateSessionCompletionSettings');
jest.spyOn(chatSessionRepository, 'getGlobalCompletionSettings');
jest.spyOn(chatSessionRepository, 'saveGlobalCompletionSettings');
jest.spyOn(chatSessionRepository, 'setSessionActivePal');

describe('chatSessionStore', () => {
  const mockMessage = {
    id: 'message1',
    text: 'Hello, world!',
    type: 'text',
    author: {id: 'user1', name: 'User'},
    createdAt: Date.now(),
  } as MessageType.Text;

  beforeEach(() => {
    jest.clearAllMocks();
    chatSessionStore.sessions = [];
    chatSessionStore.activeSessionId = null;
  });

  describe('loadSessionList', () => {
    it('loads session list from database successfully', async () => {
      const mockSession = {
        id: '1',
        title: 'Session 1',
        date: new Date().toISOString(),
      };

      const mockMessages = [
        {
          toMessageObject: () => ({
            id: 'msg1',
            text: 'Hello',
            type: 'text',
            author: {id: 'user1'},
            createdAt: Date.now(),
          }),
        },
      ];

      const mockCompletionSettings = {
        getSettings: () => ({
          ...defaultCompletionSettings,
          temperature: 0.7,
        }),
      };

      const mockSessionData = {
        messages: mockMessages,
        completionSettings: mockCompletionSettings,
      };

      (chatSessionRepository.getAllSessions as jest.Mock).mockResolvedValue([
        mockSession,
      ]);
      (chatSessionRepository.getSessionById as jest.Mock).mockResolvedValue(
        mockSessionData,
      );

      await chatSessionStore.loadSessionList();

      expect(chatSessionStore.sessions.length).toBe(1);
      expect(chatSessionStore.sessions[0].title).toBe('Session 1');
      expect(chatSessionRepository.getAllSessions).toHaveBeenCalled();
      expect(chatSessionRepository.getSessionById).toHaveBeenCalledWith('1');
    });

    it('handles database error gracefully', async () => {
      (chatSessionRepository.getAllSessions as jest.Mock).mockRejectedValue(
        new Error('Database error'),
      );

      await chatSessionStore.loadSessionList();

      expect(chatSessionStore.sessions).toEqual([]);
      expect(chatSessionRepository.getAllSessions).toHaveBeenCalled();
    });
  });

  describe('deleteSession', () => {
    it('deletes the session from database and updates store', async () => {
      const mockSessionId = 'session1';
      chatSessionStore.sessions = [
        {
          id: mockSessionId,
          title: 'Session 1',
          date: new Date().toISOString(),
          messages: [],
          completionSettings: defaultCompletionSettings,
        },
      ];
      (chatSessionRepository.deleteSession as jest.Mock).mockResolvedValue(
        undefined,
      );

      await chatSessionStore.deleteSession(mockSessionId);

      expect(chatSessionRepository.deleteSession).toHaveBeenCalledWith(
        mockSessionId,
      );
      expect(chatSessionStore.sessions.length).toBe(0);
    });

    it('handles database error during session deletion', async () => {
      const mockSessionId = 'session1';
      chatSessionStore.sessions = [
        {
          id: mockSessionId,
          title: 'Session 1',
          date: new Date().toISOString(),
          messages: [],
          completionSettings: defaultCompletionSettings,
        },
      ];
      (chatSessionRepository.deleteSession as jest.Mock).mockRejectedValue(
        new Error('Database error'),
      );

      await chatSessionStore.deleteSession(mockSessionId);

      expect(chatSessionRepository.deleteSession).toHaveBeenCalledWith(
        mockSessionId,
      );
      // Session should still be in the store if deletion failed
      expect(chatSessionStore.sessions.length).toBe(1);
    });
  });

  describe('addMessageToCurrentSession', () => {
    it('creates a new session if no active session', async () => {
      const mockNewSession = {
        id: 'new-session',
        title: 'New Session',
        date: new Date().toISOString(),
      };

      const mockSessionData = {
        messages: [
          {
            toMessageObject: () => mockMessage,
          },
        ],
        completionSettings: {
          getSettings: () => defaultCompletionSettings,
        },
      };

      (chatSessionRepository.createSession as jest.Mock).mockResolvedValue(
        mockNewSession,
      );
      (chatSessionRepository.getSessionById as jest.Mock).mockResolvedValue(
        mockSessionData,
      );

      await chatSessionStore.addMessageToCurrentSession(mockMessage);

      expect(chatSessionRepository.createSession).toHaveBeenCalled();
      expect(chatSessionRepository.getSessionById).toHaveBeenCalledWith(
        mockNewSession.id,
      );
      expect(chatSessionStore.sessions.length).toBe(1);
      expect(chatSessionStore.activeSessionId).toBe(mockNewSession.id);
    });

    it('adds a message to the active session', async () => {
      const mockSession = {
        id: 'session1',
        title: 'Session 1',
        date: new Date().toISOString(),
        messages: [],
        completionSettings: defaultCompletionSettings,
      };
      chatSessionStore.sessions = [mockSession];
      chatSessionStore.activeSessionId = mockSession.id;

      await chatSessionStore.addMessageToCurrentSession(mockMessage);

      expect(chatSessionRepository.addMessageToSession).toHaveBeenCalledWith(
        mockSession.id,
        mockMessage,
      );
      expect(chatSessionStore.sessions[0].messages.length).toBe(1);
      expect(chatSessionStore.sessions[0].messages[0]).toEqual(mockMessage);
    });
  });

  describe('updateMessage', () => {
    it('updates a message in the active session', async () => {
      const mockSession = {
        id: 'session1',
        title: 'Session 1',
        date: new Date().toISOString(),
        messages: [mockMessage],
        completionSettings: defaultCompletionSettings,
      };
      chatSessionStore.sessions = [mockSession];
      chatSessionStore.activeSessionId = mockSession.id;

      (chatSessionRepository.updateMessage as jest.Mock).mockResolvedValue(
        undefined,
      );

      const updatedMessage = {text: 'Updated message text'};
      await chatSessionStore.updateMessage(
        mockMessage.id,
        mockSession.id,
        updatedMessage,
      );

      expect(chatSessionRepository.updateMessage).toHaveBeenCalledWith(
        mockMessage.id,
        updatedMessage,
      );
      expect(
        (chatSessionStore.sessions[0].messages[0] as MessageType.Text).text,
      ).toBe(updatedMessage.text);
    });
  });

  describe('updateSessionTitle', () => {
    it('updates the session title based on the latest message', async () => {
      const mockSession = {
        id: 'session1',
        title: 'New Session',
        date: new Date().toISOString(),
        messages: [mockMessage],
        completionSettings: defaultCompletionSettings,
      };

      (chatSessionRepository.updateSessionTitle as jest.Mock).mockResolvedValue(
        undefined,
      );

      await chatSessionStore.updateSessionTitle(mockSession);

      expect(chatSessionRepository.updateSessionTitle).toHaveBeenCalledWith(
        mockSession.id,
        'Hello, world!',
      );
      expect(mockSession.title).toBe('Hello, world!');
    });

    it('limits the session title to 40 characters', async () => {
      const longMessage = 'a'.repeat(100);
      const mockSession = {
        id: 'session1',
        title: 'New Session',
        date: new Date().toISOString(),
        messages: [{...mockMessage, text: longMessage}],
        completionSettings: defaultCompletionSettings,
      };

      (chatSessionRepository.updateSessionTitle as jest.Mock).mockResolvedValue(
        undefined,
      );

      await chatSessionStore.updateSessionTitle(mockSession);

      const expectedTitle = longMessage.substring(0, 40) + '...';
      expect(chatSessionRepository.updateSessionTitle).toHaveBeenCalledWith(
        mockSession.id,
        expectedTitle,
      );
      expect(mockSession.title.length).toBe(43); // 40 chars + '...'
      expect(mockSession.title.endsWith('...')).toBe(true);
    });
  });

  describe('createNewSession', () => {
    it('creates a new session and sets it as active', async () => {
      const mockNewSession = {
        id: 'new-session',
        title: 'My New Session',
        date: new Date().toISOString(),
      };

      const mockSessionData = {
        messages: [
          {
            toMessageObject: () => mockMessage,
          },
        ],
        completionSettings: {
          getSettings: () => defaultCompletionSettings,
        },
      };

      (chatSessionRepository.createSession as jest.Mock).mockResolvedValue(
        mockNewSession,
      );
      (chatSessionRepository.getSessionById as jest.Mock).mockResolvedValue(
        mockSessionData,
      );

      await chatSessionStore.createNewSession('My New Session', [mockMessage]);

      expect(chatSessionRepository.createSession).toHaveBeenCalledWith(
        'My New Session',
        [mockMessage],
        defaultCompletionSettings,
        undefined,
      );
      expect(chatSessionRepository.getSessionById).toHaveBeenCalledWith(
        mockNewSession.id,
      );
      expect(chatSessionStore.sessions.length).toBe(1);
      expect(chatSessionStore.activeSessionId).toBe(mockNewSession.id);
    });

    it('inherits settings from active session when creating a new session', async () => {
      // Create and set active session with custom settings
      const originalSession = {
        id: 'session1',
        title: 'Original Session',
        date: new Date().toISOString(),
        messages: [],
        completionSettings: {
          ...defaultCompletionSettings,
          temperature: 0.9,
        },
      };
      chatSessionStore.sessions = [originalSession];
      chatSessionStore.activeSessionId = originalSession.id;

      // When active session exists and user creates a new session
      chatSessionStore.resetActiveSession();
      // This simulates that settings from active session are copied to newChatCompletionSettings
      chatSessionStore.newChatCompletionSettings =
        originalSession.completionSettings;

      // Mock for addMessageToCurrentSession
      const mockNewSession = {
        id: 'new-session',
        title: 'New Session',
        date: new Date().toISOString(),
      };

      const mockSessionData = {
        messages: [
          {
            toMessageObject: () => mockMessage,
          },
        ],
        completionSettings: {
          getSettings: () => originalSession.completionSettings,
        },
      };

      (chatSessionRepository.createSession as jest.Mock).mockResolvedValue(
        mockNewSession,
      );
      (chatSessionRepository.getSessionById as jest.Mock).mockResolvedValue(
        mockSessionData,
      );

      await chatSessionStore.addMessageToCurrentSession(mockMessage);

      // The new session should have the same settings
      expect(chatSessionRepository.createSession).toHaveBeenCalledWith(
        expect.any(String),
        [mockMessage],
        originalSession.completionSettings,
        undefined,
      );
      expect(chatSessionStore.sessions.length).toBe(2);
      expect(chatSessionStore.sessions[1].completionSettings.temperature).toBe(
        0.9,
      );
    });
  });

  describe('resetActiveSession', () => {
    it('resets the active session to null', () => {
      chatSessionStore.activeSessionId = 'session1';
      chatSessionStore.resetActiveSession();

      expect(chatSessionStore.activeSessionId).toBeNull();
    });
  });

  // saveSessionsMetadata tests removed as this method is no longer needed with database storage

  describe('setActiveSession', () => {
    it('sets the active session id', () => {
      const sessionId = 'session1';
      chatSessionStore.setActiveSession(sessionId);
      expect(chatSessionStore.activeSessionId).toBe(sessionId);
    });
  });

  describe('currentSessionMessages', () => {
    it('returns messages for active session', () => {
      const session = {
        id: 'session1',
        title: 'Session 1',
        date: new Date().toISOString(),
        messages: [mockMessage],
        completionSettings: defaultCompletionSettings,
      };
      chatSessionStore.sessions = [session];
      chatSessionStore.activeSessionId = session.id;

      expect(chatSessionStore.currentSessionMessages).toEqual([mockMessage]);
    });

    it('returns empty array when no active session', () => {
      expect(chatSessionStore.currentSessionMessages).toEqual([]);
    });
  });

  describe('updateMessageToken', () => {
    it('updates existing message with new token', async () => {
      const session = {
        id: 'session1',
        title: 'Session 1',
        date: new Date().toISOString(),
        messages: [mockMessage],
        completionSettings: defaultCompletionSettings,
      };
      chatSessionStore.sessions = [session];
      chatSessionStore.activeSessionId = session.id;

      const mockContext = new LlamaContext({
        contextId: 1,
        gpu: false,
        reasonNoGPU: 'Test environment',
        model: mockContextModel,
      });

      (chatSessionRepository.updateMessage as jest.Mock).mockResolvedValue(
        true,
      );

      await chatSessionStore.updateMessageToken(
        {token: ' world'},
        Date.now(),
        mockMessage.id,
        session.id,
        mockContext,
      );

      expect(chatSessionRepository.updateMessage).toHaveBeenCalled();
      expect(
        (chatSessionStore.currentSessionMessages[0] as MessageType.Text).text,
      ).toBe('Hello, world! world');
    });

    it('creates new message if id not found', async () => {
      const session = {
        id: 'session1',
        title: 'Session 1',
        date: new Date().toISOString(),
        messages: [],
        completionSettings: defaultCompletionSettings,
      };
      chatSessionStore.sessions = [session];
      chatSessionStore.activeSessionId = session.id;

      const mockContext = new LlamaContext({
        contextId: 1,
        gpu: false,
        reasonNoGPU: 'Test environment',
        model: mockContextModel,
      });
      const newMessageId = 'new-message';
      const createdAt = Date.now();

      // Mock the updateMessage method to return false (message not found)
      (chatSessionRepository.updateMessage as jest.Mock).mockResolvedValue(
        false,
      );

      await chatSessionStore.updateMessageToken(
        {token: 'New message'},
        createdAt,
        newMessageId,
        session.id,
        mockContext,
      );

      expect(chatSessionRepository.updateMessage).toHaveBeenCalled();
      const newMessage = chatSessionStore.currentSessionMessages[0];
      expect(newMessage.id).toBe(newMessageId);
      expect((newMessage as MessageType.Text).text).toBe('New message');
      expect(newMessage.metadata).toEqual({contextId: 1, copyable: true});
    });
  });

  describe('groupedSessions', () => {
    it('groups sessions by date categories', () => {
      const today = new Date();
      const yesterday = new Date(today);
      yesterday.setDate(yesterday.getDate() - 1);
      const lastWeek = new Date(today);
      lastWeek.setDate(lastWeek.getDate() - 7);

      chatSessionStore.sessions = [
        {
          id: '1',
          title: 'Today Session',
          date: today.toISOString(),
          messages: [],
          completionSettings: defaultCompletionSettings,
        },
        {
          id: '2',
          title: 'Yesterday Session',
          date: yesterday.toISOString(),
          messages: [],
          completionSettings: defaultCompletionSettings,
        },
        {
          id: '3',
          title: 'Last Week Session',
          date: lastWeek.toISOString(),
          messages: [],
          completionSettings: defaultCompletionSettings,
        },
      ];

      const grouped = chatSessionStore.groupedSessions;
      expect(grouped.Today).toBeDefined();
      expect(grouped.Yesterday).toBeDefined();
      expect(grouped['Last week']).toBeDefined();
    });
  });

  describe('duplicateSession', () => {
    it('duplicates a session with its messages and settings', async () => {
      const originalSession = {
        id: 'session1',
        title: 'Original Session',
        date: new Date().toISOString(),
        messages: [mockMessage],
        completionSettings: {
          ...defaultCompletionSettings,
          temperature: 0.7,
        },
      };

      chatSessionStore.sessions = [originalSession];

      const mockNewSession = {
        id: 'new-session',
        title: 'Original Session - Copy',
        date: new Date().toISOString(),
      };

      const mockSessionData = {
        messages: [
          {
            toMessageObject: () => mockMessage,
          },
        ],
        completionSettings: {
          getSettings: () => originalSession.completionSettings,
        },
      };

      (chatSessionRepository.createSession as jest.Mock).mockResolvedValue(
        mockNewSession,
      );
      (chatSessionRepository.getSessionById as jest.Mock).mockResolvedValue(
        mockSessionData,
      );

      await chatSessionStore.duplicateSession('session1');

      expect(chatSessionRepository.createSession).toHaveBeenCalledWith(
        'Original Session - Copy',
        [mockMessage],
        originalSession.completionSettings,
        undefined,
      );
      expect(chatSessionStore.sessions.length).toBe(2);
      expect(chatSessionStore.sessions[1].title).toBe(
        'Original Session - Copy',
      );
      expect(chatSessionStore.sessions[1].completionSettings.temperature).toBe(
        0.7,
      );
    });
  });

  // Tests from ChatSessionStoreExtended.test.ts
  describe('isGenerating flag', () => {
    it('sets and gets the isGenerating flag', () => {
      expect(chatSessionStore.isGenerating).toBe(false);

      chatSessionStore.setIsGenerating(true);
      expect(chatSessionStore.isGenerating).toBe(true);

      chatSessionStore.setIsGenerating(false);
      expect(chatSessionStore.isGenerating).toBe(false);
    });

    it('shouldShowHeaderDivider returns true when conditions met', () => {
      // No active session
      expect(chatSessionStore.shouldShowHeaderDivider).toBe(true);

      // Active session with no messages
      const session = {
        id: 'session1',
        title: 'Session 1',
        date: new Date().toISOString(),
        messages: [] as MessageType.Any[],
        completionSettings: defaultCompletionSettings,
      };
      chatSessionStore.sessions = [session];
      chatSessionStore.activeSessionId = session.id;
      expect(chatSessionStore.shouldShowHeaderDivider).toBe(true);

      // Active session with messages
      session.messages = [mockMessage] as MessageType.Any[];
      expect(chatSessionStore.shouldShowHeaderDivider).toBe(true);

      // With isGenerating true
      chatSessionStore.setIsGenerating(true);
      expect(chatSessionStore.shouldShowHeaderDivider).toBe(false);

      // With isEditMode true
      chatSessionStore.setIsGenerating(false);
      chatSessionStore.isEditMode = true;
      expect(chatSessionStore.shouldShowHeaderDivider).toBe(false);
    });
  });

  describe('updateSessionTitleBySessionId', () => {
    it('updates session title by ID', async () => {
      const session = {
        id: 'session1',
        title: 'Original Title',
        date: new Date().toISOString(),
        messages: [],
        completionSettings: defaultCompletionSettings,
      };
      chatSessionStore.sessions = [session];

      (chatSessionRepository.updateSessionTitle as jest.Mock).mockResolvedValue(
        undefined,
      );

      await chatSessionStore.updateSessionTitleBySessionId(
        'session1',
        'New Title',
      );

      expect(chatSessionRepository.updateSessionTitle).toHaveBeenCalledWith(
        'session1',
        'New Title',
      );
      expect(chatSessionStore.sessions[0].title).toBe('New Title');
    });

    it('does nothing for non-existent session ID', async () => {
      const session = {
        id: 'session1',
        title: 'Original Title',
        date: new Date().toISOString(),
        messages: [],
        completionSettings: defaultCompletionSettings,
      };
      chatSessionStore.sessions = [session];

      (chatSessionRepository.updateSessionTitle as jest.Mock).mockResolvedValue(
        undefined,
      );

      await chatSessionStore.updateSessionTitleBySessionId(
        'non-existent',
        'New Title',
      );

      expect(chatSessionRepository.updateSessionTitle).toHaveBeenCalledWith(
        'non-existent',
        'New Title',
      );
      expect(chatSessionStore.sessions[0].title).toBe('Original Title');
    });
  });

  describe('completion settings', () => {
    it('updates completion settings for active session', async () => {
      const session = {
        id: 'session1',
        title: 'Session 1',
        date: new Date().toISOString(),
        messages: [],
        completionSettings: defaultCompletionSettings,
      };
      chatSessionStore.sessions = [session];
      chatSessionStore.activeSessionId = session.id;

      const newSettings = {
        ...defaultCompletionSettings,
        temperature: 0.9,
        top_p: 0.95,
      };

      (
        chatSessionRepository.updateSessionCompletionSettings as jest.Mock
      ).mockResolvedValue(undefined);

      await chatSessionStore.updateSessionCompletionSettings(newSettings);

      expect(
        chatSessionRepository.updateSessionCompletionSettings,
      ).toHaveBeenCalledWith(session.id, newSettings);
      expect(chatSessionStore.sessions[0].completionSettings).toEqual(
        newSettings,
      );
    });

    it('sets new chat completion settings', async () => {
      const newSettings = {
        ...defaultCompletionSettings,
        temperature: 0.9,
      };

      (
        chatSessionRepository.saveGlobalCompletionSettings as jest.Mock
      ).mockResolvedValue(undefined);

      await chatSessionStore.setNewChatCompletionSettings(newSettings);

      expect(
        chatSessionRepository.saveGlobalCompletionSettings,
      ).toHaveBeenCalledWith(newSettings);
      expect(chatSessionStore.newChatCompletionSettings).toEqual(newSettings);
    });

    it('resets new chat completion settings', async () => {
      chatSessionStore.newChatCompletionSettings = {
        ...defaultCompletionSettings,
        temperature: 0.9,
      };

      (
        chatSessionRepository.saveGlobalCompletionSettings as jest.Mock
      ).mockResolvedValue(undefined);

      await chatSessionStore.resetNewChatCompletionSettings();

      expect(
        chatSessionRepository.saveGlobalCompletionSettings,
      ).toHaveBeenCalledWith(defaultCompletionSettings);
      expect(chatSessionStore.newChatCompletionSettings).toEqual(
        defaultCompletionSettings,
      );
    });

    it('applies new chat completion settings when creating a new session', async () => {
      const customSettings = {
        ...defaultCompletionSettings,
        temperature: 0.7,
        top_p: 0.95,
      };

      chatSessionStore.newChatCompletionSettings = customSettings;

      const mockNewSession = {
        id: 'new-session',
        title: 'New Session',
        date: new Date().toISOString(),
      };

      const mockSessionData = {
        messages: [],
        completionSettings: {
          getSettings: () => customSettings,
        },
      };

      (chatSessionRepository.createSession as jest.Mock).mockResolvedValue(
        mockNewSession,
      );
      (chatSessionRepository.getSessionById as jest.Mock).mockResolvedValue(
        mockSessionData,
      );
      (
        chatSessionRepository.saveGlobalCompletionSettings as jest.Mock
      ).mockResolvedValue(undefined);

      await chatSessionStore.createNewSession('New Session');

      expect(chatSessionRepository.createSession).toHaveBeenCalledWith(
        'New Session',
        [],
        customSettings,
        undefined,
      );
      expect(chatSessionStore.sessions[0].completionSettings).toEqual(
        customSettings,
      );
      expect(chatSessionStore.newChatCompletionSettings).toEqual(
        defaultCompletionSettings,
      );
    });
  });

  describe('edit mode', () => {
    const mockMessage2 = {
      id: 'message2',
      text: 'Second message',
      type: 'text',
      author: {id: 'assistant', name: 'Assistant'},
      createdAt: Date.now() - 1000,
    } as MessageType.Text;

    const mockMessage3 = {
      id: 'message3',
      text: 'Third message',
      type: 'text',
      author: {id: 'user1', name: 'User'},
      createdAt: Date.now(),
    } as MessageType.Text;

    beforeEach(() => {
      const session = {
        id: 'session1',
        title: 'Session 1',
        date: new Date().toISOString(),
        messages: [
          mockMessage3, // newest - user (message3)
          mockMessage2, // middle - assistant (message2)
          mockMessage, // oldest - user (message1)
        ],
        completionSettings: defaultCompletionSettings,
      };
      chatSessionStore.sessions = [session];
      chatSessionStore.activeSessionId = 'session1';
    });

    it('enters edit mode for a specific message', () => {
      chatSessionStore.enterEditMode(mockMessage2.id);

      expect(chatSessionStore.isEditMode).toBe(true);
      expect(chatSessionStore.editingMessageId).toBe(mockMessage2.id);
    });

    it('exits edit mode', () => {
      chatSessionStore.enterEditMode(mockMessage2.id);
      chatSessionStore.exitEditMode();

      expect(chatSessionStore.isEditMode).toBe(false);
      expect(chatSessionStore.editingMessageId).toBeNull();
    });

    it('commits edit by removing messages after the edited message', async () => {
      chatSessionStore.enterEditMode(mockMessage3.id);
      await chatSessionStore.commitEdit();

      await waitFor(() => {
        expect(chatSessionStore.isEditMode).toBe(false);
      });

      // expect(chatSessionStore.isEditMode).toBe(false);
      expect(chatSessionStore.editingMessageId).toBeNull();
      // Not sure how to test this after migration to db
      // expect(chatSessionStore.sessions[0].messages.length).toBe(2);
      // expect(chatSessionStore.sessions[0].messages[0].id).toBe(mockMessage2.id);
      // expect(chatSessionStore.sessions[0].messages[1].id).toBe(mockMessage.id);
    });

    it('returns correct messages when in edit mode', () => {
      // editing the first message will remove all messages after it
      chatSessionStore.enterEditMode(mockMessage.id);

      const messages = chatSessionStore.currentSessionMessages;
      expect(messages.length).toBe(0);
    });
  });

  describe('removeMessagesFromId', () => {
    const mockMessage2 = {
      id: 'message2',
      text: 'Second message',
      type: 'text',
      author: {id: 'assistant', name: 'Assistant'},
      createdAt: Date.now() - 1000,
    } as MessageType.Text;

    const mockMessage3 = {
      id: 'message3',
      text: 'Third message',
      type: 'text',
      author: {id: 'user1', name: 'User'},
      createdAt: Date.now(),
    } as MessageType.Text;

    beforeEach(() => {
      const session = {
        id: 'session1',
        title: 'Session 1',
        date: new Date().toISOString(),
        messages: [
          mockMessage3, // newest - user (message3)
          mockMessage2, // middle - assistant (message2)
          mockMessage, // oldest - user (message1)
        ],
        completionSettings: defaultCompletionSettings,
      };
      chatSessionStore.sessions = [session];
      chatSessionStore.activeSessionId = 'session1';
    });

    it('removes messages up to a specific ID (including the message)', async () => {
      // TODO: this is cheating: we need to mock db so we can test this
      (chatSessionRepository.getSessionById as jest.Mock).mockResolvedValueOnce(
        {
          session: {
            id: 'session1',
            title: 'Session 1',
            date: new Date().toISOString(),
          },
          messages: [
            {
              toMessageObject: () => mockMessage,
            },
          ],
          completionSettings: {
            getSettings: () => defaultCompletionSettings,
          },
        },
      );

      await chatSessionStore.removeMessagesFromId(mockMessage2.id, true);

      // Should remove mockMessage3 and mockMessage2, leaving only mockMessage
      expect(chatSessionStore.sessions[0].messages.length).toBe(1);
      expect(chatSessionStore.sessions[0].messages[0].id).toBe(mockMessage.id);
    });

    it('removes messages up to a specific ID (excluding the message)', async () => {
      // TODO: this is cheating: we need to mock db so we can test this
      (chatSessionRepository.getSessionById as jest.Mock).mockResolvedValueOnce(
        {
          session: {
            id: 'session1',
            title: 'Session 1',
            date: new Date().toISOString(),
          },
          messages: [
            {
              toMessageObject: () => mockMessage2,
            },
            {
              toMessageObject: () => mockMessage,
            },
          ],
          completionSettings: {
            getSettings: () => defaultCompletionSettings,
          },
        },
      );

      await chatSessionStore.removeMessagesFromId(mockMessage2.id, false);

      // Should remove only mockMessage3, leaving mockMessage2 and mockMessage
      expect(chatSessionStore.sessions[0].messages.length).toBe(2);
      expect(chatSessionStore.sessions[0].messages[0].id).toBe(mockMessage2.id);
      expect(chatSessionStore.sessions[0].messages[1].id).toBe(mockMessage.id);
    });

    it('does nothing for non-existent message ID', async () => {
      await chatSessionStore.removeMessagesFromId('non-existent');

      expect(chatSessionStore.sessions[0].messages.length).toBe(3);
    });
  });

  describe('pal management', () => {
    it('gets active pal ID from active session', () => {
      const session = {
        id: 'session1',
        title: 'Session 1',
        date: new Date().toISOString(),
        messages: [],
        completionSettings: defaultCompletionSettings,
        activePalId: 'pal1',
      };
      chatSessionStore.sessions = [session];
      chatSessionStore.activeSessionId = 'session1';

      expect(chatSessionStore.activePalId).toBe('pal1');
    });

    it('gets active pal ID from newChatPalId when no active session', () => {
      chatSessionStore.newChatPalId = 'pal2';

      expect(chatSessionStore.activePalId).toBe('pal2');
    });

    it('sets active pal ID for active session', async () => {
      const session = {
        id: 'session1',
        title: 'Session 1',
        date: new Date().toISOString(),
        messages: [],
        completionSettings: defaultCompletionSettings,
      };
      chatSessionStore.sessions = [session];
      chatSessionStore.activeSessionId = 'session1';

      await chatSessionStore.setActivePal('pal1');

      expect(chatSessionStore.sessions[0].activePalId).toBe('pal1');
    });

    it('sets newChatPalId when no active session', async () => {
      await chatSessionStore.setActivePal('pal2');

      expect(chatSessionStore.newChatPalId).toBe('pal2');
    });

    it('preserves active pal ID when resetting active session', () => {
      const session = {
        id: 'session1',
        title: 'Session 1',
        date: new Date().toISOString(),
        messages: [],
        completionSettings: defaultCompletionSettings,
        activePalId: 'pal1',
      };
      chatSessionStore.sessions = [session];
      chatSessionStore.activeSessionId = 'session1';

      chatSessionStore.resetActiveSession();

      expect(chatSessionStore.newChatPalId).toBe('pal1');
      expect(chatSessionStore.activeSessionId).toBeNull();
    });

    it('applies newChatPalId when creating a new session', async () => {
      chatSessionStore.newChatPalId = 'pal1';

      await chatSessionStore.createNewSession('New Session');

      expect(chatSessionStore.sessions[0].activePalId).toBe('pal1');
      expect(chatSessionStore.newChatPalId).toBeUndefined();
    });
  });
});



================================================
FILE: src/store/__tests__/HFStore.test.ts
================================================
import {
  mockHFModel1,
  mockHFModel2,
  mockGGUFSpecs1,
  mockGGUFSpecs2,
  mockHFModelFiles1,
} from '../../../jest/fixtures/models';
import {hfStore} from '../../store/HFStore';
import {
  fetchGGUFSpecs,
  fetchModelFilesDetails,
  fetchModels,
} from '../../api/hf';

// Mock the API calls
jest.mock('../../api/hf');

describe('HFStore', () => {
  beforeEach(() => {
    // Clear all mocks before each test
    jest.clearAllMocks();
    // Reset store to initial state
    hfStore.models = [];
    hfStore.isLoading = false;
    hfStore.error = null;
    hfStore.nextPageLink = null;
    hfStore.searchQuery = '';
    // Clear the token to ensure tests start with no authentication
    hfStore.hfToken = null;
    hfStore.useHfToken = true;
  });

  describe('fetchModels', () => {
    it('should fetch and process models successfully', async () => {
      const mockResponse = {
        models: [mockHFModel1, mockHFModel2],
        nextLink: 'next-page-url',
      };
      (fetchModels as jest.Mock).mockResolvedValueOnce(mockResponse);

      await hfStore.fetchModels();

      expect(hfStore.models).toHaveLength(2);
      expect(hfStore.models[0].url).toBe(
        'https://huggingface.co/owner/hf-model-name-1',
      );
      expect(hfStore.nextPageLink).toBe('next-page-url');
      expect(hfStore.error).toBe(null);
      expect(hfStore.isLoading).toBe(false);
    });

    it('should handle fetch error', async () => {
      (fetchModels as jest.Mock).mockRejectedValueOnce(
        new Error('Network error'),
      );

      await hfStore.fetchModels();

      expect(hfStore.models).toHaveLength(0);
      expect(hfStore.error).toEqual(
        expect.objectContaining({
          context: 'search',
          message: 'Network error',
          recoverable: true,
          service: 'huggingface',
        }),
      );
      expect(hfStore.isLoading).toBe(false);
    });
  });

  describe('fetchMoreModels', () => {
    it('should not fetch if nextPageLink is null', async () => {
      hfStore.nextPageLink = null;
      await hfStore.fetchMoreModels();

      expect(fetchModels).not.toHaveBeenCalled();
    });

    it('should append new models to existing ones', async () => {
      // Set initial state
      hfStore.models = [mockHFModel1];
      hfStore.nextPageLink = 'next-page-url';

      const mockResponse = {
        models: [mockHFModel2],
        nextLink: null,
      };
      (fetchModels as jest.Mock).mockResolvedValueOnce(mockResponse);

      await hfStore.fetchMoreModels();

      expect(hfStore.models).toHaveLength(2);
      expect(hfStore.models[1].id).toBe(mockHFModel2.id);
      expect(hfStore.nextPageLink).toBeNull();
    });
  });

  describe('fetchModelData', () => {
    it('should fetch both GGUF specs and file sizes', async () => {
      const modelId = 'owner/hf-model-name-1';

      (fetchGGUFSpecs as jest.Mock).mockResolvedValueOnce(mockGGUFSpecs1);
      (fetchModelFilesDetails as jest.Mock).mockResolvedValueOnce(
        mockHFModelFiles1,
      );

      await hfStore.fetchModelData(modelId);

      expect(fetchGGUFSpecs).toHaveBeenCalledWith(modelId, null);
      expect(fetchModelFilesDetails).toHaveBeenCalledWith(modelId, null);
    });
  });

  describe('getModelById', () => {
    it('should return model by id', () => {
      hfStore.models = [mockHFModel1, mockHFModel2];

      const model = hfStore.getModelById(mockHFModel1.id);

      // With MobX stores, the objects are wrapped in Proxies, hence toStrictEqual as opposed to toBe.
      expect(model).toStrictEqual(mockHFModel1);
    });

    it('should return null for non-existent model', () => {
      hfStore.models = [mockHFModel1];

      const model = hfStore.getModelById('non-existent-id');

      expect(model).toBeNull();
    });
  });

  describe('setSearchQuery', () => {
    it('should update search query', () => {
      const query = 'test query';

      hfStore.setSearchQuery(query);

      expect(hfStore.searchQuery).toBe(query);
    });
  });

  describe('fetchAndSetGGUFSpecs', () => {
    it('should update model specs when successful', async () => {
      hfStore.models = [mockHFModel1];
      (fetchGGUFSpecs as jest.Mock).mockResolvedValueOnce(mockGGUFSpecs2);

      await hfStore.fetchAndSetGGUFSpecs(mockHFModel1.id);

      expect(hfStore.models[0].specs).toEqual(mockGGUFSpecs2);
    });

    it('should handle non-existent model', async () => {
      hfStore.models = [];
      (fetchGGUFSpecs as jest.Mock).mockResolvedValueOnce(mockGGUFSpecs1);

      await hfStore.fetchAndSetGGUFSpecs('non-existent-id');

      expect(fetchGGUFSpecs).toHaveBeenCalled();
      // Should not throw error
    });
  });

  describe('fetchModelFileDetails', () => {
    it('should update model siblings with file sizes', async () => {
      hfStore.models = [mockHFModel1];
      const fileDetails = [
        {path: 'hf-model-name-1.Q4_K_M.gguf', size: 1111, oid: 'abc123'},
      ];

      (fetchModelFilesDetails as jest.Mock).mockResolvedValueOnce(fileDetails);

      await hfStore.fetchModelFileDetails(mockHFModel1.id);

      expect(hfStore.models[0].siblings[0].size).toBe(1111);
      expect(hfStore.models[0].siblings[0].oid).toBe('abc123');
    });

    it('should handle non-existent model', async () => {
      hfStore.models = [];
      (fetchModelFilesDetails as jest.Mock).mockResolvedValueOnce([]);

      await hfStore.fetchModelFileDetails('non-existent-id');

      expect(fetchModelFilesDetails).toHaveBeenCalled();
      // Should not throw error
    });
  });
});



================================================
FILE: src/store/__tests__/PalStore.test.ts
================================================
import {palStore} from '../PalStore';
import {
  PalType,
  AssistantFormData,
  RoleplayFormData,
} from '../../components/PalsSheets/types';
import {modelsList} from '../../../jest/fixtures/models';

describe('PalStore', () => {
  beforeEach(() => {
    // Clear pals before each test
    palStore.pals = [];
  });

  describe('addPal', () => {
    it('should add an assistant pal correctly', () => {
      const assistantPal: AssistantFormData = {
        name: 'Test Assistant',
        palType: PalType.ASSISTANT,
        systemPrompt: 'Test system prompt',
        defaultModel: modelsList[0],
        useAIPrompt: false,
        isSystemPromptChanged: false,
        originalSystemPrompt: '',
        promptGenerationModel: modelsList[0],
        generatingPrompt: '',
        color: undefined,
      };

      palStore.addPal(assistantPal);

      expect(palStore.pals).toHaveLength(1);
      expect(palStore.pals[0]).toEqual(
        expect.objectContaining({
          ...assistantPal,
          id: expect.any(String),
        }),
      );
    });

    it('should add a roleplay pal correctly', () => {
      const roleplayPal: RoleplayFormData = {
        name: 'Test Roleplay',
        palType: PalType.ROLEPLAY,
        world: 'Test world',
        location: 'Test location',
        aiRole: 'Test AI role',
        userRole: 'Test user role',
        situation: 'Test situation',
        toneStyle: 'Test tone',
        systemPrompt: 'Test system prompt',
        defaultModel: modelsList[0],
        useAIPrompt: false,
        isSystemPromptChanged: false,
        promptGenerationModel: modelsList[0],
        generatingPrompt: '',
        color: undefined,
      };

      palStore.addPal(roleplayPal);

      expect(palStore.pals).toHaveLength(1);
      expect(palStore.pals[0]).toEqual(
        expect.objectContaining({
          ...roleplayPal,
          id: expect.any(String),
        }),
      );
    });
  });

  describe('updatePal', () => {
    it('should update an existing pal', () => {
      // First add a pal
      const initialPal: AssistantFormData = {
        name: 'Test Assistant',
        palType: PalType.ASSISTANT,
        systemPrompt: 'Initial prompt',
        defaultModel: modelsList[0],
        useAIPrompt: false,
        isSystemPromptChanged: false,
        originalSystemPrompt: '',
        promptGenerationModel: modelsList[0],
        generatingPrompt: '',
        color: undefined,
      };
      palStore.addPal(initialPal);
      const palId = palStore.pals[0].id;

      // Update the pal
      const updates = {
        name: 'Updated Assistant',
        systemPrompt: 'Updated prompt',
      };
      palStore.updatePal(palId, updates);

      expect(palStore.pals[0]).toEqual(
        expect.objectContaining({
          ...initialPal,
          ...updates,
          id: palId,
        }),
      );
    });

    it('should not update pal type when updating', () => {
      // First add a pal
      const initialPal: AssistantFormData = {
        name: 'Test Assistant',
        palType: PalType.ASSISTANT,
        systemPrompt: 'Initial prompt',
        defaultModel: modelsList[0],
        useAIPrompt: false,
        isSystemPromptChanged: false,
        originalSystemPrompt: '',
        promptGenerationModel: undefined,
        generatingPrompt: '',
        color: undefined,
      };
      palStore.addPal(initialPal);
      const palId = palStore.pals[0].id;

      // Try to update the pal type
      const updates = {
        palType: PalType.ROLEPLAY,
      };
      palStore.updatePal(palId, updates);

      // Verify pal type remains unchanged
      expect(palStore.pals[0].palType).toBe(PalType.ASSISTANT);
    });

    it('should not update non-existent pal', () => {
      const updates = {
        name: 'Updated Name',
      };
      palStore.updatePal('non-existent-id', updates);

      expect(palStore.pals).toHaveLength(0);
    });
  });

  describe('deletePal', () => {
    it('should delete an existing pal', () => {
      // First add a pal
      const pal: AssistantFormData = {
        name: 'Test Assistant',
        palType: PalType.ASSISTANT,
        systemPrompt: 'Test prompt',
        defaultModel: modelsList[0],
        useAIPrompt: false,
        isSystemPromptChanged: false,
        originalSystemPrompt: '',
        promptGenerationModel: modelsList[0],
        generatingPrompt: '',
        color: undefined,
      };
      palStore.addPal(pal);
      const palId = palStore.pals[0].id;

      // Delete the pal
      palStore.deletePal(palId);

      expect(palStore.pals).toHaveLength(0);
    });

    it('should not throw when deleting non-existent pal', () => {
      expect(() => palStore.deletePal('non-existent-id')).not.toThrow();
    });
  });

  describe('getPals', () => {
    it('should return all pals', () => {
      const pals: AssistantFormData[] = [
        {
          name: 'Assistant 1',
          palType: PalType.ASSISTANT,
          systemPrompt: 'Prompt 1',
          defaultModel: modelsList[0],
          useAIPrompt: false,
          isSystemPromptChanged: false,
          originalSystemPrompt: '',
          promptGenerationModel: modelsList[0],
          generatingPrompt: '',
          color: undefined,
        },
        {
          name: 'Assistant 2',
          palType: PalType.ASSISTANT,
          systemPrompt: 'Prompt 2',
          defaultModel: modelsList[0],
          useAIPrompt: false,
          isSystemPromptChanged: false,
          originalSystemPrompt: '',
          promptGenerationModel: modelsList[0],
          generatingPrompt: '',
          color: undefined,
        },
      ];

      pals.forEach(pal => palStore.addPal(pal));

      const retrievedPals = palStore.getPals();
      expect(retrievedPals).toHaveLength(2);
      expect(retrievedPals).toEqual(
        expect.arrayContaining([
          expect.objectContaining({...pals[0]}),
          expect.objectContaining({...pals[1]}),
        ]),
      );
    });

    it('should return empty array when no pals exist', () => {
      const pals = palStore.getPals();
      expect(pals).toEqual([]);
    });
  });
});



================================================
FILE: src/store/__tests__/UIStore.test.ts
================================================
import {UIStore, uiStore} from '../UIStore';

jest.mock('react-native/Libraries/Utilities/Appearance', () => ({
  getColorScheme: jest.fn(() => 'light'),
}));

describe('UIStore', () => {
  beforeEach(() => {
    uiStore.setColorScheme('light');
    uiStore.setAutoNavigateToChat(true);
    uiStore.setDisplayMemUsage(false);
    uiStore.setValue('modelsScreen', 'filters', []);
  });

  it('should initialize with default values', () => {
    expect(uiStore.pageStates).toEqual({
      modelsScreen: {
        filters: [],
        expandedGroups: {
          [UIStore.GROUP_KEYS.READY_TO_USE]: true,
        },
      },
    });
    expect(uiStore.autoNavigatetoChat).toBe(true);
    expect(uiStore.colorScheme).toBe('light');
    expect(uiStore.displayMemUsage).toBe(false);
  });

  it('should set color scheme', () => {
    uiStore.setColorScheme('dark');
    expect(uiStore.colorScheme).toBe('dark');
  });

  it('should set auto navigate to chat', () => {
    uiStore.setAutoNavigateToChat(false);
    expect(uiStore.autoNavigatetoChat).toBe(false);
  });

  it('should set display memory usage', () => {
    uiStore.setDisplayMemUsage(true);
    expect(uiStore.displayMemUsage).toBe(true);
  });

  it('should set page state value correctly', () => {
    uiStore.setValue('modelsScreen', 'filters', ['ungrouped']);
    expect(uiStore.pageStates.modelsScreen.filters).toEqual(['ungrouped']);
  });

  it('should handle invalid page in setValue', () => {
    const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
    // @ts-ignore - Testing invalid input
    uiStore.setValue('invalidPage', 'someKey', 'someValue');
    expect(consoleSpy).toHaveBeenCalledWith(
      "Page 'invalidPage' does not exist in pageStates",
    );
    consoleSpy.mockRestore();
  });
});



================================================
FILE: src/utils/androidPermission.ts
================================================
import {Platform, PermissionsAndroid, Alert} from 'react-native';
import {uiStore} from '../store';

export async function ensureLegacyStoragePermission() {
  // Skip everything on iOS or any Android 11+ device (API 29+)
  if (Platform.OS !== 'android' || Platform.Version >= 29) {
    return true;
  }

  // Ask for storage permission on API 23‚Äë28 (Android 6-9)
  const needed = PermissionsAndroid.PERMISSIONS.WRITE_EXTERNAL_STORAGE;

  // Already granted? ‚Üí done
  const already = await PermissionsAndroid.check(needed);
  if (already) {
    return true;
  }

  const l10n = uiStore.l10n;

  // Optional rationale dialog
  const rationale = {
    title: l10n.components.exportUtils.permissionRequired,
    message: l10n.components.exportUtils.permissionMessage,
    buttonPositive: l10n.components.exportUtils.continue,
    buttonNegative: l10n.common.cancel,
  };

  // Show the system prompt
  const results = await PermissionsAndroid.request(needed, rationale);

  const granted = results === PermissionsAndroid.RESULTS.GRANTED;

  if (!granted) {
    Alert.alert(
      l10n.components.exportUtils.permissionDenied,
      l10n.components.exportUtils.permissionDeniedMessage,
      [{text: 'OK'}],
    );
  }
  return granted;
}



================================================
FILE: src/utils/chat.ts
================================================
import {applyTemplate, Templates} from 'chat-formatter';
import {JinjaFormattedChatResult, LlamaContext} from '@pocketpalai/llama.rn';
import {CompletionParams} from './completionTypes';
import {defaultCompletionParams} from './completionSettingsVersions';

import {
  ChatMessage,
  ChatTemplateConfig,
  HuggingFaceModel,
  MessageType,
  Model,
} from './types';

export const userId = 'y9d7f8pgn';
export const assistantId = 'h3o3lc5xj';
export const user = {id: userId};
export const assistant = {id: assistantId};

export function convertToChatMessages(
  messages: MessageType.Any[],
  isMultimodalEnabled: boolean = true,
): ChatMessage[] {
  return messages
    .filter(message => message.type === 'text' && message.text !== undefined)
    .map(message => {
      const textMessage = message as MessageType.Text;
      const role: 'assistant' | 'user' =
        message.author.id === assistant.id ? 'assistant' : 'user';

      // Check if this message has images (multimodal) and if multimodal is enabled
      if (
        textMessage.imageUris &&
        textMessage.imageUris.length > 0 &&
        isMultimodalEnabled
      ) {
        // Create multimodal content with text and images
        const content: Array<{
          type: 'text' | 'image_url';
          text?: string;
          image_url?: {url: string};
        }> = [
          {
            type: 'text',
            text: textMessage.text!,
          },
        ];

        // Add images to content
        content.push(
          ...textMessage.imageUris.map(path => ({
            type: 'image_url' as const,
            image_url: {url: path},
          })),
        );

        return {
          role,
          content,
        } as ChatMessage;
      } else {
        // Text-only message (backward compatibility)
        return {
          role,
          content: textMessage.text!,
        } as ChatMessage;
      }
    })
    .reverse();
}

/**
 * Formats chat messages using the appropriate template based on the model or context.
 *
 * @param messages - Array of OAI compatible chat messages
 * @param model - The model configuration, which may contain a custom chat template
 * @param context - The LlamaContext instance, which may contain a chat template
 * @returns A formatted prompt
 *
 * Priority of template selection:
 * 1. Model's custom chat template (if available)
 * 2. Context's model-specific template (if available)
 * 3. Default chat template as fallback
 */
export async function applyChatTemplate(
  messages: ChatMessage[],
  model: Model | null,
  context: LlamaContext | null,
): Promise<string | JinjaFormattedChatResult> {
  const modelChatTemplate = model?.chatTemplate;
  const contextChatTemplate = (context?.model as any)?.metadata?.[
    'tokenizer.chat_template'
  ];

  let formattedChat: string | JinjaFormattedChatResult | undefined;

  try {
    // Model's custom chat template. This uses chat-formatter, which is based on Nunjucks (as opposed to Jinja2).
    if (modelChatTemplate?.chatTemplate) {
      // Convert multimodal messages to text-only for chat-formatter compatibility
      const textOnlyMessages = messages.map(msg => ({
        ...msg,
        content: Array.isArray(msg.content)
          ? msg.content.find(part => part.type === 'text')?.text || ''
          : msg.content,
      }));
      formattedChat = applyTemplate(textOnlyMessages, {
        customTemplate: modelChatTemplate,
        addGenerationPrompt: modelChatTemplate.addGenerationPrompt,
      }) as string;
    } else if (contextChatTemplate) {
      // Context's model-specific chat template. This uses llama.cpp's getFormattedChat.
      formattedChat = await context?.getFormattedChat(messages);
    }

    if (!formattedChat) {
      // Default chat template - convert multimodal messages to text-only for chat-formatter compatibility
      const textOnlyMessages = messages.map(msg => ({
        ...msg,
        content: Array.isArray(msg.content)
          ? msg.content.find(part => part.type === 'text')?.text || ''
          : msg.content,
      }));
      formattedChat = applyTemplate(textOnlyMessages, {
        customTemplate: chatTemplates.default,
        addGenerationPrompt: chatTemplates.default.addGenerationPrompt,
      }) as string;
    }
  } catch (error) {
    console.error('Error applying chat template:', error); // TODO: handle error
  }

  return formattedChat || ' ';
}

export const chatTemplates: Record<string, ChatTemplateConfig> = {
  custom: {
    name: 'custom',
    addGenerationPrompt: true,
    bosToken: '',
    eosToken: '',
    chatTemplate: '',
    systemPrompt: '',
  },
  danube3: {
    ...Templates.templates.danube2,
    name: 'danube3',
    addGenerationPrompt: true,
    systemPrompt:
      'You are a helpful assistant named H2O Danube3. You are precise, concise, and casual.',
  },
  danube2: {
    ...Templates.templates.danube2,
    name: 'danube2',
    addGenerationPrompt: true,
    systemPrompt:
      'You are a helpful assistant named H2O Danube2. You are precise, concise, and casual.',
  },
  phi3: {
    ...Templates.templates.phi3,
    name: 'phi3',
    addGenerationPrompt: true,
    systemPrompt:
      'You are a helpful conversational chat assistant. You are precise, concise, and casual.',
  },
  gemmaIt: {
    ...Templates.templates.gemmaIt,
    name: 'gemmaIt',
    addGenerationPrompt: true,
    systemPrompt:
      'You are a helpful conversational chat assistant. You are precise, concise, and casual.',
  },
  chatML: {
    ...Templates.templates.chatML,
    name: 'chatML',
    addGenerationPrompt: true,
    systemPrompt:
      'You are a helpful conversational chat assistant. You are precise, concise, and casual.',
  },
  default: {
    ...Templates.templates.default,
    name: 'default',
    addGenerationPrompt: true,
    systemPrompt:
      'You are a helpful conversational chat assistant. You are precise, concise, and casual.',
  },
  llama3: {
    ...Templates.templates.llama3,
    name: 'llama3',
    addGenerationPrompt: true,
    systemPrompt:
      'You are a helpful conversational chat assistant. You are precise, concise, and casual.',
  },
  llama32: {
    ...Templates.templates.llama32,
    name: 'llama32',
    addGenerationPrompt: true,
    systemPrompt: '',
  },
  gemmasutra: {
    ...Templates.templates.gemmasutra,
    name: 'gemmasutra',
    addGenerationPrompt: true,
    systemPrompt:
      'You are a helpful conversational chat assistant. You are precise, concise, and casual.',
  },
  qwen2: {
    ...Templates.templates.qwen2,
    name: 'qwen2',
    addGenerationPrompt: true,
    systemPrompt: 'You are a helpful assistant.',
  },
  qwen25: {
    ...Templates.templates.qwen25,
    name: 'qwen25',
    addGenerationPrompt: true,
    systemPrompt:
      'You are Qwen, created by Alibaba Cloud. You are a helpful assistant.',
  },
  smolLM: {
    name: 'smolLM',
    addGenerationPrompt: true,
    systemPrompt: 'You are a helpful assistant.',
    bosToken: '<|im_start|>',
    eosToken: '<|im_end|>',
    addBosToken: false,
    addEosToken: false,
    chatTemplate: '',
  },
  smolVLM: {
    name: 'smolVLM',
    addGenerationPrompt: true,
    systemPrompt: '',
    bosToken: '<|im_start|>',
    eosToken: '<|im_end|>',
    addBosToken: false,
    addEosToken: false,
    chatTemplate: '',
  },
};

export function getLocalModelDefaultSettings(): {
  chatTemplate: ChatTemplateConfig;
  completionParams: CompletionParams;
} {
  return {
    chatTemplate: chatTemplates.custom,
    completionParams: defaultCompletionParams,
  };
}

export function getHFDefaultSettings(hfModel: HuggingFaceModel): {
  chatTemplate: ChatTemplateConfig;
  completionParams: CompletionParams;
} {
  const _defaultChatTemplate = {
    addBosToken: false, // It is expected that chat templates will take care of this
    addEosToken: false, // It is expected that chat templates will take care of this
    bosToken: hfModel.specs?.gguf?.bos_token ?? '',
    eosToken: hfModel.specs?.gguf?.eos_token ?? '',
    //chatTemplate: hfModel.specs?.gguf?.chat_template ?? '',
    chatTemplate: '', // At the moment chatTemplate needs to be nunjucks, not jinja2. So by using empty string we force the use of gguf's chat template.
    addGenerationPrompt: true,
    systemPrompt: '',
    name: 'custom',
  };

  const _defaultCompletionParams = {
    ...defaultCompletionParams,
    stop: _defaultChatTemplate.eosToken ? [_defaultChatTemplate.eosToken] : [],
  };

  return {
    chatTemplate: _defaultChatTemplate,
    completionParams: _defaultCompletionParams,
  };
}

// Default completion parameters are now defined in settingsVersions.ts

export const stops = [
  '</s>',
  // '<|end|>', conflicts with gpt-oss. Which model uses <|end|>?
  '<|eot_id|>',
  '<|end_of_text|>',
  '<|im_end|>',
  '<|EOT|>',
  '<|END_OF_TURN_TOKEN|>',
  '<|end_of_turn|>',
  '<end_of_turn>',
  '<|endoftext|>',
  '<|return|>', // gpt-oss
];

/**
 * Removes thinking parts from text content.
 * This function removes content between <think>, <thought>, or <thinking> tags and their closing tags.
 *
 * @param text - The text to process
 * @returns The text with thinking parts removed
 */
export function removeThinkingParts(text: string): string {
  // Check if the text contains any thinking tags
  const hasThinkingTags =
    text.includes('<think>') ||
    text.includes('<thought>') ||
    text.includes('<thinking>');

  // If no thinking tags are found, return the original text
  if (!hasThinkingTags) {
    return text;
  }

  // Remove content between <think> and </think> tags
  let result = text.replace(/<think>[\s\S]*?<\/think>/g, '');

  // Remove content between <thought> and </thought> tags
  result = result.replace(/<thought>[\s\S]*?<\/thought>/g, '');

  // Remove content between <thinking> and </thinking> tags
  result = result.replace(/<thinking>[\s\S]*?<\/thinking>/g, '');

  // Log for debugging
  console.log('Removed thinking parts from context');

  return result;
}



================================================
FILE: src/utils/colorUtils.ts
================================================
/**
 * Converts a hex color to RGBA
 */
export const hexToRGBA = (hex: string, alpha: number = 1): string => {
  // Remove the hash if it exists
  hex = hex.replace('#', '');

  // Parse the hex values
  const r = parseInt(hex.substring(0, 2), 16);
  const g = parseInt(hex.substring(2, 4), 16);
  const b = parseInt(hex.substring(4, 6), 16);

  // Return the rgba string
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
};

/**
 * Applies opacity to a color (works with both hex and rgba)
 */
export const withOpacity = (color: string, opacity: number): string => {
  if (color.startsWith('rgba')) {
    // If it's already rgba, just modify the opacity
    return color.replace(/[\d.]+\)$/g, `${opacity})`);
  }
  return hexToRGBA(color, opacity);
};

/**
 * Determines if a color is light or dark
 */
export const isLightColor = (color: string): boolean => {
  let r: number, g: number, b: number;

  if (color.startsWith('#')) {
    const hex = color.replace('#', '');
    r = parseInt(hex.substring(0, 2), 16);
    g = parseInt(hex.substring(2, 4), 16);
    b = parseInt(hex.substring(4, 6), 16);
  } else if (color.startsWith('rgba')) {
    const matches = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
    if (!matches) {
      return true;
    }
    [, r, g, b] = matches.map(Number);
  } else {
    return true; // Default to light for unknown formats
  }

  // Calculate relative luminance
  const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
  return luminance > 0.5;
};

/**
 * Gets a contrasting color (black or white) based on background
 */
export const getContrastColor = (backgroundColor: string): string => {
  return isLightColor(backgroundColor) ? '#000000' : '#FFFFFF';
};

/**
 * MD3 state layer opacity values
 */
export const stateLayerOpacity = {
  hover: 0.08,
  focus: 0.12,
  pressed: 0.12,
  dragged: 0.16,
} as const;

/**
 * Creates a state layer color based on the type of state
 */
export const createStateLayer = (
  baseColor: string,
  state: keyof typeof stateLayerOpacity,
): string => {
  return withOpacity(baseColor, stateLayerOpacity[state]);
};



================================================
FILE: src/utils/completionSettingsVersions.ts
================================================
/**
 * Completion settings version constants and migration utilities
 *
 * This file handles the versioning and migration of completion settings.
 * It contains the default completion settings and migration logic.
 *
 * When adding new settings:
 * 1. Add the setting to defaultCompletionParams
 * 2. Increment CURRENT_COMPLETION_SETTINGS_VERSION
 * 3. Add a migration step in migrateCompletionSettings to handle the new setting
 */

import {CompletionParams} from './completionTypes';

// Current version of the completion settings schema
// Increment this when adding new settings or changing existing ones
export const CURRENT_COMPLETION_SETTINGS_VERSION = 3;

/**
 * Default completion parameters used throughout the app
 */
export const defaultCompletionParams: CompletionParams = {
  // App-specific properties
  version: CURRENT_COMPLETION_SETTINGS_VERSION, // Schema version for migrations
  include_thinking_in_context: true, // Whether to include thinking parts in the context sent to the model

  // llama.rn API properties
  prompt: '',
  n_predict: 1024, // The maximum number of tokens to predict when generating text.
  temperature: 0.7, // The randomness of the generated text.
  top_k: 40, // Limit the next token selection to the K most probable tokens.
  top_p: 0.95, // Limit the next token selection to a subset of tokens with a cumulative probability above a threshold P.
  min_p: 0.05, //The minimum probability for a token to be considered, relative to the probability of the most likely token.
  xtc_threshold: 0.1, // Sets a minimum probability threshold for tokens to be removed.
  xtc_probability: 0.0, // Sets the chance for token removal (checked once on sampler start)
  typical_p: 1.0, // Enable locally typical sampling with parameter p. Default: `1.0`, which is disabled.
  penalty_last_n: 64, // Last n tokens to consider for penalizing repetition. Default: `64`, where `0` is disabled and `-1` is ctx-size.
  penalty_repeat: 1.0, // Control the repetition of token sequences in the generated text.
  penalty_freq: 0.0, // Repeat alpha frequency penalty. Default: `0.0`, which is disabled.
  penalty_present: 0.0, // Repeat alpha presence penalty. Default: `0.0`, which is disabled.
  mirostat: 0, //Enable Mirostat sampling, controlling perplexity during text generation. Default: `0`, where `0` is disabled, `1` is Mirostat, and `2` is Mirostat 2.0.
  mirostat_tau: 5, // Set the Mirostat target entropy, parameter tau. Default: `5.0`
  mirostat_eta: 0.1, // Set the Mirostat learning rate, parameter eta.  Default: `0.1`
  seed: -1,
  n_probs: 0, // If greater than 0, the response also contains the probabilities of top N tokens for each generated token given the sampling settings.
  stop: ['</s>'],
  jinja: true, // Whether to use Jinja templating for chat formatting
  enable_thinking: true, // Whether to enable thinking mode for compatible models
  // emit_partial_completion: true, // This is not used in the current version of llama.rn
};

/**
 * Migrates completion settings to the latest version
 * @param settings The settings object to migrate
 * @returns The migrated settings object
 */
export function migrateCompletionSettings(settings: any): any {
  // Clone the settings to avoid modifying the original
  const migratedSettings = {...settings};

  // If no version is specified, assume it's the initial version (0)
  if (migratedSettings.version === undefined) {
    migratedSettings.version = 0;
  }

  // Apply migrations sequentially
  if (migratedSettings.version < 1) {
    // Migration to version 1: Add include_thinking_in_context
    migratedSettings.include_thinking_in_context =
      defaultCompletionParams.include_thinking_in_context;
    migratedSettings.version = 1;
  }

  if (migratedSettings.version < 2) {
    // Migration to version 2: Add jinja parameter
    migratedSettings.jinja = defaultCompletionParams.jinja;
    migratedSettings.version = 2;
  }

  // Add future migrations here as needed
  if (migratedSettings.version < 3) {
    // Migration to version 3: Add enable_thinking parameter
    migratedSettings.enable_thinking = defaultCompletionParams.enable_thinking;
    migratedSettings.version = 3;
  }

  // Add future migrations here as needed
  // if (migratedSettings.version < 4) {
  //   // Migration to version 4
  //   migratedSettings.new_field = defaultCompletionParams.new_field;
  //   migratedSettings.version = 4;
  // }

  return migratedSettings;
}



================================================
FILE: src/utils/completionTypes.ts
================================================
import {CompletionParams as LlamaRNCompletionParams} from '@pocketpalai/llama.rn';

// Alias allows flexibility to switch API providers later
// We should move towards OpenAI Compatible API Params
export type ApiCompletionParams = LlamaRNCompletionParams;

/**
 * App-specific completion parameters that are not part of the llama.rn API.
 * These parameters are used only within the app and should be stripped before
 * sending to the llama.rn API.
 */
export type AppOnlyCompletionParams = {
  /**
   * Schema version for the completion parameters.
   * Used for migrations when the schema changes.
   */
  version?: number;

  /**
   * Whether to include thinking parts in the context sent to the model.
   * When false, thinking parts are removed from the context to save context space.
   */
  include_thinking_in_context?: boolean;
  // Add other PocketPal-only fields here
};

/**
 * List of keys that are app-specific and should be stripped before
 * sending to the llama.rn API.
 */
const APP_ONLY_KEYS: (keyof AppOnlyCompletionParams)[] = [
  'version',
  'include_thinking_in_context',
];

/**
 * The merged type used throughout the app.
 * This includes both API parameters and app-specific parameters.
 */
export type CompletionParams = ApiCompletionParams & AppOnlyCompletionParams;

/**
 * Strips PocketPal-specific fields before sending to llama.rn.
 *
 * @param params - The app completion parameters that may include app-specific properties
 * @returns A clean API completion parameters object with only properties supported by the API
 */
export function toApiCompletionParams(
  params: CompletionParams,
): ApiCompletionParams {
  const apiParams: Partial<CompletionParams> = {...params};

  for (const key of APP_ONLY_KEYS) {
    delete apiParams[key];
  }

  return apiParams as ApiCompletionParams;
}



================================================
FILE: src/utils/errors.ts
================================================
/**
 * Error classes for better error handling throughout the application
 */

import axios from 'axios';
import {uiStore} from '../store/UIStore';
/**
 * NetworkError - Used for connectivity-related errors
 * Examples: No internet connection, timeout, etc.
 */
export class NetworkError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'NetworkError';
  }
}

/**
 * AppCheckError - Used for Firebase App Check verification errors
 * Examples: App not installed from official store, verification failed, etc.
 */
export class AppCheckError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'AppCheckError';
  }
}

/**
 * ServerError - Used for backend server errors
 * Examples: 500 errors, API unavailable, etc.
 */
export class ServerError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ServerError';
  }
}

/**
 * Standardized error state interface for consistent error handling across the app
 */
export interface ErrorState {
  code:
    | 'authentication'
    | 'authorization'
    | 'network'
    | 'storage'
    | 'server'
    | 'multimodal'
    | 'unknown';
  service?: 'huggingface' | 'firebase' | 'localapi';
  message: string;
  context: 'search' | 'download' | 'modelDetails' | 'chat';
  recoverable: boolean;
  severity?: 'error' | 'warning';
  metadata?: {
    modelId?: string;
    [key: string]: any;
  };
}

/**
 * Helper function to create a standardized error state from any error
 */
export function createErrorState(
  error: unknown,
  context: ErrorState['context'],
  service?: ErrorState['service'],
  metadata?: ErrorState['metadata'],
  severity: ErrorState['severity'] = 'error',
): ErrorState {
  const l10nObject = uiStore.l10n;
  let code: ErrorState['code'] = 'unknown';
  let message = l10nObject.errors.unexpectedError;
  let recoverable = true;
  let errorService = service;

  if (axios.isAxiosError(error)) {
    const statusCode = error.response?.status;

    // Check URL to determine service if not explicitly provided
    if (!errorService) {
      const url = error.config?.url || '';
      if (url.includes('huggingface.co') || url.includes('hf.co')) {
        errorService = 'huggingface';
      }
    }

    if (statusCode === 401) {
      code = 'authentication';
      message =
        errorService === 'huggingface'
          ? context === 'search'
            ? l10nObject.errors.hfAuthenticationErrorSearch
            : l10nObject.errors.hfAuthenticationError
          : l10nObject.errors.authenticationError;
    } else if (statusCode === 403) {
      code = 'authorization';
      message =
        errorService === 'huggingface'
          ? l10nObject.errors.hfAuthorizationError
          : l10nObject.errors.authorizationError;
    } else if (statusCode && statusCode >= 500) {
      code = 'server';
      message =
        errorService === 'huggingface'
          ? l10nObject.errors.hfServerError
          : l10nObject.errors.serverError;
    } else if (error.code === 'ECONNABORTED' || error.code === 'ETIMEDOUT') {
      code = 'network';
      message =
        errorService === 'huggingface'
          ? l10nObject.errors.hfNetworkTimeout
          : l10nObject.errors.networkTimeout;
    } else if (error.code === 'ERR_NETWORK') {
      code = 'network';
      message =
        errorService === 'huggingface'
          ? l10nObject.errors.hfNetworkError
          : l10nObject.errors.networkError;
    }
  } else if (error instanceof NetworkError) {
    code = 'network';
    message = error.message;
  } else if (error instanceof ServerError) {
    code = 'server';
    message = error.message;
  } else if (error instanceof Error) {
    // Handle error messages containing HTTP status codes (e.g., 'Client error: 403')
    if (typeof error.message === 'string') {
      const statusCodeMatch = error.message.match(
        /(?:Client error:|status:?)\s*(\d{3})/i,
      );
      if (statusCodeMatch) {
        const statusCode = parseInt(statusCodeMatch[1], 10);

        if (statusCode === 401) {
          code = 'authentication';
          message =
            errorService === 'huggingface'
              ? l10nObject.errors.hfAuthenticationError
              : l10nObject.errors.authenticationError;
        } else if (statusCode === 403) {
          code = 'authorization';
          message =
            errorService === 'huggingface'
              ? l10nObject.errors.hfAuthorizationError
              : l10nObject.errors.authorizationError;
        } else if (statusCode >= 500) {
          code = 'server';
          message =
            errorService === 'huggingface'
              ? l10nObject.errors.hfServerError
              : l10nObject.errors.serverError;
        }
      } else if (
        error.message.includes('storage') ||
        error.message.includes('space')
      ) {
        code = 'storage';
        message = error.message;
      } else {
        message = error.message;
      }
    } else {
      message = error.message;
    }
  }

  return {
    code,
    service: errorService,
    message,
    context,
    recoverable,
    severity,
    metadata,
  };
}

/**
 * Helper function to create a multimodal warning state
 */
export function createMultimodalWarning(
  message: string,
  context: ErrorState['context'] = 'chat',
): ErrorState {
  return {
    code: 'multimodal',
    message,
    context,
    recoverable: false,
    severity: 'warning',
  };
}



================================================
FILE: src/utils/exportUtils.ts
================================================
import {Platform, Alert} from 'react-native';

import {format} from 'date-fns';
import Share from 'react-native-share';
import * as RNFS from '@dr.pogodin/react-native-fs';

import {chatSessionRepository} from '../repositories/ChatSessionRepository';

import {uiStore, palStore} from '../store';
import {ensureLegacyStoragePermission} from './androidPermission';
import {PalType} from '../components/PalsSheets/types';
/**
 * Export a single chat session to a JSON file
 * @param sessionId The ID of the session to export
 */
export const exportChatSession = async (sessionId: string): Promise<void> => {
  try {
    // Get the session data
    const sessionData = await chatSessionRepository.getSessionById(sessionId);
    if (!sessionData) {
      throw new Error('Session not found');
    }

    // Format the session data for export
    const {session, messages, completionSettings} = sessionData;

    const exportData = {
      id: session.id,
      title: session.title,
      date: session.date,
      messages: messages.map(msg => ({
        id: msg.id,
        author: msg.author,
        text: msg.text,
        type: msg.type,
        metadata: msg.metadata ? JSON.parse(msg.metadata) : {},
        createdAt: msg.createdAt,
      })),
      completionSettings: completionSettings
        ? JSON.parse(completionSettings.settings)
        : {},
      activePalId: session.activePalId,
    };

    // Create a filename with the session title and date
    const timestamp = format(new Date(), 'yyyy-MM-dd_HH-mm-ss');
    const sanitizedTitle = session.title
      .replace(/[^a-z0-9]/gi, '_')
      .toLowerCase();
    const filename = `${sanitizedTitle}_${timestamp}.json`;

    // Convert to JSON
    const jsonData = JSON.stringify(exportData, null, 2);

    // Share the file
    await shareJsonData(jsonData, filename);
  } catch (error) {
    console.error('Error exporting chat session:', error);
    throw error;
  }
};

/**
 * Export all chat sessions to a JSON file
 */
export const exportAllChatSessions = async (): Promise<void> => {
  try {
    // Get all sessions
    const sessions = await chatSessionRepository.getAllSessions();

    // Create an array to hold all exported sessions
    const exportData: any[] = [];

    // Process each session
    for (const session of sessions) {
      const sessionData = await chatSessionRepository.getSessionById(
        session.id,
      );
      if (sessionData) {
        const {
          session: sessionInfo,
          messages,
          completionSettings,
        } = sessionData;

        exportData.push({
          id: sessionInfo.id,
          title: sessionInfo.title,
          date: sessionInfo.date,
          messages: messages.map(msg => ({
            id: msg.id,
            author: msg.author,
            text: msg.text,
            type: msg.type,
            metadata: msg.metadata ? JSON.parse(msg.metadata) : {},
            createdAt: msg.createdAt,
          })),
          completionSettings: completionSettings
            ? JSON.parse(completionSettings.settings)
            : {},
          activePalId: sessionInfo.activePalId,
        });
      }
    }

    // Create a filename with the current date
    const timestamp = format(new Date(), 'yyyy-MM-dd_HH-mm-ss');
    const filename = `all_chat_sessions_${timestamp}.json`;

    // Convert to JSON
    const jsonData = JSON.stringify(exportData, null, 2);

    // Share the file
    await shareJsonData(jsonData, filename);
  } catch (error) {
    console.error('Error exporting all chat sessions:', error);
    throw error;
  }
};

/**
 * Export a single pal to a JSON file
 * @param palId The ID of the pal to export
 */
export const exportPal = async (palId: string): Promise<void> => {
  try {
    const pal = palStore.getPals().find(p => p.id === palId);
    if (!pal) {
      throw new Error('Pal not found');
    }

    const exportData = transformExportPal(pal);

    const timestamp = format(new Date(), 'yyyy-MM-dd_HH-mm-ss');
    const sanitizedName = pal.name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    const filename = `${sanitizedName}_${timestamp}.json`;

    const jsonData = JSON.stringify(exportData, null, 2);

    await shareJsonData(jsonData, filename);
  } catch (error) {
    console.error('Error exporting pal:', error);
    throw error;
  }
};

/**
 * Export all pals to a JSON file
 */
export const exportAllPals = async (): Promise<void> => {
  try {
    const pals = palStore.getPals();
    const exportData = pals.map(transformExportPal);

    const timestamp = format(new Date(), 'yyyy-MM-dd_HH-mm-ss');
    const filename = `all_pals_${timestamp}.json`;

    const jsonData = JSON.stringify(exportData, null, 2);

    await shareJsonData(jsonData, filename);
  } catch (error) {
    console.error('Error exporting all pals:', error);
    throw error;
  }
};

const transformExportPal = (pal: any) => {
  const palData = {
    id: pal.id,
    palType: pal.palType,
    name: pal.name,
    defaultModel: pal.defaultModel,
    useAIPrompt: pal.useAIPrompt,
    systemPrompt: pal.systemPrompt,
    originalSystemPrompt: pal.originalSystemPrompt,
    isSystemPromptChanged: pal.isSystemPromptChanged,
    color: pal.color,
    promptGenerationModel: pal.promptGenerationModel,
    generatingPrompt: pal.generatingPrompt,
    // roleplay fields
    ...(pal.palType === PalType.ROLEPLAY
      ? {
          world: pal.world,
          location: pal.location,
          aiRole: pal.aiRole,
          userRole: pal.userRole,
          situation: pal.situation,
          toneStyle: pal.toneStyle,
        }
      : {}),
    // video fields
    ...(pal.palType === PalType.VIDEO
      ? {
          captureInterval: pal.captureInterval,
        }
      : {}),
  };
  return palData;
};

/**
 * Export legacy chat sessions from JSON file
 */
export const exportLegacyChatSessions = async (): Promise<void> => {
  try {
    // Check if the legacy file exists
    const legacyFilePath = `${RNFS.DocumentDirectoryPath}/session-metadata.json`;
    const exists = await RNFS.exists(legacyFilePath);

    if (!exists) {
      throw new Error('Legacy chat sessions file not found');
    }

    // Read the legacy file
    const legacyData = await RNFS.readFile(legacyFilePath);

    // Create a filename with the current date
    const timestamp = format(new Date(), 'yyyy-MM-dd_HH-mm-ss');
    const filename = `legacy_chat_sessions_${timestamp}.json`;

    // Share the file
    await shareJsonData(legacyData, filename);
  } catch (error) {
    console.error('Error exporting legacy chat sessions:', error);
    throw error;
  }
};

/**
 * Helper function to share JSON data as a file
 */
const shareJsonData = async (
  jsonData: string,
  filename: string,
): Promise<void> => {
  const currentL10n = uiStore.l10n;
  try {
    // Create a temporary file
    const tempFilePath = `${RNFS.CachesDirectoryPath}/${filename}`;
    await RNFS.writeFile(tempFilePath, jsonData, 'utf8');

    // Share the file
    if (Platform.OS === 'ios') {
      // On iOS, use react-native-share
      await Share.open({
        url: `file://${tempFilePath}`,
        title: `Share ${filename}`,
        type: 'application/json',
        failOnCancel: false,
      });
    } else if (Platform.OS === 'android' && Platform.Version === 29) {
      // Special handling for Android 10 (API 29)
      // Use direct sharing from temp directory instead of saving to Downloads
      try {
        await Share.open({
          url: `file://${tempFilePath}`,
          title: `Share ${filename}`,
          type: 'application/json',
          failOnCancel: false,
        });
        return; // Exit early after sharing
      } catch (error) {
        console.error('Error sharing on Android 10:', error);
        throw error;
      }
    } else {
      // On Android (not API 29), handle with storage permissions
      const permissionGranted = await ensureLegacyStoragePermission();
      if (!permissionGranted) {
        // If permission denied, fall back to direct sharing
        try {
          await Share.open({
            url: `file://${tempFilePath}`,
            title: `Share ${filename}`,
            type: 'application/json',
            failOnCancel: false,
          });
          return; // Exit early after sharing
        } catch (error) {
          console.error('Error sharing after permission denied:', error);
          throw error;
        }
      }

      try {
        // Save to appropriate directory based on platform
        const saveDir = getSaveDirectory();
        const savePath = `${saveDir}/${filename}`;
        await RNFS.copyFile(tempFilePath, savePath);

        // Show success message with the path
        const fileSavedMsg =
          currentL10n.components.exportUtils.fileSavedMessage.replace(
            '{{filename}}',
            filename,
          );

        Alert.alert(
          currentL10n.components.exportUtils.fileSaved,
          fileSavedMsg,
          [
            {
              text: currentL10n.components.exportUtils.share,
              onPress: async () => {
                // Use react-native-share for both platforms
                try {
                  const options = {
                    title: `Share ${filename}`,
                    message: 'PocketPal AI Chat Export',
                    url: `file://${savePath}`,
                    type: 'application/json',
                    failOnCancel: false,
                  };

                  await Share.open(options);
                } catch (error) {
                  const shareError = error as any;
                  console.error('Error sharing file:', shareError);

                  // Fallback to sharing content directly if file sharing fails
                  if (shareError.message !== 'User did not share') {
                    try {
                      await Share.open({
                        title: `Share ${filename}`,
                        message: jsonData,
                      });
                    } catch (err) {
                      const fallbackError = err as any;
                      console.error(
                        'Error with fallback sharing:',
                        fallbackError,
                      );
                      // Ignore cancellation errors
                      if (fallbackError.message !== 'User did not share') {
                        Alert.alert(
                          currentL10n.components.exportUtils.shareError,
                          currentL10n.components.exportUtils.shareErrorMessage,
                          [{text: currentL10n.components.exportUtils.ok}],
                        );
                      }
                    }
                  }
                }
              },
            },
            {text: currentL10n.components.exportUtils.ok},
          ],
        );
      } catch (error) {
        console.error('Error saving to Downloads:', error);

        // Fallback to just sharing the file content
        Alert.alert(
          currentL10n.components.exportUtils.saveOptions,
          currentL10n.components.exportUtils.saveOptionsMessage,
          [
            {
              text: currentL10n.components.exportUtils.share,
              onPress: async () => {
                // For fallback, share the file content directly
                try {
                  await Share.open({
                    title: `Share ${filename}`,
                    message: jsonData,
                  });
                } catch (err) {
                  const shareError = err as any;
                  console.error('Error sharing content:', shareError);
                  // Ignore cancellation errors
                  if (shareError.message !== 'User did not share') {
                    Alert.alert(
                      currentL10n.components.exportUtils.shareError,
                      currentL10n.components.exportUtils
                        .shareContentErrorMessage,
                      [{text: currentL10n.components.exportUtils.ok}],
                    );
                  }
                }
              },
            },
            {text: currentL10n.components.exportUtils.cancel},
          ],
        );
      }
    }
  } catch (error: any) {
    console.error('Error sharing JSON data:', error);

    // Show a more user-friendly error message
    Alert.alert(
      currentL10n.components.exportUtils.exportError,
      currentL10n.components.exportUtils.exportErrorMessage,
      [{text: currentL10n.components.exportUtils.ok}],
    );

    throw error;
  }
};

/**
 * Get the appropriate directory for saving files
 * @returns The path to the directory
 */
const getSaveDirectory = (): string => {
  if (Platform.OS === 'ios') {
    return RNFS.DocumentDirectoryPath;
  } else {
    return RNFS.DownloadDirectoryPath;
  }
};



================================================
FILE: src/utils/fb.ts
================================================
import '@react-native-firebase/app-check';
import firebase from '@react-native-firebase/app';
import {APPCHECK_DEBUG_TOKEN_ANDROID, APPCHECK_DEBUG_TOKEN_IOS} from '@env';

// Track initialization status
let isAppCheckInitialized = false;

export const initializeAppCheck = () => {
  if (isAppCheckInitialized) {
    return;
  }

  try {
    const rnfbProvider = firebase
      .appCheck()
      .newReactNativeFirebaseAppCheckProvider();

    rnfbProvider.configure({
      android: {
        provider: __DEV__ ? 'debug' : 'playIntegrity',
        debugToken: APPCHECK_DEBUG_TOKEN_ANDROID,
      },
      apple: {
        provider: __DEV__ ? 'debug' : 'appAttestWithDeviceCheckFallback',
        debugToken: APPCHECK_DEBUG_TOKEN_IOS,
      },
    });
    firebase.appCheck().initializeAppCheck({
      provider: rnfbProvider,
      isTokenAutoRefreshEnabled: true,
    });

    isAppCheckInitialized = true;
  } catch (error) {
    console.error('Failed to initialize Firebase App Check:', error);
  }
};

// Get a fresh App Check token
export const getAppCheckToken = async () => {
  try {
    if (!firebase.appCheck) {
      throw new Error('Firebase App Check module is not available');
    }
    const {token} = await firebase.appCheck().getToken(true);
    return token;
  } catch (error) {
    console.error('Failed to get App Check token:', error);
    throw error;
  }
};



================================================
FILE: src/utils/formatters.ts
================================================
import dayjs from 'dayjs';
import {l10n} from './l10n';

/**
 * Formats a byte value into a human-readable string with appropriate units
 * @param size - The size in bytes to format
 * @param fractionDigits - Number of decimal places to show (default: 2)
 * @param useBinary - Whether to use binary (1024) or decimal (1000) units (default: false)
 * @param threeDigits - Whether to format the number to always show 3 significant digits (default: false)
 *                      When true:
 *                      - Numbers >= 100 show no decimals (e.g., "234 MB")
 *                      - Numbers >= 10 show 1 decimal (e.g., "23.4 MB")
 *                      - Numbers < 10 show 2 decimals (e.g., "2.34 MB")
 * @returns Formatted string with units (e.g., "1.5 MB" or "2 GiB")
 */
export const formatBytes = (
  size: number,
  fractionDigits = 2,
  useBinary = false,
  threeDigits = false,
) => {
  if (size <= 0) {
    return '0 B';
  }

  const base = useBinary ? 1024 : 1000;
  const multiple = Math.floor(Math.log(size) / Math.log(base));

  const units = useBinary
    ? ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']
    : ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];

  const value = size / Math.pow(base, multiple);

  if (threeDigits) {
    const digits = value >= 100 ? 0 : value >= 10 ? 1 : 2;
    return value.toFixed(digits) + ' ' + units[multiple];
  }

  return parseFloat(value.toFixed(fractionDigits)) + ' ' + units[multiple];
};

export function formatNumber(
  num: number,
  fractionDigits = 2,
  uppercase = false,
  withSpace = false,
): string {
  const space = withSpace ? ' ' : '';

  if (num < 1000) {
    return num.toString();
  } else if (num < 1_000_000) {
    const suffix = uppercase ? 'K' : 'k';
    return `${(num / 1_000)
      .toFixed(fractionDigits)
      .replace(/\.?0+$/, '')}${space}${suffix}`;
  } else if (num < 1_000_000_000) {
    const suffix = uppercase ? 'M' : 'm';
    return `${(num / 1_000_000)
      .toFixed(fractionDigits)
      .replace(/\.?0+$/, '')}${space}${suffix}`;
  } else {
    const suffix = uppercase ? 'B' : 'b';
    return `${(num / 1_000_000_000)
      .toFixed(fractionDigits)
      .replace(/\.?0+$/, '')}${space}${suffix}`;
  }
}

/** Returns formatted date used as a divider between different days in the chat history */
export const getVerboseDateTimeRepresentation = (
  dateTime: number,
  {
    dateFormat,
    timeFormat,
  }: {
    dateFormat?: string;
    timeFormat?: string;
  },
) => {
  const formattedDate = dateFormat
    ? dayjs(dateTime).format(dateFormat)
    : dayjs(dateTime).format('MMM D');

  const formattedTime = timeFormat
    ? dayjs(dateTime).format(timeFormat)
    : dayjs(dateTime).format('HH:mm');

  const localDateTime = dayjs(dateTime);
  const now = dayjs();

  if (
    localDateTime.isSame(now, 'day') &&
    localDateTime.isSame(now, 'month') &&
    localDateTime.isSame(now, 'year')
  ) {
    return formattedTime;
  }

  return `${formattedDate}, ${formattedTime}`;
};

export function timeAgo(
  dateValue: string | number | Date,
  l10nData = l10n.en,
  format: 'short' | 'long' = 'long',
): string {
  const inputDate =
    typeof dateValue === 'string' ? new Date(dateValue) : new Date(dateValue);
  const now = new Date();

  const seconds = Math.floor((now.getTime() - inputDate.getTime()) / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  const weeks = Math.floor(days / 7);
  const months = Math.floor(days / 30);
  const years = Math.floor(days / 365);

  // Time value and unit, e.g. "2 days"
  let timeValue = '';

  if (years > 0) {
    timeValue = `${years} ${
      years > 1 ? l10nData.common.years : l10nData.common.year
    }`;
  } else if (months > 0) {
    timeValue = `${months} ${
      months > 1 ? l10nData.common.months : l10nData.common.month
    }`;
  } else if (weeks > 0) {
    timeValue = `${weeks} ${
      weeks > 1 ? l10nData.common.weeks : l10nData.common.week
    }`;
  } else if (days > 0) {
    timeValue = `${days} ${
      days > 1 ? l10nData.common.days : l10nData.common.day
    }`;
  } else if (hours > 0) {
    timeValue = `${hours} ${
      hours > 1 ? l10nData.common.hours : l10nData.common.hour
    }`;
  } else if (minutes > 0) {
    timeValue = `${minutes} ${
      minutes > 1 ? l10nData.common.minutes : l10nData.common.minute
    }`;
  } else {
    // Special case for "just now"
    return format === 'short'
      ? l10nData.models.search.modelUpdatedJustNowShort
      : l10nData.models.search.modelUpdatedJustNowLong;
  }

  if (format === 'short') {
    return l10nData.models.search.modelUpdatedShort.replace(
      '{{time}}',
      timeValue,
    );
  } else {
    return l10nData.models.search.modelUpdatedLong.replace(
      '{{time}}',
      timeValue,
    );
  }
}



================================================
FILE: src/utils/importUtils.ts
================================================
import * as RNFS from '@dr.pogodin/react-native-fs';
import DocumentPicker from 'react-native-document-picker';
import {Platform} from 'react-native';
import {v4 as uuidv4} from 'uuid';
import 'react-native-get-random-values';

import {chatSessionRepository} from '../repositories/ChatSessionRepository';
import {MessageType} from './types';
import {CompletionParams} from './completionTypes';
import {migrateCompletionSettings} from './completionSettingsVersions';
import {
  PalType,
  AssistantFormData,
  RoleplayFormData,
  VideoPalFormData,
} from '../components/PalsSheets/types';
import {palStore} from '../store';

/**
 * Interface for imported chat session data
 */
export interface ImportedChatSession {
  id: string;
  title: string;
  date: string;
  messages: ImportedMessage[];
  completionSettings: CompletionParams;
  activePalId?: string;
}

/**
 * Interface for imported message data
 */
export interface ImportedMessage {
  id: string;
  author: string;
  text?: string;
  type: string;
  metadata?: Record<string, any>;
  createdAt?: number;
}

/**
 * Pick a JSON file using document picker
 */
export const pickJsonFile = async (): Promise<string | null> => {
  try {
    const res = await DocumentPicker.pick({
      type:
        Platform.OS === 'ios' ? 'public.json' : [DocumentPicker.types.allFiles],
    });

    if (res && res.length > 0) {
      const file = res[0];

      // Check if it's a JSON file
      if (
        !file.name?.toLowerCase().endsWith('.json') &&
        !file.type?.includes('json')
      ) {
        throw new Error('Selected file is not a JSON file');
      }

      return file.uri;
    }
    return null;
  } catch (err: any) {
    if (DocumentPicker.isCancel(err)) {
      // User cancelled the picker
      return null;
    }
    throw err;
  }
};

/**
 * Read and parse a JSON file
 */
export const readJsonFile = async (fileUri: string): Promise<any> => {
  try {
    const fileContent = await RNFS.readFile(fileUri, 'utf8');
    return JSON.parse(fileContent);
  } catch (error) {
    console.error('Error reading or parsing JSON file:', error);
    throw new Error('Failed to read or parse the selected file');
  }
};

/**
 * Validate imported chat session data
 */
export const validateImportedData = (
  data: any,
): ImportedChatSession | ImportedChatSession[] => {
  // Check if it's an array or a single object
  if (Array.isArray(data)) {
    // Validate each session in the array
    return data.map(session => validateSingleSession(session));
  } else {
    // Validate a single session
    return validateSingleSession(data);
  }
};

/**
 * Validate a single chat session
 */
const validateSingleSession = (session: any): ImportedChatSession => {
  // Check required fields
  if (!session.title || typeof session.title !== 'string') {
    throw new Error('Invalid session: missing or invalid title');
  }

  if (!session.date || typeof session.date !== 'string') {
    // If date is missing, create a new one
    session.date = new Date().toISOString();
  }

  if (!session.messages || !Array.isArray(session.messages)) {
    session.messages = [];
  }

  // Validate messages
  session.messages = session.messages.map((msg: any) => {
    if (!msg.id) {
      msg.id = uuidv4();
    }

    if (!msg.author) {
      throw new Error('Invalid message: missing author');
    }

    if (!msg.type) {
      msg.type = 'text';
    }

    if (!msg.createdAt) {
      msg.createdAt = Date.now();
    }

    return msg;
  });

  // Ensure completionSettings exists
  if (!session.completionSettings) {
    session.completionSettings = {};
  }

  // Migrate completion settings to latest version
  session.completionSettings = migrateCompletionSettings(
    session.completionSettings,
  );

  // Generate a new ID if not present or to avoid conflicts
  if (!session.id) {
    session.id = uuidv4();
  }

  return session as ImportedChatSession;
};

/**
 * Import chat sessions from a JSON file
 */
export const importChatSessions = async (): Promise<number> => {
  try {
    // Pick a JSON file
    const fileUri = await pickJsonFile();
    if (!fileUri) {
      return 0; // User cancelled
    }

    // Read and parse the file
    const data = await readJsonFile(fileUri);

    // Validate the data
    const validatedData = validateImportedData(data);

    // Import the sessions
    if (Array.isArray(validatedData)) {
      // Import multiple sessions
      let importedCount = 0;
      for (const session of validatedData) {
        await importSingleSession(session);
        importedCount++;
      }
      return importedCount;
    } else {
      // Import a single session
      await importSingleSession(validatedData);
      return 1;
    }
  } catch (error) {
    console.error('Error importing chat sessions:', error);
    throw error;
  }
};

/**
 * Import a single chat session
 */
const importSingleSession = async (
  session: ImportedChatSession,
): Promise<void> => {
  try {
    // Map messages to the correct format
    const messages = session.messages.map(
      msg =>
        ({
          id: msg.id,
          author: {id: msg.author},
          text: msg.text || '',
          type: msg.type as any,
          metadata: msg.metadata || {},
          createdAt: msg.createdAt || Date.now(),
        } as MessageType.Any),
    );

    // Create a new session in the database
    await chatSessionRepository.createSession(
      session.title,
      messages,
      session.completionSettings,
      session.activePalId,
    );
  } catch (error) {
    console.error('Error importing single session:', error);
    throw error;
  }
};

/**
 * Interface for imported pal data
 */
export interface ImportedPal {
  id: string;
  name: string;
  palType: PalType;
  defaultModel?: any;
  useAIPrompt: boolean;
  systemPrompt: string;
  originalSystemPrompt?: string;
  isSystemPromptChanged: boolean;
  color?: [string, string];
  promptGenerationModel?: any;
  generatingPrompt?: string;

  // Roleplay fields
  world?: string;
  location?: string;
  aiRole?: string;
  userRole?: string;
  situation?: string;
  toneStyle?: string;

  // Video fields
  captureInterval?: number;
}

/**
 * Import pals from a JSON file (single or multiple)
 */
export const importPals = async (): Promise<number> => {
  try {
    // Pick a JSON file
    const fileUri = await pickJsonFile();
    if (!fileUri) {
      return 0;
    }

    const data = await readJsonFile(fileUri);
    const validatedData = validateImportedPalData(data);

    if (Array.isArray(validatedData)) {
      let importedCount = 0;
      for (const pal of validatedData) {
        await importSinglePal(pal);
        importedCount++;
      }
      return importedCount;
    } else {
      await importSinglePal(validatedData);
      return 1;
    }
  } catch (error) {
    console.error('Error importing pals:', error);
    throw error;
  }
};

/**
 * Validate imported pal data
 */
export const validateImportedPalData = (
  data: any,
): ImportedPal | ImportedPal[] => {
  // Check if it's an array or a single object
  if (Array.isArray(data)) {
    // Validate each pal in the array
    return data.map(pal => validateSinglePal(pal));
  } else {
    // Validate a single pal
    return validateSinglePal(data);
  }
};

/**
 * Validate a single pal
 */
const validateSinglePal = (pal: any): ImportedPal => {
  // Check required fields
  if (!pal.name || typeof pal.name !== 'string') {
    throw new Error('Invalid pal: missing or invalid name');
  }

  if (!pal.palType || !Object.values(PalType).includes(pal.palType)) {
    throw new Error('Invalid pal: missing or invalid palType');
  }

  if (!pal.systemPrompt || typeof pal.systemPrompt !== 'string') {
    throw new Error('Invalid pal: missing or invalid systemPrompt');
  }

  if (typeof pal.useAIPrompt !== 'boolean') {
    pal.useAIPrompt = false;
  }

  if (typeof pal.isSystemPromptChanged !== 'boolean') {
    pal.isSystemPromptChanged = false;
  }

  // Validate roleplay required fields
  if (pal.palType === PalType.ROLEPLAY) {
    const requiredRoleplayFields = [
      'world',
      'location',
      'aiRole',
      'userRole',
      'situation',
      'toneStyle',
    ];

    for (const field of requiredRoleplayFields) {
      if (!pal[field] || typeof pal[field] !== 'string') {
        throw new Error(`Invalid roleplay pal: missing or invalid ${field}`);
      }
    }
  }

  // Validate video required fields
  if (pal.palType === PalType.VIDEO) {
    if (
      pal.captureInterval === undefined ||
      typeof pal.captureInterval !== 'number'
    ) {
      pal.captureInterval = 3000;
    }
  }

  if (!pal.id) {
    pal.id = uuidv4();
  }

  return pal as ImportedPal;
};

const transformImportPal = (
  pal: ImportedPal,
): AssistantFormData | RoleplayFormData | VideoPalFormData => {
  const baseData = {
    name: pal.name,
    defaultModel: pal.defaultModel,
    useAIPrompt: pal.useAIPrompt,
    systemPrompt: pal.systemPrompt,
    originalSystemPrompt: pal.originalSystemPrompt,
    isSystemPromptChanged: pal.isSystemPromptChanged,
    color: pal.color,
    promptGenerationModel: pal.promptGenerationModel,
    generatingPrompt: pal.generatingPrompt,
  };
  switch (pal.palType) {
    case PalType.ROLEPLAY:
      return {
        ...baseData,
        palType: PalType.ROLEPLAY,
        world: pal.world!,
        location: pal.location!,
        aiRole: pal.aiRole!,
        userRole: pal.userRole!,
        situation: pal.situation!,
        toneStyle: pal.toneStyle!,
      } as RoleplayFormData;

    case PalType.VIDEO:
      return {
        ...baseData,
        palType: PalType.VIDEO,
        captureInterval: pal.captureInterval!,
      } as VideoPalFormData;

    case PalType.ASSISTANT:
    default:
      return {
        ...baseData,
        palType: PalType.ASSISTANT,
      } as AssistantFormData;
  }
};

/**
 * Import a single pal
 */
const importSinglePal = async (pal: ImportedPal): Promise<void> => {
  try {
    const palData = transformImportPal(pal);
    await palStore.addPal(palData);
  } catch (error) {
    console.error('Error importing single pal:', error);
    throw error;
  }
};



================================================
FILE: src/utils/index.ts
================================================
import * as React from 'react';
import {ColorValue} from 'react-native';

import _ from 'lodash';
import dayjs from 'dayjs';
import {MD3Theme} from 'react-native-paper';
import DeviceInfo from 'react-native-device-info';
import Blob from 'react-native/Libraries/Blob/Blob';
import * as RNFS from '@dr.pogodin/react-native-fs';

import {l10n} from './l10n';
import {modelStore} from '../store';
import {getHFDefaultSettings} from './chat';
import {formatBytes, formatNumber} from './formatters';
import {getVerboseDateTimeRepresentation} from './formatters';
import {
  HuggingFaceModel,
  MessageType,
  Model,
  ModelFile,
  ModelOrigin,
  ModelType,
  PreviewImage,
  User,
} from './types';
import {
  isVisionRepo,
  getMmprojFiles,
  isProjectionModel,
  getRecommendedProjectionModel,
  getVisionModelSizeBreakdown,
} from './multimodalHelpers';

export const L10nContext = React.createContext<
  (typeof l10n)[keyof typeof l10n]
>(l10n.en);
export const UserContext = React.createContext<User | undefined>(undefined);

/** Returns size in bytes of the provided text */
export const getTextSizeInBytes = (text: string) => new Blob([text]).size;

/** Returns theme colors as ColorValue array */
export const getThemeColorsAsArray = (theme: MD3Theme): ColorValue[] => {
  const colors = theme.colors;
  return Object.values(colors) as ColorValue[];
};

/** Returns user avatar and name color based on the ID */
export const getUserAvatarNameColor = (user: User, colors: ColorValue[]) =>
  colors[hashCode(user.id) % colors.length];

/** Returns user initials (can have only first letter of firstName/lastName or both) */
export const getUserInitials = ({firstName, lastName}: User) =>
  `${firstName?.charAt(0) ?? ''}${lastName?.charAt(0) ?? ''}`
    .toUpperCase()
    .trim();

/** Returns user name as joined firstName and lastName */
export const getUserName = ({firstName, lastName}: User) =>
  `${firstName ?? ''} ${lastName ?? ''}`.trim();

/** Returns hash code of the provided text */
export const hashCode = (text = '') => {
  let i,
    chr,
    hash = 0;
  if (text.length === 0) {
    return hash;
  }
  for (i = 0; i < text.length; i++) {
    chr = text.charCodeAt(i);
    // eslint-disable-next-line no-bitwise
    hash = (hash << 5) - hash + chr;
    // eslint-disable-next-line no-bitwise
    hash |= 0; // Convert to 32bit integer
  }
  return Math.abs(hash);
};

/** Inits dayjs locale */
export const initLocale = (locale?: keyof typeof l10n) => {
  const locales: {[key in keyof typeof l10n]: unknown} = {
    en: require('dayjs/locale/en'),
    // es: require('dayjs/locale/es'),
    // ko: require('dayjs/locale/ko'),
    // pl: require('dayjs/locale/pl'),
    // pt: require('dayjs/locale/pt'),
    // ru: require('dayjs/locale/ru'),
    // tr: require('dayjs/locale/tr'),
    // uk: require('dayjs/locale/uk'),
    // ca: require('dayjs/locale/ca'),
    // de: require('dayjs/locale/de'),
    ja: require('dayjs/locale/ja'),
    zh: require('dayjs/locale/zh'),
  };

  locale ? locales[locale] : locales.en;
  dayjs.locale(locale);
};

/** Returns either prop or empty object if null or undefined */
export const unwrap = <T>(prop: T) => prop ?? {};

/** Parses provided messages to chat messages (with headers) and returns them with a gallery */
export const calculateChatMessages = (
  messages: MessageType.Any[],
  user: User,
  {
    customDateHeaderText,
    dateFormat,
    showUserNames,
    timeFormat,
  }: {
    customDateHeaderText?: (dateTime: number) => string;
    dateFormat?: string;
    showUserNames: boolean;
    timeFormat?: string;
  },
) => {
  let chatMessages: MessageType.DerivedAny[] = [];
  let gallery: PreviewImage[] = [];

  let shouldShowName = false;

  for (let i = messages.length - 1; i >= 0; i--) {
    const isFirst = i === messages.length - 1;
    const isLast = i === 0;
    const message = messages[i];
    const messageHasCreatedAt = !!message.createdAt;
    const nextMessage = isLast ? undefined : messages[i - 1];
    const nextMessageHasCreatedAt = !!nextMessage?.createdAt;
    const nextMessageSameAuthor = message.author.id === nextMessage?.author.id;
    const notMyMessage = message.author.id !== user.id;

    let nextMessageDateThreshold = false;
    let nextMessageDifferentDay = false;
    let nextMessageInGroup = false;
    let showName = false;

    if (showUserNames) {
      const previousMessage = isFirst ? undefined : messages[i + 1];

      const isFirstInGroup =
        notMyMessage &&
        (message.author.id !== previousMessage?.author.id ||
          (messageHasCreatedAt &&
            !!previousMessage?.createdAt &&
            message.createdAt! - previousMessage!.createdAt! > 60000));

      if (isFirstInGroup) {
        shouldShowName = false;
        if (message.type === 'text') {
          showName = true;
        } else {
          shouldShowName = true;
        }
      }

      if (message.type === 'text' && shouldShowName) {
        showName = true;
        shouldShowName = false;
      }
    }

    if (messageHasCreatedAt && nextMessageHasCreatedAt) {
      nextMessageDateThreshold =
        nextMessage!.createdAt! - message.createdAt! >= 900000;

      nextMessageDifferentDay = !dayjs(message.createdAt!).isSame(
        nextMessage!.createdAt!,
        'day',
      );

      nextMessageInGroup =
        nextMessageSameAuthor &&
        nextMessage!.createdAt! - message.createdAt! <= 60000;
    }

    if (isFirst && messageHasCreatedAt) {
      const text =
        customDateHeaderText?.(message.createdAt!) ??
        getVerboseDateTimeRepresentation(message.createdAt!, {
          dateFormat,
          timeFormat,
        });
      chatMessages = [{id: text, text, type: 'dateHeader'}, ...chatMessages];
    }

    chatMessages = [
      {
        ...message,
        nextMessageInGroup,
        // TODO: Check this
        offset: !nextMessageInGroup ? 12 : 0,
        showName:
          notMyMessage &&
          showUserNames &&
          showName &&
          !!getUserName(message.author),
        showStatus: true,
      },
      ...chatMessages,
    ];

    if (nextMessageDifferentDay || nextMessageDateThreshold) {
      const text =
        customDateHeaderText?.(nextMessage!.createdAt!) ??
        getVerboseDateTimeRepresentation(nextMessage!.createdAt!, {
          dateFormat,
          timeFormat,
        });

      chatMessages = [
        {
          id: text,
          text,
          type: 'dateHeader',
        },
        ...chatMessages,
      ];
    }

    if (message.type === 'image') {
      gallery = [...gallery, {id: message.id, uri: message.uri}];
    }
  }

  return {
    chatMessages,
    gallery,
  };
};

/** Removes all derived message props from the derived message */
export const excludeDerivedMessageProps = (
  message: MessageType.DerivedMessage,
) => {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const {nextMessageInGroup, offset, showName, showStatus, ...rest} = message;
  return {...rest} as MessageType.Any;
};

export function roundToBillion(num: number) {
  const billion = 1e9;
  return Math.round((num / billion) * 10) / 10;
}

export function bytesToGB(bytes: number): string {
  const bytesPerGB = 1000 ** 3;
  const gib = bytes / bytesPerGB;
  return gib.toFixed(2);
}

export const getModelDescription = (
  model: Model,
  isActiveModel: boolean,
  l10nData = l10n.en,
): string => {
  // Get size and params from context if the model is active.
  // This is relevant only for local models (when we don't know size/params upfront),
  // otherwise the values should be the same.
  const {size, params} =
    isActiveModel && modelStore.context?.model
      ? {
          size: modelStore.context.model.size,
          params: modelStore.context.model.nParams,
        }
      : {
          size: model.size,
          params: model.params,
        };

  const notAvailable = l10nData.models.modelDescription.notAvailable;
  let sizeString = size > 0 ? formatBytes(size) : notAvailable;

  // For vision models, show combined size if projection model is available
  if (model.supportsMultimodal && model.hfModelFile && model.hfModel) {
    const sizeBreakdown = getVisionModelSizeBreakdown(
      model.hfModelFile,
      model.hfModel,
    );
    if (sizeBreakdown.hasProjection) {
      sizeString = `${formatBytes(sizeBreakdown.totalSize)}`;
    }
  }

  const paramsString =
    params > 0 ? formatNumber(params, 2, true, false) : notAvailable;

  return `${l10nData.models.modelDescription.size}${sizeString}${l10nData.models.modelDescription.separator}${l10nData.models.modelDescription.parameters}${paramsString}`;
};

export async function hasEnoughSpace(model: Model): Promise<boolean> {
  try {
    let requiredSpaceBytes = model.size;

    // For vision models, consider the total size including projection model
    if (model.supportsMultimodal && model.hfModelFile && model.hfModel) {
      const sizeBreakdown = getVisionModelSizeBreakdown(
        model.hfModelFile,
        model.hfModel,
      );
      if (sizeBreakdown.hasProjection) {
        requiredSpaceBytes = sizeBreakdown.totalSize;
      }
    }

    if (isNaN(requiredSpaceBytes) || requiredSpaceBytes <= 0) {
      console.error('Invalid model size:', model.size);
      return false;
    }

    const freeDiskBytes = await DeviceInfo.getFreeDiskStorage('important');
    // console.log('Free disk space:', freeDiskBytes);

    return requiredSpaceBytes <= freeDiskBytes;
  } catch (error) {
    console.error('Error fetching free disk space:', error);
    return false;
  }
}

/**
 * Merges properties from the source object into the target object deeply.
 * Only sets properties that do not already exist in the target or if the types differ.
 *
 * @param target - The target object to merge properties into.
 * @param source - The source object from which properties are taken.
 * @returns The updated target object after merging.
 */
export const deepMerge = (target: any, source: any): any => {
  for (const key in source) {
    if (source.hasOwnProperty(key)) {
      if (typeof source[key] === 'object' && source[key] !== null) {
        // If the property is an object, recursively merge.
        // If target[key] is not an object, it means the property type is different so we will replace it.
        target[key] =
          target[key] && typeof target[key] === 'object' ? target[key] : {};
        deepMerge(target[key], source[key]);
      } else {
        // Set the property in the target only if it doesn't exist or if the types differ
        if (!(key in target) || typeof target[key] !== typeof source[key]) {
          target[key] = source[key];
        }
      }
    }
  }
  return target;
};

export function extractHFModelType(modelId: string): string {
  const match = modelId.match(/\/([^-]+)/);
  return match ? match[1] : 'Unknown';
}

export function extractHFModelTitle(modelId: string): string {
  // Remove "GGUF", "-GGUF", or "_GGUF" at the end regardless of case
  const sanitizedModelId = modelId.replace(/[-_]?[Gg][Gg][Uu][Ff]$/, '');

  // If there is no "/" in the modelId, ie owner is not included, return sanitizedModelId
  if (!sanitizedModelId.includes('/')) {
    return sanitizedModelId;
  }

  // Remove owner from the modelId
  const match = sanitizedModelId.match(/^([^/]+)\/(.+)$/);
  return match ? match[2] : 'Unknown';
}

export function hfAsModel(
  hfModel: HuggingFaceModel,
  modelFile: ModelFile,
): Model {
  const defaultSettings = getHFDefaultSettings(hfModel);

  // Check if this is a vision repository
  const isVision = isVisionRepo(hfModel.siblings || []);

  // Check if this is a projection model
  const isProjModel = isProjectionModel(modelFile.rfilename);

  // Check if this is a vision LLM (in a vision repo but not a projection model)
  const isVisionLLM = isVision && !isProjModel;

  // Get compatible projection models if this is a vision LLM
  let compatibleProjectionModels: string[] = [];
  let defaultProjectionModel: string | undefined;

  if (isVisionLLM) {
    // Get mmproj files from the repository
    const mmprojFiles = getMmprojFiles(hfModel.siblings || []);

    // Convert to model IDs
    compatibleProjectionModels = mmprojFiles.map(
      file => `${hfModel.id}/${file.rfilename}`,
    );

    // Set default projection model based on quantization matching
    if (compatibleProjectionModels.length > 0) {
      // Get the filenames only
      const mmprojFilenames = mmprojFiles.map(file => file.rfilename);

      // Find the best matching projection model based on quantization
      const recommendedFile = getRecommendedProjectionModel(
        modelFile.rfilename,
        mmprojFilenames,
      );

      if (recommendedFile) {
        defaultProjectionModel = `${hfModel.id}/${recommendedFile}`;
      }
    }
  }

  const _model: Model = {
    id: hfModel.id + '/' + modelFile.rfilename,
    type: extractHFModelType(hfModel.id),
    author: hfModel.author,
    name: extractHFModelTitle(modelFile.rfilename),
    size: modelFile.size ?? 0,
    params: hfModel.specs?.gguf?.total ?? 0,
    isDownloaded: false,
    downloadUrl: modelFile.url ?? '',
    hfUrl: hfModel.url ?? '',
    progress: 0,
    filename: modelFile.rfilename,
    capabilities: isVisionLLM ? ['vision'] : undefined,
    //fullPath: '',
    isLocal: false,
    origin: ModelOrigin.HF,
    defaultChatTemplate: defaultSettings.chatTemplate,
    chatTemplate: _.cloneDeep(defaultSettings.chatTemplate),
    defaultCompletionSettings: defaultSettings.completionParams,
    completionSettings: {...defaultSettings.completionParams},
    defaultStopWords: defaultSettings.completionParams.stop,
    stopWords: defaultSettings.completionParams.stop,
    hfModelFile: modelFile,
    hfModel: hfModel,

    // Set multimodal fields
    supportsMultimodal: isVisionLLM,
    modelType: isProjModel
      ? ModelType.PROJECTION
      : isVisionLLM
      ? ModelType.VISION
      : undefined,
    compatibleProjectionModels: isVisionLLM
      ? compatibleProjectionModels
      : undefined,
    defaultProjectionModel: isVisionLLM ? defaultProjectionModel : undefined,
  };

  return _model;
}
export const randId = () => Math.random().toString(36).substring(2, 11);

// There is a an issue with RNFS.hash: https://github.com/birdofpreyru/react-native-fs/issues/99
export const getSHA256Hash = async (filePath: string): Promise<string> => {
  try {
    const hash = await RNFS.hash(filePath, 'sha256');
    return hash;
  } catch (error) {
    console.error('Error generating SHA256 hash:', error);
    throw error;
  }
};

/**
 * Checks if a model's file integrity is valid by comparing  file size. Hash doesn't seem to be reliable, and expensive.
 * see: https://github.com/birdofpreyru/react-native-fs/issues/99
 * @param model - The model to check integrity for
 * @param modelStore - The model store instance for updating model details
 * @returns An object containing the integrity check result and any error message
 */
export const checkModelFileIntegrity = async (
  model: Model,
): Promise<{
  isValid: boolean;
  errorMessage: string | null;
}> => {
  try {
    // For HF models, if we don't have lfs details, fetch them
    if (model.origin === ModelOrigin.HF && !model.hfModelFile?.lfs?.size) {
      await modelStore.fetchAndUpdateModelFileDetails(model);
    }

    const filePath = await modelStore.getModelFullPath(model);
    const fileStats = await RNFS.stat(filePath);

    // If we have expected file size from HF, compare it
    if (model.hfModelFile?.lfs?.size) {
      const expectedSize = model.hfModelFile.lfs.size;
      const actualSize = fileStats.size;

      // Calculate size difference ratio
      const sizeDiffPercentage =
        Math.abs(actualSize - expectedSize) / expectedSize;

      // If size difference is more than 0.1% and hash doesn't match, consider it corrupted
      if (sizeDiffPercentage > 0.001) {
        modelStore.updateModelHash(model.id, false);

        // If hash matches, consider it valid
        if (model.hash && model.hfModelFile?.lfs?.oid) {
          if (model.hash === model.hfModelFile.lfs.oid) {
            return {
              isValid: true,
              errorMessage: null,
            };
          }
        }

        // If hash doesn't match and file size doesn't match, consider it corrupted
        return {
          isValid: false,
          errorMessage: `Model file size mismatch (${formatBytes(
            actualSize,
          )} vs ${formatBytes(expectedSize)}). Please delete and redownload.`,
        };
      }

      // File size matches within tolerance, consider it valid
      return {
        isValid: true,
        errorMessage: null,
      };
    }

    // If we reach here, either:
    // 1. We don't have size/hash info to verify against
    // 2. The file passed all available integrity checks
    return {
      isValid: true,
      errorMessage: null,
    };
  } catch (error) {
    console.error('Error checking file integrity:', error);
    return {
      isValid: false,
      errorMessage: 'Error checking file integrity. Please try again.',
    };
  }
};

export const safeParseJSON = (json: string) => {
  try {
    // First try parsing the string as-is
    try {
      return JSON.parse(json);
    } catch {
      // Clean up common issues
      let cleanJson = json.trim();

      // Find the first { and last } to extract the main JSON object
      const startIdx = cleanJson.indexOf('{');
      let endIdx = cleanJson.lastIndexOf('}');

      if (startIdx === -1) {
        throw new Error('No JSON object found');
      }

      // Check for prompt key with flexible spacing
      const hasPromptKey = /["']prompt["']\s*:/.test(cleanJson);

      // If no closing brace is found but we have the opening structure with prompt key
      if (endIdx === -1 && hasPromptKey) {
        // Add closing brace and quote if missing
        cleanJson = cleanJson + '"}';
        endIdx = cleanJson.length - 1;
      }

      // Extract what looks like the main JSON object
      cleanJson = cleanJson.substring(startIdx, endIdx + 1);

      return JSON.parse(cleanJson);
    }
  } catch (error) {
    console.log('Original json: ', json);
    console.error('Error parsing JSON:', error);
    return {prompt: '', error: error};
  }
};

/**
 * Configuration for model capabilities with their visual representation
 */
export const SKILL_CONFIG = {
  vision: {
    icon: 'eye',
    color: 'tertiary' as const,
    isSpecial: true, // Gets special visual treatment
    labelKey: 'vision' as const,
  },
  questionAnswering: {
    icon: 'help-circle-outline',
    color: 'primary' as const,
    isSpecial: false,
    labelKey: 'questionAnswering' as const,
  },
  summarization: {
    icon: 'text-short',
    color: 'primary' as const,
    isSpecial: false,
    labelKey: 'summarization' as const,
  },
  reasoning: {
    icon: 'brain',
    color: 'primary' as const,
    isSpecial: false,
    labelKey: 'reasoning' as const,
  },
  roleplay: {
    icon: 'account-voice',
    color: 'primary' as const,
    isSpecial: false,
    labelKey: 'roleplay' as const,
  },
  instructions: {
    icon: 'format-list-bulleted',
    color: 'primary' as const,
    isSpecial: false,
    labelKey: 'instructions' as const,
  },
  code: {
    icon: 'code-tags',
    color: 'primary' as const,
    isSpecial: false,
    labelKey: 'code' as const,
  },
  math: {
    icon: 'calculator',
    color: 'primary' as const,
    isSpecial: false,
    labelKey: 'math' as const,
  },
  multilingual: {
    icon: 'translate',
    color: 'primary' as const,
    isSpecial: false,
    labelKey: 'multilingual' as const,
  },
  rewriting: {
    icon: 'pencil',
    color: 'primary' as const,
    isSpecial: false,
    labelKey: 'rewriting' as const,
  },
  creativity: {
    icon: 'lightbulb-outline',
    color: 'primary' as const,
    isSpecial: false,
    labelKey: 'creativity' as const,
  },
} as const;

export type SkillKey = keyof typeof SKILL_CONFIG;

/**
 * Enhanced skill item with icon and styling information
 */
export interface SkillItem {
  key: string;
  labelKey: string;
  icon?: string;
  color?: 'primary' | 'tertiary';
  isSpecial?: boolean;
}

/**
 * Get unified skills list for a model, combining capabilities and multimodal support
 * @param model - The model object
 * @returns Array of skill items with icons and styling (localization done at render time)
 */
export const getModelSkills = (model: {
  capabilities?: string[];
  supportsMultimodal?: boolean;
}): SkillItem[] => {
  const skills: SkillItem[] = [];

  // Add vision skill first if model supports multimodal
  if (model.supportsMultimodal) {
    const visionConfig = SKILL_CONFIG.vision;
    skills.push({
      key: 'vision',
      labelKey: visionConfig.labelKey,
      icon: visionConfig.icon,
      color: visionConfig.color,
      isSpecial: visionConfig.isSpecial,
    });
  }

  // Add other capabilities (excluding vision to avoid duplication)
  if (model.capabilities?.length) {
    const otherCapabilities = model.capabilities.filter(
      cap => cap !== 'vision',
    );

    otherCapabilities.forEach(capability => {
      const config = SKILL_CONFIG[capability as SkillKey];

      if (config) {
        skills.push({
          key: capability,
          labelKey: config.labelKey,
          icon: config.icon,
          color: config.color,
          isSpecial: config.isSpecial,
        });
      }
    });
  }

  return skills;
};

/**
 * Extract quantization level from filename
 * @param filename The filename to extract quantization level from
 * @returns The quantization level string (e.g., 'q4_0', 'q5_k_m', etc.) or null if not found
 */
export function extractModelPrecision(filename: string): string | null {
  const lower = filename.toLowerCase();

  // Match and return full-precision types
  const fpMatch = lower.match(/\b(f16|bf16|f32)\b/);
  if (fpMatch) {
    return fpMatch[1];
  }

  // Match quantized types like iq4_k_m, q4_0_0, q5_k, etc., and normalize to just q4, q5, etc.
  const quantMatch = lower.match(/\b[iq]?(q[1-8])(?:[_\-a-z0-9]*)?\b/);
  if (quantMatch) {
    return quantMatch[1];
  }

  return null;
}

const QUANT_ORDER = [
  'q1',
  'q2',
  'q3',
  'q4',
  'q5',
  'q6',
  'q8',
  'bf16',
  'f16',
  'f32',
];

export function getQuantRank(level: string): number {
  const simplified = level.toLowerCase();
  return QUANT_ORDER.indexOf(simplified);
}

export * from './errors';
export * from './fb';
export * from './formatters';
export * from './multimodalHelpers';
export * from './network';
export * from './types';



================================================
FILE: src/utils/keepAwake.ts
================================================
import {NativeModules} from 'react-native';

const {KeepAwakeModule} = NativeModules;

if (!KeepAwakeModule) {
  console.warn(
    'KeepAwakeModule is not available. Make sure:\n' +
      '- You rebuilt the app after adding the native modules\n' +
      '- The native module is properly linked\n' +
      '- You are not using Expo managed workflow',
  );
}

/**
 * Activates keep awake functionality to prevent the screen from going to sleep
 * @throws {Error} If the native module fails to activate
 */
export const activateKeepAwake = (): void => {
  try {
    KeepAwakeModule.activate();
  } catch (error) {
    console.error('Failed to activate keep awake:', error);
    throw error;
  }
};

/**
 * Deactivates keep awake functionality allowing the screen to go to sleep
 * @throws {Error} If the native module fails to deactivate
 */
export const deactivateKeepAwake = (): void => {
  try {
    KeepAwakeModule.deactivate();
  } catch (error) {
    console.error('Failed to deactivate keep awake:', error);
    throw error;
  }
};



================================================
FILE: src/utils/memorySettings.ts
================================================
import {Platform} from 'react-native';
import {loadLlamaModelInfo} from '@pocketpalai/llama.rn';

/**
 * Quantization types that are repackable and should use use_mmap=false
 */
const REPACKABLE_QUANTS = ['Q4_0', 'IQ4_NL'];

/**
 * LlamaFileType enum values for repackable quantizations
 * Based on the LlamaFileType enum from llama.cpp
 */
const REPACKABLE_FILE_TYPES = {
  MOSTLY_Q4_0: 2, // Q4_0 quantization
  MOSTLY_IQ4_NL: 25, // IQ4_NL quantization
};

/**
 * Detects if a model uses repackable quantization types (Q4_0 or IQ4_NL)
 */
export async function isRepackableQuantization(
  modelPath: string,
): Promise<boolean> {
  try {
    const modelInfo = await loadLlamaModelInfo(modelPath);

    // Check if model info is valid and contains file_type
    if (
      !modelInfo ||
      typeof modelInfo !== 'object' ||
      !('general.file_type' in modelInfo)
    ) {
      return false;
    }

    const fileType = (modelInfo as any)['general.file_type'];

    // Ensure fileType exists
    if (fileType === undefined || fileType === null) {
      return false;
    }

    if (typeof fileType === 'string') {
      const numericValue = parseInt(fileType, 10);
      if (!isNaN(numericValue)) {
        const isRepackable = Object.values(REPACKABLE_FILE_TYPES).includes(
          numericValue,
        );
        if (isRepackable) {
          console.log(
            'Detected repackable quantization:',
            fileType,
            '(enum value:',
            numericValue,
            ')',
          );
        }
        return isRepackable;
      }

      const isRepackable = REPACKABLE_QUANTS.some(quant =>
        fileType.toUpperCase().includes(quant.toUpperCase()),
      );
      if (isRepackable) {
        console.log('Detected repackable quantization from string:', fileType);
      }
      return isRepackable;
    }

    // Handle numeric fileType (just in case)
    if (typeof fileType === 'number') {
      const isRepackable = Object.values(REPACKABLE_FILE_TYPES).includes(
        fileType,
      );
      if (isRepackable) {
        console.log('Detected repackable quantization from number:', fileType);
      }
      return isRepackable;
    }

    return false;
  } catch (error) {
    console.warn(
      'Failed to detect quantization type, defaulting to false:',
      error,
    );
    return false;
  }
}

/**
 * Resolves the effective use_mmap value based on the setting and model characteristics
 *
 * @param setting - The user's mmap setting ('true', 'false', or 'smart')
 * @param modelPath - Path to the model file (used for smart detection)
 * @returns Promise<boolean> - The resolved use_mmap value
 */
export async function resolveUseMmap(
  setting: 'true' | 'false' | 'smart',
  modelPath: string,
): Promise<boolean> {
  switch (setting) {
    case 'true':
      return true;
    case 'false':
      return false;
    case 'smart':
      // Smart mode: only available on Android
      if (Platform.OS !== 'android') {
        return true; // Default to true on non-Android platforms
      }

      if (!modelPath) {
        console.log('No model path provided, defaulting to use_mmap=true');
        return true; // Default to true if no model path provided
      }

      // For Android: use mmap=false for repackable quants, true otherwise
      const isRepackable = await isRepackableQuantization(modelPath);
      return !isRepackable;
    default:
      return true;
  }
}



================================================
FILE: src/utils/modelSettings.ts
================================================
import {CompletionParams} from './completionTypes';
import {defaultCompletionParams} from './completionSettingsVersions';

export const LEGACY_QUANTIZATION_WARNINGS = [
  'Q4_0_4_8',
  'Q4_0_4_4',
  'Q4_0_8_8',
];

export const isLegacyQuantization = (filename: string): boolean => {
  return LEGACY_QUANTIZATION_WARNINGS.some(q =>
    filename.toLowerCase().includes(q.toLowerCase()),
  );
};

export type ValidationRule =
  | {type: 'numeric'; min: number; max: number; required?: boolean}
  | {type: 'array'; required?: boolean}
  | {type: 'boolean'; required?: boolean};

export interface CompletionParamMetadata {
  validation: ValidationRule;
  defaultValue: number | boolean | string[] | null | undefined;
}

export const COMPLETION_PARAMS_METADATA: Partial<
  Record<keyof CompletionParams, CompletionParamMetadata>
> = {
  n_threads: {
    // TODO: get number of cores from device
    validation: {type: 'numeric', min: 1, max: 16, required: true},
    defaultValue: defaultCompletionParams.n_threads,
  },
  n_predict: {
    validation: {type: 'numeric', min: 1, max: 4096, required: true},
    defaultValue: defaultCompletionParams.n_predict,
  },
  temperature: {
    validation: {type: 'numeric', min: 0, max: 2, required: true},
    defaultValue: defaultCompletionParams.temperature,
  },
  top_k: {
    validation: {type: 'numeric', min: 1, max: 128, required: true},
    defaultValue: defaultCompletionParams.top_k,
  },
  top_p: {
    validation: {type: 'numeric', min: 0, max: 1, required: true},
    defaultValue: defaultCompletionParams.top_p,
  },
  min_p: {
    validation: {type: 'numeric', min: 0, max: 1, required: true},
    defaultValue: defaultCompletionParams.min_p,
  },
  xtc_threshold: {
    validation: {type: 'numeric', min: 0, max: 1, required: true},
    defaultValue: defaultCompletionParams.xtc_threshold,
  },
  xtc_probability: {
    validation: {type: 'numeric', min: 0, max: 1, required: true},
    defaultValue: defaultCompletionParams.xtc_probability,
  },
  typical_p: {
    validation: {type: 'numeric', min: 0, max: 2, required: true},
    defaultValue: defaultCompletionParams.typical_p,
  },
  penalty_last_n: {
    validation: {type: 'numeric', min: 0, max: 256, required: true},
    defaultValue: defaultCompletionParams.penalty_last_n,
  },
  penalty_repeat: {
    validation: {type: 'numeric', min: 0, max: 2, required: true},
    defaultValue: defaultCompletionParams.penalty_repeat,
  },
  penalty_freq: {
    validation: {type: 'numeric', min: 0, max: 2, required: true},
    defaultValue: defaultCompletionParams.penalty_freq,
  },
  penalty_present: {
    validation: {type: 'numeric', min: 0, max: 2, required: true},
    defaultValue: defaultCompletionParams.penalty_present,
  },
  mirostat: {
    validation: {type: 'numeric', min: 0, max: 2, required: true},
    defaultValue: defaultCompletionParams.mirostat,
  },
  mirostat_tau: {
    validation: {type: 'numeric', min: 0, max: 10, required: true},
    defaultValue: defaultCompletionParams.mirostat_tau,
  },
  mirostat_eta: {
    validation: {type: 'numeric', min: 0, max: 1, required: true},
    defaultValue: defaultCompletionParams.mirostat_eta,
  },
  seed: {
    validation: {
      type: 'numeric',
      min: -1,
      max: Number.MAX_SAFE_INTEGER,
      required: true,
    },
    defaultValue: defaultCompletionParams.seed,
  },
  n_probs: {
    validation: {type: 'numeric', min: 0, max: 100, required: true},
    defaultValue: defaultCompletionParams.n_probs,
  },
  stop: {
    validation: {type: 'array', required: false},
    defaultValue: defaultCompletionParams.stop,
  },
  include_thinking_in_context: {
    validation: {type: 'boolean', required: false},
    defaultValue: defaultCompletionParams.include_thinking_in_context,
  },
  jinja: {
    validation: {type: 'boolean', required: false},
    defaultValue: defaultCompletionParams.jinja,
  },
};

// Validation helpers
export const validateNumericField = (
  value: string | number,
  rule: ValidationRule,
): {isValid: boolean; errorMessage?: string} => {
  if (rule.type !== 'numeric') {
    return {isValid: true};
  }

  const numValue = typeof value === 'string' ? parseInt(value, 10) : value;

  if (
    rule.required &&
    (value === undefined || value === null || value === '')
  ) {
    return {
      isValid: false,
      errorMessage: 'This field is required',
    };
  }

  if (isNaN(numValue)) {
    return {
      isValid: !rule.required,
      errorMessage: rule.required ? 'Please enter a valid number' : undefined,
    };
  }

  if (typeof value === 'string' && !/^-?\d*\.?\d*$/.test(value)) {
    return {isValid: false, errorMessage: 'Please enter a valid number'};
  }

  const isValid = numValue >= rule.min && numValue <= rule.max;
  return {
    isValid,
    errorMessage: isValid
      ? undefined
      : `Value must be between ${rule.min} and ${rule.max}`,
  };
};

export const validateCompletionSettings = (
  settings: Partial<CompletionParams>,
): {
  isValid: boolean;
  errors: Record<string, string>;
} => {
  const errors: Record<string, string> = {};

  Object.entries(COMPLETION_PARAMS_METADATA).forEach(([key, metadata]) => {
    if (
      key in settings &&
      metadata &&
      !validateNumericField(settings[key], metadata.validation)
    ) {
      const rule = metadata.validation;
      if (rule.type === 'numeric') {
        errors[key] = `Value must be between ${rule.min} and ${rule.max}`;
      }
    }
  });

  return {
    isValid: Object.keys(errors).length === 0,
    errors,
  };
};



================================================
FILE: src/utils/multimodalHelpers.ts
================================================
/**
 * Helper functions for multimodal support
 */

import {extractModelPrecision, getQuantRank} from '.';
import {HuggingFaceModel, ModelFile} from './types';

const MMProjRegex = /[-_.]*mmproj[-_.].+\.gguf$/i;

/**
 * Checks if a repository contains vision models based on the presence of mmproj files
 * @param siblings Array of model files in the repository
 * @returns boolean indicating if the repository contains vision models
 */
export function isVisionRepo(siblings: ModelFile[]): boolean {
  return siblings.some(f => MMProjRegex.test(f.rfilename));
}

/**
 * Gets the mmproj files from a repository
 * @param siblings Array of model files in the repository
 * @returns Array of mmproj filenames
 */
export function getMmprojFiles(siblings: ModelFile[]): ModelFile[] {
  return siblings.filter(f => MMProjRegex.test(f.rfilename));
}

/**
 * Gets the LLM files (non-mmproj files) from a repository
 * @param siblings Array of model files in the repository
 * @returns Array of LLM model files
 */
export function getLLMFiles(siblings: ModelFile[]): ModelFile[] {
  return siblings.filter(f => !MMProjRegex.test(f.rfilename));
}

/**
 * Checks if a model file is a projection model
 * @param filename Model filename
 * @returns boolean indicating if the model is a projection model
 */
export function isProjectionModel(filename: string): boolean {
  return MMProjRegex.test(filename);
}

/**
 * Gets the recommended projection model for a vision model
 * @param visionModelFilename Vision model filename
 * @param availableProjModels Array of available projection model filenames
 * @returns The recommended projection model filename or undefined if none found
 */
export function getRecommendedProjectionModel(
  visionModelFilename: string,
  availableProjModels: string[],
): string | undefined {
  if (availableProjModels.length === 0) {
    return undefined;
  }
  if (availableProjModels.length === 1) {
    return availableProjModels[0];
  }

  // Helper function to get the highest quality projection model
  const getHighestQualityModel = (): string => {
    return [...availableProjModels].sort((a, b) => {
      const rankA = getQuantRank(extractModelPrecision(a) || '');
      const rankB = getQuantRank(extractModelPrecision(b) || '');
      return rankB - rankA; // Sort in descending order (highest quality first)
    })[0];
  };

  const llmQuant = extractModelPrecision(visionModelFilename);
  if (!llmQuant) {
    // If no quantization detected, return the highest quality projection model
    return getHighestQualityModel();
  }

  const llmRank = getQuantRank(llmQuant);
  if (llmRank === -1) {
    // If quantization not recognized, return the highest quality projection model
    return getHighestQualityModel();
  }

  // First: exact match
  const exactMatch = availableProjModels.find(
    p => extractModelPrecision(p)?.toLowerCase() === llmQuant.toLowerCase(),
  );
  if (exactMatch) {
    return exactMatch;
  }

  // Second: find closest higher or equal quality match
  const sortedByProximity = [...availableProjModels].sort((a, b) => {
    const rankA = getQuantRank(extractModelPrecision(a) || '');
    const rankB = getQuantRank(extractModelPrecision(b) || '');
    const diffA =
      rankA - llmRank >= 0 ? rankA - llmRank : Number.MAX_SAFE_INTEGER;
    const diffB =
      rankB - llmRank >= 0 ? rankB - llmRank : Number.MAX_SAFE_INTEGER;
    return diffA - diffB;
  });

  const closestMatch = sortedByProximity.find(
    p => getQuantRank(extractModelPrecision(p) || '') >= llmRank,
  );

  // If no higher quality match found, return the highest quality available
  return closestMatch ?? getHighestQualityModel();
}

/**
 * Filters out projection models from a list of models for display purposes
 * @param models Array of models to filter
 * @returns Array of models with projection models removed
 */
export function filterProjectionModels<T extends {modelType?: string}>(
  models: T[],
): T[] {
  return models.filter(model => model.modelType !== 'projection');
}

/**
 * Gets size breakdown for a vision model using HF siblings data
 * This is used in HF search context where projection models aren't in modelStore yet
 * @param modelFile The LLM model file
 * @param hfModel The HF model containing siblings
 * @returns Object with llmSize, projectionSize, and totalSize
 */
export function getVisionModelSizeBreakdown(
  modelFile: ModelFile,
  hfModel: HuggingFaceModel,
): {
  llmSize: number;
  projectionSize: number;
  totalSize: number;
  hasProjection: boolean;
} {
  const llmSize = modelFile.size || 0;
  let projectionSize = 0;
  let hasProjection = false;

  // Find the default projection model from siblings
  const mmprojFiles = getMmprojFiles(hfModel.siblings || []);
  if (mmprojFiles.length > 0) {
    // Get the recommended projection model
    const recommendedProj = getRecommendedProjectionModel(
      modelFile.rfilename,
      mmprojFiles.map(f => f.rfilename),
    );

    if (recommendedProj) {
      const projFile = mmprojFiles.find(f => f.rfilename === recommendedProj);
      if (projFile && projFile.size) {
        projectionSize = projFile.size;
        hasProjection = true;
      }
    }
  }

  return {
    llmSize,
    projectionSize,
    totalSize: llmSize + projectionSize,
    hasProjection,
  };
}



================================================
FILE: src/utils/navigationConstants.ts
================================================
// Navigation route names
export const ROUTES = {
  // Main app routes
  CHAT: 'Chat',
  MODELS: 'Models',
  PALS: 'Pals (experimental)',
  BENCHMARK: 'Benchmark',
  SETTINGS: 'Settings',
  APP_INFO: 'App Info',

  // Dev tools route. Only available in debug mode.
  DEV_TOOLS: 'Dev Tools',
};



================================================
FILE: src/utils/network.ts
================================================
import axios from 'axios';

/**
 * Checks if the device has internet connectivity
 * @param timeoutMs Timeout in milliseconds (default: 5000)
 * @returns Promise resolving to boolean indicating connectivity status
 */
export const checkConnectivity = async (timeoutMs = 5000): Promise<boolean> => {
  try {
    // Try to fetch a small amount of data from a reliable endpoint
    await axios.head('https://www.google.com', {timeout: timeoutMs});
    return true;
  } catch (error) {
    return false;
  }
};



================================================
FILE: src/utils/theme.ts
================================================
import {
  MD3DarkTheme,
  DefaultTheme as PaperLightTheme,
  configureFonts,
} from 'react-native-paper';

import {MD3BaseColors, SemanticColors, Theme} from './types';
import {withOpacity, stateLayerOpacity} from './colorUtils';

// MD3 key colors (seed colors)
const md3BaseColors: Partial<MD3BaseColors> = {
  primary: '#333333',
  secondary: '#1E4DF6',
  tertiary: '#7880FF',
  error: '#FF653F',
};

const createBaseColors = (isDark: boolean): MD3BaseColors => {
  const baseTheme = isDark ? MD3DarkTheme : PaperLightTheme;

  if (isDark) {
    return {
      ...baseTheme.colors,
      primary: '#DADDE6',
      onPrimary: '#44464C',
      primaryContainer: '#5B5E66',
      onPrimaryContainer: '#DEE0E6',
      secondary: '#95ABE6',
      onSecondary: '#11214C',
      secondaryContainer: '#424242',
      onSecondaryContainer: '#E0E0E0',
      tertiary: '#80E6E4',
      onTertiary: '#014C4C',
      tertiaryContainer: '#016665',
      onTertiaryContainer: '#9EE6E5',
      error: md3BaseColors.error!,
      onError: '#4C100D',
      errorContainer: '#661511',
      onErrorContainer: '#E6ACA9',
      background: '#000000',
      onBackground: '#ffffff',
      surface: '#1E1E1E',
      onSurface: '#E2E2E2',
      surfaceVariant: '#646466',
      onSurfaceVariant: '#e3e4e6',
      outline: '#444444',
      outlineVariant: '#a1a1a1',
      // Additional required MD3 colors
      surfaceDisabled: withOpacity('#333333', 0.12),
      onSurfaceDisabled: withOpacity('#e5e5e6', 0.38),
      inverseSurface: '#e5e5e6',
      inverseOnSurface: '#333333',
      inversePrimary: '#5B5E66',
      inverseSecondary: md3BaseColors.secondary!,
      shadow: '#ffffff',
      scrim: 'rgba(0, 0, 0, 0.25)',
      backdrop: 'rgba(38, 37, 37, 0.8)',
    };
  }

  return {
    ...baseTheme.colors,
    primary: md3BaseColors.primary!,
    onPrimary: '#FFFFFF',
    primaryContainer: '#DEE0E6',
    onPrimaryContainer: '#2D2F33',
    secondary: md3BaseColors.secondary!,
    onSecondary: '#FFFFFF',
    secondaryContainer: '#E0E0E0',
    onSecondaryContainer: '#424242',
    tertiary: md3BaseColors.tertiary!,
    onTertiary: '#FFFFFF',
    tertiaryContainer: '#F1F3FF',
    onTertiaryContainer: '#013332',
    error: md3BaseColors.error!,
    onError: '#FFFFFF',
    errorContainer: '#E6ACA9',
    onErrorContainer: '#330B09',
    background: '#ffffff',
    onBackground: '#111111',
    surface: '#F9FAFB',
    onSurface: '#333333',
    surfaceVariant: '#e4e4e6',
    onSurfaceVariant: '#646466',
    outline: withOpacity(md3BaseColors.primary!, 0.05),
    outlineVariant: '#a1a1a1',
    // Additional required MD3 colors
    surfaceDisabled: withOpacity('#fcfcfc', 0.12),
    onSurfaceDisabled: withOpacity('#333333', 0.38),
    inverseSurface: '#858585',
    inverseOnSurface: '#fcfcfc',
    inversePrimary: '#DEE0E6',
    inverseSecondary: '#95ABE6',
    shadow: '#000000',
    scrim: 'rgba(0, 0, 0, 0.25)',
    backdrop: 'rgba(51, 51, 51, 0.6)',
  };
};

const createSemanticColors = (
  baseColors: MD3BaseColors,
  isDark: boolean,
): SemanticColors => ({
  // Surface variants
  surfaceContainerHighest: isDark
    ? withOpacity(baseColors.surface, 0.22)
    : withOpacity(baseColors.primary, 0.05),
  surfaceContainerHigh: isDark
    ? withOpacity(baseColors.surface, 0.16)
    : withOpacity(baseColors.primary, 0.03),
  surfaceContainer: isDark
    ? withOpacity(baseColors.surface, 0.12)
    : withOpacity(baseColors.primary, 0.02),
  surfaceContainerLow: isDark
    ? withOpacity(baseColors.surface, 0.08)
    : withOpacity(baseColors.primary, 0.01),
  surfaceContainerLowest: isDark
    ? withOpacity(baseColors.surface, 0.04)
    : baseColors.surface,
  surfaceDim: isDark
    ? withOpacity(baseColors.surface, 0.06)
    : withOpacity(baseColors.primary, 0.06),
  surfaceBright: isDark
    ? withOpacity(baseColors.surface, 0.24)
    : baseColors.surface,

  border: withOpacity(baseColors.onSurface, 0.05),
  placeholder: withOpacity(baseColors.onSurface, 0.3),
  text: baseColors.onBackground,
  textSecondary: withOpacity(baseColors.onSurface, 0.5),
  inverseText: baseColors.inverseOnSurface,
  inverseTextSecondary: withOpacity(baseColors.inverseOnSurface, 0.5),

  // Interactive states
  stateLayerOpacity: 0.12,
  hoverStateOpacity: stateLayerOpacity.hover,
  pressedStateOpacity: stateLayerOpacity.pressed,
  draggedStateOpacity: stateLayerOpacity.dragged,
  focusStateOpacity: stateLayerOpacity.focus,

  // Menu specific
  menuBackground: isDark ? '#2a2a2a' : baseColors.surface,
  menuBackgroundDimmed: withOpacity(baseColors.surface, 0.9),
  menuBackgroundActive: withOpacity(baseColors.primary, 0.08),
  menuSeparator: withOpacity(baseColors.primary, 0.5),
  menuGroupSeparator: isDark
    ? withOpacity('#FFFFFF', 0.08)
    : withOpacity('#000000', 0.08),
  menuText: baseColors.onSurface,
  menuDangerText: baseColors.error,

  // Message specific
  authorBubbleBackground: isDark ? '#212121' : '#f2f2f2',
  receivedMessageDocumentIcon: baseColors.primary,
  sentMessageDocumentIcon: baseColors.onSurface,
  userAvatarImageBackground: 'transparent',
  userAvatarNameColors: [
    baseColors.primary,
    baseColors.secondary,
    baseColors.tertiary,
    baseColors.error,
  ],
  searchBarBackground: isDark
    ? 'rgba(28, 28, 30, 0.92)'
    : 'rgba(118, 118, 128, 0.12)',

  // Thinking bubble specific
  thinkingBubbleBackground: isDark ? '#142e4d' : '#f0f5fa',
  thinkingBubbleText: isDark ? '#6abaff' : '#0a5999',
  thinkingBubbleBorder: isDark
    ? 'rgba(74, 140, 199, 0.6)'
    : 'rgba(10, 89, 153, 0.4)',
  thinkingBubbleShadow: isDark ? '#4a9fff' : '#0a5999',
  thinkingBubbleChevronBackground: isDark
    ? 'rgba(74, 140, 199, 0.15)'
    : 'rgba(10, 89, 153, 0.1)',
  thinkingBubbleChevronBorder: isDark
    ? 'rgba(74, 140, 199, 0.3)'
    : 'rgba(10, 89, 153, 0.2)',
});

export const fontStyles = {
  regular: {fontFamily: 'Inter-Regular'},
  medium: {fontFamily: 'Inter-Medium'},
  bold: {fontFamily: 'Inter-Bold'},
  thin: {fontFamily: 'Inter-Thin'},
  light: {fontFamily: 'Inter-Light'},
  semibold: {fontFamily: 'Inter-SemiBold'},
  extraBold: {fontFamily: 'Inter-ExtraBold'},
};

const baseFontVariants = configureFonts({
  config: {...fontStyles.regular},
});

const customVariants = {
  // Add custom variants:
  bold: {
    ...baseFontVariants.bodyMedium,
    ...fontStyles.bold,
  },
  medium: {
    ...baseFontVariants.bodyMedium,
    ...fontStyles.medium,
  },
  thin: {
    ...baseFontVariants.bodyMedium,
    ...fontStyles.thin,
  },
  light: {
    ...baseFontVariants.bodyMedium,
    ...fontStyles.light,
  },
  semibold: {
    ...baseFontVariants.bodyMedium,
    ...fontStyles.semibold,
  },
} as const;

const configuredFonts = configureFonts({
  config: {
    ...baseFontVariants,
    ...customVariants,
    displayMedium: {
      ...baseFontVariants.displayMedium,
      ...fontStyles.bold,
    },
    titleSmall: {
      ...baseFontVariants.titleSmall,
      ...fontStyles.medium,
    },
  },
});

const createTheme = (isDark: boolean): Theme => {
  const baseTheme = isDark ? MD3DarkTheme : PaperLightTheme;
  const baseColors = createBaseColors(isDark);
  const semanticColors = createSemanticColors(baseColors, isDark);

  return {
    ...baseTheme,
    colors: {
      ...baseColors,
      ...semanticColors,
    },
    borders: {
      inputBorderRadius: 16,
      messageBorderRadius: 15,
      default: 12,
    },
    fonts: {
      ...baseTheme.fonts,
      ...configuredFonts,
      titleMediumLight: {
        ...fontStyles.regular,
        fontSize: 16,
        lineHeight: 22,
      },
      dateDividerTextStyle: {
        ...fontStyles.extraBold,
        color: baseColors.onSurface,
        fontSize: 12,
        lineHeight: 16,
        opacity: 0.4,
      },
      emptyChatPlaceholderTextStyle: {
        color: baseColors.onSurface,
        fontSize: 16,
        lineHeight: 24,
        ...fontStyles.medium,
      },
      inputTextStyle: {
        fontSize: 16,
        lineHeight: 24,
        ...fontStyles.medium,
      },
      receivedMessageBodyTextStyle: {
        color: baseColors.onPrimary,
        fontSize: 16,
        lineHeight: 24,
        ...fontStyles.medium,
      },
      receivedMessageCaptionTextStyle: {
        color: baseColors.onSurfaceVariant,
        fontSize: 12,
        lineHeight: 16,
        ...fontStyles.medium,
      },
      receivedMessageLinkDescriptionTextStyle: {
        color: baseColors.onPrimary,
        fontSize: 14,
        lineHeight: 20,
        ...fontStyles.regular,
      },
      receivedMessageLinkTitleTextStyle: {
        color: baseColors.onPrimary,
        fontSize: 16,
        lineHeight: 22,
        ...fontStyles.extraBold,
      },
      sentMessageBodyTextStyle: {
        color: baseColors.onSurface,
        fontSize: 16,
        lineHeight: 24,
        ...fontStyles.medium,
      },
      sentMessageCaptionTextStyle: {
        color: baseColors.onSurfaceVariant,
        fontSize: 12,
        lineHeight: 16,
        ...fontStyles.medium,
      },
      sentMessageLinkDescriptionTextStyle: {
        color: baseColors.onSurface,
        fontSize: 14,
        lineHeight: 20,
        ...fontStyles.regular,
      },
      sentMessageLinkTitleTextStyle: {
        color: baseColors.onSurface,
        fontSize: 16,
        lineHeight: 22,
        ...fontStyles.extraBold,
      },
      userAvatarTextStyle: {
        color: baseColors.onSurface,
        fontSize: 12,
        lineHeight: 16,
        ...fontStyles.extraBold,
      },
      userNameTextStyle: {
        fontSize: 12,
        lineHeight: 16,
        ...fontStyles.extraBold,
      },
    },
    insets: {
      messageInsetsHorizontal: 20,
      messageInsetsVertical: 10,
    },
    spacing: {
      default: 16,
    },
    icons: {},
  };
};

export const lightTheme = createTheme(false);
export const darkTheme = createTheme(true);



================================================
FILE: src/utils/thinkingCapabilityDetection.ts
================================================
/**
 * Utility functions for detecting thinking capabilities in models
 */

import {LlamaContext} from '@pocketpalai/llama.rn';
import {Model} from './types';

// List of known thinking-capable model architectures
const KNOWN_THINKING_CAPABLE_ARCHITECTURES = ['qwen3', 'smollm3'];

// Thinking-related tokens to check in chat templates
const THINKING_TOKENS = [
  '<think>',
  '</think>',
  'assistant_thoughts',
  'reasoning_format',
  '<|start_thinking|>',
  '<|end_thinking|>',
  '<|thinking|>',
  'start_thinking',
  'end_thinking',
];

/**
 * Checks if a model supports thinking capabilities
 *
 * @param model The model to check
 * @param ctx Optional LlamaContext if already loaded
 * @returns Promise<boolean> True if the model supports thinking
 */
export async function supportsThinking(
  model: Model,
  ctx?: LlamaContext,
): Promise<boolean> {
  // First check: Architecture-based detection using model metadata
  let modelArchitecture: string | undefined;

  if (ctx?.model?.metadata) {
    // Get architecture from loaded model metadata
    modelArchitecture = ctx.model.metadata['general.architecture'];
  } else if (model.hfModel?.specs?.gguf?.architecture) {
    // Get architecture from HF model specs
    modelArchitecture = model.hfModel.specs.gguf.architecture;
  }

  if (modelArchitecture) {
    const archLower = modelArchitecture.toLowerCase();
    for (const architecture of KNOWN_THINKING_CAPABLE_ARCHITECTURES) {
      if (archLower.includes(architecture)) {
        return true;
      }
    }
  }

  // Third check: Chat template analysis
  if (model.chatTemplate?.chatTemplate) {
    if (templateSupportsThinking(model.chatTemplate.chatTemplate)) {
      return true;
    }
  }

  // Fourth check: Context-based analysis (if context is available)
  if (ctx) {
    try {
      // Check model metadata for chat template
      const modelMetadata = (ctx.model as any)?.metadata;
      if (modelMetadata) {
        const chatTemplate = modelMetadata['tokenizer.chat_template'];
        if (chatTemplate && templateSupportsThinking(chatTemplate)) {
          return true;
        }
      }

      // Check model description for thinking-related terms
      const modelDetails = await ctx.bench(1, 1, 1, 1);
      const modelDesc = modelDetails.modelDesc.toLowerCase();
      for (const token of THINKING_TOKENS) {
        if (modelDesc.includes(token.toLowerCase())) {
          return true;
        }
      }
    } catch (error) {
      console.error('Error checking thinking capabilities:', error);
    }
  }

  // Default to false if no thinking capabilities detected
  return false;
}

/**
 * Checks if a model's chat template contains thinking-related tokens
 *
 * @param template The chat template string
 * @returns boolean True if the template contains thinking tokens
 */
export function templateSupportsThinking(template: string): boolean {
  if (!template) {
    return false;
  }

  const templateLower = template.toLowerCase();

  // Check for thinking-related tokens
  for (const token of THINKING_TOKENS) {
    if (templateLower.includes(token.toLowerCase())) {
      return true;
    }
  }

  // Check for specific template patterns that indicate thinking support
  // DeepSeek-R1 pattern
  if (
    templateLower.includes('deepseek') &&
    (templateLower.includes('<think>') || templateLower.includes('thinking'))
  ) {
    return true;
  }

  // Cohere Command-R pattern
  if (
    templateLower.includes('cohere') &&
    (templateLower.includes('thinking') || templateLower.includes('reasoning'))
  ) {
    return true;
  }

  // Qwen-3 pattern
  if (templateLower.includes('qwen') && templateLower.includes('thinking')) {
    return true;
  }

  return false;
}



================================================
FILE: src/utils/types.ts
================================================
import * as React from 'react';
import {ImageURISource, TextStyle} from 'react-native';

import {MD3Theme} from 'react-native-paper';
import {TemplateConfig} from 'chat-formatter';
import {TokenData} from '@pocketpalai/llama.rn';
import {CompletionParams} from './completionTypes';
import {PreviewData} from '@flyerhq/react-native-link-preview';
import {MD3Colors, MD3Typescale} from 'react-native-paper/lib/typescript/types';
import {SkillKey} from '.';

export namespace MessageType {
  export type Any = Custom | File | Image | Text | Unsupported;

  export type DerivedMessage =
    | DerivedCustom
    | DerivedFile
    | DerivedImage
    | DerivedText
    | DerivedUnsupported;
  export type DerivedAny = DateHeader | DerivedMessage;

  export type PartialAny =
    | PartialCustom
    | PartialFile
    | PartialImage
    | PartialText;

  interface Base {
    author: User;
    createdAt?: number;
    id: string;
    metadata?: Record<string, any>;
    roomId?: string;
    status?: 'delivered' | 'error' | 'seen' | 'sending' | 'sent';
    type: 'custom' | 'file' | 'image' | 'text' | 'unsupported';
    updatedAt?: number;
  }

  export interface DerivedMessageProps extends Base {
    nextMessageInGroup: boolean;
    // TODO: Check name?
    offset: number;
    showName: boolean;
    showStatus: boolean;
  }

  export interface DerivedCustom extends DerivedMessageProps, Custom {
    type: Custom['type'];
  }

  export interface DerivedFile extends DerivedMessageProps, File {
    type: File['type'];
  }

  export interface DerivedImage extends DerivedMessageProps, Image {
    type: Image['type'];
  }

  export interface DerivedText extends DerivedMessageProps, Text {
    type: Text['type'];
  }

  export interface DerivedUnsupported extends DerivedMessageProps, Unsupported {
    type: Unsupported['type'];
  }

  export interface PartialCustom extends Base {
    metadata?: Record<string, any>;
    type: 'custom';
  }

  export interface Custom extends Base, PartialCustom {
    type: 'custom';
  }

  export interface PartialFile {
    metadata?: Record<string, any>;
    mimeType?: string;
    name: string;
    size: number;
    type: 'file';
    uri: string;
  }

  export interface File extends Base, PartialFile {
    type: 'file';
  }

  export interface PartialImage {
    height?: number;
    metadata?: Record<string, any>;
    name: string;
    size: number;
    type: 'image';
    uri: string;
    width?: number;
  }

  export interface Image extends Base, PartialImage {
    type: 'image';
  }

  export interface PartialText {
    metadata?: Record<string, any>;
    previewData?: PreviewData;
    text: string;
    type: 'text';
    imageUris?: string[]; // Optional array of image URIs for multimodal messages
  }

  export interface Text extends Base, PartialText {
    type: 'text';
  }

  export interface Unsupported extends Base {
    type: 'unsupported';
  }

  export interface DateHeader {
    id: string;
    text: string;
    type: 'dateHeader';
  }
}

export interface PreviewImage {
  id: string;
  uri: ImageURISource['uri'];
}

export interface Size {
  height: number;
  width: number;
}

export interface MD3BaseColors extends MD3Colors {
  primary: string;
  onPrimary: string;
  primaryContainer: string;
  onPrimaryContainer: string;
  secondary: string;
  onSecondary: string;
  secondaryContainer: string;
  onSecondaryContainer: string;
  tertiary: string;
  onTertiary: string;
  tertiaryContainer: string;
  onTertiaryContainer: string;
  error: string;
  onError: string;
  errorContainer: string;
  onErrorContainer: string;
  background: string;
  onBackground: string;
  surface: string;
  onSurface: string;
  surfaceVariant: string;
  onSurfaceVariant: string;
  outline: string;
  outlineVariant: string;

  // Additional MD3 required colors
  surfaceDisabled: string;
  onSurfaceDisabled: string;
  inverseSurface: string;
  inverseOnSurface: string;
  inversePrimary: string;
  inverseSecondary: string;
  shadow: string;
  scrim: string;
}

export interface ThemeIcons {
  attachmentButtonIcon?: () => React.ReactNode;
  deliveredIcon?: () => React.ReactNode;
  documentIcon?: () => React.ReactNode;
  errorIcon?: () => React.ReactNode;
  seenIcon?: () => React.ReactNode;
  sendButtonIcon?: () => React.ReactNode;
  sendingIcon?: () => React.ReactNode;
}

export interface SemanticColors {
  // Surface variants
  surfaceContainerHighest: string;
  surfaceContainerHigh: string;
  surfaceContainer: string;
  surfaceContainerLow: string;
  surfaceContainerLowest: string;
  surfaceDim: string;
  surfaceBright: string;

  text: string;
  textSecondary: string;
  inverseText: string;
  inverseTextSecondary: string;

  border: string;
  placeholder: string;

  // Interactive states
  stateLayerOpacity: number;
  hoverStateOpacity: number;
  pressedStateOpacity: number;
  draggedStateOpacity: number;
  focusStateOpacity: number;

  // Menu specific
  menuBackground: string;
  menuBackgroundDimmed: string;
  menuBackgroundActive: string;
  menuSeparator: string;
  menuGroupSeparator: string;
  menuText: string;
  menuDangerText: string;

  // Message specific
  authorBubbleBackground: string;
  receivedMessageDocumentIcon: string;
  sentMessageDocumentIcon: string;
  userAvatarImageBackground: string;
  userAvatarNameColors: string[];
  searchBarBackground: string;

  // Thinking bubble specific
  thinkingBubbleBackground: string;
  thinkingBubbleText: string;
  thinkingBubbleBorder: string;
  thinkingBubbleShadow: string;
  thinkingBubbleChevronBackground: string;
  thinkingBubbleChevronBorder: string;
}

export interface ThemeBorders {
  inputBorderRadius: number;
  messageBorderRadius: number;
  default: number;
}

export interface ThemeFonts extends MD3Typescale {
  titleMediumLight: TextStyle;
  dateDividerTextStyle: TextStyle;
  emptyChatPlaceholderTextStyle: TextStyle;
  inputTextStyle: TextStyle;
  receivedMessageBodyTextStyle: TextStyle;
  receivedMessageCaptionTextStyle: TextStyle;
  receivedMessageLinkDescriptionTextStyle: TextStyle;
  receivedMessageLinkTitleTextStyle: TextStyle;
  sentMessageBodyTextStyle: TextStyle;
  sentMessageCaptionTextStyle: TextStyle;
  sentMessageLinkDescriptionTextStyle: TextStyle;
  sentMessageLinkTitleTextStyle: TextStyle;
  userAvatarTextStyle: TextStyle;
  userNameTextStyle: TextStyle;
}

export interface ThemeInsets {
  messageInsetsHorizontal: number;
  messageInsetsVertical: number;
}

export interface ThemeSpacing {
  default: number;
}

export interface Theme extends MD3Theme {
  colors: MD3BaseColors & SemanticColors;
  borders: ThemeBorders;
  spacing: ThemeSpacing;
  fonts: ThemeFonts;
  insets: ThemeInsets;
  icons?: ThemeIcons;
}

export interface User {
  createdAt?: number;
  firstName?: string;
  id: string;
  imageUrl?: ImageURISource['uri'];
  lastName?: string;
  lastSeen?: number;
  metadata?: Record<string, any>;
  role?: 'admin' | 'agent' | 'moderator' | 'user';
  updatedAt?: number;
}

export interface ChatTemplateConfig extends TemplateConfig {
  addGenerationPrompt: boolean;
  systemPrompt?: string;
  name: string;
}

export type ChatMessage = {
  role: 'system' | 'assistant' | 'user';
  content:
    | string
    | Array<{
        type: 'text' | 'image_url';
        text?: string;
        image_url?: {url: string};
      }>;
};

export enum ModelOrigin {
  PRESET = 'preset',
  LOCAL = 'local',
  HF = 'hf',
}

export enum ModelType {
  PROJECTION = 'projection',
  VISION = 'vision',
  LLM = 'llm',
}

export interface Model {
  id: string;
  author: string;
  name: string;
  type?: string;
  capabilities?: SkillKey[]; // Array of capability keys
  size: number; // Size in bytes
  params: number;
  isDownloaded: boolean;
  downloadUrl: string;
  hfUrl: string;
  progress: number; // Progress as a percentage
  downloadSpeed?: string;
  filename: string;
  fullPath?: string; // Full path for local models
  /**
   * @deprecated Use 'origin' instead.
   */
  isLocal: boolean; // this need to be deprecated
  origin: ModelOrigin;
  modelType?: ModelType; // Type of model for multimodal support

  // Multimodal support fields
  supportsMultimodal?: boolean; // Whether this model supports multimodal input
  compatibleProjectionModels?: string[]; // Array of mmproj model IDs that work with this model
  defaultProjectionModel?: string; // Default mmproj model ID to use with this model
  visionEnabled?: boolean; // User preference for enabling vision capabilities (defaults to true for backward compatibility)

  // Thinking capabilities
  supportsThinking?: boolean; // Whether this model supports thinking/reasoning mode

  defaultChatTemplate: ChatTemplateConfig;
  chatTemplate: ChatTemplateConfig;
  defaultStopWords: CompletionParams['stop'];
  stopWords: CompletionParams['stop'];
  defaultCompletionSettings: CompletionParams;
  completionSettings: CompletionParams;
  hfModelFile?: ModelFile;
  hfModel?: HuggingFaceModel;
  hash?: string;
}

export type RootDrawerParamList = {
  Chat: undefined;
  Models: undefined;
  Settings: undefined;
};

export type TokenNativeEvent = {
  contextId: number;
  tokenResult: TokenData;
};

export interface ModelFile {
  rfilename: string;
  size?: number;
  url?: string;
  oid?: string;
  lfs?: {
    oid: string;
    size: number;
    pointerSize: number;
  };
  canFitInStorage?: boolean;
}

// Model data from HuggingFace search models
export interface HuggingFaceModel {
  _id: string;
  id: string;
  author: string;
  gated: boolean | string;
  inference: string;
  lastModified: string;
  likes: number;
  trendingScore: number;
  private: boolean;
  sha: string;
  downloads: number;
  tags: string[];
  library_name: string;
  createdAt: string;
  model_id: string;
  siblings: ModelFile[];
  url?: string;
  specs?: GGUFSpecs;
}

export interface HuggingFaceModelsResponse {
  models: HuggingFaceModel[];
  nextLink: string | null; // null if there is no next page
}

export interface ModelFileDetails {
  type: string;
  oid: string;
  size: number;
  lfs?: {
    oid: string;
    size: number;
    pointerSize: number;
  };
  path: string;
}

export interface GGUFSpecs {
  _id: string;
  id: string;
  gguf: {
    total: number;
    architecture: string;
    context_length: number;
    quantize_imatrix_file?: string;
    chat_template?: string;
    bos_token?: string;
    eos_token?: string;
  };
}
export type BenchmarkConfig = {
  pp: number;
  tg: number;
  pl: number;
  nr: number;
  label: string;
};

export interface BenchmarkResult {
  config: BenchmarkConfig;
  modelDesc: string;
  modelSize: number;
  modelNParams: number;
  ppAvg: number;
  ppStd: number;
  tgAvg: number;
  tgStd: number;
  timestamp: string;
  modelId: string;
  modelName: string;
  oid?: string;
  rfilename?: string;
  filename?: string;
  peakMemoryUsage?: {
    total: number;
    used: number;
    percentage: number;
  };
  wallTimeMs?: number;
  uuid: string;
  submitted?: boolean;
  initSettings?: {
    n_context: number;
    n_batch: number;
    n_ubatch: number;
    n_threads: number;
    flash_attn: boolean;
    cache_type_k: CacheType;
    cache_type_v: CacheType;
    n_gpu_layers: number;
  };
}

export type DeviceInfo = {
  model: string;
  systemName: string;
  systemVersion: string;
  brand: string;
  cpuArch: string[];
  isEmulator: boolean;
  version: string;
  buildNumber: string;
  device: string;
  deviceId: string;
  totalMemory: number;
  chipset: string;
  cpu: string;
  cpuDetails: {
    cores: number;
    processors: Array<{
      processor: string;
      'model name': string;
      'cpu MHz': string;
      vendor_id: string;
    }>;
    socModel: string;
    features: string[];
    hasFp16: boolean;
    hasDotProd: boolean;
    hasSve: boolean;
    hasI8mm: boolean;
  };
};

export enum CacheType {
  F16 = 'f16',
  F32 = 'f32',
  Q8_0 = 'q8_0',
  Q4_0 = 'q4_0',
  Q4_1 = 'q4_1',
  IQ4_NL = 'iq4_nl',
  Q5_0 = 'q5_0',
  Q5_1 = 'q5_1',
}



================================================
FILE: src/utils/__tests__/chat.test.ts
================================================
import {Templates} from 'chat-formatter';
import {
  applyChatTemplate,
  convertToChatMessages,
  user,
  assistant,
} from '../chat';
import {ChatMessage, ChatTemplateConfig, MessageType} from '../types';
import {createModel} from '../../../jest/fixtures/models';

const conversationWSystem: ChatMessage[] = [
  {role: 'system', content: 'System prompt. '},
  {role: 'user', content: 'Hi there!'},
  {role: 'assistant', content: 'Nice to meet you!'},
  {role: 'user', content: 'Can I ask a question?'},
];

describe('convertToChatMessages', () => {
  it('should convert text-only messages correctly', () => {
    const messages: MessageType.Text[] = [
      {
        id: '1',
        author: user,
        text: 'Hello',
        type: 'text',
        createdAt: Date.now(),
      },
      {
        id: '2',
        author: assistant,
        text: 'Hi there!',
        type: 'text',
        createdAt: Date.now(),
      },
    ];

    const result = convertToChatMessages(messages, true);

    expect(result).toEqual([
      {
        role: 'assistant',
        content: 'Hi there!',
      },
      {
        role: 'user',
        content: 'Hello',
      },
    ] as ChatMessage[]);
  });

  it('should convert multimodal messages with images correctly when multimodal is enabled', () => {
    const messages: MessageType.Text[] = [
      {
        id: '1',
        author: user,
        text: 'Look at this image',
        type: 'text',
        imageUris: ['file:///path/to/image1.jpg', 'file:///path/to/image2.jpg'],
        createdAt: Date.now(),
      },
      {
        id: '2',
        author: assistant,
        text: 'I can see the images',
        type: 'text',
        createdAt: Date.now(),
      },
    ];

    const result = convertToChatMessages(messages, true);

    expect(result).toEqual([
      {
        role: 'assistant',
        content: 'I can see the images',
      },
      {
        role: 'user',
        content: [
          {
            type: 'text',
            text: 'Look at this image',
          },
          {
            type: 'image_url',
            image_url: {url: 'file:///path/to/image1.jpg'},
          },
          {
            type: 'image_url',
            image_url: {url: 'file:///path/to/image2.jpg'},
          },
        ],
      },
    ] as ChatMessage[]);
  });

  it('should convert multimodal messages to text-only when multimodal is disabled', () => {
    const messages: MessageType.Text[] = [
      {
        id: '1',
        author: user,
        text: 'Look at this image',
        type: 'text',
        imageUris: ['file:///path/to/image1.jpg', 'file:///path/to/image2.jpg'],
        createdAt: Date.now(),
      },
      {
        id: '2',
        author: assistant,
        text: 'I can see the images',
        type: 'text',
        createdAt: Date.now(),
      },
    ];

    const result = convertToChatMessages(messages, false);

    expect(result).toEqual([
      {
        role: 'assistant',
        content: 'I can see the images',
      },
      {
        role: 'user',
        content: 'Look at this image', // Images should be stripped, only text remains
      },
    ] as ChatMessage[]);
  });

  it('should handle mixed conversation with text and multimodal messages', () => {
    const messages: MessageType.Text[] = [
      {
        id: '1',
        author: user,
        text: 'Hello',
        type: 'text',
        createdAt: Date.now(),
      },
      {
        id: '2',
        author: assistant,
        text: 'Hi! How can I help?',
        type: 'text',
        createdAt: Date.now(),
      },
      {
        id: '3',
        author: user,
        text: 'Can you analyze this image?',
        type: 'text',
        imageUris: ['file:///path/to/image.jpg'],
        createdAt: Date.now(),
      },
      {
        id: '4',
        author: assistant,
        text: 'I can see a beautiful landscape in the image.',
        type: 'text',
        createdAt: Date.now(),
      },
    ];

    const result = convertToChatMessages(messages, true);

    expect(result).toEqual([
      {
        role: 'assistant',
        content: 'I can see a beautiful landscape in the image.',
      },
      {
        role: 'user',
        content: [
          {
            type: 'text',
            text: 'Can you analyze this image?',
          },
          {
            type: 'image_url',
            image_url: {url: 'file:///path/to/image.jpg'},
          },
        ],
      },
      {
        role: 'assistant',
        content: 'Hi! How can I help?',
      },
      {
        role: 'user',
        content: 'Hello',
      },
    ] as ChatMessage[]);
  });

  it('should filter out non-text messages', () => {
    const messages: MessageType.Any[] = [
      {
        id: '1',
        author: user,
        text: 'Hello',
        type: 'text',
        createdAt: Date.now(),
      },
      {
        id: '2',
        author: user,
        type: 'image',
        uri: 'file:///path/to/image.jpg',
        name: 'image.jpg',
        size: 1024,
        createdAt: Date.now(),
      } as MessageType.Image,
      {
        id: '3',
        author: assistant,
        text: 'I can see your message',
        type: 'text',
        createdAt: Date.now(),
      },
    ];

    const result = convertToChatMessages(messages, true);

    expect(result).toEqual([
      {
        role: 'assistant',
        content: 'I can see your message',
      },
      {
        role: 'user',
        content: 'Hello',
      },
    ] as ChatMessage[]);
  });
});

describe('Test Danube2 Chat Templates', () => {
  it('Test danube-2 template with geneneration and system prompt', async () => {
    const chatTemplate: ChatTemplateConfig = {
      ...Templates.templates.danube2,
      //isBeginningOfSequence: true,
      //isEndOfSequence: true,
      addGenerationPrompt: true,
      name: 'danube2',
    };
    const model = createModel({chatTemplate: chatTemplate});
    const result = await applyChatTemplate(conversationWSystem, model, null);
    expect(result).toBe(
      'System prompt. </s><|prompt|>Hi there!</s><|answer|>Nice to meet you!</s><|prompt|>Can I ask a question?</s><|answer|>',
    );
  });
});



================================================
FILE: src/utils/__tests__/completionSettingsVersions.test.ts
================================================
/**
 * Tests for completion settings versioning and migration
 */

import {
  migrateCompletionSettings,
  defaultCompletionParams,
  CURRENT_COMPLETION_SETTINGS_VERSION,
} from '../completionSettingsVersions';

describe('migrateCompletionSettings', () => {
  it('should add version 0 to settings without version', () => {
    const settings = {temperature: 0.7};
    const migrated = migrateCompletionSettings(settings);

    expect(migrated.version).toBe(CURRENT_COMPLETION_SETTINGS_VERSION);
    expect(migrated.temperature).toBe(0.7);
  });

  it('should migrate from version 0 to version 1', () => {
    const settings = {
      version: 0,
      temperature: 0.7,
    };
    const migrated = migrateCompletionSettings(settings);

    expect(migrated.version).toBe(CURRENT_COMPLETION_SETTINGS_VERSION);
    expect(migrated.include_thinking_in_context).toBe(
      defaultCompletionParams.include_thinking_in_context,
    );
    expect(migrated.temperature).toBe(0.7);
  });

  it('should migrate from version 1 to version 2', () => {
    const settings = {
      version: 1,
      temperature: 0.7,
      include_thinking_in_context: false,
    };
    const migrated = migrateCompletionSettings(settings);

    expect(migrated.version).toBe(CURRENT_COMPLETION_SETTINGS_VERSION);
    expect(migrated.jinja).toBe(defaultCompletionParams.jinja);
    expect(migrated.include_thinking_in_context).toBe(false);
    expect(migrated.temperature).toBe(0.7);
  });

  it('should migrate from version 2 to version 3 (add enable_thinking)', () => {
    const settings = {
      version: 2,
      temperature: 0.7,
      include_thinking_in_context: true,
      jinja: true,
    };
    const migrated = migrateCompletionSettings(settings);

    expect(migrated.version).toBe(CURRENT_COMPLETION_SETTINGS_VERSION);
    expect(migrated.enable_thinking).toBe(
      defaultCompletionParams.enable_thinking,
    );
    expect(migrated.jinja).toBe(true);
    expect(migrated.include_thinking_in_context).toBe(true);
    expect(migrated.temperature).toBe(0.7);
  });

  it('should migrate through multiple versions', () => {
    const settings = {
      version: 0,
      temperature: 0.5,
      top_p: 0.9,
    };
    const migrated = migrateCompletionSettings(settings);

    expect(migrated.version).toBe(CURRENT_COMPLETION_SETTINGS_VERSION);
    expect(migrated.include_thinking_in_context).toBe(
      defaultCompletionParams.include_thinking_in_context,
    );
    expect(migrated.jinja).toBe(defaultCompletionParams.jinja);
    expect(migrated.enable_thinking).toBe(
      defaultCompletionParams.enable_thinking,
    );
    expect(migrated.temperature).toBe(0.5);
    expect(migrated.top_p).toBe(0.9);
  });

  it('should not modify settings that are already current version', () => {
    const settings = {
      version: CURRENT_COMPLETION_SETTINGS_VERSION,
      temperature: 0.8,
      include_thinking_in_context: false,
      jinja: false,
      enable_thinking: false,
    };
    const migrated = migrateCompletionSettings(settings);

    expect(migrated).toEqual(settings);
  });

  it('should preserve existing values during migration', () => {
    const settings = {
      version: 1,
      temperature: 0.3,
      include_thinking_in_context: false,
      top_k: 50,
    };
    const migrated = migrateCompletionSettings(settings);

    expect(migrated.version).toBe(CURRENT_COMPLETION_SETTINGS_VERSION);
    expect(migrated.temperature).toBe(0.3);
    expect(migrated.include_thinking_in_context).toBe(false); // Preserved
    expect(migrated.top_k).toBe(50);
    expect(migrated.jinja).toBe(defaultCompletionParams.jinja); // Added
    expect(migrated.enable_thinking).toBe(
      defaultCompletionParams.enable_thinking,
    ); // Added
  });

  it('should handle empty settings object', () => {
    const settings = {};
    const migrated = migrateCompletionSettings(settings);

    expect(migrated.version).toBe(CURRENT_COMPLETION_SETTINGS_VERSION);
    expect(migrated.include_thinking_in_context).toBe(
      defaultCompletionParams.include_thinking_in_context,
    );
    expect(migrated.jinja).toBe(defaultCompletionParams.jinja);
    expect(migrated.enable_thinking).toBe(
      defaultCompletionParams.enable_thinking,
    );
  });

  it('should not mutate the original settings object', () => {
    const settings = {
      version: 0,
      temperature: 0.7,
    };
    const originalSettings = {...settings};
    const migrated = migrateCompletionSettings(settings);

    expect(settings).toEqual(originalSettings);
    expect(migrated).not.toBe(settings);
  });
});

describe('defaultCompletionParams', () => {
  it('should have the current version', () => {
    expect(defaultCompletionParams.version).toBe(
      CURRENT_COMPLETION_SETTINGS_VERSION,
    );
  });

  it('should have enable_thinking set to true by default', () => {
    expect(defaultCompletionParams.enable_thinking).toBe(true);
  });

  it('should have include_thinking_in_context set to true by default', () => {
    expect(defaultCompletionParams.include_thinking_in_context).toBe(true);
  });

  it('should have jinja set to true by default', () => {
    expect(defaultCompletionParams.jinja).toBe(true);
  });
});



================================================
FILE: src/utils/__tests__/errors.test.ts
================================================
import axios from 'axios';
import {
  createErrorState,
  createMultimodalWarning,
  NetworkError,
  ServerError,
  AppCheckError,
} from '../errors';

// Mock uiStore
jest.mock('../../store/UIStore', () => ({
  uiStore: {
    l10n: {
      errors: {
        unexpectedError: 'An unexpected error occurred',
        hfAuthenticationError: 'HF authentication error',
        hfAuthenticationErrorSearch: 'HF authentication error during search',
        authenticationError: 'Authentication error',
        hfAuthorizationError: 'HF authorization error',
        authorizationError: 'Authorization error',
        hfServerError: 'HF server error',
        serverError: 'Server error',
        hfNetworkTimeout: 'HF network timeout',
        networkTimeout: 'Network timeout',
        hfNetworkError: 'HF network error',
        networkError: 'Network error',
      },
    },
  },
}));

describe('errors.ts', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    jest.restoreAllMocks();
  });

  describe('Error classes', () => {
    it('should create NetworkError correctly', () => {
      const error = new NetworkError('Network connection failed');
      expect(error.name).toBe('NetworkError');
      expect(error.message).toBe('Network connection failed');
      expect(error instanceof Error).toBe(true);
    });

    it('should create ServerError correctly', () => {
      const error = new ServerError('Server is down');
      expect(error.name).toBe('ServerError');
      expect(error.message).toBe('Server is down');
      expect(error instanceof Error).toBe(true);
    });

    it('should create AppCheckError correctly', () => {
      const error = new AppCheckError('App check failed');
      expect(error.name).toBe('AppCheckError');
      expect(error.message).toBe('App check failed');
      expect(error instanceof Error).toBe(true);
    });
  });

  describe('createErrorState', () => {
    it('should handle axios 401 errors', () => {
      const axiosError = {
        isAxiosError: true,
        response: {status: 401},
        config: {url: 'https://huggingface.co/api/models'},
      };
      jest.spyOn(axios, 'isAxiosError').mockReturnValue(true);

      const errorState = createErrorState(axiosError, 'search', 'huggingface');

      expect(errorState.code).toBe('authentication');
      expect(errorState.service).toBe('huggingface');
      expect(errorState.message).toBe('HF authentication error during search');
      expect(errorState.context).toBe('search');
      expect(errorState.recoverable).toBe(true);
    });

    it('should handle axios 403 errors', () => {
      const axiosError = {
        isAxiosError: true,
        response: {status: 403},
        config: {url: 'https://api.example.com'},
      };
      jest.spyOn(axios, 'isAxiosError').mockReturnValue(true);

      const errorState = createErrorState(axiosError, 'download');

      expect(errorState.code).toBe('authorization');
      expect(errorState.message).toBe('Authorization error');
      expect(errorState.context).toBe('download');
    });

    it('should handle axios 500+ errors', () => {
      const axiosError = {
        isAxiosError: true,
        response: {status: 502},
        config: {url: 'https://huggingface.co/api'},
      };
      jest.spyOn(axios, 'isAxiosError').mockReturnValue(true);

      const errorState = createErrorState(axiosError, 'search', 'huggingface');

      expect(errorState.code).toBe('server');
      expect(errorState.service).toBe('huggingface');
      expect(errorState.message).toBe('HF server error');
    });

    it('should handle network timeout errors', () => {
      const axiosError = {
        isAxiosError: true,
        code: 'ECONNABORTED',
        config: {url: 'https://huggingface.co/api'},
      };
      jest.spyOn(axios, 'isAxiosError').mockReturnValue(true);

      const errorState = createErrorState(axiosError, 'search', 'huggingface');

      expect(errorState.code).toBe('network');
      expect(errorState.message).toBe('HF network timeout');
    });

    it('should handle network connection errors', () => {
      const axiosError = {
        isAxiosError: true,
        code: 'ERR_NETWORK',
        config: {url: 'https://huggingface.co/api'},
      };
      jest.spyOn(axios, 'isAxiosError').mockReturnValue(true);

      const errorState = createErrorState(axiosError, 'search', 'huggingface');

      expect(errorState.code).toBe('network');
      expect(errorState.message).toBe('HF network error');
    });

    it('should auto-detect HuggingFace service from URL', () => {
      const axiosError = {
        isAxiosError: true,
        response: {status: 401},
        config: {url: 'https://hf.co/api/models'},
      };
      jest.spyOn(axios, 'isAxiosError').mockReturnValue(true);

      const errorState = createErrorState(axiosError, 'search');

      expect(errorState.service).toBe('huggingface');
      expect(errorState.message).toBe('HF authentication error during search');
    });

    it('should handle NetworkError instances', () => {
      const networkError = new NetworkError('Connection lost');

      const errorState = createErrorState(networkError, 'download');

      expect(errorState.code).toBe('network');
      expect(errorState.message).toBe('Connection lost');
    });

    it('should handle ServerError instances', () => {
      const serverError = new ServerError('Internal server error');

      const errorState = createErrorState(serverError, 'download');

      expect(errorState.code).toBe('server');
      expect(errorState.message).toBe('Internal server error');
    });

    it('should handle generic Error with status code in message', () => {
      const error = new Error('Client error: 403 Forbidden');

      const errorState = createErrorState(error, 'download', 'huggingface');

      expect(errorState.code).toBe('authorization');
      expect(errorState.message).toBe('HF authorization error');
    });

    it('should handle storage-related errors', () => {
      const error = new Error('Insufficient storage space available');

      const errorState = createErrorState(error, 'download');

      expect(errorState.code).toBe('storage');
      expect(errorState.message).toBe('Insufficient storage space available');
    });

    it('should handle unknown errors with default values', () => {
      const unknownError = 'Some string error';

      const errorState = createErrorState(unknownError, 'chat');

      expect(errorState.code).toBe('unknown');
      expect(errorState.message).toBe('An unexpected error occurred');
      expect(errorState.context).toBe('chat');
      expect(errorState.recoverable).toBe(true);
    });

    it('should include metadata when provided', () => {
      const error = new Error('Test error');
      const metadata = {modelId: 'test-model', extra: 'data'};

      const errorState = createErrorState(
        error,
        'download',
        undefined,
        metadata,
      );

      expect(errorState.metadata).toEqual(metadata);
    });

    it('should set severity when provided', () => {
      const error = new Error('Warning message');

      const errorState = createErrorState(
        error,
        'chat',
        undefined,
        undefined,
        'warning',
      );

      expect(errorState.severity).toBe('warning');
    });
  });

  describe('createMultimodalWarning', () => {
    it('should create multimodal warning with default context', () => {
      const warning = createMultimodalWarning('Vision model not loaded');

      expect(warning.code).toBe('multimodal');
      expect(warning.message).toBe('Vision model not loaded');
      expect(warning.context).toBe('chat');
      expect(warning.recoverable).toBe(false);
      expect(warning.severity).toBe('warning');
    });

    it('should create multimodal warning with custom context', () => {
      const warning = createMultimodalWarning(
        'Projection model missing',
        'modelDetails',
      );

      expect(warning.code).toBe('multimodal');
      expect(warning.message).toBe('Projection model missing');
      expect(warning.context).toBe('modelDetails');
      expect(warning.recoverable).toBe(false);
      expect(warning.severity).toBe('warning');
    });
  });
});



================================================
FILE: src/utils/__tests__/exportUtils.test.ts
================================================
import Share from 'react-native-share';
import * as RNFS from '@dr.pogodin/react-native-fs';
import {Alert, Platform} from 'react-native';
import {
  exportLegacyChatSessions,
  exportChatSession,
  exportAllChatSessions,
} from '../exportUtils';

// Mock dependencies
jest.mock('react-native', () => ({
  Platform: {
    OS: 'ios',
  },
  Alert: {
    alert: jest.fn(),
  },
}));

// Mock react-native-share
jest.mock('react-native-share', () => ({
  open: jest.fn().mockResolvedValue({success: true}),
}));

jest.mock('@dr.pogodin/react-native-fs', () => ({
  writeFile: jest.fn().mockResolvedValue(undefined),
  readFile: jest.fn().mockResolvedValue('{"legacy":"data"}'),
  exists: jest.fn().mockResolvedValue(true),
  copyFile: jest.fn().mockResolvedValue(undefined),
  DocumentDirectoryPath: '/mock/document/path',
  CachesDirectoryPath: '/mock/cache/path',
  DownloadDirectoryPath: '/mock/download/path',
}));

jest.mock('date-fns', () => ({
  format: jest.fn().mockReturnValue('2024-01-01_12-00-00'),
}));

// Import the actual repository to spy on it
import {chatSessionRepository} from '../../repositories/ChatSessionRepository';

jest.mock('../androidPermission', () => ({
  ensureLegacyStoragePermission: jest.fn().mockResolvedValue(true),
}));

describe('exportUtils', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    // Don't restore all mocks here as it interferes with console.error mocking in error handling tests
  });

  describe('exportLegacyChatSessions', () => {
    it('should export legacy sessions if file exists', async () => {
      // Setup
      (RNFS.exists as jest.Mock).mockResolvedValueOnce(true);

      // Execute
      await exportLegacyChatSessions();

      // Verify
      expect(RNFS.exists).toHaveBeenCalled();
      expect(RNFS.readFile).toHaveBeenCalled();
      expect(RNFS.writeFile).toHaveBeenCalled();
      expect(Share.open).toHaveBeenCalled();
    });

    it('should throw error if legacy file does not exist', async () => {
      (RNFS.exists as jest.Mock).mockResolvedValueOnce(false);

      await expect(exportLegacyChatSessions()).rejects.toThrow(
        'Legacy chat sessions file not found',
      );
    });

    it('should handle file read errors', async () => {
      (RNFS.exists as jest.Mock).mockResolvedValueOnce(true);
      (RNFS.readFile as jest.Mock).mockRejectedValueOnce(
        new Error('File read failed'),
      );

      await expect(exportLegacyChatSessions()).rejects.toThrow(
        'File read failed',
      );
    });
  });

  describe('exportChatSession', () => {
    const mockSessionData = {
      session: {
        id: 'session-1',
        title: 'Test Session',
        date: '2024-01-01T00:00:00Z',
        activePalId: 'pal-1',
      },
      messages: [
        {
          id: 'msg-1',
          author: 'user',
          text: 'Hello',
          type: 'text',
          metadata: '{"test": true}',
          createdAt: 1704067200000,
        },
      ],
      completionSettings: {
        settings: '{"temperature": 0.7}',
      },
    };

    beforeEach(() => {
      jest
        .spyOn(chatSessionRepository, 'getSessionById')
        .mockResolvedValue(mockSessionData as any);
    });

    it('should export single chat session successfully', async () => {
      await exportChatSession('session-1');

      expect(chatSessionRepository.getSessionById).toHaveBeenCalledWith(
        'session-1',
      );
      expect(RNFS.writeFile).toHaveBeenCalled();
      expect(Share.open).toHaveBeenCalled();
    });

    it('should throw error if session not found', async () => {
      jest
        .spyOn(chatSessionRepository, 'getSessionById')
        .mockResolvedValue(null);

      await expect(exportChatSession('nonexistent')).rejects.toThrow(
        'Session not found',
      );
    });

    it('should handle export errors', async () => {
      (RNFS.writeFile as jest.Mock).mockRejectedValueOnce(
        new Error('Write failed'),
      );

      await expect(exportChatSession('session-1')).rejects.toThrow(
        'Write failed',
      );
    });
  });

  describe('exportAllChatSessions', () => {
    const mockSessions = [
      {id: 'session-1', title: 'Session 1', date: '2024-01-01T00:00:00Z'},
      {id: 'session-2', title: 'Session 2', date: '2024-01-02T00:00:00Z'},
    ];

    const mockSessionData = {
      session: mockSessions[0],
      messages: [],
      completionSettings: null,
    };

    beforeEach(() => {
      jest
        .spyOn(chatSessionRepository, 'getAllSessions')
        .mockResolvedValue(mockSessions as any);
      jest
        .spyOn(chatSessionRepository, 'getSessionById')
        .mockResolvedValue(mockSessionData as any);
    });

    it('should export all chat sessions successfully', async () => {
      await exportAllChatSessions();

      expect(chatSessionRepository.getAllSessions).toHaveBeenCalled();
      expect(chatSessionRepository.getSessionById).toHaveBeenCalledTimes(2);
      expect(RNFS.writeFile).toHaveBeenCalled();
      expect(Share.open).toHaveBeenCalled();
    });

    it('should handle empty sessions list', async () => {
      jest.spyOn(chatSessionRepository, 'getAllSessions').mockResolvedValue([]);

      await exportAllChatSessions();

      expect(RNFS.writeFile).toHaveBeenCalled();
      expect(Share.open).toHaveBeenCalled();
    });
  });

  describe('Platform-specific behavior', () => {
    it('should handle iOS file sharing', async () => {
      // iOS is already mocked as default
      await exportChatSession('session-1');

      expect(Share.open).toHaveBeenCalledWith(
        expect.objectContaining({
          url: expect.stringContaining('file://'),
          type: 'application/json',
        }),
      );
    });

    it('should handle Android file sharing with permissions', async () => {
      // Mock Android
      (Platform as any).OS = 'android';
      const {ensureLegacyStoragePermission} = require('../androidPermission');
      (ensureLegacyStoragePermission as jest.Mock).mockResolvedValue(true);

      await exportChatSession('session-1');

      expect(ensureLegacyStoragePermission).toHaveBeenCalled();
      expect(RNFS.copyFile).toHaveBeenCalled();
    });

    it('should handle Android permission denial gracefully', async () => {
      (Platform as any).OS = 'android';
      const {ensureLegacyStoragePermission} = require('../androidPermission');
      (ensureLegacyStoragePermission as jest.Mock).mockResolvedValue(false);

      await exportChatSession('session-1');

      // Should fall back to direct sharing
      expect(Share.open).toHaveBeenCalled();
    });
  });

  describe('Error handling', () => {
    beforeEach(() => {
      jest.spyOn(console, 'error').mockImplementation();
    });

    afterEach(() => {
      (console.error as jest.Mock).mockRestore();
    });

    it('should handle share errors gracefully', async () => {
      (Share.open as jest.Mock).mockRejectedValue(new Error('Share failed'));

      await expect(exportChatSession('session-1')).rejects.toThrow();
      expect(Alert.alert).toHaveBeenCalledWith(
        expect.stringContaining('Export Error'),
        expect.stringContaining('export'),
        expect.any(Array),
      );
    });

    it('should handle file write errors', async () => {
      (RNFS.writeFile as jest.Mock).mockRejectedValue(new Error('Disk full'));

      await expect(exportChatSession('session-1')).rejects.toThrow('Disk full');
      expect(console.error).toHaveBeenCalledWith(
        'Error sharing JSON data:',
        expect.any(Error),
      );
    });

    it('should handle copy file errors on Android', async () => {
      (Platform as any).OS = 'android';
      (RNFS.copyFile as jest.Mock).mockRejectedValue(new Error('Copy failed'));

      await expect(exportChatSession('session-1')).rejects.toThrow();
    });
  });
});



================================================
FILE: src/utils/__tests__/importUtils.test.ts
================================================
import * as RNFS from '@dr.pogodin/react-native-fs';
import {
  readJsonFile,
  validateImportedData,
  ImportedChatSession,
} from '../importUtils';

// Mock dependencies
jest.mock('react-native', () => ({
  Platform: {
    OS: 'ios',
  },
  Alert: {
    alert: jest.fn(),
  },
}));

jest.mock('@dr.pogodin/react-native-fs', () => ({
  readFile: jest.fn(),
}));

jest.mock('react-native-document-picker', () => ({
  pick: jest.fn(),
  isCancel: jest.fn(err => err && err.code === 'DOCUMENT_PICKER_CANCELED'),
  types: {
    allFiles: 'public.all-files',
  },
}));

jest.mock('../../repositories/ChatSessionRepository');

// Mock uuid
jest.mock('uuid', () => ({
  v4: jest.fn().mockReturnValue('mock-uuid-12345'),
}));

describe('importUtils', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('readJsonFile', () => {
    it('should read and parse a JSON file successfully', async () => {
      // Setup
      const mockJsonData = '{"test":"data"}';
      (RNFS.readFile as jest.Mock).mockResolvedValueOnce(mockJsonData);

      // Execute
      const result = await readJsonFile('file:///mock/path/test.json');

      // Verify
      expect(RNFS.readFile).toHaveBeenCalled();
      expect(result).toEqual({test: 'data'});
    });
  });

  describe('validateImportedData', () => {
    it('should validate a single session correctly', () => {
      // Setup
      const mockSession = {
        id: 'test-id',
        title: 'Test Session',
        date: '2024-01-01T12:00:00.000Z',
        messages: [
          {
            id: 'msg1',
            author: 'user',
            text: 'Hello',
            type: 'text',
          },
        ],
        completionSettings: {
          temperature: 0.7,
        },
      };

      // Execute
      const result = validateImportedData(mockSession);

      // Verify
      expect(result).toEqual(mockSession);
    });

    it('should add missing fields with default values', () => {
      // Setup
      const incompleteSession = {
        title: 'Incomplete Session',
      };

      // Execute
      const result = validateImportedData(
        incompleteSession,
      ) as ImportedChatSession;

      // Verify
      expect(result.id).toBe('mock-uuid-12345');
      expect(result.date).toBeDefined();
      expect(result.messages).toEqual([]);
      expect(result.completionSettings).toBeDefined();
    });
  });
});



================================================
FILE: src/utils/__tests__/memorySettings.test.ts
================================================
import {Platform} from 'react-native';
import {isRepackableQuantization, resolveUseMmap} from '../memorySettings';
import {loadLlamaModelInfo} from '@pocketpalai/llama.rn';

// Mock Platform
jest.mock('react-native', () => ({
  Platform: {
    OS: 'android',
  },
}));

const mockLoadLlamaModelInfo = loadLlamaModelInfo as jest.MockedFunction<
  typeof loadLlamaModelInfo
>;

describe('memorySettings', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('isRepackableQuantization', () => {
    it('should return true for Q4_0 quantization', async () => {
      mockLoadLlamaModelInfo.mockResolvedValue({
        'general.file_type': 'Q4_0',
      });

      const result = await isRepackableQuantization('/path/to/model.gguf');
      expect(result).toBe(true);
    });

    it('should return true for IQ4_NL quantization', async () => {
      mockLoadLlamaModelInfo.mockResolvedValue({
        'general.file_type': 'IQ4_NL',
      });

      const result = await isRepackableQuantization('/path/to/model.gguf');
      expect(result).toBe(true);
    });

    it('should return false for non-repackable quantization', async () => {
      mockLoadLlamaModelInfo.mockResolvedValue({
        'general.file_type': 'Q8_0',
      });

      const result = await isRepackableQuantization('/path/to/model.gguf');
      expect(result).toBe(false);
    });

    it('should return false when general.file_type is missing', async () => {
      mockLoadLlamaModelInfo.mockResolvedValue({
        'other.field': 'value',
      });

      const result = await isRepackableQuantization('/path/to/model.gguf');
      expect(result).toBe(false);
    });

    it('should return false when loadLlamaModelInfo throws error', async () => {
      mockLoadLlamaModelInfo.mockRejectedValue(
        new Error('Failed to load model info'),
      );

      const result = await isRepackableQuantization('/path/to/model.gguf');
      expect(result).toBe(false);
    });

    it('should handle case-insensitive matching', async () => {
      mockLoadLlamaModelInfo.mockResolvedValue({
        'general.file_type': 'q4_0',
      });

      const result = await isRepackableQuantization('/path/to/model.gguf');
      expect(result).toBe(true);
    });
  });

  describe('resolveUseMmap', () => {
    it('should return true for "true" setting', async () => {
      const result = await resolveUseMmap('true', '/path/to/model.gguf');
      expect(result).toBe(true);
    });

    it('should return false for "false" setting', async () => {
      const result = await resolveUseMmap('false', '/path/to/model.gguf');
      expect(result).toBe(false);
    });

    it('should return true for "smart" setting on non-Android platforms', async () => {
      (Platform as any).OS = 'ios';
      const result = await resolveUseMmap('smart', '/path/to/model.gguf');
      expect(result).toBe(true);
    });

    it('should return true for "smart" setting without model path', async () => {
      (Platform as any).OS = 'android';
      const result = await resolveUseMmap('smart', '');
      expect(result).toBe(true);
    });

    it('should return false for "smart" setting with repackable quantization on Android', async () => {
      (Platform as any).OS = 'android';
      mockLoadLlamaModelInfo.mockResolvedValue({
        'general.file_type': 'Q4_0',
      });

      const result = await resolveUseMmap('smart', '/path/to/model.gguf');
      expect(result).toBe(false);
    });

    it('should return true for "smart" setting with non-repackable quantization on Android', async () => {
      (Platform as any).OS = 'android';
      mockLoadLlamaModelInfo.mockResolvedValue({
        'general.file_type': 'Q8_0',
      });

      const result = await resolveUseMmap('smart', '/path/to/model.gguf');
      expect(result).toBe(true);
    });
  });
});



================================================
FILE: src/utils/__tests__/modelSettings.test.ts
================================================
import {defaultCompletionParams} from '../completionSettingsVersions';
import {
  isLegacyQuantization,
  validateNumericField,
  validateCompletionSettings,
  COMPLETION_PARAMS_METADATA,
} from '../modelSettings';

describe('modelSettings', () => {
  describe('isLegacyQuantization', () => {
    it('returns true for filenames containing legacy quantization patterns', () => {
      expect(isLegacyQuantization('model-Q4_0_4_8.gguf')).toBe(true);
      expect(isLegacyQuantization('llama-Q4_0_4_4-v2.gguf')).toBe(true);
      expect(isLegacyQuantization('mistral-Q4_0_8_8.bin')).toBe(true);
      // Test case insensitivity
      expect(isLegacyQuantization('model-q4_0_4_8.gguf')).toBe(true);
    });

    it('returns false for filenames without legacy quantization patterns', () => {
      expect(isLegacyQuantization('model-Q5_K_M.gguf')).toBe(false);
      expect(isLegacyQuantization('llama-Q8_0.gguf')).toBe(false);
      expect(isLegacyQuantization('mistral.bin')).toBe(false);
    });
  });

  describe('validateNumericField', () => {
    const numericRule = {
      type: 'numeric' as const,
      min: 0,
      max: 10,
      required: true,
    };
    const optionalRule = {
      type: 'numeric' as const,
      min: 0,
      max: 10,
      required: false,
    };

    it('validates numbers within range', () => {
      expect(validateNumericField(5, numericRule).isValid).toBe(true);
      expect(validateNumericField(0, numericRule).isValid).toBe(true);
      expect(validateNumericField(10, numericRule).isValid).toBe(true);
      expect(validateNumericField('7', numericRule).isValid).toBe(true);
    });

    it('invalidates numbers outside range', () => {
      expect(validateNumericField(-1, numericRule).isValid).toBe(false);
      expect(validateNumericField(11, numericRule).isValid).toBe(false);
      expect(validateNumericField('-1', numericRule).isValid).toBe(false);
      expect(validateNumericField('11', numericRule).isValid).toBe(false);
    });

    it('handles required fields correctly', () => {
      expect(validateNumericField('', numericRule).isValid).toBe(false);
      expect(validateNumericField('' as any, numericRule).isValid).toBe(false);
      expect(validateNumericField(null as any, numericRule).isValid).toBe(
        false,
      );
    });

    it('handles optional fields correctly', () => {
      expect(validateNumericField('', optionalRule).isValid).toBe(true);
      expect(validateNumericField(undefined as any, optionalRule).isValid).toBe(
        true,
      );
      expect(validateNumericField(null as any, optionalRule).isValid).toBe(
        true,
      );
    });

    it('validates non-numeric strings correctly', () => {
      expect(validateNumericField('abc', numericRule).isValid).toBe(false);
      expect(validateNumericField('5a', numericRule).isValid).toBe(false);
    });

    it('returns appropriate error messages', () => {
      expect(validateNumericField(15, numericRule).errorMessage).toBe(
        'Value must be between 0 and 10',
      );
      expect(validateNumericField('', numericRule).errorMessage).toBe(
        'This field is required',
      );
      expect(validateNumericField('abc', numericRule).errorMessage).toBe(
        'Please enter a valid number',
      );
    });
  });

  describe('validateCompletionSettings', () => {
    it('validates valid settings', () => {
      const validSettings = {
        temperature: 0.7,
        top_k: 40,
        top_p: 0.9,
      };

      const result = validateCompletionSettings(validSettings);
      expect(result.isValid).toBe(true);
      expect(result.errors).toEqual({});
    });

    it('ignores fields not in COMPLETION_PARAMS_METADATA', () => {
      const settingsWithExtraFields = {
        temperature: 0.7,
        unknownField: 'value',
      };

      const result = validateCompletionSettings(settingsWithExtraFields);
      expect(result.isValid).toBe(true);
      expect(result.errors).toEqual({});
    });
  });

  describe('COMPLETION_PARAMS_METADATA', () => {
    it('has default values matching defaultCompletionParams', () => {
      Object.entries(COMPLETION_PARAMS_METADATA).forEach(([key, metadata]) => {
        if (key in defaultCompletionParams) {
          expect(metadata.defaultValue).toBe(defaultCompletionParams[key]);
        }
      });
    });

    it('has valid validation rules', () => {
      Object.values(COMPLETION_PARAMS_METADATA).forEach(metadata => {
        if (metadata.validation.type === 'numeric') {
          expect(metadata.validation.min).toBeLessThanOrEqual(
            metadata.validation.max,
          );
        }
      });
    });
  });
});



================================================
FILE: src/utils/__tests__/multimodalHelpers.test.ts
================================================
import {
  isVisionRepo,
  getMmprojFiles,
  isProjectionModel,
  getRecommendedProjectionModel,
  getLLMFiles,
} from '../multimodalHelpers';
import {ModelFile} from '../types';

describe('multimodalHelpers', () => {
  // Test data for model files
  const testModelFiles: ModelFile[] = [
    {
      rfilename: 'llama-3.1-8b-instruct-q4_0.gguf',
      size: 4000000000,
    },
    {
      rfilename: 'llama-3.1-8b-instruct-q5_k_m.gguf',
      size: 5000000000,
    },
    {
      rfilename: 'mmproj-llama-3.1-vision-q4_0.gguf',
      size: 100000000,
    },
    {
      rfilename: 'mmproj_llama-3.1-vision-q5_k_m.gguf',
      size: 120000000,
    },
    {
      rfilename: 'mmproj.llama-3.1-vision-q8_0.gguf',
      size: 150000000,
    },
  ];
  const testModelFilesWithDot: ModelFile[] = [
    {
      rfilename: 'llama-3.1-8b-instruct-q4_0.gguf',
      size: 4000000000,
    },
    {
      rfilename: 'mmproj.llama-3.1-vision-q8_0.gguf',
      size: 150000000,
    },
  ];

  const testModelFilesWithDash: ModelFile[] = [
    {
      rfilename: 'llama-3.1-8b-instruct-q4_0.gguf',
      size: 4000000000,
    },
    {
      rfilename: 'mmproj-llama-3.1-vision-q8_0.gguf',
      size: 150000000,
    },
  ];

  const testModelFilesWith_: ModelFile[] = [
    {
      rfilename: 'llama-3.1-8b-instruct-q4_0.gguf',
      size: 4000000000,
    },
    {
      rfilename: 'mmproj_llama-3.1-vision-q8_0.gguf',
      size: 150000000,
    },
  ];

  const nonVisionFiles: ModelFile[] = [
    {
      rfilename: 'llama-3.1-8b-instruct-q4_0.gguf',
      size: 4000000000,
    },
    {
      rfilename: 'mmprojblabblah-instruct-q5_k_m.gguf',
      size: 5000000000,
    },
  ];

  // Test isVisionRepo function
  describe('isVisionRepo', () => {
    it('returns true when repository contains mmproj files', () => {
      expect(isVisionRepo(testModelFiles)).toBe(true);
    });

    it('returns true when repository does contain mmproj files only .', () => {
      expect(isVisionRepo(testModelFilesWithDot)).toBe(true);
    });

    it('returns true when repository does contain mmproj files only -', () => {
      expect(isVisionRepo(testModelFilesWithDash)).toBe(true);
    });

    it('returns true when repository does contain mmproj files only _', () => {
      expect(isVisionRepo(testModelFilesWith_)).toBe(true);
    });

    it('returns false when repository does not contain mmproj files', () => {
      expect(isVisionRepo(nonVisionFiles)).toBe(false);
    });

    it('returns false for empty array', () => {
      expect(isVisionRepo([])).toBe(false);
    });
  });

  // Test getMmprojFiles function
  describe('getMmprojFiles', () => {
    it('returns only mmproj files from repository', () => {
      const result = getMmprojFiles(testModelFiles);
      expect(result.length).toBe(3);
      expect(result.every(file => file.rfilename.startsWith('mmproj'))).toBe(
        true,
      );
    });

    it('returns empty array when no mmproj files exist', () => {
      expect(getMmprojFiles(nonVisionFiles).length).toBe(0);
    });

    it('returns empty array for empty input', () => {
      expect(getMmprojFiles([])).toEqual([]);
    });
  });

  // Test isProjectionModel function
  describe('isProjectionModel', () => {
    it('returns true for projection model filenames', () => {
      expect(isProjectionModel('mmproj.llama-3.1-vision-q4_0.gguf')).toBe(true);
      expect(isProjectionModel('mmproj-llama-3.1-vision-q4_0.gguf')).toBe(true);
      expect(isProjectionModel('mmproj_llama-3.1-vision-q5_k_m.gguf')).toBe(
        true,
      );
    });

    it('returns false for non-projection model filenames', () => {
      expect(isProjectionModel('llama-3.1-8b-instruct-q4_0.gguf')).toBe(false);
      expect(isProjectionModel('vision-model-q8_0.gguf')).toBe(false);
    });

    it('handles case insensitivity', () => {
      expect(isProjectionModel('MMpROJ-llama-3.1-vision-q4_0.gguf')).toBe(true);
    });
  });

  // Test getLLMFiles function
  describe('getLLMFiles', () => {
    it('returns only LLM files from repository', () => {
      const result = getLLMFiles(testModelFiles);
      expect(result.length).toBe(2);
      expect(result.every(file => !file.rfilename.startsWith('mmproj'))).toBe(
        true,
      );
    });

    it('returns all files when no mmproj files exist', () => {
      expect(getLLMFiles(nonVisionFiles).length).toBe(2);
    });

    it('returns empty array when only mmproj files exist', () => {
      const onlyVisionFiles: ModelFile[] = [
        {
          rfilename: 'mmproj-llama-3.1-vision-q4_0.gguf',
          size: 100000000,
        },
      ];
      expect(getLLMFiles(onlyVisionFiles).length).toBe(0);
    });

    it('returns empty array for empty input', () => {
      expect(getLLMFiles([])).toEqual([]);
    });
  });

  describe('getRecommendedProjectionModel', () => {
    // Test case 1: Empty array of projection models
    it('returns undefined when no projection models are available', () => {
      const result = getRecommendedProjectionModel(
        'llama-3.1-8b-instruct-q4_0.gguf',
        [],
      );
      expect(result).toBeUndefined();
    });

    // Test case 2: Only one projection model available
    it('returns the only available projection model when only one exists', () => {
      const result = getRecommendedProjectionModel(
        'llama-3.1-8b-instruct-q4_0.gguf',
        ['mmproj-llama-3.1-vision-q5_k_m.gguf'],
      );
      expect(result).toBe('mmproj-llama-3.1-vision-q5_k_m.gguf');
    });

    // Test case 3: Exact quantization match
    it('returns the projection model with exact quantization match', () => {
      const result = getRecommendedProjectionModel(
        'llama-3.1-8b-instruct-q4_0.gguf',
        [
          'mmproj-llama-3.1-vision-q5_k_m.gguf',
          'mmproj-llama-3.1-vision-q4_0.gguf',
          'mmproj-llama-3.1-vision-q8_0.gguf',
        ],
      );
      expect(result).toBe('mmproj-llama-3.1-vision-q4_0.gguf');
    });

    // Test case 4: Higher quality quantization when exact match not found
    it('returns a higher quality projection model when exact match not found', () => {
      const result = getRecommendedProjectionModel(
        'llama-3.1-8b-instruct-q4_0.gguf',
        [
          'mmproj-llama-3.1-vision-q5_k_m.gguf',
          'mmproj-llama-3.1-vision-q8_0.gguf',
        ],
      );
      expect(result).toBe('mmproj-llama-3.1-vision-q5_k_m.gguf');
    });

    // Test case 5: First available when no match or higher quality found
    it('returns the first available projection model when no match or higher quality found', () => {
      const result = getRecommendedProjectionModel(
        'llama-3.1-8b-instruct-q6_k.gguf',
        [
          'mmproj-llama-3.1-vision-q4_0.gguf',
          'mmproj-llama-3.1-vision-q5_k_m.gguf',
        ],
      );
      // this fails since q5 is the highest quality that should have been returned in cases of no match or higher quality found but Received: "mmproj-llama-3.1-vision-q4_0.gguf"
      expect(result).toBe('mmproj-llama-3.1-vision-q5_k_m.gguf');
    });

    // Test case 6: Case insensitivity
    it('handles case insensitivity in quantization levels', () => {
      const result = getRecommendedProjectionModel(
        'llama-3.1-8b-instruct-q4_0.gguf',
        [
          'mmproj-llama-3.1-vision-q5_k_m.gguf',
          'mmproj-llama-3.1-vision-Q4.gguf',
          'mmproj-llama-3.1-vision-q8_0.gguf',
        ],
      );
      expect(result).toBe('mmproj-llama-3.1-vision-Q4.gguf');
    });

    // Test case 7: Different quantization formats
    it('handles different quantization formats correctly', () => {
      const result = getRecommendedProjectionModel(
        'llama-3.1-8b-instruct-q4.gguf', // Using dot instead of underscore
        [
          'mmproj-llama-3.1-vision-q4_0.gguf',
          'mmproj-llama-3.1-vision-q5_k_m.gguf',
        ],
      );
      expect(result).toBe('mmproj-llama-3.1-vision-q4_0.gguf');
    });

    // Test case 8: No quantization in LLM filename
    it('returns first available when LLM has no quantization in filename', () => {
      const result = getRecommendedProjectionModel(
        'llama-3.1-8b-instruct.gguf', // No quantization
        [
          'mmproj-llama-3.1-vision-q4_0.gguf',
          'mmproj-llama-3.1-vision-q5_k_m.gguf',
          'mmproj-llama-3.1-vision-q8_0.gguf',
        ],
      );
      // this fails since q8 is the highest quality but Received: "mmproj-llama-3.1-vision-q4_0.gguf"
      expect(result).toBe('mmproj-llama-3.1-vision-q8_0.gguf');
    });

    // Test case 9: Different quantization prefixes (iq vs q)
    it('handles different quantization prefixes correctly', () => {
      const result = getRecommendedProjectionModel(
        'llama-3.1-8b-instruct-iq4_xs.gguf', // Using iq prefix
        [
          'mmproj-llama-3.1-vision-q3_0.gguf',
          'mmproj-llama-3.1-vision-Q4.gguf',
          'mmproj-llama-3.1-vision-q8_0.gguf',
        ],
      );
      expect(result).toBe('mmproj-llama-3.1-vision-Q4.gguf');
    });

    // Test case 10: Edge case with unusual quantization format
    it('handles edge cases with unusual quantization formats', () => {
      const result = getRecommendedProjectionModel(
        'llama-3.1-8b-instruct-Q4-K.gguf', // Using hyphen instead of underscore
        [
          'mmproj-llama-3.1-vision-q4_k.gguf',
          'mmproj-llama-3.1-vision-q5_k_m.gguf',
        ],
      );
      expect(result).toBe('mmproj-llama-3.1-vision-q4_k.gguf');
    });
  });
});



================================================
FILE: src/utils/__tests__/thinkingCapabilityDetection.test.ts
================================================
/**
 * Tests for thinking capability detection utilities
 */

import {
  supportsThinking,
  templateSupportsThinking,
} from '../thinkingCapabilityDetection';
import {Model} from '../types';

// Mock model for testing
const createMockModel = (name: string, chatTemplate?: string): Model => ({
  id: `test-${name}`,
  name,
  size: 1000000,
  isDownloaded: true,
  origin: 'HF' as any,
  chatTemplate: chatTemplate
    ? {
        chatTemplate,
        addGenerationPrompt: true,
        name: 'test',
        bosToken: '<s>',
        eosToken: '</s>',
      }
    : {
        chatTemplate: '',
        addGenerationPrompt: true,
        name: 'test',
        bosToken: '<s>',
        eosToken: '</s>',
      },
  // Add other required Model properties with default values
  hfModel: {} as any,
  modelType: 'LLM' as any,
  stopWords: [],
  defaultStopWords: [],
  defaultChatTemplate: {
    chatTemplate: '',
    addGenerationPrompt: true,
    name: 'test',
    bosToken: '<s>',
    eosToken: '</s>',
  },
  isLocal: false,
  downloadSpeed: '0 MB/s',
  // Add minimal required properties
  author: 'test',
  params: 1000000,
  downloadUrl: 'test://url',
  hfUrl: 'test://hf',
  progress: 0,
  filename: 'test.gguf',
  defaultCompletionSettings: {} as any,
  completionSettings: {} as any,
});

describe('templateSupportsThinking', () => {
  it('should return false for empty or null template', () => {
    expect(templateSupportsThinking('')).toBe(false);
    expect(templateSupportsThinking(null as any)).toBe(false);
    expect(templateSupportsThinking(undefined as any)).toBe(false);
  });

  it('should detect thinking tokens in templates', () => {
    expect(templateSupportsThinking('Some template with <think> token')).toBe(
      true,
    );
    expect(templateSupportsThinking('Template with </think> closing tag')).toBe(
      true,
    );
    expect(templateSupportsThinking('Has assistant_thoughts capability')).toBe(
      true,
    );
    expect(templateSupportsThinking('Supports reasoning_format')).toBe(true);
    expect(templateSupportsThinking('Uses <|start_thinking|> format')).toBe(
      true,
    );
    expect(templateSupportsThinking('Uses <|end_thinking|> format')).toBe(true);
  });

  it('should detect DeepSeek-R1 patterns', () => {
    expect(
      templateSupportsThinking('deepseek model with <think> support'),
    ).toBe(true);
    expect(templateSupportsThinking('DeepSeek-R1 thinking capabilities')).toBe(
      true,
    );
    expect(templateSupportsThinking('DEEPSEEK with thinking mode')).toBe(true);
  });

  it('should detect Cohere Command-R patterns', () => {
    expect(templateSupportsThinking('cohere model with thinking support')).toBe(
      true,
    );
    expect(
      templateSupportsThinking('Cohere Command-R reasoning capabilities'),
    ).toBe(true);
    expect(templateSupportsThinking('COHERE with reasoning mode')).toBe(true);
  });

  it('should detect Qwen-3 patterns', () => {
    expect(templateSupportsThinking('qwen model with thinking support')).toBe(
      true,
    );
    expect(templateSupportsThinking('Qwen-3 thinking capabilities')).toBe(true);
  });

  it('should return false for templates without thinking support', () => {
    expect(templateSupportsThinking('Regular chat template')).toBe(false);
    expect(templateSupportsThinking('Standard model template')).toBe(false);
    expect(templateSupportsThinking('No special capabilities')).toBe(false);
  });

  it('should be case insensitive', () => {
    expect(templateSupportsThinking('TEMPLATE WITH <THINK> TOKEN')).toBe(true);
    expect(templateSupportsThinking('template with ASSISTANT_THOUGHTS')).toBe(
      true,
    );
    expect(templateSupportsThinking('DEEPSEEK WITH THINKING')).toBe(true);
  });
});

describe('supportsThinking', () => {
  it('should detect thinking support based on model architecture', async () => {
    const mockModel = createMockModel('Test-Model');
    mockModel.hfModel = {
      specs: {
        gguf: {
          architecture: 'qwen3',
        },
      },
    } as any;

    expect(await supportsThinking(mockModel)).toBe(true);
  });

  it('should detect thinking support based on chat template', async () => {
    const modelWithThinkingTemplate = createMockModel(
      'Regular-Model',
      'Template with <think> support',
    );
    expect(await supportsThinking(modelWithThinkingTemplate)).toBe(true);

    const modelWithoutThinkingTemplate = createMockModel(
      'Regular-Model',
      'Standard template',
    );
    expect(await supportsThinking(modelWithoutThinkingTemplate)).toBe(false);
  });

  it('should return false for models without thinking support', async () => {
    const regularModel = createMockModel('Llama-3.1-8B-Instruct');
    expect(await supportsThinking(regularModel)).toBe(false);

    const gemmaModel = createMockModel('Gemma-2-9B-IT');
    expect(await supportsThinking(gemmaModel)).toBe(false);
  });

  it('should handle models without chat templates', async () => {
    const modelWithoutTemplate = createMockModel('SmolLM3-1.7B');
    modelWithoutTemplate.hfModel = {
      specs: {
        gguf: {
          architecture: 'qwen3',
        },
      },
    } as any;
    expect(await supportsThinking(modelWithoutTemplate)).toBe(true);

    const regularModelWithoutTemplate = createMockModel('Llama-3.1-8B');
    expect(await supportsThinking(regularModelWithoutTemplate)).toBe(false);
  });
});



================================================
FILE: src/utils/__tests__/utils.test.ts
================================================
import {
  deepMerge,
  extractHFModelTitle,
  extractHFModelType,
  extractModelPrecision,
  formatBytes,
  getTextSizeInBytes,
  safeParseJSON,
  unwrap,
} from '..';

describe('formatBytes', () => {
  it('formats bytes correctly when the size is 0', () => {
    expect.assertions(1);
    expect(formatBytes(0)).toBe('0 B');
  });

  it('formats kiB correctly', () => {
    expect.assertions(1);
    expect(formatBytes(1024, 2, true)).toBe('1 KiB');
  });

  it('formats GiB correctly', () => {
    expect.assertions(1);
    expect(formatBytes(1024 * 1024 * 1024, 2, true)).toBe('1 GiB');
  });

  it('formats MB correctly', () => {
    expect.assertions(1);
    expect(formatBytes(1234567, 2, false)).toBe('1.23 MB');
  });

  it('formats GB correctly', () => {
    expect.assertions(1);
    expect(formatBytes(12345678901, 2, false)).toBe('12.35 GB');
  });

  it('formats correctly with three digits with 2 decimals', () => {
    expect.assertions(1);
    expect(formatBytes(1234567890, 2, false, true)).toBe('1.23 GB');
  });

  it('formats correctly with three digits with 1 decimals', () => {
    expect.assertions(1);
    expect(formatBytes(12345678901, 2, false, true)).toBe('12.3 GB');
  });

  it('formats correctly with three digits with 0 decimals', () => {
    expect.assertions(1);
    expect(formatBytes(123456789000, 2, false, true)).toBe('123 GB');
  });
});

describe('getTextSizeInBytes', () => {
  it('calculates the size for a simple text', () => {
    expect.assertions(1);
    const text = 'text';
    expect(getTextSizeInBytes(text)).toBe(4);
  });

  it('calculates the size for an emoji text', () => {
    expect.assertions(1);
    const text = 'ü§î ü§ì';
    expect(getTextSizeInBytes(text)).toBe(9);
  });
});

describe('unwrap', () => {
  it('returns an empty object', () => {
    expect.assertions(1);
    expect(unwrap(undefined)).toStrictEqual({});
  });

  it('returns a provided prop', () => {
    expect.assertions(1);
    const prop = 'prop';
    expect(unwrap(prop)).toStrictEqual(prop);
  });
});

describe('deepMerge', () => {
  it('should merge two flat objects', () => {
    const target = {a: 1, b: 2};
    const source = {b: 3, c: 4};
    const result = deepMerge(target, source);
    expect(result).toEqual({a: 1, b: 2, c: 4}); // b should remain 2
  });

  it('should merge nested objects', () => {
    const target = {a: {b: 1}};
    const source = {a: {c: 2}};
    const result = deepMerge(target, source);
    expect(result).toEqual({a: {b: 1, c: 2}}); // c should be added
  });

  it('should overwrite nested properties', () => {
    const target = {a: {b: 1, c: 2}};
    const source = {a: {b: 3}};
    const result = deepMerge(target, source);
    expect(result).toEqual({a: {b: 1, c: 2}}); // b should remain 1
  });

  it('should handle arrays correctly', () => {
    const target = {a: [1, 2]};
    const source = {a: [3, 4]};
    const result = deepMerge(target, source);
    expect(result).toEqual({a: [1, 2]});
  });

  it('should handle null values', () => {
    const target = {a: null};
    const source = {a: {b: 1}};
    const result = deepMerge(target, source);
    expect(result).toEqual({a: {b: 1}}); // Replaces null with the object
  });

  it('should handle flat to nested', () => {
    const target = {a: 1, c: {d: 2, e: 3}};
    const source = {a: {b: 1}, c: 4};
    const result = deepMerge(target, source);
    expect(result).toEqual({a: {b: 1}, c: 4});
  });

  it('should not modify the original objects', () => {
    const target = {a: 1};
    const source = {b: 2};
    deepMerge(target, source);
    expect(target).toEqual({a: 1, b: 2});
    expect(source).toEqual({b: 2}); // Source should remain unchanged
  });

  it('should handle empty objects', () => {
    const target = {};
    const source = {a: 1};
    const result = deepMerge(target, source);
    expect(result).toEqual({a: 1}); // Merges from source
  });

  it('should handle deeply nested objects', () => {
    const target = {a: {b: {c: 1}}};
    const source = {a: {b: {d: 2}}};
    const result = deepMerge(target, source);
    expect(result).toEqual({a: {b: {c: 1, d: 2}}});
  });

  it('should merge multiple levels of nesting', () => {
    const target = {a: {b: {c: {d: 1, e: 3}}}};
    const source = {a: {b: {c: {e: 2, f: 4}}}};
    const result = deepMerge(target, source);
    expect(result).toEqual({a: {b: {c: {d: 1, e: 3, f: 4}}}});
  });
});

describe('extractHFModelType', () => {
  test('extracts model type correctly', () => {
    expect(
      extractHFModelType('bartowski/Llama-3.1-Nemotron-70B-Instruct-HF-GGUF'),
    ).toBe('Llama');
    expect(extractHFModelType('author/Giraffe-2.0-Model-Guide-Example')).toBe(
      'Giraffe',
    );
    expect(extractHFModelType('foo/Bar-1.0-Test')).toBe('Bar');
    expect(extractHFModelType('invalidInputWithoutSlashOrHyphen')).toBe(
      'Unknown',
    );
    expect(extractHFModelType('slashOnly/')).toBe('Unknown');
    expect(extractHFModelType('owner/modelWithoutSuffix')).toBe(
      'modelWithoutSuffix',
    );
  });
});

describe('extractHFModelTitle', () => {
  test('extracts model title correctly', () => {
    expect(
      extractHFModelTitle('bartowski/Llama-3.1-Nemotron-70B-Instruct-HF-GGUF'),
    ).toBe('Llama-3.1-Nemotron-70B-Instruct-HF');
    expect(
      extractHFModelTitle('bartowski/Llama-3.1-Nemotron-70B-Instruct-HF_gguf'),
    ).toBe('Llama-3.1-Nemotron-70B-Instruct-HF');
    expect(
      extractHFModelTitle('bartowski/Llama-3.1-Nemotron-70B-Instruct-HFGGUF'),
    ).toBe('Llama-3.1-Nemotron-70B-Instruct-HF');
    expect(extractHFModelTitle('author/Giraffe-2.0-Model-Guide-Example')).toBe(
      'Giraffe-2.0-Model-Guide-Example',
    );
    expect(extractHFModelTitle('foo/Bar-1.0-Test')).toBe('Bar-1.0-Test');
    expect(extractHFModelTitle('withoutSlashOrHyphen')).toBe(
      'withoutSlashOrHyphen',
    );
    expect(extractHFModelTitle('slashOnly/')).toBe('Unknown');
    expect(extractHFModelTitle('owner/modelWithoutSuffix')).toBe(
      'modelWithoutSuffix',
    );
  });
});

describe('safeParseJSON', () => {
  // Case 1: Normal valid JSON
  test('parses valid JSON correctly', () => {
    const validJson = '{"prompt": "Hello world"}';
    expect(safeParseJSON(validJson)).toEqual({prompt: 'Hello world'});
  });

  // Case 2: JSON with trailing text
  test('parses JSON with trailing text', () => {
    const jsonWithTrailing = '{"prompt": "Hello world"} Some extra text here';
    expect(safeParseJSON(jsonWithTrailing)).toEqual({prompt: 'Hello world'});
  });

  // Case 3: Incomplete JSON missing closing brace
  test('handles incomplete JSON with missing closing brace', () => {
    const incompleteJson = '{"prompt": "Hello world';
    expect(safeParseJSON(incompleteJson)).toEqual({prompt: 'Hello world'});
  });

  // Additional edge cases
  test('handles different quote styles and spacing around prompt key', () => {
    const variations = [
      '{"prompt" : "Hello"}',
      '{"prompt"  :  "Hello"}',
      '{"prompt"\n:\n"Hello"}',
    ];

    variations.forEach(json => {
      expect(safeParseJSON(json)).toHaveProperty('prompt', 'Hello');
    });
  });

  test('returns null for invalid JSON', () => {
    const invalidCases = ['', 'not json at all', '{notEvenJson}'];

    invalidCases.forEach(invalid => {
      expect(safeParseJSON(invalid)).toEqual({
        prompt: '',
        error: expect.any(Error),
      });
    });
  });

  // Additional tests for extractModelPrecision function
  describe('extractModelPrecision', () => {
    it('extracts standard quantization levels correctly', () => {
      expect(extractModelPrecision('model-q1_M.gguf')).toBe('q1');
      expect(extractModelPrecision('model-q2_M.gguf')).toBe('q2');
      expect(extractModelPrecision('model-q2.gguf')).toBe('q2');
      expect(extractModelPrecision('model-iq4_xs.gguf')).toBe('q4');
      expect(extractModelPrecision('model-q4_0.gguf')).toBe('q4');
      expect(extractModelPrecision('model-q4.0.gguf')).toBe('q4');
      expect(extractModelPrecision('model-q4-0.gguf')).toBe('q4');
      expect(extractModelPrecision('model-Q4_k_m.gguf')).toBe('q4');
      expect(extractModelPrecision('model-IQ4_XS.gguf')).toBe('q4');
      expect(extractModelPrecision('model-q5_k_m.gguf')).toBe('q5');
      expect(extractModelPrecision('model-q6_k_m.gguf')).toBe('q6');
      expect(extractModelPrecision('model-q8_0.gguf')).toBe('q8');
      expect(extractModelPrecision('model-f16.gguf')).toBe('f16');
      expect(extractModelPrecision('model-bf16.gguf')).toBe('bf16');
      expect(extractModelPrecision('model-f32.gguf')).toBe('f32');
    });
  });
});



================================================
FILE: .github/FUNDING.yml
================================================
github: a-ghorbani
buy_me_a_coffee: aghorbani
custom: ["https://paypal.me/AsgharGhorbani"]



================================================
FILE: .github/PULL_REQUEST_TEMPLATE.md
================================================
## Description

Provide a brief description of the changes made and the issue(s) this resolves.

Fixes # (issue number)

## Platform Affected

- [ ] iOS
- [ ] Android

## Checklist

- [ ] Necessary comments have been made.
- [ ] I have tested this change on:
  - [ ] iOS Simulator/Device
  - [ ] Android Emulator/Device
- [ ] Unit tests and integration tests pass locally.



================================================
FILE: .github/ISSUE_TEMPLATE/bug_report.md
================================================
---
name: Bug report
about: Create a report to help us improve
title: "[Bug]: "
labels: bug
assignees: ''

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '...'
3. Scroll down to '...'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Environment (please complete the following information):**
- Device: [e.g., iPhone 12]
- OS: [e.g., iOS 14.4, Android 11]
- App Version: [e.g., 1.0.0]

**Additional context**
Add any other context about the problem here.



================================================
FILE: .github/ISSUE_TEMPLATE/config.yml
================================================
blank_issues_enabled: false





================================================
FILE: .github/ISSUE_TEMPLATE/custom_template.md
================================================
---
name: General issue
about: Use this for general issues or questions (when it is not a bug or feature request)
title: "[General]: "
labels: question
assignees: ''

---

**Issue description**
Provide a clear and concise description of your issue.

**Context**
Provide any relevant information that might help resolve the issue.



================================================
FILE: .github/ISSUE_TEMPLATE/feature_request.md
================================================
---
name: Feature request
about: Suggest an idea for this project
title: "[Feat]: "
labels: enhancement
assignees: ''

---

**Description**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]
What would you like to see implemented? A clear and concise description of what you want to happen.

**Use Case**
Describe a scenario where this feature could come handy.





================================================
FILE: .github/workflows/ci.yml
================================================
name: CI Pipeline

on:
  pull_request:
    branches:
      - main
  push:
    branches:
      - main

permissions:
  contents: read

jobs:
  # Job for linting, type checking, unit testing
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      # Step 1: Check out the repository
      - name: Check out code
        uses: actions/checkout@v3

      # Cache node_modules
      - name: Cache node_modules
        uses: actions/cache@v3
        with:
          path: node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('yarn.lock') }}

      # Step 2: Set up Node.js environment
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install Yarn
        run: npm install -g yarn

      # Step 3: Install dependencies and iOS Pods
      - name: Install dependencies
        run: yarn install

      # Step 4: Run linters (ESLint)
      - name: Run ESLint
        run: yarn lint

      # Step 5: Run TypeScript type checks
      - name: Run TypeScript type check
        run: yarn typecheck

      # Step 6: Run unit tests (Jest)
      - name: Run unit tests
        run: yarn test --coverage

  # Job for Android build
  build-android:
    runs-on: ubuntu-latest
    needs: build-and-test
    steps:
      - name: Check out code
        uses: actions/checkout@v3

      # Cache node_modules
      - name: Cache node_modules
        uses: actions/cache@v3
        with:
          path: node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('yarn.lock') }}

      - name: Install Yarn
        run: npm install -g yarn

      - name: Install dependencies
        run: yarn install

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'gradle'

      - name: Create dummy google-services.json for CI
        run: |
          cat > android/app/google-services.json << 'EOL'
          {
            "project_info": {
              "project_number": "000000000000",
              "project_id": "dummy-project-for-ci",
              "storage_bucket": "dummy-project-for-ci.appspot.com"
            },
            "client": [{
              "client_info": {
                "mobilesdk_app_id": "1:000000000000:android:0000000000000000",
                "android_client_info": {
                  "package_name": "com.pocketpalai"
                }
              },
              "api_key": [{
                "current_key": "dummy-api-key-for-ci-builds"
              }]
            }]
          }
          EOL

      - name: Build Android
        run: yarn build:android # TODO: change to build:android:release

      - name: Upload Android APK
        uses: actions/upload-artifact@v4
        with:
          name: android-debug-apk # TODO: change to release-apk
          path: android/app/build/outputs/apk/debug/app-debug.apk

  # Job for iOS build
  build-ios:
    runs-on: macos-15  # macOS 15 with Xcode 16
    needs: build-and-test
    steps:
      - name: Check out code
        uses: actions/checkout@v3

      # Cache node_modules
      - name: Cache node_modules
        uses: actions/cache@v3
        with:
          path: node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('yarn.lock') }}

      - name: Install Yarn
        run: npm install -g yarn

      - name: Install dependencies
        run: yarn install
      
      - name: Install CocoaPods dependencies
        run: |
          cd ios
          pod install
          cd ..

      - name: Build iOS
        run: yarn ios:build



================================================
FILE: .github/workflows/release.yml
================================================
name: Release Workflow

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: "Type of version bump (major, minor, patch, premajor, preminor, prepatch, prerelease)"
        required: true
        default: "patch"
        type: choice
        options:
          - major
          - minor
          - patch
          - premajor
          - preminor
          - prepatch
          - prerelease

jobs:
  # Job 1: Version Bumping and Android Build
  build_android:
    runs-on: ubuntu-latest
    permissions:
      contents: 'write' # Allows workflow to checkout repository code
      id-token: 'write' # Required for Google Cloud Workload Identity Federation authentication (OIDC token generation)

    steps:
      # Step 1: Checkout the code
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Important for git history
          ssh-key: ${{ secrets.DEPLOY_KEY }}

      # Step 2: Set up JDK 17
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      # Step 3: Set up Node.js
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20.18.0' # Use the specified Node.js version
          cache: 'yarn'

      # Step 4: Install dependencies using Yarn
      - name: Install dependencies
        run: yarn install

      # Step 5: Set up Ruby and Bundler
      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2.3'  # Specify a Ruby version
          bundler-cache: true

      # Step 6: Combined version bump
      - name: Bump versions
        working-directory: ${{ github.workspace }}
        run: bundle exec fastlane bump_version version_type:${{ github.event_name == 'workflow_dispatch' && github.event.inputs.version_type || 'patch' }}

      # Step 7: Commit and push version changes
      - name: Commit and push version changes
        run: |
          echo "VERSION=$(cat .version)" >> $GITHUB_ENV
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add .version package.json android/app/build.gradle ios/PocketPal.xcodeproj/project.pbxproj
          git commit -m "chore(release): bump version to ${{ env.VERSION }}"
          git push
          git tag "v${{ env.VERSION }}"
          git push origin "v${{ env.VERSION }}"

      # Step 8: Set up Android Keystore
      - name: Set up Android Keystore
        working-directory: android
        run: |
          echo "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" | base64 --decode > app/pocketpal-release-key.keystore

      # Step 9: Authenticate to Google Cloud
      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with:
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}
          workload_identity_provider: ${{ secrets.WORKLOAD_IDENTITY_PROVIDER }}
          create_credentials_file: true

      # Add this step before the Android build
      - name: Create .env file
        run: |
          echo "FIREBASE_FUNCTIONS_URL=${{ vars.FIREBASE_FUNCTIONS_URL }}" > .env

      # Step 10: Build and upload Android app to Alpha track (includes building APK and Bundle)
      - name: Build and upload Android app
        working-directory: android
        env:
          KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
          KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
          KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}
          GRADLE_USER_HOME: ${{ runner.temp }}/.gradle
          #  GOOGLE_APPLICATION_CREDENTIALS: ${{ steps.auth.outputs.credentials_file_path }} # This is not supported by fastlane, we need to replace it with PLAY_STORE_JSON_KEY in the future.
          PLAY_STORE_JSON_KEY: ${{ secrets.PLAY_STORE_SERVICE_ACCOUNT_JSON }}
          GOOGLE_SERVICES_JSON: ${{ secrets.GOOGLE_SERVICES_JSON }}
        run: |
          echo "$PLAY_STORE_JSON_KEY" > play-store-key.json
          bundle exec fastlane release_android_alpha

      # Step 11: Create GitHub Release with APK
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: android/app/build/outputs/apk/release/app-release.apk
          tag_name: "v${{ env.VERSION }}"
          name: "Release v${{ env.VERSION }}"
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Job 2: iOS Build and Upload (runs on macOS)
  build_ios:
    runs-on: macos-15 # macOS 15 with Xcode 16
    needs: build_android

    steps:
      - name: Checkout code    # Replace the Download code step
        uses: actions/checkout@v3
        with:
          ref: ${{ github.ref }}    # This ensures we get the latest changes including the version bump

      # Step 2: Set up Node.js
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20.18.0'
          cache: 'yarn'

      # Step 3: Install dependencies using Yarn
      - name: Install dependencies
        run: yarn install

      # Step 4: Set up Ruby and Bundler
      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2.3'  # Specify a Ruby version
          bundler-cache: true

      # Step 5: Install CocoaPods dependencies
      - name: Install CocoaPods dependencies
        working-directory: ios
        run: pod install

      # Add this step before the iOS build
      - name: Create .env file
        run: |
          echo "FIREBASE_FUNCTIONS_URL=${{ vars.FIREBASE_FUNCTIONS_URL }}" > .env

      # Step 6: Build and upload iOS app to TestFlight
      - name: Build and upload iOS app
        working-directory: ios
        env:
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
          MATCH_GITHUB_TOKEN: ${{ secrets.MATCH_GITHUB_TOKEN }}
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_API_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_API_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_CONTENT: ${{ secrets.APP_STORE_CONNECT_API_KEY_CONTENT }}
          APP_STORE_CONNECT_USER_ID: ${{ secrets.APP_STORE_CONNECT_USER_ID }}
          GOOGLE_SERVICES_PLIST: ${{ secrets.GOOGLE_SERVICES_PLIST }}
        run: bundle exec fastlane release_ios_testflight



================================================
FILE: .husky/commit-msg
================================================
yarn --silent commitlint --edit "$1"


