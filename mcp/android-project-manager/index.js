#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

/**
 * Android Project Manager - Automates Android project file management and builds
 * 
 * Usage:
 *   node android-project-manager add-file <file-path> <package-path>
 *   node android-project-manager build [task]
 *   node android-project-manager clean
 *   node android-project-manager verify
 *   node android-project-manager lint
 * 
 * Examples:
 *   node android-project-manager add-file LocationAuthorizationScreen.kt ui.screens
 *   node android-project-manager build compileDebugKotlin
 *   node android-project-manager lint
 */

const PROJECT_ROOT = path.resolve(__dirname, '../../mobile/android');
const APP_PATH = path.join(PROJECT_ROOT, 'app');
const SRC_PATH = path.join(APP_PATH, 'src/main/java/com/roadtrip/copilot');
const BUILD_GRADLE_PATH = path.join(APP_PATH, 'build.gradle');
const MANIFEST_PATH = path.join(APP_PATH, 'src/main/AndroidManifest.xml');

// Parse command line arguments
const command = process.argv[2];
const args = process.argv.slice(3);

switch (command) {
    case 'add-file':
        addFileToProject(args[0], args[1]);
        break;
    case 'build':
        buildProject(args[0]);
        break;
    case 'clean':
        cleanProject();
        break;
    case 'verify':
        verifyProject();
        break;
    case 'lint':
        lintProject();
        break;
    case 'help':
    case '--help':
    case '-h':
        showHelp();
        break;
    default:
        console.error('Unknown command:', command);
        showHelp();
        process.exit(1);
}

function addFileToProject(fileName, packagePath) {
    if (!fileName || !packagePath) {
        console.error('Error: File name and package path are required');
        console.error('Usage: add-file <file-name> <package-path>');
        console.error('Example: add-file LocationAuthorizationScreen.kt ui.screens');
        process.exit(1);
    }

    console.log(`üìÅ Adding ${fileName} to Android project...`);

    try {
        // Create the full package directory path
        const fullPackagePath = path.join(SRC_PATH, packagePath.replace(/\\./g, '/'));
        const filePath = path.join(fullPackagePath, fileName);
        
        console.log(`   üìÇ Package: com.roadtrip.copilot.${packagePath}`);
        console.log(`   üìÑ File: ${fileName}`);
        console.log(`   üìç Path: ${filePath}`);
        
        // Create directory if it doesn't exist
        if (!fs.existsSync(fullPackagePath)) {
            fs.mkdirSync(fullPackagePath, { recursive: true });
            console.log(`   ‚úÖ Created directory: ${fullPackagePath}`);
        }
        
        // Determine file type and generate appropriate template
        const fileExtension = path.extname(fileName);
        let fileContent = '';
        
        if (fileExtension === '.kt') {
            fileContent = generateKotlinTemplate(fileName, packagePath);
        } else if (fileExtension === '.java') {
            fileContent = generateJavaTemplate(fileName, packagePath);
        } else if (fileExtension === '.xml') {
            fileContent = generateXmlTemplate(fileName);
        } else {
            // Generic file
            fileContent = `// ${fileName}\\n// Generated by Android Project Manager\\n`;
        }
        
        // Write the file if it doesn't exist
        if (fs.existsSync(filePath)) {
            console.log(`   ‚ö†Ô∏è  File already exists: ${fileName}`);
        } else {
            fs.writeFileSync(filePath, fileContent);
            console.log(`   ‚úÖ Created file: ${fileName}`);
            console.log(`   üìù Template: ${getTemplateType(fileExtension)} generated`);
        }
        
        // Check if any dependencies need to be added based on file content
        checkAndUpdateDependencies(fileContent);
        
        console.log(`‚úÖ Successfully processed ${fileName}`);
        
    } catch (error) {
        console.error('‚ùå Error adding file to project:', error.message);
        process.exit(1);
    }
}

function buildProject(task = 'compileDebugKotlin') {
    console.log(`üî® Building Android project (${task})...`);
    
    try {
        const buildCommand = `cd "${PROJECT_ROOT}" && ./gradlew ${task}`;
        console.log(`   üöÄ Running: ./gradlew ${task}`);
        
        const startTime = Date.now();
        const output = execSync(buildCommand, { encoding: 'utf8', stdio: 'pipe' });
        const duration = ((Date.now() - startTime) / 1000).toFixed(1);
        
        // Parse build output for analysis
        const warnings = (output.match(/warning:/g) || []).length;
        const errors = (output.match(/error:/g) || []).length;
        const deprecations = (output.match(/deprecated/gi) || []).length;
        
        if (output.includes('BUILD SUCCESSFUL')) {
            console.log(`‚úÖ Build SUCCESSFUL (${duration}s)`);
            if (warnings > 0) {
                console.log(`   ‚ö†Ô∏è  Warnings: ${warnings}`);
            }
            if (deprecations > 0) {
                console.log(`   üîÑ Deprecation warnings: ${deprecations}`);
            }
            
            // Show build summary
            if (output.includes('actionable tasks:')) {
                const taskSummary = output.match(/\\d+ actionable tasks: [^\\n]+/);
                if (taskSummary) {
                    console.log(`   üìä ${taskSummary[0]}`);
                }
            }
            
        } else {
            console.log('‚ùå Build FAILED');
            console.log(`   üêõ Errors: ${errors}`);
            console.log(`   ‚ö†Ô∏è  Warnings: ${warnings}`);
            
            // Extract and show compilation errors
            const errorLines = output.split('\\n').filter(line => 
                line.includes('error:') || 
                line.includes('Unresolved reference:') ||
                line.includes('Type mismatch:') ||
                line.includes('Cannot find')
            );
            
            if (errorLines.length > 0) {
                console.log('\\nüìã Compilation Errors:');
                errorLines.slice(0, 15).forEach(line => {
                    console.log(`   ${line.trim()}`);
                });
                if (errorLines.length > 15) {
                    console.log(`   ... and ${errorLines.length - 15} more errors`);
                }
            }
            process.exit(1);
        }
        
    } catch (error) {
        console.error('‚ùå Build failed:', error.message);
        
        // Parse stderr for Gradle-specific errors
        if (error.stderr) {
            console.log('\\nüìã Build Error Details:');
            const errorLines = error.stderr.split('\\n').filter(line => 
                line.trim() && !line.includes('Daemon') && !line.includes('WARNING')
            );
            errorLines.slice(0, 10).forEach(line => console.log(`   ${line.trim()}`));
        }
        process.exit(1);
    }
}

function cleanProject() {
    console.log('üßπ Cleaning Android project...');
    
    try {
        const cleanCommand = `cd "${PROJECT_ROOT}" && ./gradlew clean`;
        const output = execSync(cleanCommand, { encoding: 'utf8', stdio: 'inherit' });
        console.log('‚úÖ Project cleaned successfully');
    } catch (error) {
        console.error('‚ùå Clean failed:', error.message);
        process.exit(1);
    }
}

function lintProject() {
    console.log('üîç Running Android lint analysis...');
    
    try {
        const lintCommand = `cd "${PROJECT_ROOT}" && ./gradlew lint`;
        const output = execSync(lintCommand, { encoding: 'utf8', stdio: 'pipe' });
        
        if (output.includes('BUILD SUCCESSFUL')) {
            console.log('‚úÖ Lint analysis completed');
            
            // Look for lint results
            const lintResults = output.match(/Lint found \\d+ issues/);
            if (lintResults) {
                console.log(`   üìä ${lintResults[0]}`);
            }
            
            // Check for lint report file
            const reportPath = path.join(PROJECT_ROOT, 'app/build/reports/lint-results.html');
            if (fs.existsSync(reportPath)) {
                console.log(`   üìÑ Report: ${reportPath}`);
            }
        }
        
    } catch (error) {
        console.log('‚ö†Ô∏è  Lint analysis completed with issues');
        if (error.stdout && error.stdout.includes('Lint found')) {
            const issues = error.stdout.match(/Lint found \\d+ issues/);
            if (issues) {
                console.log(`   üìä ${issues[0]}`);
            }
        }
    }
}

function verifyProject() {
    console.log('üîç Verifying Android project structure...');
    
    const requiredFiles = [
        { path: path.join(APP_PATH, 'build.gradle'), name: 'build.gradle' },
        { path: MANIFEST_PATH, name: 'AndroidManifest.xml' },
        { path: path.join(PROJECT_ROOT, 'settings.gradle'), name: 'settings.gradle' },
        { path: path.join(PROJECT_ROOT, 'gradlew'), name: 'gradlew' }
    ];
    
    let isValid = true;
    
    requiredFiles.forEach(file => {
        if (fs.existsSync(file.path)) {
            console.log(`   ‚úÖ ${file.name}`);
        } else {
            console.log(`   ‚ùå Missing: ${file.name}`);
            isValid = false;
        }
    });
    
    if (isValid) {
        // Count source files
        const kotlinFiles = getFileCount(SRC_PATH, '.kt');
        const javaFiles = getFileCount(SRC_PATH, '.java');
        const xmlFiles = getFileCount(path.join(APP_PATH, 'src/main/res'), '.xml');
        
        console.log(`\\nüìä Project Statistics:`);
        console.log(`   üìÑ Kotlin files: ${kotlinFiles}`);
        console.log(`   üìÑ Java files: ${javaFiles}`);
        console.log(`   üìÑ XML files: ${xmlFiles}`);
        
        // Check Gradle version
        try {
            const gradleVersion = execSync(`cd "${PROJECT_ROOT}" && ./gradlew --version`, { encoding: 'utf8' });
            const versionMatch = gradleVersion.match(/Gradle ([\\d.]+)/);
            if (versionMatch) {
                console.log(`   üîß Gradle: ${versionMatch[1]}`);
            }
        } catch (e) {
            console.log(`   ‚ö†Ô∏è  Could not determine Gradle version`);
        }
        
        console.log('\\n‚úÖ Project structure is valid');
    } else {
        console.log('\\n‚ùå Project structure has issues');
        process.exit(1);
    }
}

// Helper functions
function generateKotlinTemplate(fileName, packagePath) {
    const className = path.basename(fileName, '.kt');
    const fullPackage = `com.roadtrip.copilot.${packagePath}`;
    
    if (fileName.includes('Screen') || fileName.includes('View')) {
        return `package ${fullPackage}

import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier

@Composable
fun ${className}() {
    // TODO: Implement ${className}
}
`;
    } else if (fileName.includes('Manager') || fileName.includes('Service')) {
        return `package ${fullPackage}

import androidx.lifecycle.ViewModel
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject

@HiltViewModel
class ${className} @Inject constructor() : ViewModel() {
    
    // TODO: Implement ${className}
    
}
`;
    } else {
        return `package ${fullPackage}

/**
 * ${className}
 * 
 * TODO: Add class description
 */
class ${className} {
    
    // TODO: Implement ${className}
    
}
`;
    }
}

function generateJavaTemplate(fileName, packagePath) {
    const className = path.basename(fileName, '.java');
    const fullPackage = `com.roadtrip.copilot.${packagePath}`;
    
    return `package ${fullPackage};

/**
 * ${className}
 * 
 * TODO: Add class description
 */
public class ${className} {
    
    // TODO: Implement ${className}
    
}
`;
}

function generateXmlTemplate(fileName) {
    return `<?xml version="1.0" encoding="utf-8"?>
<!-- ${fileName} -->
<!-- TODO: Add XML content -->
`;
}

function getTemplateType(extension) {
    switch (extension) {
        case '.kt': return 'Kotlin class';
        case '.java': return 'Java class';  
        case '.xml': return 'XML layout';
        default: return 'Generic file';
    }
}

function checkAndUpdateDependencies(fileContent) {
    // Check if new dependencies are needed based on file content
    const dependencyChecks = [
        { pattern: /@Composable/, dependency: 'Jetpack Compose' },
        { pattern: /@HiltViewModel/, dependency: 'Hilt' },
        { pattern: /Room/, dependency: 'Room database' },
        { pattern: /Retrofit/, dependency: 'Retrofit' }
    ];
    
    const neededDeps = dependencyChecks.filter(check => 
        check.pattern.test(fileContent)
    );
    
    if (neededDeps.length > 0) {
        console.log(`   üì¶ Detected dependencies: ${neededDeps.map(d => d.dependency).join(', ')}`);
    }
}

function getFileCount(dirPath, extension) {
    if (!fs.existsSync(dirPath)) return 0;
    
    let count = 0;
    function countFiles(dir) {
        const files = fs.readdirSync(dir);
        files.forEach(file => {
            const filePath = path.join(dir, file);
            const stat = fs.statSync(filePath);
            if (stat.isDirectory()) {
                countFiles(filePath);
            } else if (file.endsWith(extension)) {
                count++;
            }
        });
    }
    
    countFiles(dirPath);
    return count;
}

function showHelp() {
    console.log(`
ü§ñ Android Project Manager

COMMANDS:
  add-file <name> <package>     Add a new file with proper package structure
  build [task]                  Build the Android project
  clean                         Clean the project build artifacts  
  verify                        Verify project structure and dependencies
  lint                          Run lint analysis on the project
  help                          Show this help message

EXAMPLES:
  node android-project-manager add-file LocationAuthorizationScreen.kt ui.screens
  node android-project-manager build compileDebugKotlin
  node android-project-manager build assembleDebug
  node android-project-manager clean
  node android-project-manager verify
  node android-project-manager lint

OPTIONS:
  <name>     File name with extension (.kt, .java, .xml)
  <package>  Package path relative to com.roadtrip.copilot (e.g., ui.screens)
  [task]     Gradle task (default: compileDebugKotlin)

PACKAGE EXAMPLES:
  ui.screens          -> com.roadtrip.copilot.ui.screens
  managers            -> com.roadtrip.copilot.managers  
  models              -> com.roadtrip.copilot.models
  ui.components       -> com.roadtrip.copilot.ui.components
`);
}